SPEAKER_02:
hello and welcome everyone this is active inference math stream 9.1 on march 5th 2024 we're here with jonathan gorard and we'll be discussing a variety of topics yet to be determined or are they so thank you for joining and to you for any introduction and we'll really look forward to everyone's comments and questions so thanks again for joining to you


SPEAKER_00:
Okay, well, yeah, thanks very much, Daniel, for the introduction and for inviting me to be here on Active Inference.

I'm looking forward to a very, very fun discussion.

So I don't have anything especially prepared to talk about, which is probably a good thing because it means we'll be able to extend the unstructured part of this for as long as possible.

But I think just to give a little bit of context, I want to talk about

an area where I think some things that I've been working on, some collaborators that might have been working on that might have some kind of intersection of interest with things that, you know, active inference type people might care about.

Right.

So and in particular, that concerns the relationship between kind of computation, observation and cognition.

and specifically using methods that come from category theory and topos theory and some other kind of branches of mathematics and theoretical computer science to understand the relationship between uh system specifically the computational and algorithmic complexity of systems versus the computational algorithmic complexity of observers of those systems and how those things trade off between each other

So just to give a little bit of context to that, I want to show these are just some visuals from a paper that I put out about a year ago now.

And this kind of really defines this research program that I've been working on for the last year and a half in some form or another, which is looking at exactly this tradeoff using category theoretic machinery.

So here's a specification of a Turing machine.

This is just a simple deterministic computation.

It's saying, you know,

you have a Turing machine that has this head state and this tape state, and on the next step, you're going to replace the tape state with something that looks like this, the head state with something that looks like that, and you're going to scroll the Turing machine head left, or in this case, scroll it right, etc.

So this is just a specification of a very simple computation.

I think this is a two-state, two-color Turing machine on a simple one-dimensional tape.

It's about as simple a computation as you could define.

So if you run that thing for some initial condition, you'll get an evolution that looks like this.

And so right now, this is just a purely deterministic single path evolution.

But from this, we can construct and we can build a mathematical structure.

Namely, we can build a category.

And the rules for how we build that category are very simple.

So each arrow here is some simple computation, some application of the Turing machine transition function.

And then what we can do is we can say, well, anytime we have two arrows that are laid end to end like this, we can compose them together to create a third arrow that goes like that.

I may even have a picture.

Yes, like this.

So we have a computation f that takes us from x to y, a computation g that takes us from y to z, and then we obtain a composite computation g compose f that takes us directly from x to z.

And we also add some additional edges, some additional arrows on each state itself, a sort of identity operation that maps a computational state directly to itself.

And so this, combined with some axioms of associativity and identity, forms a category of elementary computations.

So this is a very, very simple example.

But what I want to try and build up towards and kind of pump your intuition for is a category which I call comp, which is a category whose objects are essentially the class of all data structures.

and whose arrows or morphisms are the class of all elementary computations.

So you start by just applying all possible computations, in this case, for the case of Turing machines, all possible Turing machine transition functions.

And then you do this closure operation where you essentially do what I'm doing here, but you allow those elementary computations to be composed together in arbitrary ways.

And so that gives you effectively a class of all possible programs.

So this category contains not only all possible data structures as objects, but all possible programs as morphisms.

And this is a very rich category with some very interesting algebraic structure that we'll kind of again, I'm sure we'll allude to in our subsequent discussion.

But.

In a sense, when we do this operation of taking what mathematically we call a transitive closure, where we allow two elementary computations to be composed together to produce a third, we are essentially kind of neglecting considerations of computational complexity.

This arrow here might correspond to one application of the Turing machine transition function.

This arrow might correspond to another application of the transition function.

But this composite arrow might correspond to two applications of the transition function.

And so somehow when we allow arrows or morphisms to be composed in this way, we're neglecting considerations of the complexity of operations.

So the question then is, could we imagine constructing a generalization of category theory which takes into account computational complexity?

So here's an example of how that would look.

So here you can see every edge, every morphism has been tagged with certain computational complexity information.

In particular, it's been tagged with a number specifying what is the minimum number of applications of my transition function?

What's the minimum number of elementary computations that I need in order to evolve from this data structure to this data structure?

so here to go from here to here it's just one to go from here to here it's one to go to it from here to here it's one etc uh but to go to hit from here to here directly it would be three uh to go from here to here directly it would be two um and you know just for convention we say that the identity uh the the identity computation the trivial computation always has complexity zero

So this is, again, a fairly simple mathematical structure, and you can construct this, again, using purely category theoretic technology by building a particular functor from the category of data structures and computations to what's called a discrete cobordism category.

And again, we might discuss that later on if people are interested, but let me not get too bogged down into the technical details of how we do that.

But once you've got this,

it gives us immediately a very nice way of characterizing phenomena like computational irreducibility.

So there is this idea that has existed in some form or another since the very early days of theoretical computer science, since the days of, you know, GÃ¶del and Turing and Post and Church and so on.

But was given this term computational irreducibility by Stephen Wolfram, where the idea is essentially that you just, you know, intuitively you describe a computation as being irreducible or the result of the computation as being irreducibly complex.

if it's not possible to shortcut it in any way.

So where that computation takes a certain number of steps, and there does not exist a shorter computation that would give you the same answer in less time.

And one of the nice features of thinking about computations and their complexity algebraically like this is that it gives you a purely algebraic characterization of irreducibility.

In particular, what it says is that irreducible computations are ones for which the computational complexity acts purely additively under composition.

So if it's the case that if we compose, say, two computations of complexity one together,

uh if the if the resulting composite takes you know has complexity two then it's an irreducible computation if it has complexity less than two like one then that means that we could have we could have jumped directly from the input to the output without having to pass through the two elementary computations that made it up so that would be an example of a reducible computation so reducible computations are ones whose complexities compose sub-additively in this category theoretic sense

Okay, so here's an illustration of showing what intermediate computational states you had to go through in order to get from one data structure to another data structure.

So to go from here to here, you had to go through steps one to two.

To go from here to here, you had to go through steps one, two, three, and four, etc.

So you can build up a kind of complete algebra of complexity this way, which has some nice properties, which again I can talk about, but let me not get too bogged down in mathematical details right now.

But here's the thing I really want to talk about, which is what happens when you go to multi-way systems, what happens when you go to non-deterministic computations.

So now imagine having, instead of just a Turing machine with a single rule, a single transition function that just evolves deterministically with a single thread of time.

Now imagine having a Turing machine that has say two transition functions, like this one and this one.

And so at any given point, it can apply one of the two.

And so now evolution, instead of just being a single path, becomes this kind of branching structure, which if we didn't have any merging would be a tree.

But because we are merging equivalent states, it's actually just a kind of more general directed graph.

And so it looks like this and this we call a multiway system.

And so we can build a category out of these multi-way systems as well.

We can build a category using exactly the same rules.

So again, we do this transitive closure operation.

So we add an edge for every possible composition of these elementary computations and an identity edge that maps every data structure to itself.

But it turns out this category has even more structure than the single way system that we showed previously, because now it's possible to compose computations not just sequentially in time using ordinary composition, but it's possible to compose them in parallel across what is sometimes referred to as branchial space.

So essentially you're saying instead of, you know,

The ordinary morphism composition that I showed previously is essentially saying I apply this elementary computation, then this elementary computation sequentially.

Whereas this parallel composition is saying I apply this computation and this computation in parallel to the same data structure.

And so that parallel operation is what causes these branches, right?

Effectively, when you have two threads of time that are branching from the same state, like here, that's arising because we have chosen to apply this elementary computation and this elementary computation together in parallel rather than sequentialized in time.

And so here you can see this parallelization indicated using what's referred to as a branchial decomposition, which is just a kind of a visual way of decomposing what's going on between these different threads of time.

And again, there's a purely algebraic characterization of what's going on here, which is that what we've done is we've taken our simple category that we started with and we've equipped it with a tensor product structure.

and so it's become what we fancy call a monoidal category or actually a symmetric monoidal category so the tensor so we now have these two operations we have sequential sequential composition in time and we have this tensor product operation which is a parallel composition in branchial space

And just like before, where we equipped our edges, our morphisms, with certain computational complexity information, we can do the same thing, and we described how those complexities composed sequentially in time, we can do the same thing and describe how the complexities compose in parallel as one composes morphisms in branchial space.

And so this allows one, by exactly the same token, to quantify multi-computational irreducibility rather than just computational irreducibility.

So now multi-computational irreducibility becomes a measure of how additive or sub-additive your time complexities are when you compose them in parallel through the tensor products rather than just in sequence through standard morphism composition.

um okay but i promise i i am cut and so here's an analogous diagram to the one i showed before showing all the kind of intermediate steps uh that that are being uh uh that that are being applied when one composes uh computation when one constructs computations or indeed multi-computations by composing elementary computations both sequentially in time and in parallel in in branchial space now but i promise i i am the the point that i'm trying to get to

is that it turns out that in addition to just being a useful way to think about computational complexity theory and to formulate complexity classes like polynomial time or non-deterministic polynomial time, et cetera, it turns out this is also an interesting way to think about the role of observation in computational models of reality.

Because so, and here's where I'm going to get a little bit philosophical and I don't immediately have a slide or a graphic that I can show to illustrate this point.

But so when we think about modeling a system computationally, one has to bear in mind that there are really two computations going on, right?

There's the computation that the system is itself performing.

And then there's the computation that the observer, the person who is measuring that system and concluding things from it, there's the computation that they are performing.

and somehow you know so when we construct models of reality or when we construct models of systems

Simon Borgson, Ph.D.

: You know, and we want to describe kind of at a metal level what we're doing in computational terms.

Simon Borgson, Ph.D.

: there's our own computation that you know that's going on inside our own internal representation of the world and then there's presumably some external computation that's going on outside.

Simon Borgson, Ph.D.

: And then, when we make observations and when we make measurements when we construct theoretical models and what we're doing is we're somehow constructing some kind of encoding function that allows us to take a.

a concrete physical state of the system we're observing and encode it as some abstract state of the internal model that we have of what's going on.

And that's all very well, but then now we don't just have one computation to care about, we have three, right?

We've got the computation of the system, computation of the observer, and the computation, this encoding function computation that's responsible for the interface between their internal model of the world and the external reality.

And the computational complexities of these computations interplay in an extremely interesting way.

And so part of the reason for trying to develop this algebraic semantics for thinking about computational complexity and multi-computational complexity was to try to give one a systematic way to reason about exactly this three-way interplay between systems, observers, and encoding functions.

And so in particular, when an observer makes a model of the world, one thing that they're doing is that they are, you know, for any model that isn't just, you know, a complete description of reality, there's a certain amount of coarse graining, right?

There's a certain amount of taking a bunch of states that in the system itself are distinguished, but in the internal model are treated as the same.

they're cast in the same bucket.

So in some sense, how coarse a model is, is a measure of how much the encoding function fails to be subjective.

And so again, there's a kind of algebraic or category-theoretic characterization of what's going on, that the fewer of your morphisms are epimorphisms, the more coarse your model is, the more abstract or idealized your model of reality is.

And so then the interesting thing is that this characterization of multi-computational irreducibility, this measure of how additive or sub-additive your complexities are as you compose them together in parallel, gives you a measure of the relative complexity of the evolution function, that is the function that evolves your computation forwards in time, versus the equivalence function, that is the function that declares that two computational states, two data structures, are to be treated as equivalent.

And that interplay,

I claim, is a kind of abstract meta way of thinking about the interplay between the computation of systems versus the computation of observers.

Because it says the role of the system is to evolve forwards in time, whereas the role of the observer is to take states in the system that are distinguished in reality and say,

subject to my idealized model, I'm going to treat these as the same.

So the system is defining the evolution function, but the observer is defining this equivalence function.

And so then the trade-off in their complexities becomes exactly a trade-off between what are the algebraic rules that describe the complexities as they compose sequentially versus the algebraic rules that describe the complexities as they compose under this tensor product operation.

um and so yeah i've shown this uh in particular for for turing machine systems but this is a very this is a very general kind of algebraic semantics you can apply it to hypergraphs you can apply it to combinators lambda calculus doesn't matter uh in a sense uh there is just one category up to isomorphism of computation of data structures and computations and there are simply many different ways of parameterizing what that category is doing through things like turing machines or hypergraphs or whatever some you know the the

The algebraic formalism transcends the particular details of the computations that one's dealing with.

And so, yeah, as I say, what one ends up with is, I think, a fairly general formalism for thinking about the interplay between observers and the systems that they observe.

And that gives one a, I promise I'll stop monologuing in a moment and we'll try and pick apart what I'm really talking about here.

But so I'll just conclude with, you know, once one has that algebraic semantics, a whole bunch of things which I think previously would have been

at least to me, previously seemed like kind of fundamental confusions about, you know, how scientific observation works and how it interplays with computational models.

Those confusions kind of become much easier to clarify once you think about it in this kind of more compositional way.

So to give a very simple example or a kind of very degenerate example, you can, you know,

Within this algebraic semantics, you can effectively trade off the computational complexity of the system for the computational complexity of the observer.

So you can have, in effect, two degenerate cases.

You could have the case where the system itself has a completely trivial evolution function.

The system itself is doing something completely elementary in how it evolves.

But then the observer has some incredibly complicated equivalence function that makes the system look like it's doing something really complicated, even though what it's actually doing is something very simple.

um and so then you have the phenomenon where actually kind of all of the complexity is in the eye of the is in the eye of the observer you can also have the other degenerate case where the observer is doing something absolutely trivial where the you know the encoding function or the the observer's own internal representation is just an identity function or something so there's no complexity there but the system is doing something incredibly complex it's doing some some totally some really sophisticated universal computation and so that will also appear very complex to that observer

And so and you can also have any kind of any intermediate, you know, there's this vast interstitial space between these two extremes.

And so one thing that's kind of always one sort of philosophical problem that I've always kind of been interested in ever since I was a kid, which is this this sort of.

this tension between empiricism versus rationalism, right?

You know, the question of, you know, if you look back at the history of, you know, early European philosophy or, you know, certainly Western, you know, Western post-enlightenment philosophy, you had people like, you know, Descartes and Leibniz and so on who were, you know, and in a more sophisticated way, Bishop Berkeley with subjective immaterialism, who were trying to push for this idea that, oh, you know, all the sophistication is what's going on inside the observer's head.

And, you know, what goes on in reality is somehow secondary.

And then you had people like Locke and Hume and the empiricists who were saying, no, no, we should try and get the observer as much out of the picture as possible.

And we should say all the sophistication is going on kind of in the external world.

And one nice consequence of this formalism is it gives one actually an algebraic way of kind of parameterizing

this spectrum from rationalism to empiricism, right?

That you can choose the rationalist extreme where you just have some space of all possible computations and the observer is doing all of the work to try to narrow down to a particular one, or you can have the kind of empiricist extreme

where the observer is a completely elementary system and everything they observe is just being built up from a kind of bottom-up construction, or you can have anything in between.

And in a sense, we now have, I think, the beginnings of a mathematical theory that's able to explain how those complexities trade off in a very direct way.

So I think there's potentially

places of mutual interest there in thinking about, as I say, cognition, observation, measurement, scientific modeling and so on in fundamentally computational terms.

So I think that hopefully that will provide some context for a discussion.


SPEAKER_02:
Thank you.

Great opening.

There's so many places to spin in and jump through.

guess i'll start with the two things i wrote down were unity is plural and at minimum two and beauty is in the eye of the beholder and the way that these kinds of pieces of timeless wisdom that describe that fundamentally relational component to observers in systems which are not all kinds of systems per se but those kinds of systems those things are true for and then the way in which along the formalism that you described with the system observer encoding

three-way partition and then the way that in free energy principle and the particular physics that interface gets broken out from the agent's perspective into the incoming sensory and the outgoing action so that that results in the fourfold particular partition so maybe just to kind of dwell there how do we partition

the from a category theory perspective, or however, the action perception loop or the engagement loop?

Like, how do we make a topology or compare and contrast different topologies and flows over this kind of seemingly pervasive or universal interface like concept?


SPEAKER_00:
That's a fascinating question.

So I don't have the answer.

And this is maybe a place where both you, Daniel, and perhaps David may have useful perspectives on this, because I read Carl's work a few years back.

And so I have some familiarity with the terms, but I'm by no means an expert on free energy principle or active inference and those kinds of things.

But I think it's a very good point that you raise.

And so I should begin by just being honest and say that

All that I just described is, of course, an idealization.

In particular, it's an idealization which I think you were very right, Daniel, to pick up on.

It's an idealization in which we say the observer is completely non-interacting with the world somehow, in a sense that there's just input coming in and nothing coming out.

uh but of course we know that's not really how observation works observation is necessarily a kind of two-way process and so what's needed is not just this kind of very clean algebraic semantics that i've described here which assumes that there's a potentially a one-way function from the world to the observer but actually something more like a kind of second order cybernetics description

of what's really going on, where you have first-order and second-order interactions, where, exactly as you say, you can get these feedback loops from observation to action and back again, which is still an idealization, but probably a more realistic idealization for how real observers and real measurement apparatus work.

um i just want to begin by saying that i don't know right and you know the question of how this formalism interplays with things like second order cybernetics and other areas where i know these kinds of questions have been explored that's something i i i'm very interested to find out about uh you know going going forward um but i think hmm okay so yeah so at some point maybe you could

help me understand potentially where things might fit in with the kind of broader active inference framework.

I'm not sure I necessarily have that much more to comment on than that.

Yeah, other than to say that in a sense... Okay, so maybe one further comment is that

Because you asked specifically about how the kind of compositional category theoretic perspective might be useful.

So I don't think category theory in itself is going to be the complete answer.

I think it will be category theory augmented with some other things, computational complexity, probably second order cybernetics, and some other things that I may not be aware of.

But one place where I think that viewpoint is useful, at least on a philosophical level, is the idea that

is the idea that comes about, that you really obtain by studying mathematical structures in a categorical way, which is that the identity of something, you can define it both in terms of its intrinsic properties, or you can define it in terms of the stuff that you can do to it.

So this was really the transition that happened in the foundations of mathematics as a result of people like Samuel Eilenberg and Saunders MacLean.

So, you know, category theory has its origins in this sort of slightly abstruse branch of algebraic topology.

It was initially developed by people like Alexander Grotendieck and Jean-Pierre Serre for doing homological algebra for, you know, for reasoning about sort of the algebraic structure of topological spaces.

But then later in the, I think, 1960s, 1970s, these two American mathematicians, Eilenberg and McLean, realized that it was useful not just for thinking about topology, but for thinking about kind of mathematical structure in general.

And then later on,

applied to category theorists started saying, well, maybe it's useful for just thinking about structure in general.

But, you know, the key kind of conceptual or philosophical shift that it imposes is, you know, historically, thanks to the work of people like Cantor and Frege and Russell and so on, people have thought about mathematical structures in the foundations of mathematics in terms of set theory.

and the idea in set theory is you have this you know things like the axiom of extension that effectively say set is defined by what's inside it right so in other words you know you you a mathematical structure obtains its identity by you know you break it apart and you look at what's inside

In category theory, it's a completely different view.

The view instead is you say, well, no, you can't look inside.

It's a fundamental rule of category theory that you can't look inside an object.

Its internal structure, if it has any, is sort of out of bounds to you.

And instead, you give that object identity in terms of

how it relates to other objects of the same type.

So in other words, you can ask, what can I do to this?

What functions can I apply to it?

What functions can I apply to something else that map into this?

So if I want to define the real numbers or the integers or something, from a set theory perspective, you would say that the essence of the real numbers are all the numbers that are inside that set, all the numbers that are inside R.

Whereas the category theory perspective is, no, the essence of the real numbers are all the functions that you can define that take real numbers to some other number system, or real numbers to themselves, or that take some other number system into the real numbers, etc.

And some of the deepest results in category theory, like the Oneida Lemma and other things, are

telling one in some very precise sense that these two perspectives are really the same at some fundamental level.

That identifying an object based on its internal structure, based on breaking it apart and asking what's inside, and identifying an object by asking what can I do to it, and what can this object be transformed into, and what things can be transformed into this object,

those give you exactly the same information it's far from obvious that that's true you know the united lemma is a very kind of uh it's one of those results where you can never quite work out if it's obvious or if it's incredibly you know mysterious uh but i would i tend to fall on the side that it's incredibly mysterious it's far from evident that that those two perspectives would really be the same and yet the point you're making daniel i think is that uh

is that in a sense, historical ways of thinking about scientific observation have tended towards the set theoretic viewpoint, tended towards the viewpoint that we understand systems based on kind of breaking them apart into constituent components.

But perhaps a more realistic view is something more like the category theory perspective, where we say, I understand the system by interacting with it, by asking,

What can I do to it and how does it behave when I perform certain operations to it?

And that's a fundamentally two-way process that involves not just passive observation, but also kind of active participation.

And somehow we need to develop a formalism that kind of incorporates those two elements.

And maybe it already exists and it exists in this large literature tree of which I'm largely unaware.

That's partly why I wanted to be here, to try and find out what things I missed, so to speak.


SPEAKER_02:
All right, a few points.

Self-evident is far from evident.

Also, I tend to the mysterious, which is to say, saying more with less, especially for these frameworks, because they're less opinionated so that their space of internal semantics can be larger.

And then that description that you provided with the relationship between the set and the category theory.

So I kind of summarized it as set is to essential inclusion as category is to relational function.

now if our concept of organismality or of action in the niche is constructive compositional material

then we are looking for like what is in or out is the microbiome in is the pheromone in the ant colony in or out of that thing because it's looking for like a static material answer and then in contrast the other side of that coin highlights the the dynamic like whatever it is that's self-organizing of the tornado is the tornado whatever it is that's self-organizing for the ant is the ant

um and then also this like hint slash Mobius strip or something that those two in the moment are indistinguishable and yet systems that we choose to Define one way or another or keeping both open those design decisions do make all the difference even if for real systems as they're observed there's indistinguishability


SPEAKER_00:
Right, right.

I think that's a very important point and one which, I mean, it's always a kind of concern I have whenever I start thinking about embodied cognition or extended phenotype type ideas, right?

In a sense, you know, if what one is trying to do here is construct a kind of formalistic model of observation or of cognition or something, then as a kind of first order approximation, one has to start by somehow decomposing the world into observers and systems.

But of course, you know, we know that that decomposition is somehow arbitrarily imposed.

Right.

And that, you know,

If you take these things to their extremes and you allow essentially everything that the agent is interacting with to be considered, not just the microbiome, as you say, but also tools that they construct or environments in which they exist and so on.

As you start to consider all of that to be a component of that organism, of that agent's phenotype, which is a completely reasonable thing to do, and you start to

you start to say okay well their cognitive processes are not just localized to their brain or their spinal column but are kind of somehow extended to you know the computers they use the paper they write on uh the books they read etc again perfectly reasonable thing to do and sort of somehow more uh more descriptive of what's really going on

But my fear is always, if you take that too far, then you end up destroying the whole assumption that the idealization was based on, which is that you can neatly decompose the world into observers and systems.

And so I always get a bit nervous when thinking about that, that it's like, yes,

In a sense, we know this is an approximation and we know that that approximation is not really true, but how much can you afford to loosen your grip on that approximation before the whole thing just kind of falls apart?

I don't really know the answer to that question, but I think it's an interesting one.


SPEAKER_02:
Yeah, how about I'll ask some questions from chat and then give your first thoughts and then we'll see maybe where that kind of lands with further questions or how it connects to active inference.


SPEAKER_00:
That sounds good.


SPEAKER_02:
Oh, by the way, should I keep my screenshot on or should I... Yeah, we might want to go to a figure, so it's fine.

Okay.

Yeah.

All right.

Quantum Bell wrote, how does this help us reason about causality?


SPEAKER_00:
That's a fascinating question.

That's another major aspect of why I think this research program is exciting.

And again, this is something where I'm interested to get the kind of active inference perspective, because I know this, again, it's a topic in which much has been written, and I'm largely ignorant.

But yes, so one question you could ask is, if you have a description of a computation like this, like, let's go back up to the Turing machine case, the single-way Turing machine case that's relatively easy to analyze, although still far from obvious what's going on.

So suppose you have a computation of this kind, and you want to ask, what is its causal structure?

In other words, for each edge, each time I'm applying this Turing machine transition function, can I construct some kind of graph, some directed graph representation that tells me how these events are linked together?

Within the original research program, the so-called Wolfram Model research program that started a lot of these investigations, we were looking at this all the time.

We were looking at taking computations and looking at that causal structure and trying to infer things about what was going on, about the semantics of the computation based on causal relationships.

And at a certain point, I started to realize, and I think other people had realized this before I did, but I'm often slow to pick these things up.

I and other people started to realize that the notion of causality we were using was kind of nonsense.

I mean, it was not completely hopeless, but it wasn't really causality, or it couldn't really be called causality in any definite sense.

So what do I mean by that?

So first of all, it was a very technical problem.

So if you're looking at something like a Turing machine evolution or a hypergraphy writing system as we were, then there's a very tempting and apparently obvious natural definition of causality that you could use, which is to ask, when you split the world up into events that take some part of your data structure as input and output some other part of a data structure as output,

then you can very easily ask, does the output of one event intersect with the input of another event?

If I show the hypergraph example, it's perhaps easier to see.

So you have a hypergraphy writing rule that looks like this.

So you say, if I have a piece of hypergraph that looks like that, I replace it with another piece of hypergraph that looks like this.

So each time you apply an event, you can think of that event as ingesting certain hyperedges and replacing them with others.

So you can divide it up into the input hyperedges that are being ingested versus the output hyperedges that are being produced.

And so then you can ask, well, did I

Did I subsequently ingest in some future event hyperedges that were output in some previous event?

Well, if the answer is yes, then pretty obviously that future event couldn't have occurred unless the previous event had already occurred.

So then you could say, well, then one of those events causes the other.

So in general, you could say that event A causes event B if it's the case that the collection of tokens that was produced in the output of event A has a non-zero intersection with the collection tokens that were ingested as part of the input of event B. And that is a very tempting, very natural definition of kind of causality in these systems.

Turns out it doesn't really work.

I mean, it works...

pretty well, but there are cases in which it fails, and it fails pretty spectacularly.

And so the kind of canonical case where it fails spectacularly is that you can have events that don't actually do anything, right?

You can have events that just kind of touch an edge, touch a token, and output it again unchanged, but maybe, you know, it modifies the name, it modifies the identifier, but it doesn't actually change anything about the structure of the hypergraph or the Turing machine state or whatever.

So pretty obviously, that event doesn't matter.

It shouldn't be causally related to anything in the future.

But because it ingested the edge and then did some identity operation but then produced it in the output again, it will register as being causally related to any future event that used that edge, even though it didn't make any difference.

That's just one very obvious example.

There are other cases where it became clear that whatever this algorithm was detecting, it wasn't really causality.

So I tried to think about, you know, what's a more sensible definition of causality?

And I started working on things to do with, you know, a slightly kind of blockchain inspired ideas where you say, OK, well, rather than just arbitrarily assigning, you know, identifiers to these tokens every time they're created, what if I recursively construct the identifier of the token based on its causal history?

So in other words, each token, like each hyper edge or each state in each tape square on my Turing machine tape,

The identifier is not just some random number that gets generated by my algorithm, but instead its identifier is a directed graph representation of its complete causal history.

Well then, kind of recursively, its identifier can only change if the causal history was updated.

And so you don't end up with these kind of spurious causal relations that I described before.

So that seemed like one tempting way of resolving this problem.

But then I realized, actually, there's a much more fundamental problem.

There's a there's a philosophical problem with the way that we're thinking about causality, which is that it's not really, you know, so.

Okay, this is a long tangent, which I'll talk about a little bit, but I won't get into the complete details unless people are interested.

But I ended up talking to a bunch of philosophers who worked on causality and people who worked on parallel programming and quantum information theory and other places where causality was studied and asked them kind of basically, what do you mean by causality?

What is causality?

What is this thing we're trying to define?

And

In some form or another, all of the definitions boil down to, you know, event A causes event B if

had event A not occurred, then event B would not have occurred.

So in other words, you need a counterfactual.

You need some possible history, some possible world in which event A didn't happen.

But if you're reasoning about a purely deterministic event system, like a Turing machine, that doesn't make any sense.

Because if you have a single Turing machine transition function, there is no possible world in which that transition function didn't fire in that particular way.

Because if it didn't fire in that particular way, you would not be reasoning about that Turing machine anymore.

You'd be reasoning about a different Turing machine.

So suddenly, to make sense of these notions of causality, you need a kind of Leibnizian modalities view of reality that just doesn't exist for these deterministic computational systems.

So either you need to define causality only at the multi-way level.

at the level where you have many computations or possibly all computations happening in parallel and then you can define causality relative to all of you know relative between them or you were kind of posed right there wasn't really you know that seemed like the only kind of the only get out or you need some fundamentally new philosophical theory of causality that i was not qualified to produce

And so that's again part of what motivated this general research program, which is trying to think about this category of not just a single computation with a single sequence of data structures, because it's clear that you can't in a philosophically meaningful way assign causality in that case, but rather looking at the algebraic structure of the category of all possible computations and all possible data structures.

And in that situation, there is a notion of causality you can equip that with.

And there's a nice mathematical description in terms of weak two categories and so on, which, again, I can talk about if people are interested.

But yeah, so it's clear that these things are very deeply related, that this theory of the category of computations and data structures and the theory of how you assign causality in a meaningful way are very deeply related.

I'll just mention one other thing on that topic, which is, again, just an area which I find quite exciting because it's an unexpected spin out of this program, which is that so once you have a way of consistently applying causality at a per token level in these systems, it gives you a way of vastly generalizing what computation is.

Um, and you can, in particular, you can get, you can derive something which I call, uh, uh, well, I'm provisionally calling covariance computation, although it should probably have a better name than that, which is so, you know, in our traditional kind of Turing church type, you know, uh, type models of computation, computation is a purely forwards in time operation, you know?

So at every point, you know, you have a complete data structure and computation is about deriving what is the next state of that data structure.

So in a sense, it's only a forwards in time thing.

You might be able to kind of reconstruct the initial conditions based on some subsequent data structures.

You might be able to go backwards in time, but that's essentially what you're doing.

But then you could imagine, OK, suppose I don't know the complete state of my data structure.

Instead, I know one part of my data structure, but I know its history throughout all of time.

So you could imagine, say, an elementary cellular automaton or a Turing machine tape where you know nothing about the tape, but you know the state of one cell and you know it throughout all of time.

And then the question is, what can you infer about the rest of the computation?

And it turns out that for those kind of structured array type systems, you can infer a lot.

You can actually evolve the system, not forwards in time, but sideways in space and obtain a kind of causal diamond that, so, okay, the top left, top right, bottom left, bottom right corners are undetermined, but everything inside that diamond can be determined just from that one row or that one column that you know, you know, sort of extended throughout time.

And that's a fundamentally different notion of computation.

So it's a version of computation which is not forwards in time, but sideways in space.

But you can also have versions of computation that are sideways in branchial space, where you know one complete state, you know one branch of the multi-way system extended throughout time.

And then the question is, what else can you infer about the rest of the multi-way system just from that one branch?

And again, the answer turns out to be you can infer a lot, but not everything.

Just like in the reason I call this covariant computation is because it's very analogous to what happens in relativity.

So in relativity, once you buy into this notion of general covariance and the notion that space and time are kind of fundamentally the same thing, then you have to somehow relax your traditional view of what dynamical systems do, which is, you know, we we typically think of systems as evolving.

You know, you have a snapshot of your of your data, you know, localized on a.

you know for a particular state of space you know on a particular space like hypersurface and then your laws of physics tell you how that space like hypersurface evolves forwards or backwards in time

But in a covariant picture of physics, then you must also allow for your initial data to be defined on a time-like hypersurface and for you to be able to evolve that time-like hypersurface sideways in space or mixtures of the two and so on.

And so it's clear that there's a very general, a vast generalization of ordinary computation theory that you can construct that's kind of physics-inspired in that sense, in which you can have mixing of space-time and kind of multi-way directions

um in a completely consistent way but to make those things consistent you need to have a a definite way of assigning causality you need because you know any computation that you do even if it permutes the directions of space and time and branchial space and so on must always somehow preserve the causal structure has to respect the causal structure of what's going on or else it's inconsistent

And so this question of how you construct a covariant theory of computation is, it turns out, intimately related to the question of how you take this category of computations and data structures and equip it with a consistent notion of causality.

So very interesting question.

We could talk about that a great length.


SPEAKER_02:
okay to follow with a few pieces it's very related to professor mike levin's notion of polycomputing and about the necessity for a causality concept to be created or deployed when the question arises was that me was that action or change due to me um also connectivities

Even just in the neuroimaging setting, which is kind of the cradle from which active inference and free energy principle arise from, it's really important to distinguish the functional, effective and anatomical connectivities.

And that was one of the points that Toby Sinclair Smith made in his dissertation, which is that a lot of times the Bayesian graphs

don't convey all of the necessary and sufficient information to make the reproducible computation which is one of those kind of what's missing from the graph is what motivated a lot of the category theory developments in active inference as well as some of the formal ontological works with sumo and dave here and adam peace because

implementing modal and higher order logics is really important if it's a possible situation where a mind can have a perspective on a mind and all these things like that um then the ant turing tape the tape is the pheromone

and then the decision space is the nest mates scrolling so when you had a deterministic touring tape that was like a movie because the nest mate couldn't make any choices except for internal action which is kind of side topic but couldn't make any choices on the tape

Whereas when there's a multi-way, which is basically in active inference, what we talk about in terms of affordances and the policy space and the temporal depth of planning counterfactuals on action and action conditioned world transition states like the B matrix, all of those kinds of topics come into play because if you wanna have a causal buffer or grasp on what is it that something that could do otherwise does, what does it cause to do when it does or doesn't do otherwise?

you need something like a deterministic handle around what could be a probabilistic or deterministic but at least multi-way map of some kind of cognitive territory that's a very very interesting perspective i mean so it's again i'm i'm betraying my my ignorance of active inference theory here but you know it sounds almost like so these these um


SPEAKER_00:
When you have this interplay between epistemic versus pragmatic, there's two aspects of how this speculative part of cognition works.

This is something which I thought about in a completely different context in relation to things like quantum information theory, but I wonder if there's a potential overlap there between...

There are certain situations when thinking about these kinds of systems, purely abstractly, where you kind of need two different notions of causality.

You need a kind of speculative notion that can be, that's dynamic, that can be rewritten.

And then you need a kind of definite notion that's immutable, right?

And so, you know, a classic example of this is, you know, say for something like quantum information theory, right?

So you can have

superpositions of causal orders you can have quantum switches you can have uh you know you you can have a causal structure that exists in uh in in in superpositions of different kind of directed graph states but then once you apply a mission operator once you apply a measurement the causal structure is definite because then everything is relativistic and you have covariance and you have similar things as i understand with with um

with uh with distributed computing with parallel computing where you you potentially allow for speculative execution for a certain number of steps where you're kind of treeing up this multi-way system and you have a superposition or you know at least a collection of possible causal histories but then eventually you have to choose an actual operation to do and then the causal history you know you have this big block that gets laid down and you know and then the causal history is is somehow definite

I wonder if there's a way of thinking about speculative execution of agents and the interrelation between that speculative execution and agent actions in terms of, again, this interplay between two different causal structures, between a dynamic one versus an immutable one.


SPEAKER_02:
yeah well one funny way to think about that is like a single agent that has this counterfactual contemplative ability could be in the center place foraging arena and then imagining with discrete um branching paths like a chess algorithm or like a probability distribution could be like imagining where it could go

but not all cognitive things are the kind of things that make plans of their own actions.

Whereas like an ant colony has nest mates on the ground.

So they're actually realizing in these finite trajectories, the real exoskeleton on the ground that plays out

ending up with those simulated trajectories could have been simulated or could have been probabilistically blurred but that's kind of the difference between like the embodiment and like the body moving there for a mammal or for an animal and then like the mind simulating it and then just to the um the epistemic and pragmatic trade-off in decision making

So let's just say that we're in that multi-way moment.

We'll just have two options, two different slices of the B variable.

And the policy selection question is about which way are you going to go?

Which affordance in the moment?

Policy is basically the affordances for the time horizon of planning.

But if it's only one time step or just the next one, then the affordance space is just the actions that can be taken.

One way to make it so that what happens is the likeliest thing, path of least action, which is kind of what opens up the whole physics of cognitive systems angle in contrast to like a reinforcement or reward learning perspective.

What makes it the likeliest thing is starting with habit.

So it could just be drawn from a fixed habitual distribution.

However, for adaptive action, habit gets up-weighted with expected free energy, which is a functional that takes in

the policy space which is summing up to one because of the probability over actions and then up weighting policies according to their score on expected free energy which is consisting of epistemic plus pragmatic value so how much is it going to align the observations to be what i like to see that's pragmatic value with a preference

what is my expected information gain that's the epistemic value so how those are parameterized make the agent that always seeks out new information or always goes with habit or there's so much policy space because the knobs are not just simple sliders or there are multiple knobs even though they are seemingly quite consilient and minimal like it's hard to imagine less


SPEAKER_00:
yet especially when there's richness in the environment even simple systems can have like enormously complex or adaptive behaviors i'll just leave it there no i i i never really thought of the so okay the yeah two things right so first of all the the perspective of you know thinking of an ant colony or a termite colony or something as being you know akin to a mind that's you know

I was familiar with that perspective from people like Dan Dennett and so on, but the idea that the individual ants in that colony are, in a sense, they're kind of the hardware enacting the speculative execution.

That's a very interesting idea.

It's not speculative for them.

Well, yeah, no, exactly.

But it's sort of from the mind's perspective, I guess it's almost like speculative execution, but it's speculative execution that's being actuated in the physical world, which is very interesting.

I'd not really thought about that before.

But then, yeah, okay, so then the point you're making about connection to free energy and sort of habit formation and so on, okay, so I wonder if, so, you know, if we're thinking about a, you know, a model of cognition in which there are these two different, you know, two distinct causality notions, the immutable versus the dynamic one, I wonder if the...

You gave a very, very nice account of how habit formation sort of works in these kinds of formalisms based on prior experience of expected free energy.

So I wonder if there's a way of describing that abstractly in terms of something like you perform the speculative execution step,

where you're, you know, you're treeing out several multi-way possibilities.

And initially you kind of, you know, you, you, you know, nothing, or you have no habits.

You're just kind of, you're treeing everything out with kind of equal weighting.

But then, you know, for each possible part, you're calculating either an actual or an expected free energy.

And then somehow, you know,

In future speculative executions, you weight those paths which you previously had found to have higher free energy as higher, and so you're more likely to explore those and less likely to explore ones which have that lower expected value.

It feels like something like that should fit very, very nicely into an algebraic semantics like this, which would be interesting.


SPEAKER_02:
Cool.

How about more questions from the chat?

Okay.

Upcycle Club writes,

Acknowledging the limitations of traditional entropy in multi-computations motivates us to develop context-specific entropy metrics.

Can you share some insights towards such efforts?


SPEAKER_00:
Yeah, I can certainly try.

So yes, I mean,

The first point is that I think there's that famous conversation between John von Neumann and Claude Shannon, where I think von Neumann famously said that Shannon should call his measure entropy because no one knows what it means.

And I submit that the reason that no one knows what entropy means is because it's dependent.

I mean, one of the reasons no one knows what entropy means is because it's dependent on exactly what we've been talking about.

It's dependent on the equivalence function of the observer.

So it's one of these things like

I don't know, maybe this is a stupid analogy to use, but it's... Sorry, I'm going to go off on a tangent, but I promise it's sort of relevant.

So one thing that always breaks my brain is when I try and think about actuaries and life insurance policies, because it's one of those areas where...

Those models only make sense if they're not perfect, in a sense, right?

So if you had an actuary who knew exactly how long everyone was going to live, and somehow that information was openly available, life insurance policies would be pointless.

Whereas also, if you had a model that was completely hopeless of predicting how long people would live, life insurance policies would also be pointless.

Somehow, the very existence of actuarial science relies on your model neither being perfect nor being awful.

It somehow has to exist somewhere in between.

And that's something which I... It's one of those topics where if I think about it for too long, it all just stops making sense.

And entropy has very much that same character, right?

Because if you were Laplace's demon, if you had perfect information about the system that you were observing, there's no notion of entropy, right?

It's just you know every micro state.

So the Boltzmann formula gives you an entropy value of zero.

But the notion of entropy only exists once you take that perfect knowledge of a system and you coarse-grain it.

As I was describing earlier, you introduce an encoding function that is not 100% subjective, so that now you are mapping certain distinct micro-states onto the same coarse-grained macro-state.

And then now you can ask, okay, what's the number of micro-states that, you know, exactly how coarse is my coarse graining?

What's the number of micro-states consistent with this macro-state?

What's the number of different values of my domain that gets mapped to a single point in my codomain of my encoding function?

And that's what entropy is.

And so it's very closely, I mean, it is effectively a measure of how good is my coarse graining.

So if you had perfect knowledge, there's no entropy.

If you have no knowledge, there's no entropy.

It relies upon you having a not completely trivial, but also not 100%, you know, a slightly subjective, but not 100% subjective encoding function.

just like with life insurance policies.

The reason I'm stating that is because from that perspective it becomes a little bit clearer why there are all these different notions of entropy and why, as the questioner was alluding to, why entropy as a concept seems to be so domain and system specific.

every different system, every different observer will in principle have a different set of encoding functions, a different set of equivalence functions, and each one will give rise to a different calculation of entropy.

And so one way that you can think about this program, this program to try to understand the algebraic interplay between time complexity versus equivalencing complexity or computational irreducibility versus multi-computational irreducibility, in some sense,

That is a program to try to understand how different definitions of entropy relate to each other in these kinds of systems.

If I take one idealized observer that has this equivalence function and I ask, okay, suppose now they communicate with this different observer with a different equivalency function, they come to different understandings of what the entropy of the system is, but what is the relationship between their measured entropy values?

There clearly is one that depends algebraically on some details of the distinction between their respective equivalence functions.

but there doesn't seem to be any yet any general theory for for you know how those things are related and that there's you know that that's part of the kind of um the raison d'etre of this of of this research program um but yeah i mean okay so uh one thing that i will comment on

Although this is a little bit more speculative, it's again a sort of quasi-philosophical comment.

One place where the fact that you have all these different notions of entropy becomes kind of interesting is in fundamental physics.

So when you start to think about, if you try to model physics and the universe in these fundamentally computational terms, then one fairly generic conclusion that you can reach is that gravitation, general relativity, is essentially an entropic phenomenon.

people have kind of talked about this in in in non-computational contexts too but it's very very natural if you start to think about space-like hyper surfaces being sort of hypergraphs then you know in order to obtain a continuum geometry that's compatible with the Einstein equations you need to have certain ergodicity you know you need to be able to make certain ergodicity assumptions on the rewriting which in turn sort of implies certain lower bounds on the entropy of the system

So somehow gravitation, general relativity, is a coarse grained theory you obtain in the limit as the entropy goes to infinity.

But something that's interesting is that quantum mechanics, on the other hand, is an idealization that you obtain in the limit as entropy goes to zero.

Because in kind of one of these purely computational models of physics, the quantum mechanical state of a system is described in terms of its multi-way structure.

It's described in terms of, you know, when I have a kind of a branching program like this,

let me find, like this, then I can divide it up into these sort of, into these simultaneity surfaces.

And if I associate each state of the program as being like the analog of a quantum eigenstate and the kind of path weightings as being analogous to the amplitudes associated with these eigenstates, I can quickly build up a description of this multi-way system in terms of the evolution of some discrete analog of the Schrodinger equation.

And it turns out you get a theory that is mathematically isomorphic to standard quantum mechanics out of it.

So quantum mechanics is sort of inextricably bound up with the phenomenon of the multi-way system.

But if you take the entropy to infinity here, then you're effectively then the sophistication of your of your equivalence function becomes arbitrarily large, which means that you can describe any essentially any pair of states as being equivalent.

And so it turns out that the actually the quantum mechanical case corresponds to the zero entropy limit, whereas the kind of generalistic case corresponds to the infinite entropy limit.

But they're kind of two different two.

fundamentally different notions of entropy, one of which exists at the single-way level, one of which exists at the multi-way level.

And again, the question of how these things interplay is partly why we're investigating this.

And it's clear that that question has links to these quite foundational questions in fundamental physics.


SPEAKER_02:
The ideal point mass and the ideal distribution with its center of gravity and all this.

Dave, question for you, from you.


SPEAKER_01:
Yes.

Okay, I was, can you hear?

Yep, go for it.

Okay, good.

Yeah, I'd like to veer down to the low road during this discussion, maybe show business.

When people are trying to explain what is computational reducibility or irreducibility, often you'll see a graph that says, well, now here's the computation, our target, running along.

The fox is running along.

And behind it, there's a team of algorithms that would like to catch it.

And yeah, it either does or it doesn't outrun all of them, but some can seem to come pretty close to catching it.

Now there's something else people have been looking at for a few years, the Mandelbrot set.

The Mandelbrot set really is not only a deterministic computation, it's a crisp computation.

Every set, every point,

either is inside the safe zone, it's gonna sit there and it's happy and quiet and you color it black, or it flies off to infinity.

So it could just be a bunch of yes or nos, but that's not the way people trying to calm down after a day of work wanna look at it.

They wanna say, hey, I wanna see the 32 million deep Mandelbrot set.

And I want to see it in colors.

So when you get the colors, you ask, how hard did I have to work?

How long did I have to grind along before I made that decision?

Oh, this is a point that's going to settle down and be quiet and uninteresting, or it's going to fly off to infinity.

So you put colors in.

Now, I just wonder, would it be interesting to anyone to fuzzify these gorgeous

causal and multi-causal graphs and just show this is the portion where we had to work really hard rule 35 or what we had to go 15 000 generations before we gave up and said we're not going to follow this anymore the other one oh after 30 steps i i see


SPEAKER_00:
That's a really interesting question.

A couple comments on that.

One is, you're right in the sense that yes, the Mandelbrot set is a very clean thing to describe.

I would argue it's actually not a crisp

computation in that sense, precisely for reasons of computational irreducibility.

Because as you go arbitrarily close to the boundary of the set, you can have complex numbers that have a kind of indefinite period of transient.

There's no upper bound on how long the Zn squared plus C orbit can last before it either diverges or converges to zero.

And that statement that there will be points that can get tied up in these orbits indefinitely is really a computational irreducibility statement.

But yeah, I mean, your question about, you know, could you construct, so I mean, that way of coloring points that are on the boundary of the Mandelbrot set in that way, the so-called escape time algorithm, right, where you kind of, where you color them based on how many steps did I need to do before it either converged or escaped off, you know, above some, or, you know, the complex numbers modulus exceeded some value.

Yeah, it's an interesting idea that you could try and kind of construct

geometrical representations of the space of possible computations based on a kind of escape time algorithm for computational disability.

Yeah.

So, I mean, there are the possible ways that you could do that, right?

That you say, you know, we know

We've known since the days of Turing that the halting problem for Turing machines is undecidable.

There's no finite computation that you can do that will determine whether an arbitrary computer program will terminate in finite time.

So once you have a way of kind of geometrizing the space of possible computations, which we have now, as you say,

Yeah, you could easily construct a kind of escape time algorithm where, you know, you have your analog of the Mandelbrot set, which is, you know, here's all the halting computations.

Here are all the definitely non-halting computations.

And then there's some boundary of very fuzzy stuff where we kind of don't really know.

We have to do a lot of work.

And even then, it's only heuristic, which is which is, you know, I mean, very directly analogous.

And then, yeah.

And then the question becomes.

you know, so in the case of the M set, you know, there is some underlying theory, mostly, I think, mostly due to like Dwadi and Hubbard and people that allows you to kind of predict, like, you know, if you have a finite filament, you can, of the Mandelbrot set, you can kind of predict, you know, where that filament is going to be based on some complicated, complex analysis argument.

And, you know, I mean, the question is, once you, if you, once you have a geometrization of the space of possible computations, can you construct some general theory like the theory, you know,

developed by Duarte and Hubbard that tells you things about the topology of the computations, whether certain regions of the space are connected, whether they're compact, whether you can do a similar thing where you can make predictions based on the geometry of one part of the set, where you can extrapolate to things about the geometry of another part of the set.

That's a really interesting question.

And yeah, again, as with so many of these things, it's one of these, like, I don't know the answer, but it's a good reason for investigating, for pursuing the program, right?


SPEAKER_02:
Yeah, from the Wolfram side, as well as from the active inference side, there's both the information topology and the information geometry side.

And not just in the kind of topological deep learning, but rather looking at the topology of information flows.

which has been heavily developed in the category theory related to quantum information sciences and then the information geometries that allow us to do like machine learning type accelerated optimization and gradients all these kinds of concepts that come into play with geometry

And we just don't get them from topology so it's apology kind of sketches the skeleton and then with the computers that we have the information geometry is at least on the data sets and the ways that we have computation today that's kind of like the quantitative numerical versus the formal.

One question is, are these all discrete state space, discrete time formalisms?

Because in active inference, we often deal with hybrid models that have discrete and continuous state spaces and the same generative model or the same system of interest could be modeled with like a discrete time chapter seven or a continuous time chapter eight model.

So how does this deal with that?


SPEAKER_00:
That's a really good question.

So most of what I've been looking at so far has consisted of discrete time, discrete space models for no particularly principled reason other than they're easier to analyze.

For the most part, because you can do explicit computations, because they're more amenable to constructive analysis, it's easier to do.

But the beauty of a lot of this...

one of the beauties of using kind of general mathematical formalism is that once you develop it it's often quite easy to extend even to even to cases that you know to extrapolate to cases that you didn't explicitly analyze so in principle this formalism works for you know for continuum space and continuum time systems as well just with some you know with some slight modifications so rather than having say

branching and merging, you instead have, you know, if you think about this thing as now being a dynamical system, you know, described on some symplectic manifold, then these kind of branching, merging operations of the multi-way system become effectively divergence and convergence operate, you know, differential operators defined on the symplectic manifold.

And so, you know, one place where we can start to analyze that explicitly, and which I've done a little bit of work on, but it's one of these things which I want to go back to very soon, is looking at Petri nets.

So Petri Nets are interesting because they are a discrete time, discrete space system, but they admit a continuum, you know, continuum space, continuum time description in terms of ordinary differential equations and so on.

So they're a nice example of a hybrid kind of discrete event versus continuum event system where it's clear that this formalism can be used and is somehow agnostic as to whether the, you know, whether the underlying system is discrete or continuous.

Again, there's a broader philosophical point to make here, which is that

In a way, one of the reasons I don't feel embarrassed to be working primarily with discrete systems is because, you know, again, once you start to think about things in terms of, okay, you have to not just care about nature, you also have to care about the computations the observer can perform and what it's able to infer.

Then you quickly realize that in a sense, just like whatever you were saying earlier, Daniel, you know, beauty is in the eye of the beholder.

I think discreteness and continuity are also in the eye of the beholder, right?

I mean, so if you have,

If you have a universe that is fundamentally continuous, that's described by a continuum Lorentzian manifold or something, but you're constrained so that the only experiments you perform have computable outcomes, have discrete outcomes, where the possible number of observables is always countable, then in a sense it doesn't matter.

It's irrelevant to you as an observer whether the system is discrete or continuous, because the only parts of it that you can interface with and interact with are discrete.

And so you could have replaced the underlying substrate with a purely discrete mathematical structure and you wouldn't be able to tell.

So in some sense,

I don't feel too embarrassed dealing with discrete event systems, because even if I don't necessarily believe that nature is discrete, because I'm not even sure how we would be able to answer that, I'm reasonably convinced that the experiments that we can perform and the observations that we're able to perform are ultimately computable.

And therefore, the underlying substrate might as well be discrete, even if it's not in reality, so to speak.


SPEAKER_02:
yeah that's a great comment definitely calls back to your earlier points about like discretization being in the eye of the beholder like in the active inference models observations raw data may already be discretized depending on the situation but even if it weren't like it were a continuous sensory perception or modeled as such analytically still commonly models discretize and categorize as they move up cognitive hierarchies

and that was like initially explored to get more of this discrete either or decision making planning all those kinds of properties um well there's many interesting angles like I'm sure also it could be a multiplexed language model prompt but like what are you working on or excited about for 2024


SPEAKER_00:
Ah, that's a good question.

So I've kind of already given some hints about this general research program of trying to understand computational complexity and algorithmic complexity and interplays between observers and systems through this category-theoretic lens.

Yeah, that's a major thing which I started on, say, about maybe a couple of years ago.

I mean, in some form, I've been working on it for a long time, but this more recent perspective on it is maybe a couple of years old.

But for various reasons over the last year or so, I've kind of put that to rest and I've been

focused on these much more physics oriented questions about discrete space time and understanding things like, you know, how the black holes work and how the secretion work in discrete space, which is also very important and and very exciting.

But I've sort of slightly been missing these more abstract directions.

And so I have maybe one or two major, you know, physics related things that I need to finish off in the night.

And then I really want to go back to this to the greatest extent possible.

And I mean, so one thing is

that's quite clear is that there's great interplay between this formalism and existing theories of computational and algorithmic complexity.

So one very basic example is, I mentioned before that you have this kind of coherence between these two different algebraic structures, between the operation of time-like composition versus the operation of parallel composition.

And these two algebraic structures are, in general, related, although the precise conditions that relate them are not clear.

And that's partly what we're trying to understand.

But it turns out that degenerate cases of that question corresponds to unsolved problems in computational complexity theory.

So for instance, the P plus NP problem can essentially be recast in these terms, that you can recast the P plus NP problem as the question about,

coherence between the time-like composition of computational complexity and the parallel composition of computational complexity, which are what P and NP respectively are really about, are those coherence conditions the strictest they can be, which would be the case that P equals NP, or are they somehow more lax, which would be the case that P does not equal NP?

And so there's, you know, that's that's one thing that we kind of already investigated.

But it's clear that a whole bunch of questions about, you know, how the time complexity and space complexity trade off or how the Kolmogorov complexity and time complexity trade off.

These these are questions which can be recast in this kind of more algebraic therapeutic lens and will hopefully give insight into this general program of trying to understand observers and their relationship to the world.

And those are kind of major

Well, with any luck, those are major theorems that I hope we'll be able to prove at some point in 2024.


SPEAKER_02:
That's awesome, and it makes me think about parallel, more Nest Mates, more CPU threads.

deeper in time, more sequential, more planning and more cognitive single monolithic agent.

And then the kind of question is like, can anything that a single agent mega matrix could do, can that be decomposable at space advantage or even at space disadvantage in decomposed it into a single time step operation?


SPEAKER_00:
Yeah, that's a super important question and one that, with the possible exception of this community, not many people have asked.

That's something which comes up in quantum computing, right?

So a lot of the hype around quantum computation comes from these theoretical speedups that derive from the fact that you're able to support these superpositions of different, where each state of your data structure corresponds to a different eigenstate, and you're able to evolve some superposition of those eigenstates.

But then at the end, you have to actually come to a definite conclusion about what the answer is.

You have to perform some measurement operation.

And that measurement operation is lossy.

It's often non-deterministic.

You often have to repeat it multiple times.

And it's becoming increasingly clear that for a large class of operations that were previously thought to have quantum advantage, the additional complexity of the measurement step really kills any quantum advantage that you may have had.

You get some advantage by doing unitary evolution, but then you lose all of it by having to do the submission projection at the end.

And that's really a story of, again, this interplay between the time complexity saving of doing a multi-computation in parallel versus the loss that comes from the complexity of the equivalence function that you need to apply in order to get to some definite conclusion about what happened.

Because ultimately, you need to somehow collapse that directed graph into a single thread of time in order to be able to have some coherent representation of what happened.

And so again, that's a place where understanding these trade-offs will become very important.

And as I say, in some limiting case, that gives some perspective on your question, Daniel, which I agree is a very interesting question about

In principle, we know that anything that a deterministic Turing machine can do, a non-deterministic Turing machine can do, and vice versa with some speed up or slow down.

But that statement, which is a classic result in computability theory, neglects all consideration of the equivalence function.

So there may be cases where the equivalence function is so complex that essentially the to-do state equivalence becomes undecidable.

And so in that case, you have a scenario where actually, you know, you've got a multi computational system, but to to collapse it to one that's equivalent to a single way system requires unbounded amounts of computational effort.

And so so actually they become an equivalent, even though, you know, computability theory says they should be the same.

So it's clear that there's a there's a more rich, more subtle theory that's underlying here that we're just beginning to kind of glimpse and that I hope we'll you know, we'll be able to kind of to prove some new limited results about soon once we understand it a bit better.


SPEAKER_02:
awesome and i think definitely a special shout out to all of our colleagues on either like the wolfram and or active inference side because we've seen few if any active inference models phrased analytically or computationally with the wolfram technology um from studying complexity in other areas

It's really clear to see how productive and powerful the software and the tools can be and changing and growing every day.

So it's really interesting.

Maybe someone can, if they're listening this far in, like go from one side to the other and back or make a Wolfram active inference model.

or do some other kind of combination because it's very fruitful territory and we know that our elders have already spoken.

They've okayed it.

No, but really it's so rich with connections here between the areas that we're all studying and feeling like converging on many common places to scaffold and jump off from together.


SPEAKER_00:
Yeah, I agree.

The kinds of things that we were discussing here about speculative execution and behavior formation through free energy principle and so on, those things should be relatively easy to implement in the framework that's already been developed here.

That's a question of just implementing some kind of computation of expected free energy and using that to weight multi-way paths in the speculative execution model.

So at least the beginnings of that implementation, I think the path is pretty clear, and we will probably end up doing at some point in the future anyway as part of other research.

So yeah, I agree, it's a very exciting point of interface.


SPEAKER_02:
Yeah, well, I hope that we can stay in touch if you ever want to come back for a

009.2 or if we want to even facilitate some kind of working group or some connections to really strengthen and include the participation of more people in this super exciting area, that would be amazing.


SPEAKER_00:
Yeah, that sounds fun.

Let's try and set something up.


SPEAKER_02:
Well, Dave, first penultimate comments, then Jonathan, you can have the kind of last comments.


SPEAKER_01:
Yes, I hope you do get to continue on the Wolfram physics side to think about a more general notion of what these ultimate things are.

Are they observers or does that already prejudice the case of what you might find if you call them workers or actors or, you know, go back and ask Stuart Kaufman, what must a mind do to earn its way in the world?


SPEAKER_00:
let's make this keep happening thank you thank you dave for suggesting it also it was a great suggestion jonathan no and that's i think that's a fantastic note to end on i mean and and that that in a sense this this idea that we should start to move i mean so it's okay big picture for a moment like

where you know this formalism is being developed the the formalism i've described in this in this discussion is being developed you know assuming a kind of purely passive observer idealization and that's already been incredibly difficult right it's clear there's a lot we don't understand at that but of course david is right that that in a sense you know what you know ultimately we want to start transitioning to a to a participatory observer model where where you allow for two-way interactions or you know higher order interactions between observers and systems and things that don't just go in one direction and yeah

In a sense, I view a lot of what we're trying to do with trying to nail down these notions of causality, trying to understand these interplays between different complexity and entropy measures as the necessary groundwork for developing that subsequent theory.

It's clear that if we want to have

a uh a version of the you know of this kind of compositional multi-way formalism that is also compatible with things like second order cybernetics then uh you know at the very least we need to have a very coherent notion for what causality is and and you know and a robust algebraic description of that that's not going to to break or change and so i think um the the the non-participatory a participatory observer

model is a useful starting point because it's one that is just within our grasp of being mathematically tractable.

And then the hope is that the technology and the ideas and the conceptual structure that we develop for understanding that will then, as I say, lay the groundwork for developing something that's more like what real active participatory observers do.

Um, and, uh, and yeah, I mean, I, I think I, I don't on the, on the scientific side, I'm not really sure I have anything, any final comments apart from just, you know, as is obvious, this is a, you know, this is still a story that's being, that's being developed.

And, uh, and yeah, as Daniel alluded to, I hope that we can continue to, uh, to interact and, and, and collaborate where, where, where that makes sense.

And, and yeah, at the very least, I think.

incorporation of these active inference models within these discrete time, in the first instance, discrete time computational frameworks, and allowing things like speculative execution and multi-way path weighting based on free energy estimates.

I think that's a project that's of obvious mutual interest and something that I hope will happen in the coming months.


SPEAKER_02:
Thank you.

We just speculatively executed Act of Wolfram Prince.

Basically.

All right.

Thank you, Jonathan.

Thank you, Dave.

Thank you, everyone.

See y'all next time.