1
00:00:01,290 --> 00:00:04,494
好的，下一位是

2
00:00:04,532 --> 00:00:06,606
Keith Dugger，他提交了一段预先录制的

3
00:00:06,628 --> 00:00:09,118
视频。 预先录制的视频

4
00:00:09,204 --> 00:00:11,694
称为主动推理。 还有

5
00:00:11,732 --> 00:00:14,765
演员模型所以我现在就提出这个问题

6
00:00:14,788 --> 00:00:15,920
。

7
00:00:29,430 --> 00:00:32,958
好的，这是 Keith

8
00:00:33,134 --> 00:00:35,910
预先录制的有关主动推理

9
00:00:35,990 --> 00:00:37,660
和 Actor 模型的视频。

10
00:00:44,240 --> 00:00:46,956
主动推理和演员模型。

11
00:00:47,138 --> 00:00:49,608
你好。 你好。 我是 Keith Thugger 博士，是

12
00:00:49,704 --> 00:00:52,684
扩展现实人工智能 X Ray 的平台首席技术官

13
00:00:52,732 --> 00:00:56,464
。 公司，也是

14
00:00:56,502 --> 00:00:58,880
机器学习街头谈话播客的联合主持人。

15
00:00:59,780 --> 00:01:02,624
现在，当我们都致力于建立一个

16
00:01:02,662 --> 00:01:05,536
基于主动推理的生态系统时，

17
00:01:05,728 --> 00:01:08,324
软件显然将在充分利用主动推理方面发挥

18
00:01:08,362 --> 00:01:11,363
基础作用

19
00:01:11,402 --> 00:01:13,204
。 我们需要使用

20
00:01:13,242 --> 00:01:15,524


21
00:01:15,562 --> 00:01:17,636
符合主动

22
00:01:17,668 --> 00:01:20,136
推理原则的软件工程范式，我认为有一种

23
00:01:20,238 --> 00:01:22,664
范式适合我们的需求。 这就是所谓的

24
00:01:22,702 --> 00:01:26,084
演员模型。 主动推理

25
00:01:26,132 --> 00:01:28,356
和演员模型是

26
00:01:28,388 --> 00:01:30,750
对世界的两种紧密相连的理解。

27
00:01:31,280 --> 00:01:34,204
它们提供了

28
00:01:34,242 --> 00:01:36,280
处理复杂

29
00:01:36,360 --> 00:01:39,624
系统动态的基础框架，重点关注

30
00:01:39,672 --> 00:01:42,672
在嵌套系统生态中交互的自主代理

31
00:01:42,726 --> 00:01:46,283
。 我想探讨

32
00:01:46,332 --> 00:01:47,916
它们的一些关键联系，

33
00:01:48,108 --> 00:01:50,050
包括代理

34
00:01:50,500 --> 00:01:53,040
并发性、自主性、

35
00:01:53,380 --> 00:01:57,300
不确定性和行为适应的作用。

36
00:01:58,680 --> 00:02:00,596
我们将看到主动推理和

37
00:02:00,618 --> 00:02:03,184
主动模型都是范式

38
00:02:03,232 --> 00:02:06,300
转变，从确定性的、

39
00:02:06,480 --> 00:02:10,392
集中的、逐步的思维转向

40
00:02:10,446 --> 00:02:14,004
分散的网络并发

41
00:02:14,052 --> 00:02:17,751
计算和

42
00:02:17,806 --> 00:02:21,052
认知视角。

43
00:02:21,106 --> 00:02:25,100
关于 Actor 模型的一些历史。 早在 1973 年，

44
00:02:25,250 --> 00:02:28,504
Karl Hewitt、Peter Bishop 和 Richard

45
00:02:28,552 --> 00:02:30,555
Steiger 都在

46
00:02:30,578 --> 00:02:33,676
麻省理工学院的 AI

47
00:02:33,708 --> 00:02:37,804
实验室工作，研究

48
00:02:37,852 --> 00:02:40,972
并发计算的概念，包括

49
00:02:41,036 --> 00:02:44,304
结构和适应性

50
00:02:44,352 --> 00:02:46,020
算法执行。

51
00:02:47,480 --> 00:02:49,744
当时的传统方法缺乏

52
00:02:49,792 --> 00:02:52,224
稳健性和可靠的数学

53
00:02:52,272 --> 00:02:55,263
基础。 他们的共同努力

54
00:02:55,312 --> 00:02:57,576
最终导致了

55
00:02:57,598 --> 00:03:01,076
Actor 模型的创建。 当时，

56
00:03:01,108 --> 00:03:03,224
由于其

57
00:03:03,262 --> 00:03:05,764
增强的容错

58
00:03:05,812 --> 00:03:08,784
能力和分布式计算

59
00:03:08,852 --> 00:03:12,236
能力的特点，它被认为是革命性的。 在整个 20 世纪 80 年代和

60
00:03:12,258 --> 00:03:15,388
90 年代，Actor 模型成为

61
00:03:15,394 --> 00:03:18,476
众多研究项目

62
00:03:18,498 --> 00:03:20,856
和实际项目的基础，因其

63
00:03:20,888 --> 00:03:23,184
灵活性和

64
00:03:23,222 --> 00:03:25,516
直观的并发

65
00:03:25,548 --> 00:03:29,648
计算方法而广受欢迎。 它主要用于

66
00:03:29,734 --> 00:03:32,240
人工智能和多代理

67
00:03:32,310 --> 00:03:34,400
系统。 听起来有点熟？

68
00:03:35,880 --> 00:03:38,784
新的基于 Actor 的语言（例如 Actor、

69
00:03:38,912 --> 00:03:42,116
Saulson 和 Erlang）为

70
00:03:42,138 --> 00:03:44,356
模型的完善做出了贡献，将其塑造

71
00:03:44,378 --> 00:03:47,203
成一种更强大、更灵活的并发

72
00:03:47,332 --> 00:03:50,148
计算方法，并且

73
00:03:50,244 --> 00:03:52,164
在当今的计算机科学中仍然存在

74
00:03:52,212 --> 00:03:55,272
。 最近，Actor 模型

75
00:03:55,326 --> 00:03:57,796
重新引起了人们的兴趣，主要是

76
00:03:57,828 --> 00:03:59,944
由于对分布式

77
00:03:59,992 --> 00:04:02,904
系统、云计算和边缘

78
00:04:02,952 --> 00:04:05,036
计算的需求不断增长，推动了

79
00:04:05,058 --> 00:04:07,310
物联网和 Web 30。

80
00:04:08,480 --> 00:04:11,351
这些计算机任务非常适合

81
00:04:11,416 --> 00:04:13,436
利用 ACA 模型的

82
00:04:13,468 --> 00:04:16,800
架构 ，它的设计目的是一方面对

83
00:04:16,950 --> 00:04:20,368


84
00:04:20,534 --> 00:04:23,409
大量数据进行并发处理建模，另一方面对

85
00:04:23,800 --> 00:04:26,752
细粒度的不同自治

86
00:04:26,816 --> 00:04:28,710
系统进行建模。

87
00:04:29,640 --> 00:04:32,003
Actor模型的这种应用

88
00:04:32,042 --> 00:04:34,436
对Twitter、Facebook、LinkedIn等利用其原理处理大数据问题的各大公司产生了深远的影响，

89
00:04:34,538 --> 00:04:36,904


90
00:04:36,942 --> 00:04:38,936


91
00:04:38,958 --> 00:04:41,348


92
00:04:41,524 --> 00:04:45,256
那么这

93
00:04:45,278 --> 00:04:47,636
与主动推理有什么关系呢？ 我

94
00:04:47,668 --> 00:04:49,368
猜您已经

95
00:04:49,374 --> 00:04:51,656
在简介中听过一些相似之处。 但让我们

96
00:04:51,688 --> 00:04:53,656
首先看看

97
00:04:53,688 --> 00:04:56,396
参与者模型的一些核心原则以及

98
00:04:56,418 --> 00:04:58,568
它们与主动推理原则的关系

99
00:04:58,584 --> 00:05:01,236
。 让我们从

100
00:05:01,288 --> 00:05:04,832
隔离的概念开始。 隔离意味着

101
00:05:04,886 --> 00:05:07,664
参与者模型中的参与者

102
00:05:07,702 --> 00:05:10,464
不与任何其他参与者共享其状态

103
00:05:10,502 --> 00:05:14,212
。 它只能通过

104
00:05:14,266 --> 00:05:17,060
接收消息来影响。 它只能

105
00:05:17,130 --> 00:05:19,524


106
00:05:19,562 --> 00:05:22,164
通过发送有限数量的

107
00:05:22,202 --> 00:05:25,776
消息作为响应来影响其他参与者状态的变化。 从软件

108
00:05:25,808 --> 00:05:27,512
工程的角度来看，这种

109
00:05:27,566 --> 00:05:30,051
隔离原则将

110
00:05:30,116 --> 00:05:33,111
操作的潜在副作用限制在单个

111
00:05:33,166 --> 00:05:35,924
参与者身上，从而提高了系统的

112
00:05:35,972 --> 00:05:39,072
整体可预测性可靠性，

113
00:05:39,236 --> 00:05:42,104
最重要的是，如果完全接受，

114
00:05:42,232 --> 00:05:44,910
实际上可以简化设计。

115
00:05:46,560 --> 00:05:48,636
查看该图，我们看到一个

116
00:05:48,658 --> 00:05:51,616
参与者的生态系统，该

117
00:05:51,638 --> 00:05:54,635
参与者向特定参与者发送消息，该特定参与者又将

118
00:05:54,668 --> 00:05:57,040
消息发送回其他参与者。

119
00:05:58,340 --> 00:06:00,690
主动推理在哪里？ 好吧，

120
00:06:01,300 --> 00:06:03,816
让我们将接收和发送

121
00:06:03,868 --> 00:06:07,392
消息重新定义为感知动作周期，

122
00:06:07,536 --> 00:06:09,620
并表示外部、

123
00:06:10,200 --> 00:06:13,539
内部、感觉和

124
00:06:13,610 --> 00:06:17,112
活动状态。 现在我们显然已经具备了马尔可夫毯子

125
00:06:17,166 --> 00:06:19,956
主动推理的必要基础

126
00:06:19,988 --> 00:06:22,600
。

127
00:06:23,660 --> 00:06:26,436
参与者模型的参与者

128
00:06:26,468 --> 00:06:28,848
直接映射到主动推理的代理

129
00:06:28,884 --> 00:06:32,840
。 此外，有限性，

130
00:06:33,000 --> 00:06:35,676
即参与者只能发送

131
00:06:35,698 --> 00:06:39,003
有限数量的消息作为响应，也是

132
00:06:39,042 --> 00:06:41,150
一个重要的共享属性。

133
00:06:41,940 --> 00:06:44,780
由于主动推理对现实进行建模，因此

134
00:06:44,940 --> 00:06:47,452
它必然尊重

135
00:06:47,516 --> 00:06:50,704
真实系统的资源限制。 这

136
00:06:50,742 --> 00:06:53,376
很好地融入了主动模型的基础中

137
00:06:53,398 --> 00:06:56,496
。 我们再来看看

138
00:06:56,528 --> 00:06:59,860
异步消息传递的另一个核心原理。

139
00:07:00,840 --> 00:07:03,012
参与者之间的通信是

140
00:07:03,066 --> 00:07:05,936
异步的。 这意味着参与者

141
00:07:05,968 --> 00:07:07,832
在发送消息后不会等待响应

142
00:07:07,886 --> 00:07:10,680
。 可以说，它继续工作，

143
00:07:10,830 --> 00:07:13,210
继续生活。

144
00:07:13,820 --> 00:07:17,256
这是至关重要的，因为它将参与者解耦

145
00:07:17,278 --> 00:07:20,284
，从而使系统

146
00:07:20,322 --> 00:07:23,020


147
00:07:23,090 --> 00:07:25,948
即使在系统的某些部分速度

148
00:07:26,034 --> 00:07:28,551
缓慢甚至暂时

149
00:07:28,616 --> 00:07:31,964
不可用时也可以继续运行、运行并取得进展。 弗里斯顿教授

150
00:07:32,012 --> 00:07:34,028
说过，自由能原理

151
00:07:34,124 --> 00:07:38,240
是终极的存在问题，如果

152
00:07:38,310 --> 00:07:41,490
事物存在，它们必须做什么？

153
00:07:42,660 --> 00:07:45,412
嗯，演员模型声称他们

154
00:07:45,466 --> 00:07:47,350
不能等待别人。

155
00:07:48,360 --> 00:07:51,572
当然，演员可以选择等待

156
00:07:51,626 --> 00:07:55,284
别人，但

157
00:07:55,322 --> 00:07:58,808
在模型中绝对不能强迫这样做。 必须是可以自由

158
00:07:58,894 --> 00:07:59,770
选择的。

159
00:08:01,820 --> 00:08:04,004
这使我们得出另一个关键

160
00:08:04,052 --> 00:08:06,456
原则，即两种模型共享

161
00:08:06,558 --> 00:08:09,719
自主权。 自由能

162
00:08:09,790 --> 00:08:12,860
原理是物理现实的模型，

163
00:08:13,280 --> 00:08:15,547
毕竟我们的现实是

164
00:08:15,634 --> 00:08:18,904
同时存在的。 在整个无限

165
00:08:18,952 --> 00:08:21,572
空间中，系统都

166
00:08:21,656 --> 00:08:24,048
根据其局部

167
00:08:24,134 --> 00:08:27,696
动态同时演化。 因此，这

168
00:08:27,718 --> 00:08:29,344
反映在自由

169
00:08:29,382 --> 00:08:33,024
能原理的核心。 当然，

170
00:08:33,062 --> 00:08:35,796
计算模型不必将自身限制于

171
00:08:35,818 --> 00:08:38,784
物理。 但休伊特等人。 我们正在寻求

172
00:08:38,832 --> 00:08:41,395
开发一个模型来模拟

173
00:08:41,418 --> 00:08:43,664
分布式并发系统的现实

174
00:08:43,712 --> 00:08:47,056
。 对我们来说幸运的是，

175
00:08:47,088 --> 00:08:50,824


176
00:08:50,862 --> 00:08:53,352
从隔离原则和

177
00:08:53,486 --> 00:08:56,500
参与者自治原则来看，参与者模型同时支持并发性，使其

178
00:08:56,580 --> 00:08:58,040
与主动推理兼容。

179
00:08:59,200 --> 00:09:01,820
接下来我们来筑巢。

180
00:09:02,640 --> 00:09:05,532
参与者模型不仅允许参与者

181
00:09:05,586 --> 00:09:08,552
接收和发送有限

182
00:09:08,616 --> 00:09:11,984
数量的消息来感知和采取行动，

183
00:09:12,182 --> 00:09:15,292
还允许作为一个动作创建

184
00:09:15,356 --> 00:09:18,240
有限数量的新参与者。

185
00:09:19,220 --> 00:09:21,504
这些参与者可以嵌套在

186
00:09:21,542 --> 00:09:24,336
父代（例如动物细胞的一部分）内

187
00:09:24,368 --> 00:09:26,564
，也可以

188
00:09:26,602 --> 00:09:29,076
作为独立的参与者释放到环境中。 从那时

189
00:09:29,098 --> 00:09:32,336
起，根据这个原则，该模型非常适合

190
00:09:32,368 --> 00:09:34,628


191
00:09:34,714 --> 00:09:37,960
多尺度嵌套和主动推理的美丽概念。

192
00:09:38,940 --> 00:09:41,460
这使得参与者能够包含自下而上的

193
00:09:41,540 --> 00:09:44,791
参与者生态系统

194
00:09:44,846 --> 00:09:47,290
。

195
00:09:49,200 --> 00:09:51,976
最后，我想介绍另外两个 Actor

196
00:09:52,008 --> 00:09:55,436
模型设计原则：行为改变

197
00:09:55,618 --> 00:09:57,020
和持久性。

198
00:09:59,040 --> 00:10:01,664
参与者有能力改变自己的

199
00:10:01,702 --> 00:10:04,450
行为以响应消息。

200
00:10:05,140 --> 00:10:08,192
这种适应性允许构建可以

201
00:10:08,246 --> 00:10:10,924


202
00:10:10,972 --> 00:10:14,130
随时间演变的复杂有状态实体。

203
00:10:14,760 --> 00:10:17,492
事实上，它允许整个

204
00:10:17,626 --> 00:10:21,584
生态系统进化出新的涌现

205
00:10:21,632 --> 00:10:25,263
行为。 当用于软件

206
00:10:25,312 --> 00:10:28,264
工程时，这增加了

207
00:10:28,382 --> 00:10:31,800
管理复杂动态系统的强大工具。

208
00:10:32,700 --> 00:10:35,412
当然，主动推理将这

209
00:10:35,476 --> 00:10:39,304
一点发挥到了极致。

210
00:10:39,352 --> 00:10:42,363
事物的本质是不断尝试

211
00:10:42,402 --> 00:10:45,324
预测和适应环境，

212
00:10:45,362 --> 00:10:48,439
从而继续存在，以

213
00:10:48,520 --> 00:10:52,828
在激烈的活动海洋中维持马尔可夫毯子

214
00:10:53,004 --> 00:10:56,736
。 随之而来的还有

215
00:10:56,758 --> 00:10:58,912


216
00:10:58,966 --> 00:11:02,444
持久性的概念。 持久性允许参与者

217
00:11:02,492 --> 00:11:05,524
保存他们的状态并在以后恢复或

218
00:11:05,562 --> 00:11:08,640
修改它，这是

219
00:11:08,720 --> 00:11:11,300
体现记忆原理的功能。

220
00:11:11,800 --> 00:11:14,675
记忆是学习和适应的先决条件

221
00:11:14,778 --> 00:11:18,504
。 智能体的

222
00:11:18,622 --> 00:11:21,640
预测能力取决于其

223
00:11:21,710 --> 00:11:24,356
记住过去经历的能力，从而最大限度地

224
00:11:24,388 --> 00:11:27,176
减少与意外相关的意外情况

225
00:11:27,198 --> 00:11:30,520
。

226
00:11:30,600 --> 00:11:34,056
当我们假设主体

227
00:11:34,088 --> 00:11:36,199
具有归纳先验（

228
00:11:36,280 --> 00:11:39,100
来自经验或遗传）并

229
00:11:39,440 --> 00:11:41,470
有助于他们的世界模型时，记忆的重要作用也得到了强调。

230
00:11:42,340 --> 00:11:44,464
这个世界模型既指导他们

231
00:11:44,502 --> 00:11:47,291
当前的行为，又

232
00:11:47,356 --> 00:11:50,028
根据

233
00:11:50,204 --> 00:11:52,939
有助于他们不断适应

234
00:11:53,020 --> 00:11:54,240
和存在的新经验不断更新。

235
00:11:56,600 --> 00:11:59,684
好的，太好了。 你说

236
00:11:59,722 --> 00:12:02,308
演员模型和主动推理之间有清晰而深刻的联系

237
00:12:02,394 --> 00:12:06,424
。 但这对

238
00:12:06,462 --> 00:12:08,756
我们活跃的推理

239
00:12:08,788 --> 00:12:11,988
社区有什么帮助呢？ 嗯，首先，

240
00:12:12,084 --> 00:12:14,084
在我看来，这是

241
00:12:14,132 --> 00:12:16,520
我们应该拥抱的软件工程范例。

242
00:12:16,860 --> 00:12:19,340
如果我们这样做，当然还有我们可以使用的

243
00:12:19,410 --> 00:12:21,815
Actor 模型库和框架，

244
00:12:21,848 --> 00:12:25,448
例如 ACA、

245
00:12:25,624 --> 00:12:29,752
Orleans、thespian Actix

246
00:12:29,896 --> 00:12:33,055
Protoactor 等等，我们可以

247
00:12:33,078 --> 00:12:35,516
在构建主动

248
00:12:35,548 --> 00:12:37,872
推理软件模块和

249
00:12:37,926 --> 00:12:41,596
应用程序时立即使用它们。 还有一些库、

250
00:12:41,708 --> 00:12:43,944
语言甚至语言功能

251
00:12:44,012 --> 00:12:46,016
与参与者

252
00:12:46,048 --> 00:12:49,380
模型原则非常一致，例如 Zero、

253
00:12:49,450 --> 00:12:52,640
MQ、tokyo 和 Rust、

254
00:12:52,800 --> 00:12:56,284
Erlang、Async、Await 和 C. Sharp

255
00:12:56,432 --> 00:13:00,104
等。 但比

256
00:13:00,142 --> 00:13:04,712
我们今天可用的工具更重要的是

257
00:13:04,766 --> 00:13:07,544
软件设计思维，它将

258
00:13:07,582 --> 00:13:10,136
指导我们创建

259
00:13:10,168 --> 00:13:13,996
未来的主动推理软件。

260
00:13:14,018 --> 00:13:16,764
参与者模型提供了

261
00:13:16,802 --> 00:13:20,588
软件设计和工程的范例，这是

262
00:13:20,754 --> 00:13:24,064
我们对于主动推理最完美的匹配

263
00:13:24,102 --> 00:13:28,160
。 这

264
00:13:28,580 --> 00:13:30,876
不仅从

265
00:13:30,908 --> 00:13:34,084
我们之前讨论的核心原则的一致性中显而易见，而且从

266
00:13:34,122 --> 00:13:37,055


267
00:13:37,088 --> 00:13:39,156
参与者模型中的主动推理给

268
00:13:39,178 --> 00:13:42,916
彼此带来的见解中也可见一斑。 例如，考虑

269
00:13:42,938 --> 00:13:46,604
现在所谓的休伊特定律。 非正式地

270
00:13:46,672 --> 00:13:49,800
说，一切都无处不在，

271
00:13:51,260 --> 00:13:54,824
该定律意味着

272
00:13:54,942 --> 00:13:57,844
在真正的异步分布式

273
00:13:57,892 --> 00:14:00,652
系统中，

274
00:14:00,706 --> 00:14:03,532
消息从一个

275
00:14:03,586 --> 00:14:07,032
地方到达另一个地方可能需要任意时间，并且任何参与者都

276
00:14:07,096 --> 00:14:10,364
必须为该事件做好准备。 在这样的系统中

277
00:14:10,402 --> 00:14:13,900
根本不存在瞬时这样的事情

278
00:14:13,980 --> 00:14:17,888
，并且没有任何组件可以

279
00:14:17,974 --> 00:14:20,384
对

280
00:14:20,422 --> 00:14:23,548
另一个组件的操作的时间做出假设。 事实上，

281
00:14:23,734 --> 00:14:26,980
人们必须表现得好像消息

282
00:14:27,050 --> 00:14:30,819
永远不会到达一样。 这具有重要

283
00:14:30,890 --> 00:14:34,644
意义。 这表明

284
00:14:34,682 --> 00:14:36,744


285
00:14:36,782 --> 00:14:39,176


286
00:14:39,198 --> 00:14:42,569
在任何给定时间都不可能准确一致地确定整个系统的状态，

287
00:14:43,260 --> 00:14:45,464
因为信息可能还

288
00:14:45,502 --> 00:14:48,410
没有在整个系统中传播。

289
00:14:49,760 --> 00:14:52,904
并且尝试实现全局

290
00:14:52,952 --> 00:14:55,400
同步也不可避免地会

291
00:14:55,480 --> 00:14:57,864
引入瓶颈并降低

292
00:14:57,912 --> 00:15:01,844
效率。 休伊特定律强调

293
00:15:01,912 --> 00:15:04,976
系统设计时需要

294
00:15:04,998 --> 00:15:07,580
能够有效处理

295
00:15:07,660 --> 00:15:09,504
这些不可避免的延迟和

296
00:15:09,542 --> 00:15:11,776
不确定性，强调

297
00:15:11,798 --> 00:15:14,424
稳健的无阻塞

298
00:15:14,492 --> 00:15:17,540
通信机制和本地决策

299
00:15:17,690 --> 00:15:21,284
能力的重要性。 简而言之，

300
00:15:21,482 --> 00:15:24,240
赫克托模型系统本质上是

301
00:15:24,400 --> 00:15:27,944
不确定的。 这听起来

302
00:15:27,982 --> 00:15:31,800
很熟悉吗？ 还有什么其他范式强调

303
00:15:32,140 --> 00:15:34,616
不确定性下的运营以及

304
00:15:34,638 --> 00:15:36,904
尽管环境如何仍能继续自主

305
00:15:36,942 --> 00:15:40,328
？ 主动推理和

306
00:15:40,334 --> 00:15:43,767
自由能原理？ 主动推理

307
00:15:43,864 --> 00:15:46,552
反映了

308
00:15:46,616 --> 00:15:48,792
我们的软件系统

309
00:15:48,856 --> 00:15:51,920
运行的不可预测的世界的现实。

310
00:15:51,990 --> 00:15:55,136
由于

311
00:15:55,158 --> 00:15:57,756
事件以随机、

312
00:15:57,868 --> 00:16:01,644
不可预测的顺序发生，相同的初始条件可能会产生不同的结果。 这是

313
00:16:01,692 --> 00:16:04,310
我们都熟知的惊喜概念，

314
00:16:05,000 --> 00:16:07,572
当智能体收到的感官输入与其预测不符时，它会更新其对世界的信念

315
00:16:07,626 --> 00:16:10,404


316
00:16:10,442 --> 00:16:13,060
。

317
00:16:13,720 --> 00:16:15,856
演员模型和主动

318
00:16:15,888 --> 00:16:18,328
推理都承认世界是

319
00:16:18,414 --> 00:16:21,624
不可预测的。 这些

320
00:16:21,662 --> 00:16:24,632
模型不仅承认这一点，而且还接受这种

321
00:16:24,686 --> 00:16:27,688
不确定性是给定的，而不是

322
00:16:27,774 --> 00:16:29,530
可以消除的东西。

323
00:16:30,780 --> 00:16:33,752
事实上，正如我们在自由能原理中所知

324
00:16:33,806 --> 00:16:36,204
，我们

325
00:16:36,242 --> 00:16:38,459
在模型中保持的不确定性赋予了我们

326
00:16:38,530 --> 00:16:41,020
适应的灵活性。

327
00:16:43,540 --> 00:16:46,555
也许这只是我个人

328
00:16:46,588 --> 00:16:49,199
的幻想，但我想象在未来，

329
00:16:49,270 --> 00:16:51,596
由主动推理引导的软件模块将

330
00:16:51,628 --> 00:16:54,976
取消硬编码的错误

331
00:16:55,008 --> 00:16:57,792
处理，并替换为

332
00:16:57,856 --> 00:17:00,672


333
00:17:00,736 --> 00:17:03,200
随着错误情况的

334
00:17:03,280 --> 00:17:07,316
发展而优化自身的概率学习算法。 模块是强大的

335
00:17:07,428 --> 00:17:11,268
、自我修复的分布式系统，

336
00:17:11,364 --> 00:17:13,672
没有单点故障，

337
00:17:13,726 --> 00:17:17,716
专注于预测性灾难避免

338
00:17:17,907 --> 00:17:21,659
而不是反应性灾难恢复。

339
00:17:23,040 --> 00:17:25,308
展望未来，我们作为一个

340
00:17:25,314 --> 00:17:28,044
社区有潜力推动

341
00:17:28,082 --> 00:17:31,700
主动印记理论

342
00:17:31,880 --> 00:17:34,576
和

343
00:17:34,598 --> 00:17:37,611
行动者模型实际实现的界限。 通过结合利用

344
00:17:37,676 --> 00:17:40,096
这两种范式的优势，我们可以

345
00:17:40,118 --> 00:17:42,860
创建健壮、

346
00:17:43,020 --> 00:17:45,876
适应性强且更符合

347
00:17:45,898 --> 00:17:48,500
其实际运行的物理世界的软件系统

348
00:17:48,650 --> 00:17:52,100
。 想象一下未来，在

349
00:17:52,170 --> 00:17:54,976


350
00:17:55,008 --> 00:17:57,112
参与者模型中使用主动推理的软件组件可以

351
00:17:57,166 --> 00:18:00,344
预测潜在问题，从

352
00:18:00,382 --> 00:18:04,024
过去的错误中学习，并实时适应

353
00:18:04,062 --> 00:18:07,144
环境变化。 通过这种

354
00:18:07,182 --> 00:18:09,212
方法，我们可以构建

355
00:18:09,266 --> 00:18:11,996
从根本上更具弹性和

356
00:18:12,018 --> 00:18:15,084
效率的系统。 在我看来，这可以带来

357
00:18:15,122 --> 00:18:17,784
软件可靠性

358
00:18:17,912 --> 00:18:21,052
、性能和可扩展性的巨大变化，并

359
00:18:21,106 --> 00:18:24,044
预示着计算的新时代，将

360
00:18:24,092 --> 00:18:27,264
生物学和认知原理编织到

361
00:18:27,302 --> 00:18:30,060
我们软件系统的结构中，

362
00:18:30,220 --> 00:18:32,416
使它们在这个过程中更接近生活

363
00:18:32,438 --> 00:18:36,420
。 总之，

364
00:18:37,160 --> 00:18:39,636
主动推理与

365
00:18:39,658 --> 00:18:42,803
参与者模型的耦合提供了一个强大的新

366
00:18:42,842 --> 00:18:44,564
镜头，通过它我们可以观察

367
00:18:44,602 --> 00:18:46,820
软件设计和工程。

368
00:18:47,180 --> 00:18:49,412
无论我们利用

369
00:18:49,476 --> 00:18:51,476
与主动推理相一致的现有语言和库

370
00:18:51,508 --> 00:18:54,728
还是发明新的语言和库，

371
00:18:54,894 --> 00:18:58,056
我们都站在

372
00:18:58,078 --> 00:19:01,944
令人兴奋的前沿的边缘。 因此，让我们抓紧

373
00:19:01,992 --> 00:19:05,068
时间，看看 Actor 模型

374
00:19:05,154 --> 00:19:06,776
及其与主动

375
00:19:06,808 --> 00:19:09,484
推理的关系，让我们一起塑造

376
00:19:09,522 --> 00:19:11,980
智能分布式计算的未来。

377
00:19:13,040 --> 00:19:14,460
感谢您的聆听。

378
00:19:17,790 --> 00:19:21,050
惊人的。 基思的演讲很棒

379
00:19:21,120 --> 00:19:23,126
。 谢谢基思发送

380
00:19:23,158 --> 00:19:25,985
该信息。聊天中出现了一些评论

381
00:19:26,008 --> 00:19:28,978
。 所以，基思，如果你想在

382
00:19:28,984 --> 00:19:32,641
未来的某个时间参加问答，那么可能会，但

383
00:19:32,696 --> 00:19:33,949
演讲真的很酷。

