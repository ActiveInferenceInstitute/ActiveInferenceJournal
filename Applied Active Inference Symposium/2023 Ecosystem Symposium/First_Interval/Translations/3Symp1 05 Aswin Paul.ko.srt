1
00:00:00,840 --> 00:00:02,820
그 일을 계속하고

2
00:00:02,820 --> 00:00:05,880
오늘 밤 우리와 공유해 주셔서 정말

3
00:00:05,880 --> 00:00:07,859
감사합니다.

4
00:00:07,859 --> 00:00:09,900
다음 번에 뵙도록 해주셔서 정말 감사합니다.

5
00:00:09,900 --> 00:00:12,179
감사합니다. 안녕히 가세요.

6
00:00:12,179 --> 00:00:14,480


7
00:00:16,800 --> 00:00:19,440


8
00:00:19,440 --> 00:00:20,699
좋은

9
00:00:20,699 --> 00:00:23,640
이야기입니다. 이것을 구입하고 이제

10
00:00:23,640 --> 00:00:25,980
환영합니다. Ashwin 잘 지내세요. 안녕하세요

11
00:00:25,980 --> 00:00:27,359


12
00:00:27,359 --> 00:00:29,820
다니엘 저는 잘 지내요  같이 놀고 계시는 당신을 위해

13
00:00:29,820 --> 00:00:31,260


14
00:00:31,260 --> 00:00:33,320
음

15
00:00:33,559 --> 00:00:37,559
예 예 좋은 것 같아요 그리고 어 예

16
00:00:37,559 --> 00:00:39,719


17
00:00:39,719 --> 00:00:42,420
pi mdp의 정교한 추론에 대한 워크샵을 기대하고 있습니다.

18
00:00:42,420 --> 00:00:46,440
음 최대 90분이 될 수도 있고

19
00:00:46,440 --> 00:00:48,239
더

20
00:00:48,239 --> 00:00:51,420
짧더라도 괜찮고 잠시 쉬어도 괜찮습니다. 하지만

21
00:00:51,420 --> 00:00:53,100
음 시간을 가져주세요  그냥 알려주세요. 도와드릴

22
00:00:53,100 --> 00:00:54,600
수 있어요. 감사합니다. 음

23
00:00:54,600 --> 00:00:55,739


24
00:00:55,739 --> 00:00:57,480


25
00:00:57,480 --> 00:01:00,539
화면을 공유하고 시작하겠습니다.

26
00:01:00,539 --> 00:01:02,280


27
00:01:02,280 --> 00:01:04,860


28
00:01:04,860 --> 00:01:05,820
여기서 우리가 하고 있는 작업의 구조에 대해

29
00:01:05,820 --> 00:01:08,760
음, 나중에 이 내용을 보는 사람들이

30
00:01:08,760 --> 00:01:11,040
시도해 보고 싶어할 수도 있을 것 같습니다.

31
00:01:11,040 --> 00:01:13,080
튜토리얼 같은 것을 직접 해보는 것이

32
00:01:13,080 --> 00:01:15,780
제가 염두에 둔 구조이므로

33
00:01:15,780 --> 00:01:19,380
천천히 진행하겠습니다 uh 양해해 주시기 바랍니다

34
00:01:19,380 --> 00:01:21,180
um so uh IMDb의 정교한 추론에 관한 이 세션에 오신 것을 환영합니다.  어,

35
00:01:21,180 --> 00:01:23,340


36
00:01:23,340 --> 00:01:26,640


37
00:01:26,640 --> 00:01:28,920


38
00:01:28,920 --> 00:01:31,080
특히

39
00:01:31,080 --> 00:01:33,960
프라임 DP 모듈을 사용하여 원본 논문에 있는 것과 같은 정교한 추론 시뮬레이션을 모델링하려고 합니다.

40
00:01:33,960 --> 00:01:36,299
현재는 이것이 내 mdp의 일부가 아니지만

41
00:01:36,299 --> 00:01:38,700


42
00:01:38,700 --> 00:01:40,560
프라임 DB 모듈에 정교한 추론을 추가하는 중입니다.

43
00:01:40,560 --> 00:01:43,320
주로 해당 기능을 추가하기 위해

44
00:01:43,320 --> 00:01:46,340
개발한 코드에 대해 이야기하겠습니다.

45
00:01:46,340 --> 00:01:49,079


46
00:01:49,079 --> 00:01:52,920
Ashwin Paul입니다. 저는 마침내

47
00:01:52,920 --> 00:01:56,040
Monash University에서 박사 과정을 밟게 되었고

48
00:01:56,040 --> 00:01:58,259
주로 능동 추론 모델을 사용하여

49
00:01:58,259 --> 00:02:00,360


50
00:02:00,360 --> 00:02:03,840
사용 방법을 이해하려고 노력합니다.  지능적 행동의 출현을 기본적으로 이해하기 위한 설명 가능한 모델이므로

51
00:02:03,840 --> 00:02:05,240


52
00:02:05,240 --> 00:02:07,380


53
00:02:07,380 --> 00:02:10,020


54
00:02:10,020 --> 00:02:12,360


55
00:02:12,360 --> 00:02:16,140
제가 하는 자료에 대해 자세히 살펴보겠습니다. 자유 에너지 원리를 소개하기 위한 것입니다.

56
00:02:16,140 --> 00:02:18,180


57
00:02:18,180 --> 00:02:20,280
지금 당장 여러분 모두가 그것이 무엇인지 이해하고 있을 것이라고 확신합니다.

58
00:02:20,280 --> 00:02:23,220
아이디어는

59
00:02:23,220 --> 00:02:26,700
에이전트가 항상 uh

60
00:02:26,700 --> 00:02:28,920
관찰의 엔트로피를 최소화하려고 노력한다는 것입니다. 그렇죠.

61
00:02:28,920 --> 00:02:31,800
관찰이

62
00:02:31,800 --> 00:02:34,680
uh 당신의 마음 속에 정말 낮은 확률을 갖고 있고

63
00:02:34,680 --> 00:02:36,720
그런 일이 발생한다면 당신은 아마도

64
00:02:36,720 --> 00:02:39,660
놀랄 것이고 그 반대의 경우도 마찬가지입니다. uh

65
00:02:39,660 --> 00:02:41,940
여기의 엔트로피

66
00:02:41,940 --> 00:02:44,420
정보 이론 엔트로피로 정의됩니다.

67
00:02:44,420 --> 00:02:47,400
확률이 낮으면

68
00:02:47,400 --> 00:02:49,260
자동으로 이는 높은 놀라움 또는

69
00:02:49,260 --> 00:02:51,000
높은 엔트로피 관찰입니다.

70
00:02:51,000 --> 00:02:53,700
우리 모두 알고 있듯이 어 활성 추론은

71
00:02:53,700 --> 00:02:56,580


72
00:02:56,580 --> 00:02:58,980
에이전트 환경 루프라고 부르는 것을 정의하는 방법론도 제공합니다.

73
00:02:58,980 --> 00:03:02,040
우리가 보고 있는 에이전트가 무엇인지, 주변 환경 등을 고려할 때

74
00:03:02,040 --> 00:03:04,140


75
00:03:04,140 --> 00:03:08,180
에이전트의 동작이 무엇인지 정의하십시오.

76
00:03:08,180 --> 00:03:11,099
그러면

77
00:03:11,099 --> 00:03:12,959


78
00:03:12,959 --> 00:03:15,300
Marco 담요의 아이디어도 잘 알고 있으며

79
00:03:15,300 --> 00:03:18,000
항상 기억해야 하기 때문에 이것이 중요합니다.  제 말은

80
00:03:18,000 --> 00:03:20,040


81
00:03:20,040 --> 00:03:21,599
생성 과정과

82
00:03:21,599 --> 00:03:25,260
생성 모델 사이의 차이점을 기억해야 한다는 것입니다. 이는 음

83
00:03:25,260 --> 00:03:27,599
활동하지 않는

84
00:03:27,599 --> 00:03:29,280
유아 문학과

85
00:03:29,280 --> 00:03:31,080
처음에 그것을 이해하려고 노력하는 사람들에게 꽤 유명한 혼동 지점입니다.

86
00:03:31,080 --> 00:03:33,540
어 그래서 중심

87
00:03:33,540 --> 00:03:35,580
질문은 어떻게  에이전트 어

88
00:03:35,580 --> 00:03:37,800
엔트로피를 최소화하는 이유는

89
00:03:37,800 --> 00:03:39,900
어떤 관찰

90
00:03:39,900 --> 00:03:42,420
이 느리거나 높은지 에이전트가 어떻게 알 수 있기 때문입니다 uh 확률론적 맞습니다.

91
00:03:42,420 --> 00:03:44,519
즉 생성 모델을 유지하는 것이고

92
00:03:44,519 --> 00:03:46,920
어 생성 모델은

93
00:03:46,920 --> 00:03:49,319
어느 것이 높은 확률적

94
00:03:49,319 --> 00:03:51,360
관찰이고 어느 것이 낮은

95
00:03:51,360 --> 00:03:53,519
확률적 관찰인지 알려줄 것입니다.  아이디어는

96
00:03:53,519 --> 00:03:56,459
에이전트가 액세스할 수 있는 모든 것은

97
00:03:56,459 --> 00:03:58,799


98
00:03:58,799 --> 00:04:00,599
에이전트가

99
00:04:00,599 --> 00:04:03,299
직접 관찰할 수 없는 생성 프로세스에서 나오는 관찰이고 어

100
00:04:03,299 --> 00:04:05,459
지능형 에이전트는

101
00:04:05,459 --> 00:04:08,220
마음 속에 생성 모델을 구축하려고 시도한다는 것입니다. 이는

102
00:04:08,220 --> 00:04:09,060


103
00:04:09,060 --> 00:04:11,640
숨겨진 모델입니다.  상태와

104
00:04:11,640 --> 00:04:14,340
관찰에 액세스할 수 있고

105
00:04:14,340 --> 00:04:16,260


106
00:04:16,260 --> 00:04:18,660
이 생성 모델을 사용하여 일종의 확률을 계산할 수 있기를 바랄 수 있지만

107
00:04:18,660 --> 00:04:21,060
일반적으로 생성 모델에서 관찰

108
00:04:21,060 --> 00:04:23,460


109
00:04:23,460 --> 00:04:25,320
의 확률을 소외시키는 것은 다루기 힘든 문제라는 문제가 있습니다.  이것이

110
00:04:25,320 --> 00:04:26,880


111
00:04:26,880 --> 00:04:29,100


112
00:04:29,100 --> 00:04:31,620


113
00:04:31,620 --> 00:04:33,720
에이전트가 최소화하려고 하는 놀라움의 상한선을 정의해야 하는 이유이며

114
00:04:33,720 --> 00:04:35,400
자유 에너지에 대한 아이디어가 나온 것입니다. 따라서

115
00:04:35,400 --> 00:04:37,620
에이전트가

116
00:04:37,620 --> 00:04:40,560
최소화하는 이 상한선은 자유 에너지이고

117
00:04:40,560 --> 00:04:42,840
이것이 자유 에너지 원리인 이유입니다.

118
00:04:42,840 --> 00:04:44,880
여기에 자본 Qs라는 새로운 용어가 있습니다.

119
00:04:44,880 --> 00:04:48,000
이는

120
00:04:48,000 --> 00:04:49,740
에이전트가

121
00:04:49,740 --> 00:04:51,900
생성 모델의 숨겨진 단계에 대해 유지하고 있으며

122
00:04:51,900 --> 00:04:54,840
이 양은 자유

123
00:04:54,840 --> 00:04:57,479
에너지이며 전통적으로 이

124
00:04:57,479 --> 00:04:59,100
변형 자유 에너지는

125
00:04:59,100 --> 00:05:00,660


126
00:05:00,660 --> 00:05:02,880
어로 해석된다는 믿음으로 해석될 수 있습니다.  대부분 기계 학습 방식에서는

127
00:05:02,880 --> 00:05:05,040


128
00:05:05,040 --> 00:05:07,259
모델의 복잡성과 정확성 사이의 균형이 이루어지므로

129
00:05:07,259 --> 00:05:09,300
자유 에너지를 최소화할 때 에이전트는

130
00:05:09,300 --> 00:05:11,520
단일 모델을 만들려고 노력

131
00:05:11,520 --> 00:05:13,320
하지만 동시에 정확한 모델을 만들려고 합니다.

132
00:05:13,320 --> 00:05:15,419
여기에는 마이너스 기호가 있기 때문입니다.

133
00:05:15,419 --> 00:05:16,860
정확성은 또한

134
00:05:16,860 --> 00:05:19,919


135
00:05:19,919 --> 00:05:23,039
에이전트가 항상

136
00:05:23,039 --> 00:05:25,979
모델의 에너지를 최소화하려고 노력하지만 동시에 고전적인 최대 엔트로피 원리 등과 연계하여

137
00:05:25,979 --> 00:05:27,720
모델의 엔트로피를 최대화하는 물리학적 방식으로 해석될 수도 있습니다.

138
00:05:27,720 --> 00:05:29,580


139
00:05:29,580 --> 00:05:32,280


140
00:05:32,280 --> 00:05:35,340
문헌에 따르면

141
00:05:35,340 --> 00:05:37,740
생성 모델에 대한 이러한 아이디어는 매우

142
00:05:37,740 --> 00:05:38,820
중요합니다. 음,

143
00:05:38,820 --> 00:05:41,220
소프트웨어 관점에서 그것은 정보에 따라 정보를 받거나

144
00:05:41,220 --> 00:05:42,840


145
00:05:42,840 --> 00:05:44,580


146
00:05:44,580 --> 00:05:46,440


147
00:05:46,440 --> 00:05:47,100


148
00:05:47,100 --> 00:05:49,259
받지 않는 에이전트에 대한 생성 모델을 올바르게 정의하기 위해 수행할 수 있는 첫 번째 작업입니다.

149
00:05:49,259 --> 00:05:51,720


150
00:05:51,720 --> 00:05:53,460
모델링하려는 실험 그래서 고전적

151
00:05:53,460 --> 00:05:56,060
능동 추론에서는 일반적으로 의사 결정이

152
00:05:56,060 --> 00:05:58,979
정책 측면에서 정의됩니다.

153
00:05:58,979 --> 00:06:02,220
예를 들어 당신이 이

154
00:06:02,220 --> 00:06:04,620
환경의 에이전트라면 Mario 게임에서는 uh

155
00:06:04,620 --> 00:06:06,720
Mario가 에이전트이고 다른 모든 것은

156
00:06:06,720 --> 00:06:09,240
환경이고

157
00:06:09,240 --> 00:06:11,100
Mario는

158
00:06:11,100 --> 00:06:13,740
음 세 가지 가능한 행동을 가지고 있습니다.

159
00:06:13,740 --> 00:06:16,139
음 점프를 하거나 이 환경에 머무르세요.

160
00:06:16,139 --> 00:06:19,199
정책의 고전적인 정의는

161
00:06:19,199 --> 00:06:21,360
이것이 시간에 따른 일련의 행동이라는 것입니다.

162
00:06:21,360 --> 00:06:24,060
자본의 지평선

163
00:06:24,060 --> 00:06:27,120
T가 있다면 정책은 일련

164
00:06:27,120 --> 00:06:29,220
의 행동에 지나지 않습니다.  시간에 맞춰 실행 실행 점프 등을 수행할 수 있으므로

165
00:06:29,220 --> 00:06:33,300
위

166
00:06:33,300 --> 00:06:36,419
첨자는 작업이므로 여기서는

167
00:06:36,419 --> 00:06:39,000
점프 실행 등이고 아래 첨자는

168
00:06:39,000 --> 00:06:41,400
시간이고 그런

169
00:06:41,400 --> 00:06:44,100
다음 가질 수 있는 것은 컬렉션인 정책 공간입니다.

170
00:06:44,100 --> 00:06:45,720
이러한 많은

171
00:06:45,720 --> 00:06:46,940
특성 중

172
00:06:46,940 --> 00:06:50,520
더 작은 더미와

173
00:06:50,520 --> 00:06:52,020
활성 추론에서 결정을 내리기 위해 본질적으로 수행하는

174
00:06:52,020 --> 00:06:55,199
작업 어 계산 어 최적화하지 않음 어

175
00:06:55,199 --> 00:06:58,139


176
00:06:58,139 --> 00:07:01,680
정책 공간에 있는 모든 정책의 예상 자유 에너지를 계산하며

177
00:07:01,680 --> 00:07:04,199
기본적으로 이는

178
00:07:04,199 --> 00:07:07,860
위험과 모호함 사이의 균형으로 해석될 수 있습니다.

179
00:07:07,860 --> 00:07:10,560
그리고 음

180
00:07:10,560 --> 00:07:12,840
예 그래서 이

181
00:07:12,840 --> 00:07:14,580
예상 자유 에너지를 계산할 때 당신이 하려는 것은

182
00:07:14,580 --> 00:07:18,600
어 위험을 최소화하는 것입니다 어 그게

183
00:07:18,600 --> 00:07:21,720


184
00:07:21,720 --> 00:07:24,300
관측에 대한 믿음이 어 이전

185
00:07:24,300 --> 00:07:27,240
선호와 얼마나 다른지 어 자본 C 그래서 이것도

186
00:07:27,240 --> 00:07:28,800
생성의 일부입니다  모델

187
00:07:28,800 --> 00:07:30,900
제어를 모델링하려고 할 때 동시에

188
00:07:30,900 --> 00:07:32,280


189
00:07:32,280 --> 00:07:34,440
모호함을 최소화하려고 할 때 어

190
00:07:34,440 --> 00:07:36,419
최소 예상

191
00:07:36,419 --> 00:07:38,699
자유 에너지가 있는 정책을 선택할 때 맞습니다. 하지만 이 공식에는

192
00:07:38,699 --> 00:07:40,860
정책 공간이 빠르게 다루기 어려워지는 문제가 있습니다.

193
00:07:40,860 --> 00:07:43,259


194
00:07:43,259 --> 00:07:47,460


195
00:07:47,460 --> 00:07:49,319
귀하의 정책 공간에 엄청난 수의 작은 pis 또는 정책이 있을 수 있으며

196
00:07:49,319 --> 00:07:51,000


197
00:07:51,000 --> 00:07:53,580


198
00:07:53,580 --> 00:07:57,860
짧은 시간 동안이라도 그러한 모든 정책에 대해 예상되는 자유 에너지를 앉아서 계산하는 것은 불가능하지만

199
00:07:57,860 --> 00:08:00,240
어 이것은 IMDb에서 구현된 고전적인 구조입니다.

200
00:08:00,240 --> 00:08:02,639
그럼에도 불구하고

201
00:08:02,639 --> 00:08:06,360
우리는 pi mdp에 다른 동작 측면을 구현하기 위한 다른 모듈을 가지고 있습니다.

202
00:08:06,360 --> 00:08:10,020


203
00:08:10,020 --> 00:08:11,880


204
00:08:11,880 --> 00:08:15,000
예를 들어 추론

205
00:08:15,000 --> 00:08:17,160
이나 인식의 경우

206
00:08:17,160 --> 00:08:19,039
전파가 고정된 포인트 반복

207
00:08:19,039 --> 00:08:23,180
한계 메시지 전달과 제어 모듈

208
00:08:23,180 --> 00:08:26,099
의 추론 모듈에 구현된 모든 것을 믿습니다.

209
00:08:26,099 --> 00:08:29,819
우리는 어 정책에 대한

210
00:08:29,819 --> 00:08:32,099
예상 자유 에너지를 평가하는 다양한 방법을 가지고 있습니다.

211
00:08:32,099 --> 00:08:34,140
하나는

212
00:08:34,140 --> 00:08:36,299
기대 효용에 따라 어 다른 하나는

213
00:08:36,299 --> 00:08:38,760


214
00:08:38,760 --> 00:08:41,399
방금 설명한 고전적인 방법에 따라

215
00:08:41,399 --> 00:08:44,459
학습 모듈이 있으므로 자본과

216
00:08:44,459 --> 00:08:46,680
같은 pom DP의 매개변수를 학습합니다.

217
00:08:46,680 --> 00:08:49,019
대문자 B이므로 가능성

218
00:08:49,019 --> 00:08:51,240
전환 역학 등 그리고

219
00:08:51,240 --> 00:08:53,540


220
00:08:53,540 --> 00:08:56,279


221
00:08:56,279 --> 00:08:59,519
알고리즘 모듈에 이 모든 것을 구현하기 위한 알고리즘이 있으며

222
00:08:59,519 --> 00:09:01,620
현재 pi mdp에서 가장 강력한 것은 에이전트 환경을 정의하기

223
00:09:01,620 --> 00:09:04,080
쉬운 아시아 클래스입니다.

224
00:09:04,080 --> 00:09:06,540


225
00:09:06,540 --> 00:09:08,760
루프를

226
00:09:08,760 --> 00:09:11,459
구축하려고 노력 중이므로 오늘은

227
00:09:11,459 --> 00:09:12,959


228
00:09:12,959 --> 00:09:15,140


229
00:09:15,140 --> 00:09:17,279


230
00:09:17,279 --> 00:09:20,519
방금 본 고전적인 능동 추론이 아닌 정교한

231
00:09:20,519 --> 00:09:21,660


232
00:09:21,660 --> 00:09:24,060


233
00:09:24,060 --> 00:09:26,100
추론을 구현하는 에이전트 클래스에 대해 이야기하겠습니다.

234
00:09:26,100 --> 00:09:28,140
고전적인 활성 영향에서 15의 ​​Time Horizon

235
00:09:28,140 --> 00:09:29,519
그렇죠

236
00:09:29,519 --> 00:09:31,800
음 그럼 첫 번째 정책은 물론 어

237
00:09:31,800 --> 00:09:34,279
일련의 첫 번째 동작인 점프입니다

238
00:09:34,279 --> 00:09:37,380
어 그러면 마지막 호출 마지막

239
00:09:37,380 --> 00:09:39,660
동작을 변경할 수 있고 이미

240
00:09:39,660 --> 00:09:41,880
볼 수 있듯이 어 n이 있을 수 있습니다

241
00:09:41,880 --> 00:09:44,880
조합 수와 이 간단한 경우에 대해

242
00:09:44,880 --> 00:09:47,220
정책 공간은 10의

243
00:09:47,220 --> 00:09:49,200
13승만큼 크며 확률론적 문제

244
00:09:49,200 --> 00:09:52,080
설정에서는 어

245
00:09:52,080 --> 00:09:54,120
이 정책 공간의 작은 하위 집합을 생각해 낼

246
00:09:54,120 --> 00:09:56,519
수 있는 방법이 없습니다.  이

247
00:09:56,519 --> 00:09:59,339
계산 복잡성 문제를 해결하세요 어

248
00:09:59,339 --> 00:10:01,500
그리고 제가 확률론적

249
00:10:01,500 --> 00:10:03,360
문제 설정에서 언급했듯이 다루기 힘든

250
00:10:03,360 --> 00:10:06,120
크기 정책 공간입니다. 어

251
00:10:06,120 --> 00:10:09,300
우리가

252
00:10:09,300 --> 00:10:11,940
이 인스턴스를 다른 방식으로 취하는 것에 대해 생각하는 정교한 추론 아이디어가 나옵니다.

253
00:10:11,940 --> 00:10:13,500


254
00:10:13,500 --> 00:10:15,420


255
00:10:15,420 --> 00:10:17,820
시간에 따른 일련의 행동을 통해 우리는 무언가를 볼 때 무엇을 해야 할지 직접적으로 생각할 수 있습니다. 어

256
00:10:17,820 --> 00:10:20,100


257
00:10:20,100 --> 00:10:21,959
현재 상태에 대한 믿음과

258
00:10:21,959 --> 00:10:23,880
미래에 대한 믿음에 따라 다르죠. 그래서

259
00:10:23,880 --> 00:10:25,680
현재 상황에 처한 나 자신을 본다면 어떻게 해야 할까요

260
00:10:25,680 --> 00:10:28,080
?

261
00:10:28,080 --> 00:10:30,480
음

262
00:10:30,480 --> 00:10:33,420
어떻게 조치를 취해야 하는지에 대한 간단한 생각과 여기서

263
00:10:33,420 --> 00:10:35,459
예상 자유 에너지

264
00:10:35,459 --> 00:10:37,980
예상 자유 에너지의 구조는 동일하지만

265
00:10:37,980 --> 00:10:40,320
우리는 어 정책의 예상 자유 에너지를 평가하는 것이 아니지만

266
00:10:40,320 --> 00:10:43,440


267
00:10:43,440 --> 00:10:45,540
어 관찰 작업 조합의 예상 자유 에너지

268
00:10:45,540 --> 00:10:48,060
그래서 내가 본다면  뭔가 그리고

269
00:10:48,060 --> 00:10:49,860
내가 이것을 한다면 예상되는 자유

270
00:10:49,860 --> 00:10:51,600
에너지는 무엇이며 그것이 내가

271
00:10:51,600 --> 00:10:56,220
최소화하려고 하는 것입니다 어 그것이 내가

272
00:10:56,220 --> 00:10:58,860
최적화하려고 하는 것입니다 어 바로 이 설정에서 어 그래서

273
00:10:58,860 --> 00:11:01,500
여기 다시 우리가 최소화하려고 하는 위험 용어가 있습니다

274
00:11:01,500 --> 00:11:03,300


275
00:11:03,300 --> 00:11:05,040
믿음과 이전

276
00:11:05,040 --> 00:11:07,320
선호 사이의 편차 우리는 또한 모호성

277
00:11:07,320 --> 00:11:10,560
용어를 가지고 있습니다 uh 그리고 이것은 함께

278
00:11:10,560 --> 00:11:13,079
시간 T에서 uh의 예상 자유 에너지를 구성

279
00:11:13,079 --> 00:11:16,019
하지만 우리는 또한 다음 단계에서

280
00:11:16,019 --> 00:11:18,360
예상되는 자유 에너지가 무엇인지에 대한 기대를 가지고 있습니다

281
00:11:18,360 --> 00:11:20,760


282
00:11:20,760 --> 00:11:22,680
음 다음 단계의 예상 자유 에너지를 평가하려면

283
00:11:22,680 --> 00:11:24,660


284
00:11:24,660 --> 00:11:27,360
OT + 2를 사용하여 이 방정식을 다시 계산해야 하며 이를

285
00:11:27,360 --> 00:11:29,220
위해서는

286
00:11:29,220 --> 00:11:32,160
OT + 3 등을 사용하여 이 방정식을 다시 계산해야 하며

287
00:11:32,160 --> 00:11:34,200
이는 자동으로

288
00:11:34,200 --> 00:11:36,779
연구에 사용됩니다.  이 방정식이 정의되는 재귀적 방식으로 인해

289
00:11:36,779 --> 00:11:39,779


290
00:11:39,779 --> 00:11:41,220
자체적인 문제가 발생하지만 이를

291
00:11:41,220 --> 00:11:44,160
피할 수 있는 영리한 방법이 있으므로

292
00:11:44,160 --> 00:11:46,500


293
00:11:46,500 --> 00:11:48,899
오늘 코드에서 이에 대해 논의할 것입니다. 따라서

294
00:11:48,899 --> 00:11:51,600
여기서는 연구에 대해 언급한 것처럼 정교한 추론 구조를 고려합니다.

295
00:11:51,600 --> 00:11:54,060


296
00:11:54,060 --> 00:11:56,160


297
00:11:56,160 --> 00:11:58,620
우리가 사용하는 추가 활성 영향에 대해 우리가 본 정책 공간을 대체합니다.

298
00:11:58,620 --> 00:12:00,779
따라서 이

299
00:12:00,779 --> 00:12:04,019
워크샵에서 제가 초점을 맞추고 있는 것은

300
00:12:04,019 --> 00:12:07,740
생성 모델을 정의하는 방법

301
00:12:07,740 --> 00:12:10,980
과 주어진 환경입니다.

302
00:12:10,980 --> 00:12:13,440
예를 들어 이것이

303
00:12:13,440 --> 00:12:16,200
자극되는 그리드입니다.  원본 논문에서 시뮬레이션되었으며

304
00:12:16,200 --> 00:12:19,140
우리는 프라임 DP 모듈의 정교한 추론에 사용할 수 있는

305
00:12:19,140 --> 00:12:21,240
이 그리드에 대한 생성 모델을 구축하는 방법에 대해 이야기할 것입니다.

306
00:12:21,240 --> 00:12:22,740


307
00:12:22,740 --> 00:12:24,660


308
00:12:24,660 --> 00:12:27,600


309
00:12:27,600 --> 00:12:29,279
따라서 기본적으로 제가 이야기하려는 것은

310
00:12:29,279 --> 00:12:31,740
환경에는

311
00:12:31,740 --> 00:12:34,320


312
00:12:34,320 --> 00:12:37,680
pi MDB의 에이전트에서 작업을 수행하는 단계 기능이 있으며 에이전트는

313
00:12:37,680 --> 00:12:40,019
해당 작업에서 관찰을 얻습니다.

314
00:12:40,019 --> 00:12:42,180
우리는 이

315
00:12:42,180 --> 00:12:44,579
특정 기능에 대해 이야기할 것입니다. 에이전트 도트 단계 및

316
00:12:44,579 --> 00:12:46,860
에이전트 도트 단계가 단계가 차지할 것입니다.

317
00:12:46,860 --> 00:12:49,320
관찰하고

318
00:12:49,320 --> 00:12:50,760
다음 시간 단계에 대한 작업을 생각해내려고 시도하면

319
00:12:50,760 --> 00:12:55,079
루프가 생성되고

320
00:12:55,079 --> 00:12:58,200
음 이 루프를 영리하게 디자인하면 정교한 인쇄 설정에서

321
00:12:58,200 --> 00:13:00,240
의도적인 동작이 나타나는 것을 볼 수 있습니다.

322
00:13:00,240 --> 00:13:02,820


323
00:13:02,820 --> 00:13:05,339
예를 들어 이 특정 그리드에서

324
00:13:05,339 --> 00:13:06,839
충분한 계획 Horizon을 통해

325
00:13:06,839 --> 00:13:08,639
에이전트가 이 그리드 등에서 탐색할 수 있다는 것을 알 수 있을 것입니다.

326
00:13:08,639 --> 00:13:10,740


327
00:13:10,740 --> 00:13:12,540
이것이 제가

328
00:13:12,540 --> 00:13:16,440
오늘 이 강연에서 집중적으로 다룰 예이므로 실례합니다.

329
00:13:16,440 --> 00:13:18,000


330
00:13:18,000 --> 00:13:22,339


331
00:13:25,380 --> 00:13:29,180
바로 말씀드리고 싶습니다.  코드로 이동하여

332
00:13:29,180 --> 00:13:32,459


333
00:13:32,459 --> 00:13:36,360
pi mdp 홈을 갖게 됩니다. 여러분이

334
00:13:36,360 --> 00:13:38,639
익숙하길 바랍니다. 따라서

335
00:13:38,639 --> 00:13:41,399
pi MTP 모듈이 있는 이 GitHub 저장소가

336
00:13:41,399 --> 00:13:43,079


337
00:13:43,079 --> 00:13:46,320
있고 내부 시간 DP 모듈에는

338
00:13:46,320 --> 00:13:48,480


339
00:13:48,480 --> 00:13:50,820
이에 대한 몇 가지 부품이 있으므로 여기에 있습니다.  어 소위 고전적 능동 추론을 구현하는

340
00:13:50,820 --> 00:13:52,980
원래 Prime DP 모듈에 에이전트가 있습니다.

341
00:13:52,980 --> 00:13:55,019


342
00:13:55,019 --> 00:13:57,200
여러

343
00:13:57,200 --> 00:13:59,760
환경이 있고

344
00:13:59,760 --> 00:14:02,399
현재 지도 등에서 학습하는 것과 같은 도우미 기능이 있으므로

345
00:14:02,399 --> 00:14:05,160
이것은 시간

346
00:14:05,160 --> 00:14:09,120
DP 모듈이지만 상위 폴더에 있습니다.  또한

347
00:14:09,120 --> 00:14:11,459


348
00:14:11,459 --> 00:14:14,700


349
00:14:14,700 --> 00:14:17,220
엔진 클래스를 사용하는 방법, 환경을 처리하는 방법 등에 대한 튜토리얼이 있는 예제도 있습니다.

350
00:14:17,220 --> 00:14:20,220


351
00:14:20,220 --> 00:14:22,620
풀 요청을 보면

352
00:14:22,620 --> 00:14:25,500
지금 당장 정교한

353
00:14:25,500 --> 00:14:27,720
추론을 원본 Prime DP

354
00:14:27,720 --> 00:14:29,579
모듈에 병합하려고 합니다.  그리고 오늘 저는

355
00:14:29,579 --> 00:14:31,500
이 전체 요청의 코드에 대해 이야기할 것입니다. 따라서

356
00:14:31,500 --> 00:14:34,320
이 풀 요청을 직접 시도해보고 싶다면

357
00:14:34,320 --> 00:14:36,839


358
00:14:36,839 --> 00:14:39,959
이 풀 요청이

359
00:14:39,959 --> 00:14:41,760
있고

360
00:14:41,760 --> 00:14:44,940
시간 구조가 동일한 이 페이지로 이동하는 것이 좋습니다.  DB는

361
00:14:44,940 --> 00:14:48,420
기본적으로 piondp를 사용하여 설계되었으며

362
00:14:48,420 --> 00:14:50,699
여기에 추가로 정교한

363
00:14:50,699 --> 00:14:53,639


364
00:14:53,639 --> 00:14:55,740


365
00:14:55,740 --> 00:14:58,320


366
00:14:58,320 --> 00:15:00,480
추론 방식으로 모든 작업과 계획 및 의사 결정을 수행하는 정교한 엔터프라이즈 에이전트인 에이전트 SI가 있으며

367
00:15:00,480 --> 00:15:02,399
상위 폴더에는

368
00:15:02,399 --> 00:15:04,860
정교한 예제 폴더도 있습니다.

369
00:15:04,860 --> 00:15:07,620
추론 데모와 제가 오늘 할 일은

370
00:15:07,620 --> 00:15:09,540


371
00:15:09,540 --> 00:15:12,300
대체 추론에 대한 이 튜토리얼을 안내하는 것입니다. 그리고

372
00:15:12,300 --> 00:15:14,519
제가 논의할 방식

373
00:15:14,519 --> 00:15:18,320
과 제가 도우미 코드를 참조하는 지점에서

374
00:15:18,320 --> 00:15:21,060


375
00:15:21,060 --> 00:15:22,740
해당 코드로 가서 시도해 보겠습니다.

376
00:15:22,740 --> 00:15:24,540
실제로 무슨 일이 일어나고 있는지 그리고 우리가 의도적인 행동을 볼

377
00:15:24,540 --> 00:15:27,360
수 있는 에이전트 환경 루프를 완료하는 방법을 설명하기 위해 그렇습니다.

378
00:15:27,360 --> 00:15:31,860


379
00:15:31,860 --> 00:15:35,040
그게 주요 DP 홈이고

380
00:15:35,040 --> 00:15:37,560
풀 요청에 대해서도 이야기했으므로

381
00:15:37,560 --> 00:15:40,199
바로 Jupiter

382
00:15:40,199 --> 00:15:43,680
노트북으로 이동하겠습니다.  이 저장소의 로컬 사본을

383
00:15:43,680 --> 00:15:46,320


384
00:15:46,320 --> 00:15:47,880
실행하여 개인용 컴퓨터에 표시하는 것이 더 쉽기 때문에

385
00:15:47,880 --> 00:15:50,339
이것은

386
00:15:50,339 --> 00:15:53,279
pi mdp 및 예제가 포함된 패턴 폴더이고 내부

387
00:15:53,279 --> 00:15:55,440
예제에는 정교한 추론을 위한 데모 홀더가 있으며

388
00:15:55,440 --> 00:15:57,120
이것이 The

389
00:15:57,120 --> 00:15:59,480
Notebook I'입니다.  제가 지금 얘기하고 있는 것은

390
00:15:59,480 --> 00:16:02,579
이 예에서 우리가 하려는 것은 음

391
00:16:02,579 --> 00:16:04,760


392
00:16:04,800 --> 00:16:06,480


393
00:16:06,480 --> 00:16:08,699
원래의 정교한

394
00:16:08,699 --> 00:16:12,480
추론 논문에서 나온 이 특정 그리드 작업을 처리하고 이 에이전트를 만들거나

395
00:16:12,480 --> 00:16:14,880
이 에이전트가

396
00:16:14,880 --> 00:16:17,339
금 상태로 추정되는 이 빨간 점으로 이동할 수 있도록 하는 것입니다.

397
00:16:17,339 --> 00:16:19,860
이 특정 작업은

398
00:16:19,860 --> 00:16:21,720
이와 같은 사전 선호도를 부여하므로 이

399
00:16:21,720 --> 00:16:24,240
높은 선호도는 우리가 작성하는 의미에서 매우 유익하며

400
00:16:24,240 --> 00:16:26,760


401
00:16:26,760 --> 00:16:28,560
이것이 가장 선호되는 상태라는 것을 알 수 있습니다.

402
00:16:28,560 --> 00:16:30,420
흰색과 주변 상태는

403
00:16:30,420 --> 00:16:33,360
덜 선호되지만 더

404
00:16:33,360 --> 00:16:35,459
선호됩니다.  멀리 떨어져 있는 것

405
00:16:35,459 --> 00:16:37,920
입니다. 이것이 우리가 사용하려는 Grid World 작업입니다.

406
00:16:37,920 --> 00:16:39,120


407
00:16:39,120 --> 00:16:42,199
첫 번째 셀은

408
00:16:42,199 --> 00:16:45,139
필요한 모든 라이브러리

409
00:16:45,139 --> 00:16:48,779
와 numpy 및 matplotlib와 같은 일부 유용한 라이브러리를 가져오고

410
00:16:48,779 --> 00:16:51,839
가장 중요한 것은

411
00:16:51,839 --> 00:16:55,259
프라임 DB이므로 저는  실제로 지금은 아직 병합되지 않은 원본이 아닌 정교한 추론 구현을 사용하여

412
00:16:55,259 --> 00:16:57,360
내 Prime DB의 로컬 복사본을 호출하고

413
00:16:57,360 --> 00:16:58,800


414
00:16:58,800 --> 00:17:01,740


415
00:17:01,740 --> 00:17:04,439
있으며 가장 먼저 이야기하고 싶은

416
00:17:04,439 --> 00:17:06,720
것은 환경 자체이므로

417
00:17:06,720 --> 00:17:09,839


418
00:17:09,839 --> 00:17:11,880
어떤 조치를 취하면 환경 도트 단계 부분입니다.  환경은 어떻게

419
00:17:11,880 --> 00:17:13,740
작동하며

420
00:17:13,740 --> 00:17:16,859
이 폴더 안에는

421
00:17:16,859 --> 00:17:18,839
훌륭한 환경인 파일이 있습니다.

422
00:17:18,839 --> 00:17:23,280
uh SI Dot py 그리고 이것은 기본적으로

423
00:17:23,280 --> 00:17:25,319
환경 클래스이므로

424
00:17:25,319 --> 00:17:27,299
이 환경이 실제로 어떻게

425
00:17:27,299 --> 00:17:29,340
구현되는지 걱정하지 마세요.

426
00:17:29,340 --> 00:17:31,380
음,

427
00:17:31,380 --> 00:17:32,340


428
00:17:32,340 --> 00:17:34,919
우리가 사용할 이 함수는

429
00:17:34,919 --> 00:17:38,760
환경 도트 단계이므로 이

430
00:17:38,760 --> 00:17:41,520
함수는 이에 대한 조치를 취하고

431
00:17:41,520 --> 00:17:43,919


432
00:17:43,919 --> 00:17:45,840
환경의 현재 상태에 따라 에이전트의

433
00:17:45,840 --> 00:17:48,900
이 조치에 따라 가장 가능성이 높은 다음 상태가 무엇인지 계산합니다.

434
00:17:48,900 --> 00:17:51,360
이것이 아이디어이고

435
00:17:51,360 --> 00:17:53,880


436
00:17:53,880 --> 00:17:57,960


437
00:17:57,960 --> 00:18:00,179
목표 상태가 아닌 경우 무시할 수 있는 음수 값의 보상을 계산하고

438
00:18:00,179 --> 00:18:02,220
목표 상태인 경우

439
00:18:02,220 --> 00:18:04,320
10의 보상을 제공하며 이것이

440
00:18:04,320 --> 00:18:06,900
환경이 설계되고

441
00:18:06,900 --> 00:18:08,700
업데이트되는 방식입니다.  현재 상태를 새

442
00:18:08,700 --> 00:18:10,500
상태로 변경하고 기본적으로 반환할 내용은

443
00:18:10,500 --> 00:18:13,080
사용자의

444
00:18:13,080 --> 00:18:14,220
작업,

445
00:18:14,220 --> 00:18:16,080
음 해당 작업에 대한 보상,

446
00:18:16,080 --> 00:18:17,940
에피소드의 끝인지 여부 등에 따라 새로운 상태이므로

447
00:18:17,940 --> 00:18:20,700
이 구현은

448
00:18:20,700 --> 00:18:22,500
표준 openai 환경

449
00:18:22,500 --> 00:18:24,660
구현이며 이는  이것은

450
00:18:24,660 --> 00:18:26,520
바로 Environment.step 함수입니다. 예를 들어

451
00:18:26,520 --> 00:18:28,440
이 그리드에서

452
00:18:28,440 --> 00:18:31,320
내가 지금 이

453
00:18:31,320 --> 00:18:34,140
상태에 있고 조치를 취하면

454
00:18:34,140 --> 00:18:36,120


455
00:18:36,120 --> 00:18:38,460
북쪽, 남쪽, 동쪽, 서쪽으로 4개의 사용 가능한 작업이 있으므로

456
00:18:38,460 --> 00:18:41,100
북쪽으로 가면 환경 점이 표시됩니다.  단계는

457
00:18:41,100 --> 00:18:43,620
내가 주에 있는 상태인지 확인하고

458
00:18:43,620 --> 00:18:46,620
동쪽

459
00:18:46,620 --> 00:18:48,960
이나 서쪽으로 가면 여기나 남쪽에 머물면서

460
00:18:48,960 --> 00:18:52,679
여기에 머물겠습니다. 그게 아이디어이고 예,

461
00:18:52,679 --> 00:18:54,780
여기서는 에피소드 길이 제한이

462
00:18:54,780 --> 00:18:57,960
8개입니다.  즉, 혼란을 피하기 위해

463
00:18:57,960 --> 00:19:00,179


464
00:19:00,179 --> 00:19:01,140


465
00:19:01,140 --> 00:19:03,179
모든 에피소드의 길이를 이 골드 상태에

466
00:19:03,179 --> 00:19:05,039
도달하는 이상적인 길이인 8로 제한한다는 의미입니다.

467
00:19:05,039 --> 00:19:06,840


468
00:19:06,840 --> 00:19:09,179
따라서 이 환경에서는 8개의

469
00:19:09,179 --> 00:19:11,059
작업 후에 환경이 종료되며

470
00:19:11,059 --> 00:19:13,740
이 규칙에 도달해야 하는 경우

471
00:19:13,740 --> 00:19:16,380
최적의 시점에 상태를 유지하는 것이

472
00:19:16,380 --> 00:19:18,480
환경이 어떻게 구현되는지에 대한 아이디어입니다.

473
00:19:18,480 --> 00:19:23,100
알았어 어 명확했으면 좋겠고 이 환경

474
00:19:23,100 --> 00:19:25,799
에는

475
00:19:25,799 --> 00:19:27,780


476
00:19:27,780 --> 00:19:29,220
음

477
00:19:29,220 --> 00:19:32,100
렌더링 어

478
00:19:32,100 --> 00:19:33,660
사전 선호도를 렌더링하는 환경과 같은 유용한 기능이 많이 있기를 바랍니다. 이 환경에서 매트릭스를

479
00:19:33,660 --> 00:19:34,860
디자인한다면

480
00:19:34,860 --> 00:19:36,679
우선순위 친구인 이 환경은 아래 노트북에서

481
00:19:36,679 --> 00:19:39,720


482
00:19:39,720 --> 00:19:41,940
볼 수 있는 이전 선호도를 그림으로 보여줄 수 있습니다.

483
00:19:41,940 --> 00:19:44,039


484
00:19:44,039 --> 00:19:46,440
이제

485
00:19:46,440 --> 00:19:48,120
정교한 추론 에이전트에 대한 생성 모델을 정의할 시간입니다. 음

486
00:19:48,120 --> 00:19:50,340


487
00:19:50,340 --> 00:19:51,179


488
00:19:51,179 --> 00:19:54,020
그 전에 음

489
00:19:54,720 --> 00:19:56,580
의 구조를 정의하겠습니다.  에이전트가 염두에 두기를

490
00:19:56,580 --> 00:19:58,200
원하는 생성 모델은

491
00:19:58,200 --> 00:19:59,940


492
00:19:59,940 --> 00:20:01,919
이 특정 환경에 맞게 맞춤 제작되었습니다.

493
00:20:01,919 --> 00:20:05,120
따라서 여기 이

494
00:20:05,120 --> 00:20:08,580
특정 그리드 월드 작업에는 25개의

495
00:20:08,580 --> 00:20:10,559
유효한 상태가 있습니다. 음

496
00:20:10,559 --> 00:20:12,480
이 상태에서 시작하여

497
00:20:12,480 --> 00:20:16,320
이 경로의 모든 검은 상태는 유효한

498
00:20:16,320 --> 00:20:18,960
상태입니다.  따라서 25개의 유효한 상태가 있고

499
00:20:18,960 --> 00:20:20,700


500
00:20:20,700 --> 00:20:23,580
북쪽, 남쪽, 동쪽 및 서쪽에 대해 4개의 사용 가능한 작업이 있습니다.

501
00:20:23,580 --> 00:20:25,799
이는 생성 모델의 일부입니다.

502
00:20:25,799 --> 00:20:30,120
이는

503
00:20:30,120 --> 00:20:32,700
그리드의 현실과도 일치하지만

504
00:20:32,700 --> 00:20:34,620
에이전트가 가지고 있는 내용에 관한 것입니다.  그 마음이 맞고

505
00:20:34,620 --> 00:20:38,160
관찰은 단지

506
00:20:38,160 --> 00:20:41,460
상태 공간입니다. 에이전트는 어

507
00:20:41,460 --> 00:20:43,200
문제가 완전히 관찰 가능하므로

508
00:20:43,200 --> 00:20:46,020
모호성이 없습니다. 그러면

509
00:20:46,020 --> 00:20:49,620
우리는 기본적으로 외부 상태의 수를 정의합니다.

510
00:20:49,620 --> 00:20:51,918


511
00:20:54,980 --> 00:20:58,080
기본적으로

512
00:20:58,080 --> 00:21:00,840
상태 공간의 목록인 상태의 수입니다.

513
00:21:00,840 --> 00:21:03,660


514
00:21:03,660 --> 00:21:05,340
여기에는 하나의 열 및 상태 행위자만 있기 때문에 요인 수는 이제 1입니다.

515
00:21:05,340 --> 00:21:07,740
그러면 제어 수는

516
00:21:07,740 --> 00:21:10,260
4개가 될 것입니다. 어 그것은 사용 가능한

517
00:21:10,260 --> 00:21:13,440
작업과 관찰 공간에 대한 것이므로

518
00:21:13,440 --> 00:21:15,179
이것이 생성 모델의 구조입니다.

519
00:21:15,179 --> 00:21:18,299


520
00:21:18,299 --> 00:21:21,840
이제 pomdb 내부에 있는 매개변수의 구조를 살펴보세요.

521
00:21:21,840 --> 00:21:24,780
첫 번째 것은

522
00:21:24,780 --> 00:21:27,120


523
00:21:27,120 --> 00:21:31,380
종종 대문자 A로 표시되는 우도 함수이고

524
00:21:31,380 --> 00:21:33,240
여기서는 내가

525
00:21:33,240 --> 00:21:35,340
가지고 있는 관찰 양식 수와

526
00:21:35,340 --> 00:21:37,799
올바른 상태 양식 수에 대한 함수입니다.

527
00:21:37,799 --> 00:21:41,340
이 셀을 실행합니다.

528
00:21:41,340 --> 00:21:43,140


529
00:21:43,140 --> 00:21:45,600
모든 것이 제대로 작동하는지 확인하기 위해 상위 셀을 실행해야 하므로

530
00:21:45,600 --> 00:21:48,900
지저분한 환경을 실행해야 합니다.

531
00:21:48,900 --> 00:21:50,280
음 생성 모델의 구조입니다.

532
00:21:50,280 --> 00:21:53,280
여기에 대문자 A 매트릭스가

533
00:21:53,280 --> 00:21:56,400
있습니다. 구조는 25 25입니다. 즉,

534
00:21:56,400 --> 00:21:58,799
25개의 상태가 있고  25개의 설문 조사가

535
00:21:58,799 --> 00:22:01,860
있고 여기에서는 완전히 관찰 가능하기 때문에

536
00:22:01,860 --> 00:22:04,020


537
00:22:04,020 --> 00:22:07,200
크기 25의 항등 행렬로 초기화하므로 이것이 이

538
00:22:07,200 --> 00:22:10,500


539
00:22:10,500 --> 00:22:13,260
특정 그리드 작업에 대해 초기화하는 우도 행렬이고

540
00:22:13,260 --> 00:22:16,559
두 번째 요소는

541
00:22:16,559 --> 00:22:18,900
전환 행렬이므로 거기에

542
00:22:18,900 --> 00:22:21,240
유의하십시오.  기존의 모든

543
00:22:21,240 --> 00:22:24,299
시간 DB 기능을 사용하여

544
00:22:24,299 --> 00:22:25,679
임의의 행렬을 정의한

545
00:22:25,679 --> 00:22:28,919
다음 그 위에 항등 행렬을 사용하고 있습니다.

546
00:22:28,919 --> 00:22:32,460
그래서 예 여기서는 새로운 작업을 수행하지 않습니다.

547
00:22:32,460 --> 00:22:35,400
기존

548
00:22:35,400 --> 00:22:38,220
시간 DB 기능이므로

549
00:22:38,220 --> 00:22:41,580
지금 할 수 있는 것은 다음과 같습니다.  전환 매트릭스라고도 하는 B 매트릭스를 정의하여

550
00:22:41,580 --> 00:22:43,500


551
00:22:43,500 --> 00:22:45,960
전환 매트릭스가

552
00:22:45,960 --> 00:22:48,000


553
00:22:48,000 --> 00:22:49,799
특정 상태에서 시작하여

554
00:22:49,799 --> 00:22:52,440
조치를 취하면 미래에 끝날 위치와 같은 전환을 인코딩하므로

555
00:22:52,440 --> 00:22:55,320
이것이 상태의 수에 따라 달라지는 아이디어입니다.

556
00:22:55,320 --> 00:22:56,640
상태는 숨겨진 상태

557
00:22:56,640 --> 00:22:59,640
양식과 컨트롤 수이므로

558
00:22:59,640 --> 00:23:02,159
상태 작업 상태의 구조를 갖습니다.

559
00:23:02,159 --> 00:23:04,320
여기서 특정 상태에서 작업을 수행하면 결국

560
00:23:04,320 --> 00:23:05,640


561
00:23:05,640 --> 00:23:08,340
종료될 작업도 미래 상태이므로

562
00:23:08,340 --> 00:23:09,780


563
00:23:09,780 --> 00:23:12,980
실제 환경 상태로 초기화할 것이므로

564
00:23:12,980 --> 00:23:15,480
이제 이것은

565
00:23:15,480 --> 00:23:17,039
제가 구축한 환경의 일부입니다.

566
00:23:17,039 --> 00:23:19,380
b 매트릭스를 제공할 것입니다.

567
00:23:19,380 --> 00:23:21,179
음 이 B 매트릭스의 구조를 살펴보는 것이 가치가 있을 것입니다.

568
00:23:21,179 --> 00:23:24,740


569
00:23:25,380 --> 00:23:29,340
그래서 여기에 음 25개가 있습니다.  25 4 즉,

570
00:23:29,340 --> 00:23:32,820
내가

571
00:23:32,820 --> 00:23:34,500


572
00:23:34,500 --> 00:23:38,220
최종적으로 도달할 특정 상태에서 조치를 취하면 디자인에 따라

573
00:23:38,220 --> 00:23:40,140
이 특정 그리드에 대한 진정한 어 전환 역학이 있으므로

574
00:23:40,140 --> 00:23:42,840
get

575
00:23:42,840 --> 00:23:46,020
ruby라는 함수가 있고 이는 다음을 제공합니다.  우리는

576
00:23:46,020 --> 00:23:47,700
에이전트가 사용할 수 있는 시스템의 진정한 B이므로

577
00:23:47,700 --> 00:23:51,000
이상적으로는

578
00:23:51,000 --> 00:23:52,919
에이전트가 이를 배우기를 원하지만

579
00:23:52,919 --> 00:23:55,620
이 데모의 목적에서는

580
00:23:55,620 --> 00:23:57,900
에이전트가 이미 구조를 알고

581
00:23:57,900 --> 00:24:00,960
있고 다음과 같은 이전 발자국을 가져온다고 가정합니다.

582
00:24:00,960 --> 00:24:03,840
어 여기서는 목표 상태에 얼마나 가까운지에 따라 정의된다는 점에서 흥미롭습니다.

583
00:24:03,840 --> 00:24:05,039


584
00:24:05,039 --> 00:24:08,280


585
00:24:08,280 --> 00:24:10,200
따라서 골드 상태에 있다면

586
00:24:10,200 --> 00:24:12,720
어 분명히 그것이 가장

587
00:24:12,720 --> 00:24:15,539
선호하는 가장 많이 찾는 상태

588
00:24:15,539 --> 00:24:18,840
이고 이웃 상태를 어떻게 선호합니까?

589
00:24:18,840 --> 00:24:20,220
이는

590
00:24:20,220 --> 00:24:23,220
거리의 제곱근

591
00:24:23,220 --> 00:24:25,200
또는 기본적으로

592
00:24:25,200 --> 00:24:27,960
특정 목표 상태로부터의 거리에 따라 달라지므로

593
00:24:27,960 --> 00:24:30,860


594
00:24:30,860 --> 00:24:34,679
이 특정 그리드 작업과 동일한 크기의 8×8 그리드를 정의한

595
00:24:34,679 --> 00:24:39,419
다음

596
00:24:39,419 --> 00:24:43,440
일종의 추가 방법이 있습니다.  이는

597
00:24:43,440 --> 00:24:45,059
모든 상태에 대해 선호하는 값

598
00:24:45,059 --> 00:24:48,240
이며 특정 C 매트릭스를 렌더링하면

599
00:24:48,240 --> 00:24:49,919


600
00:24:49,919 --> 00:24:53,039
이 금 상태가

601
00:24:53,039 --> 00:24:55,140
더 선호되고 주변

602
00:24:55,140 --> 00:24:57,780
상태가 덜 준비되어 있는 것과 동일한 구조를 볼 수 있으므로

603
00:24:57,780 --> 00:25:00,539
이제 C 매트릭스가 있습니다.  또한

604
00:25:00,539 --> 00:25:03,419
고전적인 시간 DP 방식으로 정의한

605
00:25:03,419 --> 00:25:06,840
다음 해당 c 매트릭스를 이전 셀

606
00:25:06,840 --> 00:25:09,299
에서 평가한 C 매트릭스로 초기화합니다.

607
00:25:09,299 --> 00:25:11,940
이

608
00:25:11,940 --> 00:25:13,740
특정 C 매트릭스의 작은 C는 괜찮습니다.

609
00:25:13,740 --> 00:25:16,799
그런 다음 마지막으로 생성 모델의 경우

610
00:25:16,799 --> 00:25:19,140
이전 셀인 대문자 D가 있습니다.

611
00:25:19,140 --> 00:25:21,000
숨겨진 상태에 대해

612
00:25:21,000 --> 00:25:23,640
균일한 개체 배열을 사용하므로

613
00:25:23,640 --> 00:25:26,039


614
00:25:26,039 --> 00:25:29,700
시작하는 위치에 대한 사전 정보가 없으므로 보류 중인 셀을 실행하겠습니다.

615
00:25:29,700 --> 00:25:32,120


616
00:25:32,700 --> 00:25:35,100
여기서 D 매트릭스는

617
00:25:35,100 --> 00:25:37,140
숨겨진 상태 I에 대한 균일한 분포입니다.

618
00:25:37,140 --> 00:25:38,460
어디에서 시뮬레이션을 시작할지 모르겠습니다.

619
00:25:38,460 --> 00:25:41,460
이것이

620
00:25:41,460 --> 00:25:43,679
생성 모델의 기본 구조이고

621
00:25:43,679 --> 00:25:46,799


622
00:25:46,799 --> 00:25:48,500


623
00:25:48,500 --> 00:25:51,659
환경과 같이 별도로 논의하고 싶은 에이전트 클래스가 있으므로

624
00:25:51,659 --> 00:25:54,600
이러한 환경 매개변수를 고려하면 어떻게

625
00:25:54,600 --> 00:25:57,419
예상할 수 있습니까?  작동할 에이전트 클래스는 그래서

626
00:25:57,419 --> 00:25:59,880
이 폴더 구조 내의 에이전트 클래스는 어디에 있습니까?

627
00:25:59,880 --> 00:26:01,260


628
00:26:01,260 --> 00:26:05,100
어 pmdp 모듈 폴더 안에는

629
00:26:05,100 --> 00:26:07,940


630
00:26:07,940 --> 00:26:12,179
기본적으로 클래스인 에이전트 SI dot p y가 있고

631
00:26:12,179 --> 00:26:14,419


632
00:26:14,419 --> 00:26:17,880
여기에는 환경 클래스와 유사하며 여기에도 단계 함수가 있습니다.

633
00:26:17,880 --> 00:26:21,900


634
00:26:21,900 --> 00:26:25,500
함수에 대한 관찰을 수행하고

635
00:26:25,500 --> 00:26:28,020


636
00:26:28,020 --> 00:26:30,840
선택 사항인 환경을 학습할지 여부에 대한 플래그도 가져옵니다. 따라서 비활성화하면

637
00:26:30,840 --> 00:26:33,419
생성 모델을 학습하지 않고

638
00:26:33,419 --> 00:26:35,400
활성화하면 매개

639
00:26:35,400 --> 00:26:37,500
변수가 업데이트됩니다.  생성 모델이

640
00:26:37,500 --> 00:26:39,240
기본적으로 수행하는 작업은

641
00:26:39,240 --> 00:26:42,299
이 시점에서 수행할 작업을 반환

642
00:26:42,299 --> 00:26:44,880
하고 환경은

643
00:26:44,880 --> 00:26:47,400
기본적으로 해당 작업을 바로 사용할 수 있다는 것입니다. 따라서

644
00:26:47,400 --> 00:26:49,080
이 파일에는 자세히 설명할 에이전트 클래스가 있습니다.

645
00:26:49,080 --> 00:26:51,960


646
00:26:51,960 --> 00:26:54,960
기본적으로

647
00:26:54,960 --> 00:26:57,740
이 셀에 해당 에이전트 클래스를 가져온

648
00:26:57,740 --> 00:27:00,539
다음

649
00:27:00,539 --> 00:27:03,000


650
00:27:03,000 --> 00:27:05,820
The Originals of State 입학 서류에서 이 동작 결과를 재현하려고 시도할 것입니다.

651
00:27:05,820 --> 00:27:09,659


652
00:27:09,659 --> 00:27:12,480
따라서 우리가 기대하는 것은 이

653
00:27:12,480 --> 00:27:14,760
사전 선호 구조를 고려할 때

654
00:27:14,760 --> 00:27:16,919
이 사전 성능에 로컬 최대값이 있다는 것입니다.

655
00:27:16,919 --> 00:27:18,539
구조이므로 이

656
00:27:18,539 --> 00:27:21,419
특정 지점에서 시작하면 충분히 깊게 계획하지 않으면

657
00:27:21,419 --> 00:27:24,419
결국에는

658
00:27:24,419 --> 00:27:26,640


659
00:27:26,640 --> 00:27:28,919
매우 선호하는

660
00:27:28,919 --> 00:27:31,200
관찰이 없는 로컬 최대값 중 하나에 있게 됩니다. 선 아래로 4단계를 말하십시오.

661
00:27:31,200 --> 00:27:34,080
이 특정 상태에 있으면

662
00:27:34,080 --> 00:27:36,539
이 로컬 최대값이 표시되며

663
00:27:36,539 --> 00:27:38,340


664
00:27:38,340 --> 00:27:39,779
이웃 상태가 덜

665
00:27:39,779 --> 00:27:42,059
선호되고 더 선호되는 이 상태는

666
00:27:42,059 --> 00:27:43,980


667
00:27:43,980 --> 00:27:47,279
세계나 벽 구조 때문에 접근할 수 없기 때문에 거기에 가서 앉을 것입니다.

668
00:27:47,279 --> 00:27:49,320


669
00:27:49,320 --> 00:27:51,840
덜 선호하는 상태를 통과하고 에이전트가 이를 수행할 수 있도록 깊은 계획이 필요합니다.

670
00:27:51,840 --> 00:27:54,059
에이전트는

671
00:27:54,059 --> 00:27:56,220


672
00:27:56,220 --> 00:27:57,779


673
00:27:57,779 --> 00:28:00,360
음 4단계 앞서 시간에 맞춰 시뮬레이션할 수 있어야 하며

674
00:28:00,360 --> 00:28:02,880
어 매우 보람 있는

675
00:28:02,880 --> 00:28:06,080
관찰이 오는지 확인할 수 있어야 합니다.  그러한 작업을 수행하는 것이

676
00:28:06,080 --> 00:28:08,700
바로 이것이 우리가 음 이

677
00:28:08,700 --> 00:28:09,720


678
00:28:09,720 --> 00:28:13,919
특정 데모에서 보려고 하는 요점이므로 음

679
00:28:13,919 --> 00:28:17,220
낮은 계획 깊이의 경우 기본적으로

680
00:28:17,220 --> 00:28:19,559
로컬 최대값 중 하나에 갇히게 되지만

681
00:28:19,559 --> 00:28:21,179
충분한 계획 깊이가 있으면

682
00:28:21,179 --> 00:28:23,520
골드 상태로 이동하게 됩니다.  이것이 바로

683
00:28:23,520 --> 00:28:25,919
우리가 보려고 하는 것이므로 서로

684
00:28:25,919 --> 00:28:28,440
다른 계획 지평선이

685
00:28:28,440 --> 00:28:31,440
있고 기본적으로 우리가 하는 일은

686
00:28:31,440 --> 00:28:34,440
에이전트에게 생성 모델을 제공하는 것입니다.

687
00:28:34,440 --> 00:28:37,020
우리는 지금 매트릭스

688
00:28:37,020 --> 00:28:39,960
B 매트릭스 C 매트릭스 V 매트릭스를 정의한 다음

689
00:28:39,960 --> 00:28:42,480
자본 N의 계획 지평선을 갖게 됩니다.  그래서

690
00:28:42,480 --> 00:28:44,940
여기서는 계획 깊이를 반복하고 있으므로

691
00:28:44,940 --> 00:28:48,000
n은 루프에 대해 1 3과 4가 될 것입니다.

692
00:28:48,000 --> 00:28:50,580
그런 다음

693
00:28:50,580 --> 00:28:53,100
활성 영향 문헌에서 종종 알파로 표시되는 작업 정밀도가 있으므로

694
00:28:53,100 --> 00:28:55,320


695
00:28:55,320 --> 00:28:58,080
어떤 작업을 수행할지 결정하므로 매우

696
00:28:58,080 --> 00:29:01,200
정확한 작업 행렬이 됩니다.  이는

697
00:29:01,200 --> 00:29:03,620


698
00:29:03,620 --> 00:29:07,080
예상되는 자유 에너지가 가장 낮지만 액센트가 낮은 작업을 계속 수행한다는 의미입니다.

699
00:29:07,080 --> 00:29:08,400
정밀도는 일종의

700
00:29:08,400 --> 00:29:10,320
확률적이며

701
00:29:10,320 --> 00:29:12,480
다른 작업도 고려합니다. 그런 다음 자주 논의할 계획 기능의

702
00:29:12,480 --> 00:29:14,159
일부인 계획 정밀도가 있습니다.

703
00:29:14,159 --> 00:29:16,620


704
00:29:16,620 --> 00:29:18,120
문헌에서

705
00:29:18,120 --> 00:29:20,159
감마로 표시된 경우 정교한 추론에

706
00:29:20,159 --> 00:29:21,960
매우 중요한 검색 임계값도 있습니다.

707
00:29:21,960 --> 00:29:24,600
왜냐하면 연구

708
00:29:24,600 --> 00:29:26,880
에서 정교한 추론을 보았듯이

709
00:29:26,880 --> 00:29:28,559


710
00:29:28,559 --> 00:29:32,399


711
00:29:32,399 --> 00:29:34,740
계산량이 많을 수 있지만

712
00:29:34,740 --> 00:29:36,480
임계값을 정의해야 한다는 점에서 좋지 않기 때문입니다.

713
00:29:36,480 --> 00:29:39,179


714
00:29:39,179 --> 00:29:41,159
작동하도록 하기 위한 많은 가능성을 무시하는 것입니다. 그리고 그것은 우리도 논의할 아이디어입니다.

715
00:29:41,159 --> 00:29:44,340


716
00:29:44,340 --> 00:29:47,820
에이전트 클래스로 이동하기 전에 미리보기만 하려고 합니다.

717
00:29:47,820 --> 00:29:51,480


718
00:29:51,480 --> 00:29:55,200
우리가 하려는 작업은 루프에서 에이전트 도트

719
00:29:55,200 --> 00:29:57,240
단계를 호출하는 것입니다.  환경 도트 단계를 연속적으로 수행하여

720
00:29:57,240 --> 00:30:00,179
에이전트가 관찰을 볼 수 있도록 조치를

721
00:30:00,179 --> 00:30:01,559
취합니다.

722
00:30:01,559 --> 00:30:03,960
해당 작업이 환경으로 이동하고

723
00:30:03,960 --> 00:30:06,419
환경이 새로운

724
00:30:06,419 --> 00:30:08,940
관찰을 반환하며 이 루프가 계속되고

725
00:30:08,940 --> 00:30:11,600
우리는 시간이 지남에 따라 이 루프가 어떻게

726
00:30:11,600 --> 00:30:14,820
진화하는지 확인하고 싶습니다.  목적이 있는 행동을

727
00:30:14,820 --> 00:30:18,419
하고 에이전트가 그렇게 할 수 있다면

728
00:30:18,419 --> 00:30:20,720
결과를 공개하기 전에

729
00:30:20,720 --> 00:30:24,480
에이전트 클래스에 대해 논의해 보겠습니다.

730
00:30:24,480 --> 00:30:27,360


731
00:30:27,360 --> 00:30:30,179
관찰이 주어졌을 때 조치를 취하려면 에이전트가

732
00:30:30,179 --> 00:30:33,120
계획을 가지고 있어야 하며 바로

733
00:30:33,120 --> 00:30:35,700
여기에 있습니다.  에이전트 정교한

734
00:30:35,700 --> 00:30:38,340
추론 에이전트

735
00:30:38,340 --> 00:30:40,799
음 저기 우리는 실제로

736
00:30:40,799 --> 00:30:43,320
일부 기능에 대해 기존 Prime DB 에이전트를 사용하고 있습니다.

737
00:30:43,320 --> 00:30:46,320
그래서 Pym DP에는 이미

738
00:30:46,320 --> 00:30:50,580


739
00:30:50,580 --> 00:30:52,200
인식

740
00:30:52,200 --> 00:30:55,200
및 학습을 위해 정말 잘 작성된 함수가 있으므로

741
00:30:55,200 --> 00:30:57,600
대체하고 싶은 유일한 것은 어떻게  에이전트는

742
00:30:57,600 --> 00:30:59,640
계획을 세우고 에이전트가

743
00:30:59,640 --> 00:31:03,360
정책에 대해 결정을 내리는 방법을 수행하므로

744
00:31:03,360 --> 00:31:05,600


745
00:31:05,779 --> 00:31:09,419
여기서는 상위 에이전트 클래스를 사용하므로

746
00:31:09,419 --> 00:31:11,640


747
00:31:11,640 --> 00:31:14,340
dp.agent 시간부터 지금 논의 중인

748
00:31:14,340 --> 00:31:15,620


749
00:31:15,620 --> 00:31:19,500
SI 에이전트 옆에 있는 에이전트 클래스를 가져옵니다.

750
00:31:19,500 --> 00:31:21,960


751
00:31:21,960 --> 00:31:23,279


752
00:31:23,279 --> 00:31:25,919
기본적으로 우리는

753
00:31:25,919 --> 00:31:28,679


754
00:31:28,679 --> 00:31:30,480
이 수업이 작동하도록 기본 프로그램에서 생성 모델 구조(

755
00:31:30,480 --> 00:31:33,299
a b c 및 d)와

756
00:31:33,299 --> 00:31:35,460
제가 언급한 모든 정밀도 및 임계값 매개변수를 사용하고 있습니다.

757
00:31:35,460 --> 00:31:36,480


758
00:31:36,480 --> 00:31:39,140


759
00:31:39,140 --> 00:31:41,880


760
00:31:41,880 --> 00:31:45,240
그런 다음 기본 프로그램에서 언급한 이전 컨퍼런스를 일종의 정규화하는 것입니다.

761
00:31:45,240 --> 00:31:50,220
C가 어떻게 C의 구조를 보면

762
00:31:50,220 --> 00:31:52,620


763
00:31:52,620 --> 00:31:55,320
숫자로 정의되고 사전 선호도가

764
00:31:55,320 --> 00:31:56,940
종종 해석되거나

765
00:31:56,940 --> 00:31:58,679


766
00:31:58,679 --> 00:32:01,020
계산이 올바르게 작동하려면 확률 분포여야 하므로

767
00:32:01,020 --> 00:32:02,580
음 우리는 이를 확률 분포로 정규화하겠습니다.

768
00:32:02,580 --> 00:32:05,460


769
00:32:05,460 --> 00:32:06,779


770
00:32:06,779 --> 00:32:09,059
음, 어, 합이 1이 되지 않는 숫자가 있어서 그런 일이 일어나고 있습니다.

771
00:32:09,059 --> 00:32:11,340


772
00:32:11,340 --> 00:32:13,620
여기서 우리는 소프트맥스를 사용하여 이를 수행하고 있으며,

773
00:32:13,620 --> 00:32:15,600
우리가 하고 있는 일은 음,

774
00:32:15,600 --> 00:32:16,860


775
00:32:16,860 --> 00:32:20,159
이러한 생성 모델 매개변수를 사용하여 기존 시간 DB 에이전트를 초기화하는 것입니다.  하려고 하는 것은

776
00:32:20,159 --> 00:32:23,220


777
00:32:23,220 --> 00:32:27,240


778
00:32:27,240 --> 00:32:28,860
주어진 계획 지평선

779
00:32:28,860 --> 00:32:32,039
과 3초 동안 주어진 음 임계값에 대한 계획 기능을 작성하는 것입니다.

780
00:32:32,039 --> 00:32:35,399
좋습니다.

781
00:32:35,399 --> 00:32:37,740
이 에이전트 클래스에는 세 가지 기능이 있습니다.

782
00:32:37,740 --> 00:32:39,720
하나는 지금 논의할 계획을 위한 도우미 기능이고

783
00:32:39,720 --> 00:32:42,240


784
00:32:42,240 --> 00:32:45,120
계획 기능 자체가 있습니다.

785
00:32:45,120 --> 00:32:48,179
연구를 사용하여 계획을 세울 예정이고

786
00:32:48,179 --> 00:32:50,220
재귀적 연구이기 때문에

787
00:32:50,220 --> 00:32:52,260


788
00:32:52,260 --> 00:32:54,980
재귀적 평가를 구현하는 추가 함수가 필요할 것입니다.

789
00:32:54,980 --> 00:32:58,559
여기서 우리는 함수 자체 내에서

790
00:32:58,559 --> 00:33:00,799
정방향 검색이라는 이 함수를 호출할 것이므로

791
00:33:00,799 --> 00:33:04,200


792
00:33:04,200 --> 00:33:05,700
이 함수를 호출합니다.  이 함수 내부에서는

793
00:33:05,700 --> 00:33:07,740


794
00:33:07,740 --> 00:33:09,240
다음 단계에 대한 예상 자유 에너지를 계산

795
00:33:09,240 --> 00:33:11,279
하고

796
00:33:11,279 --> 00:33:13,740
계획 지평선이 나올 때까지 다음 단계에 대해 다시 호출하므로

797
00:33:13,740 --> 00:33:16,940
이것이 재귀 루프 아이디어이고

798
00:33:16,940 --> 00:33:20,460
마지막으로

799
00:33:20,460 --> 00:33:23,460
모든 작업에 대한 예상 자유 에너지를 반환합니다.  어 주어진

800
00:33:23,460 --> 00:33:25,679
관찰 후 우리는 발표에 따라 무엇을 해야 할지 순차적으로

801
00:33:25,679 --> 00:33:28,080
작성하는 단계 함수를 구현합니다.

802
00:33:28,080 --> 00:33:29,640


803
00:33:29,640 --> 00:33:32,460


804
00:33:32,460 --> 00:33:37,519


805
00:33:38,279 --> 00:33:43,500
여기 데모로 돌아가면 관찰을 얻고 동작을 제공하는 첫 번째 아이디어가 있습니다.

806
00:33:43,500 --> 00:33:46,799


807
00:33:46,799 --> 00:33:49,860
에이전트 도트 단계

808
00:33:49,860 --> 00:33:52,260
함수를 실행하고 무슨 일이 일어나는지 상상해 보세요.

809
00:33:52,260 --> 00:33:56,039
어 시간 t가 0이거나

810
00:33:56,039 --> 00:33:59,460
실험이 시작되는 경우 어

811
00:33:59,460 --> 00:34:01,019


812
00:34:01,019 --> 00:34:03,779
처음에 이상적으로 수행해야 하는 작업은 관찰을 사용하여 해당 상태에 있으므로

813
00:34:03,779 --> 00:34:06,600
우리는 무엇입니까?  그것을 주는 것은

814
00:34:06,600 --> 00:34:09,899
관찰이고 진입을 위해 모듈을 사용하면

815
00:34:09,899 --> 00:34:12,899


816
00:34:12,899 --> 00:34:16,619


817
00:34:16,619 --> 00:34:19,560
상태에 대한 믿음인 믿음 Qs가 나올 것입니다. 그렇죠. 셀프 도트 Qs는

818
00:34:19,560 --> 00:34:23,159
에이전트 내부에 대한 믿음이고

819
00:34:23,159 --> 00:34:25,500
일단 그것이 어디에 있는지에 대한 믿음을 갖게 되면

820
00:34:25,500 --> 00:34:28,379
지금은 숨겨진 상태에 대한 특정 믿음에 대한 계획을 세우는 계획 도트 연구를 구현할 수 있습니다.

821
00:34:28,379 --> 00:34:31,080


822
00:34:31,080 --> 00:34:33,839


823
00:34:33,839 --> 00:34:36,359
계획을 완료하면

824
00:34:36,359 --> 00:34:39,239


825
00:34:39,239 --> 00:34:42,239
IMDb의 샘플 작업 기능을 사용하여 결정을 내리고 기본적으로

826
00:34:42,239 --> 00:34:45,540
반환할 수 있습니다. 해당 작업을 반환합니다.

827
00:34:45,540 --> 00:34:48,000
다른 모든 시간 단계에 대해

828
00:34:48,000 --> 00:34:50,580
시퀀스는 동일하게 유지되지만

829
00:34:50,580 --> 00:34:52,139


830
00:34:52,139 --> 00:34:55,080
Horizon 수업에서 학습을 활성화하면 구조에 대해서도 학습하므로 이것이

831
00:34:55,080 --> 00:34:56,639


832
00:34:56,639 --> 00:35:01,260
단계 기능이지만

833
00:35:01,260 --> 00:35:04,859
계획을 수행하기 위해 일종의

834
00:35:04,859 --> 00:35:06,599
재구성입니다.

835
00:35:06,599 --> 00:35:08,880
다양한 열 및

836
00:35:08,880 --> 00:35:10,680
상태 양식과 다양한

837
00:35:10,680 --> 00:35:12,240
관찰 양식에 대한 생성 모델 구조

838
00:35:12,240 --> 00:35:16,320
그래서 용융이 어떻게 작동하는지 논의하기 위해

839
00:35:16,320 --> 00:35:17,760


840
00:35:17,760 --> 00:35:20,640
음 해당 계획을 구현하기 위해 평가하는 새로운 a 행렬과 B 행렬에 대해 이야기하고 싶습니다.

841
00:35:20,640 --> 00:35:22,920


842
00:35:22,920 --> 00:35:24,720


843
00:35:24,720 --> 00:35:27,780


844
00:35:27,780 --> 00:35:31,380
원래

845
00:35:31,380 --> 00:35:31,980
음

846
00:35:31,980 --> 00:35:34,440
숨겨진 상태 요소로 돌아가 보겠습니다. 여기서는

847
00:35:34,440 --> 00:35:36,780
숨겨진 상태 요소가 하나만 있습니다.

848
00:35:36,780 --> 00:35:39,599
음 그래서 d0이 맞고 B1이

849
00:35:39,599 --> 00:35:43,200
존재하지 않는 이유는

850
00:35:43,200 --> 00:35:45,660
숨겨진 상태 요소가 하나만 있기 때문입니다. 하지만

851
00:35:45,660 --> 00:35:47,880
숨겨진 상태 액터가 두 명 있다고 상상해 보세요.

852
00:35:47,880 --> 00:35:50,880
같은 크기일 수도 있고

853
00:35:50,880 --> 00:35:53,460
음 그래서 여기가

854
00:35:53,460 --> 00:35:56,880
에이전트의 마음 안에 있는 위치나 다른 것일 수도

855
00:35:56,880 --> 00:35:57,660


856
00:35:57,660 --> 00:36:00,780
있고 음과

857
00:36:00,780 --> 00:36:05,180
같이 이 두 가지 숨겨진 상태 요소에 대한 제어 기능도 있어야 합니다.

858
00:36:05,220 --> 00:36:06,300


859
00:36:06,300 --> 00:36:08,700
그러면 모든 열과 상태 요소에 대한 제어가 있어야 합니다.

860
00:36:08,700 --> 00:36:10,920


861
00:36:10,920 --> 00:36:13,859
능동 추론

862
00:36:13,859 --> 00:36:17,040
아이디어에 익숙하며 관찰

863
00:36:17,040 --> 00:36:18,540
공간도 이

864
00:36:18,540 --> 00:36:20,640
두 가지 방사율 요소를 직접 관찰할 수도 있습니다.

865
00:36:20,640 --> 00:36:21,900


866
00:36:21,900 --> 00:36:24,420
이것은

867
00:36:24,420 --> 00:36:26,040
여러 숨겨진 상태

868
00:36:26,040 --> 00:36:29,579
와 여러 관찰 양식을 갖춘 새로운 생성 모델 구조이며 매개

869
00:36:29,579 --> 00:36:32,040


870
00:36:32,040 --> 00:36:33,660
변수의 차원이

871
00:36:33,660 --> 00:36:37,500
변경되는 것을 즉시 확인할 수 있습니다.  25개의

872
00:36:37,500 --> 00:36:39,300


873
00:36:39,300 --> 00:36:43,320
숨겨진 상태 25개에서 25개의 관측값이 나오고

874
00:36:43,320 --> 00:36:44,520
첫 번째 관측 양식의 구조를 보면

875
00:36:44,520 --> 00:36:47,220
동일하지만

876
00:36:47,220 --> 00:36:49,920
우리가 원하는 것은

877
00:36:49,920 --> 00:36:54,240
25개의 숨겨진 상태가 아닌

878
00:36:54,240 --> 00:36:55,920
1개의 숨겨진 상태가 있는 25개의 새로운 매트릭스입니다.  상태 사이에서는

879
00:36:55,920 --> 00:36:58,320


880
00:36:58,320 --> 00:37:01,440
음 생성 모델의 재구성일 뿐이지만

881
00:37:01,440 --> 00:37:03,660
계산은 본질적으로 동일하게 유지됩니다.

882
00:37:03,660 --> 00:37:04,380


883
00:37:04,380 --> 00:37:06,900
따라서

884
00:37:06,900 --> 00:37:09,180
이 도우미 함수가

885
00:37:09,180 --> 00:37:11,940
수행하려는 작업은 여러 숨겨진 상태 양식이 있을 때 작업을 더 쉽게 만들어줄 것입니다.

886
00:37:11,940 --> 00:37:13,800


887
00:37:13,800 --> 00:37:15,720


888
00:37:15,720 --> 00:37:18,180


889
00:37:18,180 --> 00:37:19,859
음, 숨겨진 상태 양식이 여러 개 있는 경우

890
00:37:19,859 --> 00:37:21,060


891
00:37:21,060 --> 00:37:23,280
우리는 각 양식에

892
00:37:23,280 --> 00:37:25,320


893
00:37:25,320 --> 00:37:27,720
기록된 상태 수를 곱한 총 상태 수를 계산할 것입니다.

894
00:37:27,720 --> 00:37:29,760


895
00:37:29,760 --> 00:37:32,280
한 양식에 25개의 숨겨진 상태가

896
00:37:32,280 --> 00:37:33,960
있고 다른 양식에 25개의 숨겨진 상태가 있다면

897
00:37:33,960 --> 00:37:37,380
총 625개가 됩니다.  척도

898
00:37:37,380 --> 00:37:40,079
의 수와

899
00:37:40,079 --> 00:37:43,020
각 양식에 각각 4개의 행동이 있다면

900
00:37:43,020 --> 00:37:45,660
총 16개의 행동이 있습니다. 이는

901
00:37:45,660 --> 00:37:47,700


902
00:37:47,700 --> 00:37:51,119
각 양식에 있는 이 4개의 행동의 조합일 뿐입니다. 따라서

903
00:37:51,119 --> 00:37:53,220
당신은 4 곱하기 4 16 행동을 갖게 될 것입니다.

904
00:37:53,220 --> 00:37:55,560
두 가지 양식이 있고

905
00:37:55,560 --> 00:37:57,599
기본적으로

906
00:37:57,599 --> 00:38:00,140
음 모델 매개

907
00:38:00,140 --> 00:38:03,300


908
00:38:03,300 --> 00:38:05,640
변수는 동일하지만 차원

909
00:38:05,640 --> 00:38:07,380
구조만 다른 생성 모델을 구축하여

910
00:38:07,380 --> 00:38:09,240


911
00:38:09,240 --> 00:38:10,260
예상값을 더 쉽게 계산할 수 있으므로

912
00:38:10,260 --> 00:38:14,640
이제 새로운 a와 새로운 B,

913
00:38:14,640 --> 00:38:17,520
그리고 새로운 믿음이 생겼습니다.  이는 텐서 곱일 뿐이

914
00:38:17,520 --> 00:38:20,880
므로 기존 매개변수

915
00:38:20,880 --> 00:38:23,460
와 신념이므로 새로운

916
00:38:23,460 --> 00:38:27,359
큰 매트릭스일 뿐이고 다른 것은 아무것도 아닙니다.

917
00:38:27,359 --> 00:38:29,820
전송이 아니고 변경이 아니라 단지

918
00:38:29,820 --> 00:38:32,579
구조의 변형일 뿐이며

919
00:38:32,579 --> 00:38:36,420
이것이 b와 Q로 주어지면 우리는

920
00:38:36,420 --> 00:38:38,520
무슨 일이 일어날지 예측할 것입니다.  미래에 일어날 것으로

921
00:38:38,520 --> 00:38:41,520
예상되는 급여 에너지를 평가하므로

922
00:38:41,520 --> 00:38:43,680


923
00:38:43,680 --> 00:38:46,440
계획을 세우기 위해 이것이

924
00:38:46,440 --> 00:38:48,060
두 번째 기능입니다. 우리가 할 일은

925
00:38:48,060 --> 00:38:50,760
먼저 우리를 위해 녹이는 첫 번째 기능을 호출

926
00:38:50,760 --> 00:38:52,800
하고

927
00:38:52,800 --> 00:38:55,380
생성 모델을 설정하는 것입니다.

928
00:38:55,380 --> 00:38:59,040
계산하기 좋은 차원 cc에서 우리는

929
00:38:59,040 --> 00:39:01,500
모든 행동에 대해 예상되는 자유 에너지 자체를 가지고

930
00:39:01,500 --> 00:39:02,579


931
00:39:02,579 --> 00:39:07,040
있으며 이러한 행동에 대해

932
00:39:07,040 --> 00:39:09,300
예상되는 자유 에너지에 의존하는 확률을 가지고 있습니다.

933
00:39:09,300 --> 00:39:11,579


934
00:39:11,579 --> 00:39:13,680


935
00:39:13,680 --> 00:39:16,619
여기서 우리가 갈 것이기 때문에 이것이 관찰이 아닌 행동일 뿐인 이유는 무엇입니까?  주어진 관찰에 대해 예상되는

936
00:39:16,619 --> 00:39:18,960
행동의 자유 에너지를 평가하기 위해

937
00:39:18,960 --> 00:39:22,140


938
00:39:22,140 --> 00:39:23,460


939
00:39:23,460 --> 00:39:26,280
uh 슬라이드로 돌아가서

940
00:39:26,280 --> 00:39:29,240
uh 이것을

941
00:39:29,240 --> 00:39:31,920
그림으로 논의하여 일을 더 쉽게 하기 위해

942
00:39:31,920 --> 00:39:33,960
여기에 그리드가 있고

943
00:39:33,960 --> 00:39:36,119
더 높은 발자국과 우리가 구현하려고 하는 것이 있습니다.

944
00:39:36,119 --> 00:39:38,640


945
00:39:38,640 --> 00:39:41,700
시간 T에서 어떤 관찰을 관찰하면

946
00:39:41,700 --> 00:39:44,460


947
00:39:44,460 --> 00:39:47,640
해당 관찰에 따른 행동의 결과를 고려하게 된다는 것입니다. 왜냐하면

948
00:39:47,640 --> 00:39:49,980


949
00:39:49,980 --> 00:39:51,599
생성 모델에는 다음과 같은 경우

950
00:39:51,599 --> 00:39:53,700


951
00:39:53,700 --> 00:39:57,000
이 상태를 알려주는 전이 역학이 있기 때문에 무슨 일이 일어날지 예측할 수 있기 때문입니다.  나는

952
00:39:57,000 --> 00:39:58,380
내가 할 올바른 행동을 취합니다.

953
00:39:58,380 --> 00:40:00,359
이는 기본적으로

954
00:40:00,359 --> 00:40:03,180
미래에 무슨 일이 일어날지 예측하는 것이고 여러분은

955
00:40:03,180 --> 00:40:05,760
지금 당장

956
00:40:05,760 --> 00:40:09,839
무기고에서 사용할 수 있는 행동의 결과를 고려하고 있는 것입니다.

957
00:40:09,839 --> 00:40:12,540
그런 다음 행동을 취하면 다음을 수행할 수 있습니다.

958
00:40:12,540 --> 00:40:14,280


959
00:40:14,280 --> 00:40:16,440
다음 시간 단계에서 무슨 일이 일어날지 새로운 관측값으로 예측하면

960
00:40:16,440 --> 00:40:18,960


961
00:40:18,960 --> 00:40:20,760


962
00:40:20,760 --> 00:40:23,460
이 관측값이 가장 가능성이 높으며

963
00:40:23,460 --> 00:40:25,320
다른 관측값은

964
00:40:25,320 --> 00:40:27,839
실제로 가능성이 낮다는 것을 알려주는 확률 분포를 갖게 됩니다. 어 그러면

965
00:40:27,839 --> 00:40:30,359
할 일은 다음과 같습니다.  이것은 다시 특정 관찰

966
00:40:30,359 --> 00:40:32,220
로부터 당신의 행동을 한 결과를 고려

967
00:40:32,220 --> 00:40:34,740
하고 이것은

968
00:40:34,740 --> 00:40:37,440
당신의 계획 깊이에서 계속됩니다. 그래서

969
00:40:37,440 --> 00:40:39,780
이것은 아마도 당신이

970
00:40:39,780 --> 00:40:42,480
체육관에 가고 싶다고 생각할 수 있고

971
00:40:42,480 --> 00:40:44,460
음 모든 결과를 고려하게 될 것입니다.

972
00:40:44,460 --> 00:40:46,740
내가 신발을 신으면 일어날 일이야 내가

973
00:40:46,740 --> 00:40:49,800
신발을 신지 않으면 어 내가 차를 타면

974
00:40:49,800 --> 00:40:52,140
내가 차를 타지 않으면 넌 알겠지

975
00:40:52,140 --> 00:40:54,300
신발을 신어야 해 그러면

976
00:40:54,300 --> 00:40:56,700
너는

977
00:40:56,700 --> 00:40:59,520
내가 '  나는 이제 체육관에 갈 준비가 되었고 내가

978
00:40:59,520 --> 00:41:01,680
체육관에 가면 결국 내가 체육관에 있게 될 것입니다.

979
00:41:01,680 --> 00:41:03,660
그래서 그것은 당신이 지금 있는 위치의

980
00:41:03,660 --> 00:41:05,760
결과를 고려하고

981
00:41:05,760 --> 00:41:08,760


982
00:41:08,760 --> 00:41:10,740
당신이 원하는 만큼 갈 수 있다는 것과 같은 생각입니다. 바로 당신이 예측할 수 있습니다.  따라서

983
00:41:10,740 --> 00:41:12,420
체스 게임에서 당신은 특정 상태에 있을 수 있습니다. 당신은

984
00:41:12,420 --> 00:41:14,220
당신의 결과를 고려합니다. 당신은

985
00:41:14,220 --> 00:41:16,440
미래를 봅니다. 당신은

986
00:41:16,440 --> 00:41:18,480
그 미래의 결과를 고려하고 당신이

987
00:41:18,480 --> 00:41:21,660
원하는 만큼 깊이 들어갈 수 있습니다

988
00:41:21,660 --> 00:41:23,099


989
00:41:23,099 --> 00:41:23,700
음 음

990
00:41:23,700 --> 00:41:25,920


991
00:41:25,920 --> 00:41:27,839
당신의 계산 능력에 따라 그렇습니다.

992
00:41:27,839 --> 00:41:31,740


993
00:41:31,740 --> 00:41:36,500
우리가 결과를 고려하는 이 에이전트 클래스에서 구현하려고 합니다.

994
00:41:36,780 --> 00:41:38,880
어 예,

995
00:41:38,880 --> 00:41:40,200
그래서

996
00:41:40,200 --> 00:41:42,240
모든 양식에 대해 우리는

997
00:41:42,240 --> 00:41:44,460


998
00:41:44,460 --> 00:41:46,859
행동에 대해 예상되는 자유 에너지를 고려할 것입니다.

999
00:41:46,859 --> 00:41:49,260
이것은 기본적으로 전방 검색인 다음 함수를 호출할 것이므로

1000
00:41:49,260 --> 00:41:51,420


1001
00:41:51,420 --> 00:41:53,579
전방 검색은 제가 하는 것을 구현하는 것입니다.

1002
00:41:53,579 --> 00:41:55,560
방금 언급한

1003
00:41:55,560 --> 00:41:58,440
음, 결과를 고려하고

1004
00:41:58,440 --> 00:42:00,000
순방향 검색에서 기본적으로

1005
00:42:00,000 --> 00:42:04,020
수행하는 작업은 모든 작업에 대한 것이므로 149행에

1006
00:42:04,020 --> 00:42:06,119
모든 작업을 처리하는 루프가 있고 내가

1007
00:42:06,119 --> 00:42:07,140


1008
00:42:07,140 --> 00:42:08,760


1009
00:42:08,760 --> 00:42:11,640


1010
00:42:11,640 --> 00:42:14,400
사용하는 모든 작업의 ​​사후 또는 결과를 고려할 것입니다.

1011
00:42:14,400 --> 00:42:16,619
그 결과를 평가하기 위한 전이 확률

1012
00:42:16,619 --> 00:42:17,880


1013
00:42:17,880 --> 00:42:19,260
그런 다음

1014
00:42:19,260 --> 00:42:21,000
관찰을 예측할 것입니다. 왜냐하면 나의 이전

1015
00:42:21,000 --> 00:42:23,520
선호도는 관찰의 관점에서 정의되기 때문입니다.

1016
00:42:23,520 --> 00:42:25,980
나는

1017
00:42:25,980 --> 00:42:28,260
관찰을 예측하고

1018
00:42:28,260 --> 00:42:29,720


1019
00:42:29,720 --> 00:42:33,960
위험과 모호함의 합인 예상 자유 에너지를 평가할 것입니다.

1020
00:42:33,960 --> 00:42:37,320
알겠습니다.  여기서는

1021
00:42:37,320 --> 00:42:39,540


1022
00:42:39,540 --> 00:42:41,040


1023
00:42:41,040 --> 00:42:43,320


1024
00:42:43,320 --> 00:42:45,180
사후 또는 사후인 미래의 결과인 결과를 고려했으며

1025
00:42:45,180 --> 00:42:47,280
기본적으로

1026
00:42:47,280 --> 00:42:49,800
사후가

1027
00:42:49,800 --> 00:42:52,140
예상 범위에 따라 얼마나 좋은지 평가하고 이것이

1028
00:42:52,140 --> 00:42:53,880
해당 특정 사고에 대해 예상되는 자유 에너지가 되는 것과 같습니다.

1029
00:42:53,880 --> 00:42:56,160
당신은 모든 행동에 대해 이것을 합니다.

1030
00:42:56,160 --> 00:42:57,359


1031
00:42:57,359 --> 00:43:01,260
그리고 이것이 강력한

1032
00:43:01,260 --> 00:43:03,540
이유는 당신이 원하는 만큼 깊이 들어갈 수 있기 때문입니다.

1033
00:43:03,540 --> 00:43:07,020
따라서 여기 다음 단계에서 당신은 이 전리품으로 가서

1034
00:43:07,020 --> 00:43:07,980


1035
00:43:07,980 --> 00:43:11,819
내가

1036
00:43:11,819 --> 00:43:14,520
깊은 계획이나 깊이를 넘어서고 있는지 확인할 것입니다.  계획을 세운

1037
00:43:14,520 --> 00:43:16,380
다음 기본적으로 동일한 작업을 수행합니다.

1038
00:43:16,380 --> 00:43:18,780
해당 사후 요소

1039
00:43:18,780 --> 00:43:20,520
음

1040
00:43:20,520 --> 00:43:22,500
해당 특정 사후 요소의 작업 결과는 무엇입니까?

1041
00:43:22,500 --> 00:43:23,339
여기

1042
00:43:23,339 --> 00:43:24,900
에서 우리가 다시

1043
00:43:24,900 --> 00:43:28,020
um 상위 함수를 호출하므로

1044
00:43:28,020 --> 00:43:30,599
동일한 함수 정방향 검색을 통해

1045
00:43:30,599 --> 00:43:33,180
해당 조합의 결과를 고려합니다.

1046
00:43:33,180 --> 00:43:34,980
그것은 기본적으로 다시 돌아와서

1047
00:43:34,980 --> 00:43:37,380
예상 자유 에너지에 합산되므로

1048
00:43:37,380 --> 00:43:40,140
이 시퀀스에서 발생하는 일은

1049
00:43:40,140 --> 00:43:43,319
미래의 결과 중 일부 또는 전부를 고려한

1050
00:43:43,319 --> 00:43:46,579
다음 모든 값이

1051
00:43:46,579 --> 00:43:48,720


1052
00:43:48,720 --> 00:43:51,420
트리로 흘러내리고

1053
00:43:51,420 --> 00:43:53,400
예상 자유 에너지의 합계가 알려줄 것입니다.  어떤

1054
00:43:53,400 --> 00:43:55,140
행동이 좋은지, 어떤 행동이 나쁜지 음,

1055
00:43:55,140 --> 00:43:56,940


1056
00:43:56,940 --> 00:43:58,980
선호하는

1057
00:43:58,980 --> 00:44:00,240
관찰 결과를 확인하기 위해 취할 수 있는 것이 바로 이것이

1058
00:44:00,240 --> 00:44:02,520


1059
00:44:02,520 --> 00:44:05,819
연구 구현의 아이디어이고 어

1060
00:44:05,819 --> 00:44:09,180
여기서는 이 임계값의 중요성에 대해서도 이야기하겠습니다. 어 이것이

1061
00:44:09,180 --> 00:44:11,819
이것이 만드는 것입니다.

1062
00:44:11,819 --> 00:44:13,980
알고리즘은 가능하므로 이

1063
00:44:13,980 --> 00:44:16,140
임계값이 없으면 이 알고리즘은 작동하지 않습니다.

1064
00:44:16,140 --> 00:44:19,200
왜 그런지 명시적으로 설명

1065
00:44:19,200 --> 00:44:21,960
하고

1066
00:44:21,960 --> 00:44:23,819


1067
00:44:23,819 --> 00:44:26,460


1068
00:44:26,460 --> 00:44:28,800
현재 상태에서 사용 가능한 모든 동작에 대해 예상되는 자유 에너지를 평가하면 기본적으로 음

1069
00:44:28,800 --> 00:44:30,420


1070
00:44:30,420 --> 00:44:32,420
동작 분포라고 부르는 것을 계산할 수 있습니다.

1071
00:44:32,420 --> 00:44:36,240
이것이 내 행동의 가능성이 얼마나 되는지 또는

1072
00:44:36,240 --> 00:44:37,800
내가 행동을 취해야 하는 방법입니다.

1073
00:44:37,800 --> 00:44:40,740
그리고 우리는 또한 이 행동

1074
00:44:40,740 --> 00:44:43,560
정밀 매개변수 알파를 가지고 있습니다. 따라서 알파가

1075
00:44:43,560 --> 00:44:46,740
매우 높으면 기본적으로

1076
00:44:46,740 --> 00:44:48,839


1077
00:44:48,839 --> 00:44:50,099
항상

1078
00:44:50,099 --> 00:44:52,920
예상되는 행동을 최소화하는 행동을 선택하는 매우 편향된 분포입니다.  자유 에너지 만약 알파가

1079
00:44:52,920 --> 00:44:55,800
정말 낮다면 그것은

1080
00:44:55,800 --> 00:44:56,700
좀 더

1081
00:44:56,700 --> 00:44:59,400
희박하거나 분산된 분포가 될 것입니다.

1082
00:44:59,400 --> 00:45:00,599
그런 다음 이 동작 분포를 사용하여

1083
00:45:00,599 --> 00:45:02,339


1084
00:45:02,339 --> 00:45:07,200
동작을 샘플링할 수 있으므로 아시아

1085
00:45:07,200 --> 00:45:09,720
환경 루프에서 우리는 방금

1086
00:45:09,720 --> 00:45:12,180
해당 동작 분포의 계획과 계산을 마쳤습니다.

1087
00:45:12,180 --> 00:45:14,460
그런 다음 해당 작업

1088
00:45:14,460 --> 00:45:16,980
분포를 사용하여 정책 공간에서 작업을 샘플링할 수 있으므로

1089
00:45:16,980 --> 00:45:19,440


1090
00:45:19,440 --> 00:45:21,060
이 생성 모델의 정책 공간을 살펴보겠습니다.

1091
00:45:21,060 --> 00:45:23,040


1092
00:45:23,040 --> 00:45:25,619
그러면 하나의 숨겨진 상태 요소가 있는 원래 생성 모델로 다시 전환하고

1093
00:45:25,619 --> 00:45:27,480


1094
00:45:27,480 --> 00:45:28,760


1095
00:45:28,760 --> 00:45:30,660


1096
00:45:30,660 --> 00:45:33,720
계획을 세우고

1097
00:45:33,720 --> 00:45:35,599


1098
00:45:35,599 --> 00:45:38,819
이 에이전트를 초기화하겠습니다.

1099
00:45:38,819 --> 00:45:41,400


1100
00:45:41,400 --> 00:45:44,460
실행 값이 아닌 정책 공간을 확인하기 위해 이 에이전트를 초기화하고 싶기

1101
00:45:44,460 --> 00:45:47,000
때문에

1102
00:45:49,800 --> 00:45:52,440
계획 깊이에 대해 이 에이전트를 초기화하고

1103
00:45:52,440 --> 00:45:56,099


1104
00:45:56,099 --> 00:45:59,300
에이전트 Dot

1105
00:46:04,079 --> 00:46:05,520
정책을 보면

1106
00:46:05,520 --> 00:46:07,920
기본적으로 남동쪽이 아닌 네 가지 사용 가능한 작업이 있다고 말할 수 있습니다.

1107
00:46:07,920 --> 00:46:10,800


1108
00:46:10,800 --> 00:46:13,560
West 그리고

1109
00:46:13,560 --> 00:46:15,780
액션 분포가 있으면 어

1110
00:46:15,780 --> 00:46:18,060
그 액션을 취할 가능성이 얼마나 되는지 알려줄 테니

1111
00:46:18,060 --> 00:46:19,260


1112
00:46:19,260 --> 00:46:22,040


1113
00:46:23,339 --> 00:46:27,420
Pi에 대한 에이전트를 보면 괜찮습니다. 아직

1114
00:46:27,420 --> 00:46:30,540
계획을 세우지 않았기 때문에 정의되지 않았지만

1115
00:46:30,540 --> 00:46:32,160
계획을 세울 수 있으면 그렇게 될 것입니다.

1116
00:46:32,160 --> 00:46:34,578
정의되어야

1117
00:46:38,700 --> 00:46:41,460
합니다. 연구를 통해 계획을 구현했고

1118
00:46:41,460 --> 00:46:43,079
이제 작업

1119
00:46:43,079 --> 00:46:45,119
분포가 있으므로 이 특정

1120
00:46:45,119 --> 00:46:47,339
시나리오에서는 세 번째

1121
00:46:47,339 --> 00:46:48,900
작업을 가장 많이 수행할 것입니다(

1122
00:46:48,900 --> 00:46:52,200
기본적으로 0.99). 이는

1123
00:46:52,200 --> 00:46:54,300


1124
00:46:54,300 --> 00:46:56,099
이 특정 경우에 남북 및 동쪽인 확률입니다.

1125
00:46:56,099 --> 00:46:58,400


1126
00:46:58,400 --> 00:47:01,800
행렬에 익숙해지길 원했지만

1127
00:47:01,800 --> 00:47:03,359
이제

1128
00:47:03,359 --> 00:47:05,760
에이전트 환경 루프가 작동하는 모습을 살펴보겠습니다.

1129
00:47:05,760 --> 00:47:07,500


1130
00:47:07,500 --> 00:47:09,000


1131
00:47:09,000 --> 00:47:12,359
이제

1132
00:47:12,359 --> 00:47:15,180
샘플 작업 함수에서 작업을 샘플링한 다음

1133
00:47:15,180 --> 00:47:17,099


1134
00:47:17,099 --> 00:47:19,560
표준 Pym DP 방식을 사용하는 학습을 구현할 수 있습니다.

1135
00:47:19,560 --> 00:47:21,720
내 전환 역학을 업데이트하고

1136
00:47:21,720 --> 00:47:23,880
내가 보는 것과 내 믿음 등에 따라 동등한 역학을 좋아하므로 의사

1137
00:47:23,880 --> 00:47:26,099


1138
00:47:26,099 --> 00:47:31,280
결정 부분에 중점을 두므로

1139
00:47:38,220 --> 00:47:40,980
일단 작업을 샘플링하면 해당

1140
00:47:40,980 --> 00:47:43,520
작업은 기본적으로 환경으로 돌아갑니다.

1141
00:47:43,520 --> 00:47:46,940
알겠습니다. 이제

1142
00:47:46,940 --> 00:47:49,800
계획 깊이 1에 대해 이를 구현

1143
00:47:49,800 --> 00:47:53,099
하고 에이전트가 어떻게 행동하는지 살펴보겠습니다.

1144
00:47:53,099 --> 00:47:55,920
여기서 계획 깊이가 1인 경우

1145
00:47:55,920 --> 00:47:57,960
에이전트는

1146
00:47:57,960 --> 00:47:59,760
한 번의 Step Ahead의 결과만 고려하고

1147
00:47:59,760 --> 00:48:01,920


1148
00:48:01,920 --> 00:48:05,040
계획을 수행하기 위한 즉각적인 미래를 확인한다는 의미입니다.  그렇군요.

1149
00:48:05,040 --> 00:48:08,040
계획 깊이를 1로 설정하겠습니다.

1150
00:48:08,040 --> 00:48:09,900
음 저는

1151
00:48:09,900 --> 00:48:11,700
에이전트가

1152
00:48:11,700 --> 00:48:14,099
초기 시작 상태에서 시작할 환경을 재설정하고

1153
00:48:14,099 --> 00:48:16,260


1154
00:48:16,260 --> 00:48:18,900
있으며 루프에서

1155
00:48:18,900 --> 00:48:20,960


1156
00:48:22,079 --> 00:48:24,359
관찰을 얻고

1157
00:48:24,359 --> 00:48:27,300
해당 작업을 수행하고 작업을 반환하고

1158
00:48:27,300 --> 00:48:29,060
우리는 행동 확률을 살펴보고

1159
00:48:29,060 --> 00:48:31,920
해당 행동을 환경에 다시 제공하여

1160
00:48:31,920 --> 00:48:33,119


1161
00:48:33,119 --> 00:48:35,040
관찰을 되돌립니다. 이 루프는 에피소드가 종료될 때까지 계속됩니다.

1162
00:48:35,040 --> 00:48:37,740


1163
00:48:37,740 --> 00:48:39,780


1164
00:48:39,780 --> 00:48:42,900
세금 결과를 확인하기 위해 에피소드 길이를 8로 설정했습니다.

1165
00:48:42,900 --> 00:48:46,920
이 루프를 실행할 때 이 행렬은

1166
00:48:46,920 --> 00:48:48,780


1167
00:48:48,780 --> 00:48:51,900
각 작업이 수행될 가능성에 대한 작업 분포일 뿐이며

1168
00:48:51,900 --> 00:48:54,960
에이전트가 마지막 텍스트에서 끝나는 위치입니다.

1169
00:48:54,960 --> 00:48:58,020
알겠습니다.

1170
00:48:58,020 --> 00:49:00,900


1171
00:49:00,900 --> 00:49:03,839
표시할 환경이나 렌더링도 활성화해 보겠습니다.

1172
00:49:03,839 --> 00:49:06,000
모든 시간 단계에서 에이전트가 있는 우리 위치

1173
00:49:06,000 --> 00:49:08,880
이므로 처음에 에이전트는 이 위치에 있었고

1174
00:49:08,880 --> 00:49:11,400


1175
00:49:11,400 --> 00:49:14,400
여기에 대한 작업 분포가 있으므로

1176
00:49:14,400 --> 00:49:16,440
남동쪽과 서쪽이 아니므로 에이전트는

1177
00:49:16,440 --> 00:49:19,260
북쪽으로 가야 한다는 것을 알고 있습니다. 왜냐하면

1178
00:49:19,260 --> 00:49:21,720
이전 기본 설정을 보면 왜 그렇습니까?

1179
00:49:21,720 --> 00:49:23,940
음 이 상태가 이 상태보다 더 선호됩니다.

1180
00:49:23,940 --> 00:49:25,800
그렇죠. 에이전트는

1181
00:49:25,800 --> 00:49:27,720
예상

1182
00:49:27,720 --> 00:49:30,540
자유 에너지를 성공적으로 계산하고

1183
00:49:30,540 --> 00:49:33,480
이 상태로 가야 하고 이 상태에 머물지 말아야 한다고 추론했습니다.

1184
00:49:33,480 --> 00:49:35,220
그리고 사용 가능한

1185
00:49:35,220 --> 00:49:36,780
전환의 생성 모델이 있기 때문에

1186
00:49:36,780 --> 00:49:39,060
다음과 같이 추론할 수 있습니다.  그러면

1187
00:49:39,060 --> 00:49:41,640
에이전트는 북쪽으로 가고

1188
00:49:41,640 --> 00:49:42,540


1189
00:49:42,540 --> 00:49:45,540


1190
00:49:45,540 --> 00:49:47,880
이 특정 주에서

1191
00:49:47,880 --> 00:49:49,920
에이전트는 북쪽에서 동쪽으로 가야 한다고 추론하므로

1192
00:49:49,920 --> 00:49:52,800


1193
00:49:52,800 --> 00:49:53,819
동쪽에서 조치를 취할 것이고

1194
00:49:53,819 --> 00:49:56,460
여기로 갈 것입니다.  이

1195
00:49:56,460 --> 00:49:59,520
시점에서 어

1196
00:49:59,520 --> 00:50:01,200
행동 분포가

1197
00:50:01,200 --> 00:50:04,260
북쪽과 동쪽에 대해 동일하게 일어날 가능성이 있다는 점에 주목해 주세요. 왜

1198
00:50:04,260 --> 00:50:06,599
에이전트가 가까운 미래만 보고 있기 때문에 그렇습니까?

1199
00:50:06,599 --> 00:50:08,640


1200
00:50:08,640 --> 00:50:09,839


1201
00:50:09,839 --> 00:50:12,599
에이전트가 지금 여기 있는 사전 선호도로 돌아가겠습니다.

1202
00:50:12,599 --> 00:50:15,420


1203
00:50:15,420 --> 00:50:18,240
여기 있습니까? 예, 지금

1204
00:50:18,240 --> 00:50:20,700
이 특정 상태에 있습니다.

1205
00:50:20,700 --> 00:50:22,260
에이전트가

1206
00:50:22,260 --> 00:50:25,020
단 한 가지 작업의 즉각적인 결과를 고려하는 경우

1207
00:50:25,020 --> 00:50:27,900
이 두 상태는

1208
00:50:27,900 --> 00:50:30,599
다음 단계에 있는 데 동등하게 좋습니다.

1209
00:50:30,599 --> 00:50:33,240
따라서 이 두 상태 사이에는 차이가 없습니다.

1210
00:50:33,240 --> 00:50:34,680
그것은 단지 가까운 미래만을 바라보는

1211
00:50:34,680 --> 00:50:37,260
것이므로 예상되는

1212
00:50:37,260 --> 00:50:39,660
자유 에너지는 내가

1213
00:50:39,660 --> 00:50:41,460
북쪽이나 동쪽으로 가야 한다고 결론을 내릴 것이라는 것을 의미합니다.

1214
00:50:41,460 --> 00:50:43,800
내가 단 한 번만 보는지는 중요하지 않습니다.

1215
00:50:43,800 --> 00:50:47,760
앞으로 나아가세요 좋아요 그게 아이디어

1216
00:50:47,760 --> 00:50:53,040
이고 가능성이 없습니다.  여기로 가는 중이고

1217
00:50:53,040 --> 00:50:56,640
동쪽으로 행동을 취했고 이

1218
00:50:56,640 --> 00:50:57,420
음

1219
00:50:57,420 --> 00:50:59,220
상태로부터 추론을 할 때

1220
00:50:59,220 --> 00:51:01,740
이 상태가 더 낫다고 추론하고

1221
00:51:01,740 --> 00:51:03,780
기본적으로

1222
00:51:03,780 --> 00:51:06,960


1223
00:51:06,960 --> 00:51:10,740


1224
00:51:10,740 --> 00:51:12,599
이웃 상태가 덜 준비되어 있는 이 특정 상태인 이 지역 최대값 상태로 끝나게 됩니다.

1225
00:51:12,599 --> 00:51:14,940
이것은 벽이고 구조상 에이전트에게

1226
00:51:14,940 --> 00:51:16,980
금지되어 있기 때문에 거기에 갈 수 없습니다.

1227
00:51:16,980 --> 00:51:19,440
따라서 기본적으로 우선

1228
00:51:19,440 --> 00:51:21,839


1229
00:51:21,839 --> 00:51:25,619
순위가 높은 로컬 최대값만 볼 수 있는 곳에 영원히 앉아 있을 것이며

1230
00:51:25,619 --> 00:51:27,300


1231
00:51:27,300 --> 00:51:30,960


1232
00:51:30,960 --> 00:51:33,839
더 높은 계획이 있는 경우 어떤 일이 일어날 수 있는지 살펴보겠습니다.  깊이 따라서

1233
00:51:33,839 --> 00:51:37,800
계획 깊이 3으로 가면

1234
00:51:37,800 --> 00:51:39,480


1235
00:51:39,480 --> 00:51:42,240
에이전트가 실제로

1236
00:51:42,240 --> 00:51:45,599
마지막 단계에서 골드 상태에 도달하지만 여전히

1237
00:51:45,599 --> 00:51:46,980
세 번째 시점에

1238
00:51:46,980 --> 00:51:49,859


1239
00:51:49,859 --> 00:51:53,520
두 개의 확률적 작업이나 피아니스트가 없다는 의미이므로

1240
00:51:53,520 --> 00:51:56,700
여기 이 특정 상태에서 나옵니다.

1241
00:51:56,700 --> 00:51:59,880
아마도 북쪽으로 행동을 취했지만

1242
00:51:59,880 --> 00:52:01,980
동쪽으로 똑같이 행동하여

1243
00:52:01,980 --> 00:52:04,200
이 지역 최대값에 도달할 수는 없으므로

1244
00:52:04,200 --> 00:52:06,780
다시 실행해 보겠습니다. 아마도 이 지역 최대값에 도달할 것입니다.

1245
00:52:06,780 --> 00:52:10,260


1246
00:52:10,260 --> 00:52:12,300
계획 깊이가 4인 경우

1247
00:52:12,300 --> 00:52:15,119
에만 충분합니다. 어  이는

1248
00:52:15,119 --> 00:52:18,900
이 특정 그리드에 필요한 것입니다.

1249
00:52:18,900 --> 00:52:21,599
음 에이전트는

1250
00:52:21,599 --> 00:52:24,540
매 시점마다 무엇을 해야 할지 완전히 확신합니다. 어, 북쪽, 동쪽 북쪽 북쪽

1251
00:52:24,540 --> 00:52:28,140


1252
00:52:28,140 --> 00:52:31,559
동쪽 동쪽 및

1253
00:52:31,559 --> 00:52:34,500
남쪽으로 이동하여 이 특정 상태에 도달해야 한다는 것을 완전히 확신합니다.  따라서

1254
00:52:34,500 --> 00:52:36,119
시간 단계

1255
00:52:36,119 --> 00:52:39,300
음 또는 계획 깊이 n이 4인 경우에만 이

1256
00:52:39,300 --> 00:52:41,819
그리드를 성공적으로 탐색할 수 있습니다. 음 이것이 바로

1257
00:52:41,819 --> 00:52:44,599


1258
00:52:44,599 --> 00:52:47,339


1259
00:52:47,339 --> 00:52:50,160


1260
00:52:50,160 --> 00:52:51,059
여러분이 얻었기를 바라는 구현 아이디어입니다.

1261
00:52:51,059 --> 00:52:53,400
동작 정밀도에 대한 아이디어도 있으므로

1262
00:52:53,400 --> 00:52:55,319
여기서는 높은 동작

1263
00:52:55,319 --> 00:52:58,319
정밀도입니다.

1264
00:52:58,319 --> 00:53:01,319


1265
00:53:01,319 --> 00:53:03,180
낮은 행동 정밀도

1266
00:53:03,180 --> 00:53:05,460
음 1인 경우 확률에 따른 행동을 취하는 이유는

1267
00:53:05,460 --> 00:53:09,780
좋은 행동이 더 가능성이 높지만

1268
00:53:09,780 --> 00:53:12,540
그렇다고 운이 좋아서 바로 여기서 취한다는 의미는 아닙니다.

1269
00:53:12,540 --> 00:53:16,800


1270
00:53:16,800 --> 00:53:19,079
올바른 행동을 취하는 것입니다.  상태에 도달했지만

1271
00:53:19,079 --> 00:53:21,000
여기서는 확률이 가장 높지만

1272
00:53:21,000 --> 00:53:23,700
탐색 동작과 같은 것도 볼 수 있습니다.

1273
00:53:23,700 --> 00:53:27,059


1274
00:53:27,059 --> 00:53:29,520
이 작업 프로세스를 제어하면 더 많은 시도 횟수가 있으므로

1275
00:53:29,520 --> 00:53:31,859


1276
00:53:31,859 --> 00:53:33,780
에이전트가 이 특정 목표에 도달할 수 있도록 높은 값으로 설정했습니다.

1277
00:53:33,780 --> 00:53:36,180
문제지만

1278
00:53:36,180 --> 00:53:38,760
플레이할 가치가 있고 중요합니다.

1279
00:53:38,760 --> 00:53:40,500


1280
00:53:40,500 --> 00:53:42,180


1281
00:53:42,180 --> 00:53:42,720


1282
00:53:42,720 --> 00:53:45,480
그렇군요 음 예, 이 문제의

1283
00:53:45,480 --> 00:53:47,760
1 3과 4와 같은 다른 계획 음 깊이의 경우

1284
00:53:47,760 --> 00:53:49,980
이것은 충분하지 않은

1285
00:53:49,980 --> 00:53:52,740
낮은 계획 깊이에 대해 기대하는 동작입니다.

1286
00:53:52,740 --> 00:53:54,660
에이전트는

1287
00:53:54,660 --> 00:53:58,140
로컬 Maximus에서 종료됩니다.

1288
00:53:58,140 --> 00:54:00,420
예상 자유 에너지의 로컬 최소값

1289
00:54:00,420 --> 00:54:03,420
또는 튀긴 청사진의 로컬 최대값이지만

1290
00:54:03,420 --> 00:54:05,280


1291
00:54:05,280 --> 00:54:08,099
탐색하고 목표에 도달할 수 있는 충분한 계획이 있으므로

1292
00:54:08,099 --> 00:54:12,180


1293
00:54:12,180 --> 00:54:14,160


1294
00:54:14,160 --> 00:54:15,420


1295
00:54:15,420 --> 00:54:19,880


1296
00:54:19,880 --> 00:54:22,640


1297
00:54:22,640 --> 00:54:26,400
정교한 추론을 평가할 때 임계값을 갖는 것이 왜 중요한지 이 튜토리얼의 마지막 지점으로 이동합니다.

1298
00:54:26,400 --> 00:54:29,339
임계값에 따라 우리가 의미하는 것은

1299
00:54:29,339 --> 00:54:31,859
두 가지

1300
00:54:31,859 --> 00:54:34,200
수준에서 미래 가능성을 무시할 수 있다는 것입니다. 음 이 연구에서

1301
00:54:34,200 --> 00:54:36,900
가능성이 없는 행동이나 가능성이 없는

1302
00:54:36,900 --> 00:54:39,300
관찰은 무시할 수 있습니다. 하지만

1303
00:54:39,300 --> 00:54:41,300


1304
00:54:41,300 --> 00:54:44,220
모든 행동과 관찰의 결과를 고려한다면 이는

1305
00:54:44,220 --> 00:54:46,020
고려해야 할 사항을 고려해야 함을 의미합니다.

1306
00:54:46,020 --> 00:54:48,240
우선 네 가지 결과를 고려하면

1307
00:54:48,240 --> 00:54:50,040


1308
00:54:50,040 --> 00:54:52,559
다음 시간 단계의

1309
00:54:52,559 --> 00:54:55,140
다음 시간 단계에서 동작 상태의 4배를 고려해야 하며, 그 모든 것에

1310
00:54:55,140 --> 00:54:56,760
동작 수를 곱해야 하며

1311
00:54:56,760 --> 00:54:59,579
이 연구는

1312
00:54:59,579 --> 00:55:02,400
폭발할 때까지 다루기 어려워지며 이는 훨씬 더 나빠집니다.

1313
00:55:02,400 --> 00:55:04,079
고전적인 능동 추론 정책

1314
00:55:04,079 --> 00:55:07,140
공간 문제이지만

1315
00:55:07,140 --> 00:55:10,260
작은 값이라도 임계값을 정의함으로써 어 우리는

1316
00:55:10,260 --> 00:55:12,000
가능성을 무시할 것입니다.

1317
00:55:12,000 --> 00:55:15,420
그래서

1318
00:55:15,420 --> 00:55:18,540
정방향 검색 및 알고리즘에서 구현되는 곳은

1319
00:55:18,540 --> 00:55:21,900
음 우리는 여기서 특정 임계값

1320
00:55:21,900 --> 00:55:23,760
보다 큰 동작 확률만을 사용하여 동작을 고려하고 있습니다.

1321
00:55:23,760 --> 00:55:26,339


1322
00:55:26,339 --> 00:55:29,280
1x16으로 정의하겠습니다. 어

1323
00:55:29,280 --> 00:55:33,119
상위 논문에서도 1x16입니다.

1324
00:55:33,119 --> 00:55:36,240
음 행동 확률은

1325
00:55:36,240 --> 00:55:39,839
좋습니다. 그렇다면 0이면

1326
00:55:39,839 --> 00:55:42,180
이는 미래의 모든 결과를 고려하고

1327
00:55:42,180 --> 00:55:46,200
상호

1328
00:55:46,200 --> 00:55:48,540
작용이 가능하므로 무시할 수 있다는 의미입니다.  가능성이 없으며

1329
00:55:48,540 --> 00:55:52,440


1330
00:55:52,440 --> 00:55:56,040
확률이 낮은 상태도 무시하거나

1331
00:55:56,040 --> 00:55:57,780
이 특정 임계값보다 큰 확률을 갖는 상태만 고려하고

1332
00:55:57,780 --> 00:56:00,240


1333
00:56:00,240 --> 00:56:02,099
계산 복잡성을 크게 줄여

1334
00:56:02,099 --> 00:56:03,720


1335
00:56:03,720 --> 00:56:06,119


1336
00:56:06,119 --> 00:56:09,540
미래의 어 트리에 있을 가능성이 있는 조합만 고려할 수 있습니다.

1337
00:56:09,540 --> 00:56:12,900
음, 계획 범위를 더 깊이 들어가세요.

1338
00:56:12,900 --> 00:56:16,020
이것이 중요한 포인트입니다. 음

1339
00:56:16,020 --> 00:56:17,400


1340
00:56:17,400 --> 00:56:18,359


1341
00:56:18,359 --> 00:56:21,619


1342
00:56:21,619 --> 00:56:24,980
검색 임계값이 0인 경우 더 깊은 계획을 세우는 데 걸리는 시간을 비교한다면

1343
00:56:24,980 --> 00:56:28,619
음 검색 임계값이 0 0이라는 것은

1344
00:56:28,619 --> 00:56:30,780
모든 결과를 고려하고 더 깊은 결과를 고려한다는 의미입니다.  음,

1345
00:56:30,780 --> 00:56:33,300


1346
00:56:33,300 --> 00:56:35,880


1347
00:56:35,880 --> 00:56:38,640
시간이 더 많이 걸릴수록 계획을 세우고

1348
00:56:38,640 --> 00:56:42,480
첫 번째 미래나

1349
00:56:42,480 --> 00:56:44,579
즉각적인 미래만 고려하면 0.01초가 걸리

1350
00:56:44,579 --> 00:56:45,900


1351
00:56:45,900 --> 00:56:48,720
거나 미래의 세 가지 가능성을 고려하면

1352
00:56:48,720 --> 00:56:50,880
3초가 걸리고

1353
00:56:50,880 --> 00:56:53,099
4개에 대해서는 300초가 걸리고

1354
00:56:53,099 --> 00:56:54,960
알 수 있습니다.  계산 시간은 기하

1355
00:56:54,960 --> 00:56:59,579
급수적으로 증가하지만

1356
00:56:59,579 --> 00:57:02,819
매우 작은 thresh 검색 임계값이 있는 경우

1357
00:57:02,819 --> 00:57:08,280


1358
00:57:08,280 --> 00:57:11,940
음 실제 세계에서 구현하는 데 적합한 계산 시간이 있는 것입니다.

1359
00:57:11,940 --> 00:57:15,420
따라서 여기서 n이

1360
00:57:15,420 --> 00:57:17,880
4인 경우 이는 미래로의 4단계 단계입니다.

1361
00:57:17,880 --> 00:57:20,640
0.1초면

1362
00:57:20,640 --> 00:57:22,440
괜찮습니다. 여전히

1363
00:57:22,440 --> 00:57:25,440
이 복잡한 시뮬레이션을 할 수는 있지만

1364
00:57:25,440 --> 00:57:28,079
이것이

1365
00:57:28,079 --> 00:57:29,400


1366
00:57:29,400 --> 00:57:31,020
음

1367
00:57:31,020 --> 00:57:34,020


1368
00:57:34,020 --> 00:57:35,700
이전 선호도와

1369
00:57:35,700 --> 00:57:37,980
실제 환경의 특성에 따라 계산 복잡도가 얼마나 적은지 말할 수는 없습니다. 하지만 이 검색은

1370
00:57:37,980 --> 00:57:40,619
임계값은 실제로 실제 생활에서 작동하며

1371
00:57:40,619 --> 00:57:43,140
시뮬레이션에서

1372
00:57:43,140 --> 00:57:46,559
n이 4인 경우

1373
00:57:46,559 --> 00:57:50,040
시뮬레이션에서 0.3초밖에 걸리지 않았지만

1374
00:57:50,040 --> 00:57:53,220
검색 임계값을 0으로 설정하면

1375
00:57:53,220 --> 00:57:55,559


1376
00:57:55,559 --> 00:57:58,880
전체 단계 계획을 수행하는 데 이미 300초가 소요되었습니다.  그리고 내가

1377
00:57:58,880 --> 00:58:01,800
계획 깊이를 5로 설정하면

1378
00:58:01,800 --> 00:58:04,200
기본적으로 Run Forever가 될 것입니다. 아마도 다시 나는 시민

1379
00:58:04,200 --> 00:58:06,960
활동을 할 수 없게 될 것입니다.

1380
00:58:06,960 --> 00:58:10,619
그래서 그것이 검색 임계값의 아이디어입니다. 음

1381
00:58:10,619 --> 00:58:13,440
실제로는 그게 다입니다.

1382
00:58:13,440 --> 00:58:16,260
음

1383
00:58:16,260 --> 00:58:18,300
에이전트 클래스,

1384
00:58:18,300 --> 00:58:20,520
환경 클래스 및  특정

1385
00:58:20,520 --> 00:58:24,420
데모 그리고 네, 누군가가 듣고 있다면 질문하기에 좋은 시간이 될 것입니다. 어

1386
00:58:24,420 --> 00:58:27,180


1387
00:58:27,180 --> 00:58:29,760
그리고 저는 사람들이 음 이

1388
00:58:29,760 --> 00:58:33,359
코드를 가지고 놀고 음

1389
00:58:33,359 --> 00:58:35,819
튜토리얼을 보고

1390
00:58:35,819 --> 00:58:38,280
이것을 구현하고

1391
00:58:38,280 --> 00:58:40,260
이와 같은 생성 모델을 구축할 수 있기를 바랍니다.

1392
00:58:40,260 --> 00:58:41,640


1393
00:58:41,640 --> 00:58:43,920


1394
00:58:43,920 --> 00:58:45,359
이 그리드 작업을 위한 생성 모델을 구축

1395
00:58:45,359 --> 00:58:47,640
하고 에이전트가 어떻게

1396
00:58:47,640 --> 00:58:51,839
의미 있는 조치를 취할 수 있는지 확인하세요. 여기서는

1397
00:58:51,839 --> 00:58:54,299


1398
00:58:54,299 --> 00:58:57,000
B 매트릭스와 매트릭스 등에서 환경의 실제 구조를 제공했지만

1399
00:58:57,000 --> 00:59:00,299


1400
00:59:00,299 --> 00:59:03,480
학습을 통해 놀 수도 있습니다.

1401
00:59:03,480 --> 00:59:04,740


1402
00:59:04,740 --> 00:59:09,380
에이전트 도트 단계를 정의하는 동안 학습이 true와 같다는 플래그를 추가할 수 있고, 정보가

1403
00:59:09,380 --> 00:59:14,420


1404
00:59:14,420 --> 00:59:18,059
없는 ab로 시작하는 경우

1405
00:59:18,059 --> 00:59:20,520


1406
00:59:20,520 --> 00:59:22,380
여기에서 에이전트가 해당 환경을 학습하는 방법을

1407
00:59:22,380 --> 00:59:24,420
실험할 수 있다는 점에서  처음에는 B 매트릭스를

1408
00:59:24,420 --> 00:59:26,099


1409
00:59:26,099 --> 00:59:28,559
10번 시도한 후 B 매트릭스를 보고

1410
00:59:28,559 --> 00:59:31,140
여기서 학습이 어떻게 진행되고 있는지 확인할 수 있습니다.

1411
00:59:31,140 --> 00:59:33,059
에이전트가 구조를 알고

1412
00:59:33,059 --> 00:59:35,760
있고 많이 배우지 않기 때문에 중요하지 않지만

1413
00:59:35,760 --> 00:59:37,260


1414
00:59:37,260 --> 00:59:39,660
알려지지 않은 구조에서 시작하는 경우  그러면

1415
00:59:39,660 --> 00:59:42,180
구현될 학습 범위도 있고

1416
00:59:42,180 --> 00:59:44,640
이미 구현되어 있습니다.

1417
00:59:44,640 --> 00:59:47,700


1418
00:59:47,700 --> 00:59:50,520
어 기존 시간 DP 기능을 사용하여 A와 B를 학습

1419
00:59:50,520 --> 00:59:51,960
하고 이미 단계 함수의 일부이므로

1420
00:59:51,960 --> 00:59:52,980


1421
00:59:52,980 --> 00:59:54,780


1422
00:59:54,780 --> 00:59:57,000
단계 함수가 명확했으면 좋겠습니다.

1423
00:59:57,000 --> 00:59:58,500
음 이것이 유일한 것입니다.

1424
00:59:58,500 --> 00:59:59,819


1425
00:59:59,819 --> 01:00:02,040
정교한 추론을 구현하려고 하는지 알아야 하며

1426
01:00:02,040 --> 01:00:03,839
행렬을

1427
01:00:03,839 --> 01:00:07,380
조사하고 살펴보고 싶다면 행렬의 이름만 알아야 합니다.

1428
01:00:07,380 --> 01:00:10,880
세션이 도움이 되었기를 바랍니다. 따라서

1429
01:00:10,880 --> 01:00:13,460


1430
01:00:13,460 --> 01:00:16,140
5mdp를 유지 관리하는 공동 작업자와 Corner 및

1431
01:00:16,140 --> 01:00:18,540
Brandon에게 감사드립니다.  제가 속해 있던 주요 DP Fellowship을 운영하는 사람이 바로

1432
01:00:18,540 --> 01:00:21,720
제가 IMDb에서

1433
01:00:21,720 --> 01:00:23,579
소스 티켓 추론을 구현하는 작업을 했던 곳입니다.

1434
01:00:23,579 --> 01:00:26,599
이는

1435
01:00:26,599 --> 01:00:30,299
곧 원본 Pi mdp 모듈의 일부가 될 것입니다.

1436
01:00:30,299 --> 01:00:32,760
사람들이 이 모듈을 사용하여

1437
01:00:32,760 --> 01:00:34,500
관련 추론

1438
01:00:34,500 --> 01:00:37,680
실험을 시뮬레이션하고  이것은 기본적으로

1439
01:00:37,680 --> 01:00:39,420


1440
01:00:39,420 --> 01:00:41,579
코드에 대한 질문이나 설명을 논의하기에 좋은 시간이거나

1441
01:00:41,579 --> 01:00:43,559
휴식을 취하기에 좋은 시간일 수도 있습니다.

1442
01:00:43,559 --> 01:00:46,280
예, 정말

1443
01:00:47,880 --> 01:00:50,640
훌륭했습니다. 감사합니다.

1444
01:00:50,640 --> 01:00:52,799
몇 가지 다른 질문이 있으며 다음

1445
01:00:52,799 --> 01:00:55,500


1446
01:00:55,500 --> 01:00:58,380
중 몇 가지를 읽어 보겠습니다.  라이브 채팅 그러니까 먼저

1447
01:00:58,380 --> 01:01:00,660
라이브 채팅으로 가서 음

1448
01:01:00,660 --> 01:01:02,579
그거 물어보고 다른

1449
01:01:02,579 --> 01:01:04,980
질문 좀 할게요. Dave가 재귀 두뇌의

1450
01:01:04,980 --> 01:01:06,960
신경 구현에 대해 어떻게 생각하는지 묻습니다.

1451
01:01:06,960 --> 01:01:09,839


1452
01:01:09,839 --> 01:01:11,579
컴퓨터 하드웨어

1453
01:01:11,579 --> 01:01:13,559
스타일 재귀를 더 깊게 구현하지 않는 것 같습니다.  과도하게

1454
01:01:13,559 --> 01:01:15,660


1455
01:01:15,660 --> 01:01:18,299
학습된 작업을 제외하고 1의 기본 깊이는 시간을 탐색하면서

1456
01:01:18,299 --> 01:01:20,220


1457
01:01:20,220 --> 01:01:22,619
온화하게

1458
01:01:22,619 --> 01:01:24,780
깊은 상태 공간을 탐색할 목적으로 재귀에 대해 묻는 것으로 제한할 수 있습니다.

1459
01:01:24,780 --> 01:01:27,119
그러면

1460
01:01:27,119 --> 01:01:30,359
이 정말 아름답고 우아하며

1461
01:01:30,359 --> 01:01:32,579
계산적으로 효율적인

1462
01:01:32,579 --> 01:01:36,839
전체 깊이 연구를 어떻게 조화시킬 수 있습니까?

1463
01:01:36,839 --> 01:01:41,099
다중 규모 계획의 생물학적 기반으로

1464
01:01:41,099 --> 01:01:42,540
예 음,

1465
01:01:42,540 --> 01:01:43,260


1466
01:01:43,260 --> 01:01:45,660
저는 신경 계산 전문가는 아니지만 이에 대한

1467
01:01:45,660 --> 01:01:48,420
대답은

1468
01:01:48,420 --> 01:01:49,559


1469
01:01:49,559 --> 01:01:50,460
음

1470
01:01:50,460 --> 01:01:52,319
기본적으로

1471
01:01:52,319 --> 01:01:55,619
한 번에 단 하나의 경쟁만 하고 있고

1472
01:01:55,619 --> 01:01:58,140
필요한 것은 다음과 같습니다.

1473
01:01:58,140 --> 01:02:01,740
당신의 믿음을 저장하고 그 믿음을 사용하여

1474
01:02:01,740 --> 01:02:03,540
같은

1475
01:02:03,540 --> 01:02:06,059
계산을 다시 수행할 메모리가 있습니다.

1476
01:02:06,059 --> 01:02:08,940
음 우리는 신경에 ​​대해 말하는 것이 아닙니다.

1477
01:02:08,940 --> 01:02:11,160
이 하드코어 재귀

1478
01:02:11,160 --> 01:02:13,380
구현은 우리가 한 번에 로컬 계산만 수행한다는 것을 의미합니다.

1479
01:02:13,380 --> 01:02:15,780


1480
01:02:15,780 --> 01:02:17,700
생성 모델

1481
01:02:17,700 --> 01:02:21,660
과 우리 그리고 우리는 기억을 가지고 있기 때문에

1482
01:02:21,660 --> 01:02:23,819
음 이것은 할 수 있고 그리고 어

1483
01:02:23,819 --> 01:02:27,599
왜 개별 뉴런이 그것을 할 수 없더라도

1484
01:02:27,599 --> 01:02:29,520


1485
01:02:29,520 --> 01:02:32,099
뇌가 그것을 할 수 없는지 모르겠습니다. 주 뇌는 기억을 가지고 있습니다.

1486
01:02:32,099 --> 01:02:34,319
뇌는 가지고 있습니다  기억을 저장하는 능력

1487
01:02:34,319 --> 01:02:36,420
과 꿈을 꾸는 능력

1488
01:02:36,420 --> 01:02:39,240
시뮬레이션하는 능력 어 행동의 결과를 알고 있고

1489
01:02:39,240 --> 01:02:41,819
매일 이 일을 합니다.

1490
01:02:41,819 --> 01:02:43,500


1491
01:02:43,500 --> 01:02:46,140
음 여러분은 미래를 계획하고 무엇을

1492
01:02:46,140 --> 01:02:48,960
올바르게 해야 할지 결정합니다. 그래서 단일 뉴런 수준에서

1493
01:02:48,960 --> 01:02:50,460
저는

1494
01:02:50,460 --> 01:02:52,559
그 질문에 어떻게 대답해야 할지 잘 모르겠지만

1495
01:02:52,559 --> 01:02:54,359
왜 뇌가 유기체로서 그렇게 할 수 없는지 잘 모르겠습니다. 음

1496
01:02:54,359 --> 01:02:57,859


1497
01:02:58,740 --> 01:03:00,839


1498
01:03:00,839 --> 01:03:03,480
코드는 알겠습니다. 몇 가지

1499
01:03:03,480 --> 01:03:05,700
질문이 있는 것 같습니다. 미로로 돌아가서

1500
01:03:05,700 --> 01:03:08,058


1501
01:03:10,740 --> 01:03:13,020
물론 다른 사람이

1502
01:03:13,020 --> 01:03:16,920
라이브 채팅에 질문이 있으면 그냥 가세요.

1503
01:03:16,920 --> 01:03:17,640
음

1504
01:03:17,640 --> 01:03:21,839
그래서 미로에서 어떻게 어

1505
01:03:21,839 --> 01:03:24,900
가능한 동작이

1506
01:03:24,900 --> 01:03:28,200
어떻게 반영됩니까? 어떤 단계가

1507
01:03:28,200 --> 01:03:31,380
업데이트되었는지, 예를 들어

1508
01:03:31,380 --> 01:03:33,480
처음에 할 수 있다는 것을 알고 있는 것은 무엇입니까?  위로 올라가면

1509
01:03:33,480 --> 01:03:36,000
오른쪽이나 아래로만 갈 수 있습니다.

1510
01:03:36,000 --> 01:03:38,160


1511
01:03:38,160 --> 01:03:40,680


1512
01:03:40,680 --> 01:03:43,260
어포던스의 관계형 측면과 같은 종류의 업데이트가 반영된 위치는 무엇인지,

1513
01:03:43,260 --> 01:03:45,059


1514
01:03:45,059 --> 01:03:47,760
그리고 깊은 트리 검색에서 어떻게 평가합니까?

1515
01:03:47,760 --> 01:03:49,680


1516
01:03:49,680 --> 01:03:53,819


1517
01:03:53,819 --> 01:03:56,460
미래에 어떤 일이 일어날 수 있는지, 일어날 수 없는지 알아야 합니까?

1518
01:03:56,460 --> 01:03:58,640


1519
01:03:59,819 --> 01:04:01,140
음 그래서 제가 질문을 올바르게 이해한다면

1520
01:04:01,140 --> 01:04:02,339


1521
01:04:02,339 --> 01:04:03,000
음

1522
01:04:03,000 --> 01:04:05,099
중요한

1523
01:04:05,099 --> 01:04:06,420
점이 있습니다. 생성

1524
01:04:06,420 --> 01:04:08,880
과정과 생성 모델 사이에는 중요한 차이점이 있습니다.

1525
01:04:08,880 --> 01:04:11,579
그래서 큰 세상에서는

1526
01:04:11,579 --> 01:04:15,119
음  생성 프로세스입니다.

1527
01:04:15,119 --> 01:04:17,160
음 우리는

1528
01:04:17,160 --> 01:04:19,619
이 전환 역학이 있는 곳에서 모든 것을 수동으로 구현했습니다.

1529
01:04:19,619 --> 01:04:21,540


1530
01:04:21,540 --> 01:04:22,680
음

1531
01:04:22,680 --> 01:04:25,380


1532
01:04:25,380 --> 01:04:27,660
상태에서 조치를 취하면 어떤 일이 일어날지 이미 알고 있으므로

1533
01:04:27,660 --> 01:04:30,599
작동 방법을 아는 환경과 같습니다. 음

1534
01:04:30,599 --> 01:04:32,700
현실과 같습니다.

1535
01:04:32,700 --> 01:04:34,380
행동의 결과가 있고

1536
01:04:34,380 --> 01:04:37,619
이미 존재하지만 이 정보는

1537
01:04:37,619 --> 01:04:40,680
에이전트가 생성 모델의 일부가 되도록 사용할 수 있으며

1538
01:04:40,680 --> 01:04:43,440


1539
01:04:43,440 --> 01:04:45,240
생성 모델에서 기본적으로 수행하는 작업은 발생할

1540
01:04:45,240 --> 01:04:48,119


1541
01:04:48,119 --> 01:04:51,119
수 있는 상황을 시뮬레이션하기 위해 제공되거나 학습되는 전환 역학을 사용하는 것입니다.

1542
01:04:51,119 --> 01:04:54,299
미래는 괜찮습니다. 일단

1543
01:04:54,299 --> 01:04:56,460
그 전환 역학이 있으면

1544
01:04:56,460 --> 01:04:58,200
음,

1545
01:04:58,200 --> 01:05:00,359
죄송합니다.

1546
01:05:00,359 --> 01:05:02,700
해당 연구로 가면

1547
01:05:02,700 --> 01:05:05,160
본질적으로 하는 일은

1548
01:05:05,160 --> 01:05:08,640
특정 상태와

1549
01:05:08,640 --> 01:05:11,700
행동 유전자에 대해 사후를 평가하는 것입니다. 그래서 제 생성

1550
01:05:11,700 --> 01:05:14,520
모델에서 저는 다음을 압니다.  이 상태에서 시작

1551
01:05:14,520 --> 01:05:16,799
하고 이 작업을 수행하면

1552
01:05:16,799 --> 01:05:19,680
이 게시물 영역으로 이동하여 모든 결과를 고려합니다.

1553
01:05:19,680 --> 01:05:22,319


1554
01:05:22,319 --> 01:05:24,540
생성 모델에서

1555
01:05:24,540 --> 01:05:27,119
동쪽으로 가면 거기로 가지 않을 가능성이 높으므로

1556
01:05:27,119 --> 01:05:29,220
기본적으로

1557
01:05:29,220 --> 01:05:31,920
자동으로 수행됩니다.  예상 자유 에너지에 반영됩니다.

1558
01:05:31,920 --> 01:05:33,780


1559
01:05:33,780 --> 01:05:34,319
음

1560
01:05:34,319 --> 01:05:37,140
그래서 질문에 대한 답이 되었으면 좋겠습니다.

1561
01:05:37,140 --> 01:05:39,980


1562
01:05:40,020 --> 01:05:42,000
음 제가 작업 정밀도를 높게 설정

1563
01:05:42,000 --> 01:05:42,960


1564
01:05:42,960 --> 01:05:44,400
하고

1565
01:05:44,400 --> 01:05:48,000


1566
01:05:48,000 --> 01:05:50,599
환경을 활성화하면

1567
01:05:50,960 --> 01:05:53,579
처음에 저는 이 특정 상태에 있고

1568
01:05:53,579 --> 01:05:56,700


1569
01:05:56,700 --> 01:05:58,559
예상 자유 에너지와 관련하여 저는 무엇을 해야 할까요?  내가 하고 있는 일은

1570
01:05:58,559 --> 01:06:00,960
생성 모델을 사용하여

1571
01:06:00,960 --> 01:06:03,599
내가 네 가지 행동을 취하면 어떤 일이 일어날지 예측하는 것입니다.

1572
01:06:03,599 --> 01:06:06,180
그리고 내 예측에 따르면 내가

1573
01:06:06,180 --> 01:06:08,460
북쪽으로 가면 여기로 갈 것이고,

1574
01:06:08,460 --> 01:06:10,740
다른 모든 행동을 하면 여기

1575
01:06:10,740 --> 01:06:12,839
에 머무를 것입니다.  사전 선호 북쪽이

1576
01:06:12,839 --> 01:06:15,480
더 선호됩니다.

1577
01:06:15,480 --> 01:06:16,680


1578
01:06:16,680 --> 01:06:19,619
제가 취해야 할 어 액션뿐만 아니라 이것이

1579
01:06:19,619 --> 01:06:20,640
아이디어라고 추론할 수 있습니다.

1580
01:06:20,640 --> 01:06:22,920
여기서 그리드 구조가 에이전트에 제공되고

1581
01:06:22,920 --> 01:06:24,240
약간

1582
01:06:24,240 --> 01:06:26,039
혼란스러울 수도 있지만 에이전트는 스크립트 구조를 학습할 수도 있으며

1583
01:06:26,039 --> 01:06:27,780
이것이

1584
01:06:27,780 --> 01:06:30,059
작동한다면 일단 에이전트로서 그리드 구조를 알게 되면

1585
01:06:30,059 --> 01:06:32,339
미래를 시뮬레이션

1586
01:06:32,339 --> 01:06:34,920
하고 행동의 결과를 고려할 수 있습니다.

1587
01:06:34,920 --> 01:06:36,000


1588
01:06:36,000 --> 01:06:39,000
그래서 지금 일어나고 있는 일이고 일단 내가

1589
01:06:39,000 --> 01:06:40,319
그 상태에 있으면

1590
01:06:40,319 --> 01:06:42,780
네 가지 행동의 결과를 모두 고려하고

1591
01:06:42,780 --> 01:06:44,640
추론할 것입니다.  알았어

1592
01:06:44,640 --> 01:06:46,380
음 동쪽으로 가는 것이 더 낫습니다. 그러면

1593
01:06:46,380 --> 01:06:48,480
이 상태로 이동하게 되므로

1594
01:06:48,480 --> 01:06:50,460
항상 차이가 있습니다. 또는

1595
01:06:50,460 --> 01:06:52,319


1596
01:06:52,319 --> 01:06:54,059
생성 모델과 생성 프로세스가 얼마나

1597
01:06:54,059 --> 01:06:55,619
서로 다른지

1598
01:06:55,619 --> 01:06:58,559
그리고 에이전트가 아는 것이 현실이 아닐 수도 있고

1599
01:06:58,559 --> 01:07:00,240
현실이 아닐 수도 있다는 점을 명심해야 합니다.  현실은

1600
01:07:00,240 --> 01:07:03,660
무엇을 주느냐에 따라 다르죠

1601
01:07:03,660 --> 01:07:05,579
음

1602
01:07:05,579 --> 01:07:08,099
멋지네요.

1603
01:07:08,099 --> 01:07:10,740


1604
01:07:10,740 --> 01:07:13,380


1605
01:07:13,380 --> 01:07:15,059


1606
01:07:15,059 --> 01:07:16,920
생성 모델링을 수행하고 싶은 새로운 상황을 만들려고 한다면

1607
01:07:16,920 --> 01:07:20,400
기존에

1608
01:07:20,400 --> 01:07:23,280
작동하는 Pi mdp 노트북에서 시작하여

1609
01:07:23,280 --> 01:07:26,220
상태 공간을 수정하기 시작하는 경향이 있나요? 아니면 그림을 그리나요?

1610
01:07:26,220 --> 01:07:28,380


1611
01:07:28,380 --> 01:07:30,000


1612
01:07:30,000 --> 01:07:32,819
여기에 표시된 것을 복제하는 것 외에 어떻게 다른 사람을 추천하겠습니까?

1613
01:07:32,819 --> 01:07:34,079


1614
01:07:34,079 --> 01:07:37,079
정확히 미로가 아닌 것에 관심이 있다고 가정해 보겠습니다.

1615
01:07:37,079 --> 01:07:42,660
우리가 어떻게

1616
01:07:42,660 --> 01:07:44,880
진행해야 하는지 알아보려면 어떻게 해야 할까요?

1617
01:07:44,880 --> 01:07:46,140


1618
01:07:46,140 --> 01:07:49,260
좋은 질문입니다.

1619
01:07:49,260 --> 01:07:52,859
새로운 환경을 시뮬레이션하려는 경우

1620
01:07:52,859 --> 01:07:55,680


1621
01:07:55,680 --> 01:07:57,720


1622
01:07:57,720 --> 01:07:59,280
에이전트에 대한 생성 모델을 정의하는 작업이 매우 어렵습니다.

1623
01:07:59,280 --> 01:08:01,260
음 에이전트가 학습할 수 있는 다양한 부분 생성 모델을 정의할 수

1624
01:08:01,260 --> 01:08:02,819


1625
01:08:02,819 --> 01:08:05,039
있지만 구조를 정의해야 합니다.

1626
01:08:05,039 --> 01:08:06,980
구조가 있어야 하며

1627
01:08:06,980 --> 01:08:10,140
구조를 사용해야만 에이전트가

1628
01:08:10,140 --> 01:08:13,260
생성 모델을 학습할 수 있으므로 여기서

1629
01:08:13,260 --> 01:08:15,780
음 이 코드 셀을 사용하여 그리드의

1630
01:08:15,780 --> 01:08:17,880
구조를 정의하는 방법을 이해할 수 있습니다.

1631
01:08:17,880 --> 01:08:19,080


1632
01:08:19,080 --> 01:08:21,719
알았으니 에이전트의 구조를 정의하겠습니다.  이를

1633
01:08:21,719 --> 01:08:24,060
활용하려면

1634
01:08:24,060 --> 01:08:26,460
25개의 유효한 상태가

1635
01:08:26,460 --> 01:08:29,339
있고 4개의 사용 가능한 작업이 있으며

1636
01:08:29,339 --> 01:08:31,920
이는 시간 DB에서 상태 공간을 정의하는 표준 방법

1637
01:08:31,920 --> 01:08:33,000


1638
01:08:33,000 --> 01:08:36,540
이며 에이전트에 대한

1639
01:08:36,540 --> 01:08:40,020
중앙 매개변수 a b c 및 d도 정의해야 합니다.

1640
01:08:40,020 --> 01:08:42,779
자극이므로 여기서는

1641
01:08:42,779 --> 01:08:43,859


1642
01:08:43,859 --> 01:08:46,380
상태 공간과 관찰 공간을 사용하여 음 a를 정의하고

1643
01:08:46,380 --> 01:08:49,560
있지만

1644
01:08:49,560 --> 01:08:52,439
이를 제공하거나

1645
01:08:52,439 --> 01:08:55,198
항등원임을 알려주는 이 단계는 모델링에서 내 결정 선택입니다.

1646
01:08:55,198 --> 01:08:58,259


1647
01:08:58,259 --> 01:09:01,620
시뮬레이션에서는 이 작업을 수행할 필요가 없습니다.  에이전트는

1648
01:09:01,620 --> 01:09:04,920
임의의 행렬에서 학습하거나

1649
01:09:04,920 --> 01:09:06,420
임의의 이미지 행렬에서 시작할 때

1650
01:09:06,420 --> 01:09:07,198


1651
01:09:07,198 --> 01:09:10,679
유사하게 이 B 행렬에 대해 이

1652
01:09:10,679 --> 01:09:12,060
구조가

1653
01:09:12,060 --> 01:09:15,540
정의되고

1654
01:09:15,540 --> 01:09:17,040
임의의 B 행렬을 제공할 수 있는 이와 같은 함수가 있지만

1655
01:09:17,040 --> 01:09:19,080
이는 모델링 선택입니다.

1656
01:09:19,080 --> 01:09:21,600
그리드

1657
01:09:21,600 --> 01:09:22,979
구조를 제공하거나 그리드 구조를 제공하지 않으려면

1658
01:09:22,979 --> 01:09:25,259
임의의 B 매트릭스에서 시작할 수 있습니다.

1659
01:09:25,259 --> 01:09:27,420
에이전트가

1660
01:09:27,420 --> 01:09:29,759
학습한 빔을

1661
01:09:29,759 --> 01:09:31,799
데모 목적으로 학습하고 보도록 할 수 있습니다. 저는

1662
01:09:31,799 --> 01:09:33,660
활성화할 수 있는 가장 큰 구조를 제공했습니다.

1663
01:09:33,660 --> 01:09:36,540
조치를 취해야 하지만 필수

1664
01:09:36,540 --> 01:09:38,880
사항은 아니므로 무엇을 해야 할지 알 수 있다는 점에서 이 노트북은 유용하지만

1665
01:09:38,880 --> 01:09:40,679


1666
01:09:40,679 --> 01:09:42,299


1667
01:09:42,299 --> 01:09:46,198
필수가 아닌 단계를 수행해야 합니다. 따라서

1668
01:09:46,198 --> 01:09:49,140
이 상태에 대해 우선 순위를 두는 경우

1669
01:09:49,140 --> 01:09:51,299
최대값이 되면

1670
01:09:51,299 --> 01:09:53,520
에이전트가 시도하고 바로 거기로 이동하는 동작을 볼 수 있으므로

1671
01:09:53,520 --> 01:09:55,320


1672
01:09:55,320 --> 01:09:58,860
음 이 사전 선호도는

1673
01:09:58,860 --> 01:10:00,660
이것이 목표 상태라는 것과 함께 정의되지만

1674
01:10:00,660 --> 01:10:03,060
이것은 콜드 상태가 아닐 수도 있고

1675
01:10:03,060 --> 01:10:05,040
다른 작업에서 사전

1676
01:10:05,040 --> 01:10:06,780
선호도의 의미는 다음과 같습니다.  환경에 따라 다릅니다.

1677
01:10:06,780 --> 01:10:08,760


1678
01:10:08,760 --> 01:10:11,100
음 맞습니다. 그것도 있고

1679
01:10:11,100 --> 01:10:13,199
이전에도 있으므로 생성 모델을 정의하고 나면

1680
01:10:13,199 --> 01:10:15,900


1681
01:10:15,900 --> 01:10:18,840
실행할 수 없습니다. 그러면 모든 것이

1682
01:10:18,840 --> 01:10:21,540
일종의 자동화됩니다. 에이전트는

1683
01:10:21,540 --> 01:10:22,260
음

1684
01:10:22,260 --> 01:10:26,699
에이전트 점만 사용해야 합니다.  단계에서는

1685
01:10:26,699 --> 01:10:28,860


1686
01:10:28,860 --> 01:10:31,080
에이전트가 조치를 취하는 방법을 알고 있는 환경에서 관찰을 제공하고

1687
01:10:31,080 --> 01:10:33,600


1688
01:10:33,600 --> 01:10:36,000
에이전트 내부에서 발생하는 모든 일은 실제로 걱정할 필요가 없습니다.

1689
01:10:36,000 --> 01:10:37,500
음 예,

1690
01:10:37,500 --> 01:10:39,900
따라서 이 구조는 귀하가 수행하는 특정 작업에 유용할 것이라고 확신합니다.

1691
01:10:39,900 --> 01:10:42,420


1692
01:10:42,420 --> 01:10:47,300
네 모델링을 시도하는 중입니다.

1693
01:10:47,460 --> 01:10:49,760


1694
01:10:51,540 --> 01:10:54,659
흠 네 매우 흥미롭습니다. 그리고

1695
01:10:54,659 --> 01:10:57,900


1696
01:10:57,900 --> 01:10:59,580


1697
01:10:59,580 --> 01:11:01,560


1698
01:11:01,560 --> 01:11:03,780
누군가가 미로에서

1699
01:11:03,780 --> 01:11:06,360
다른 종류의 심층 정책

1700
01:11:06,360 --> 01:11:09,360
에이전트를 사용하려는 경우와 같이 적극적인 추론 외부에서 이것이 추구되는 방식과 이를 어떻게 대조하거나 유사점이나 차이점을 지적하시겠습니까?  예

1701
01:11:09,360 --> 01:11:11,340
음 프로세스의 어떤 부분이

1702
01:11:11,340 --> 01:11:12,600
익숙할 것이며

1703
01:11:12,600 --> 01:11:15,480
어떤 부분이

1704
01:11:15,480 --> 01:11:17,340
예상하지 못한 많은 작업과 같거나

1705
01:11:17,340 --> 01:11:18,780
많은 작업이었던 부분을 건너뛰는 것과 같을 것입니다.

1706
01:11:18,780 --> 01:11:20,040
그렇지 않으면 예

1707
01:11:20,040 --> 01:11:21,780


1708
01:11:21,780 --> 01:11:24,360
음 그래서 일반적인 구조는

1709
01:11:24,360 --> 01:11:26,640
일을 하는 사람에게 매우 친숙합니다.

1710
01:11:26,640 --> 01:11:30,780
강화 학습에서 이와 같이

1711
01:11:30,780 --> 01:11:33,179
음 에이전트 도트 단계

1712
01:11:33,179 --> 01:11:35,699
이고 환경 도트 단계라는 생각은 이것이

1713
01:11:35,699 --> 01:11:38,340


1714
01:11:38,340 --> 01:11:41,280
환경을 작성하는 표준 개방형 AI Jim 방식이고

1715
01:11:41,280 --> 01:11:43,800
에이전트를 작성하는 표준 개방형 AI 방식입니다.

1716
01:11:43,800 --> 01:11:46,380
대기열 학습이 있다면  어

1717
01:11:46,380 --> 01:11:48,780
동일한 작업을 수행하는 에이전트가

1718
01:11:48,780 --> 01:11:51,480


1719
01:11:51,480 --> 01:11:54,600
Q 매트릭스를 정의해야 하는 방식은 무거운 작업입니다.

1720
01:11:54,600 --> 01:11:58,320
이는 단지 상태 작업 매핑일 뿐이며

1721
01:11:58,320 --> 01:12:00,719
능동 추론의 그것과 달리

1722
01:12:00,719 --> 01:12:02,280


1723
01:12:02,280 --> 01:12:04,440
원하는 생성 모델을 생각해내야 합니다.  활성

1724
01:12:04,440 --> 01:12:06,360
추론에서 생성 모델이

1725
01:12:06,360 --> 01:12:08,520
핵심인 것은 바로

1726
01:12:08,520 --> 01:12:10,760
생성 모델이 없으면

1727
01:12:10,760 --> 01:12:13,739
활성 영향에서 목적 있는 행동의 의미가 없으므로

1728
01:12:13,739 --> 01:12:17,460


1729
01:12:17,460 --> 01:12:20,159


1730
01:12:20,159 --> 01:12:21,780
강화 학습과 같은 분야에서 온 사람에게 유일하게 익숙하지 않은 부분은

1731
01:12:21,780 --> 01:12:23,760
생성 모델의 구조이지만

1732
01:12:23,760 --> 01:12:25,320


1733
01:12:25,320 --> 01:12:29,100
DP 구조가 지배적인 형태인 곳에 익숙해지는 것 외에는 방법이 없습니다.

1734
01:12:29,100 --> 01:12:31,020
그러나 심층 능동 추론을 수행하는 경우 이

1735
01:12:31,020 --> 01:12:33,659
모든 것은

1736
01:12:33,659 --> 01:12:36,300
신경망이 될 것이며 Palm DPS도

1737
01:12:36,300 --> 01:12:38,400
활성화되지 않습니다.  인쇄

1738
01:12:38,400 --> 01:12:40,800
음 일이 맞습니다. 산업

1739
01:12:40,800 --> 01:12:43,380
공학적인 일입니다. 어 그래서 DPS는 컴퓨터 과학 배경을 가진

1740
01:12:43,380 --> 01:12:45,000
사람들에게도 친숙할 것입니다. 단지

1741
01:12:45,000 --> 01:12:46,020


1742
01:12:46,020 --> 01:12:49,739


1743
01:12:49,739 --> 01:12:52,140
에이전트에서 실제로 일어나는 일은

1744
01:12:52,140 --> 01:12:54,179
우리가

1745
01:12:54,179 --> 01:12:55,980
자유 에너지와 변형을 기대했던 능동 추론 부분이라는 생각뿐입니다.

1746
01:12:55,980 --> 01:12:57,960
자유 에너지에 대해 배우고 싶다면

1747
01:12:57,960 --> 01:13:00,540
에이전트에 가서

1748
01:13:00,540 --> 01:13:03,060
그것이 어떻게 작동하는지 확인해야 합니다.

1749
01:13:03,060 --> 01:13:04,620
행렬을 수치적으로 보고 무슨 일이

1750
01:13:04,620 --> 01:13:07,440
일어나고 있는지 확인하지만 저는 여러분이 시작하고 싶은 수준에 있지 않습니다.

1751
01:13:07,440 --> 01:13:09,239


1752
01:13:09,239 --> 01:13:12,120
어떤 문제가 있는지 보세요.

1753
01:13:12,120 --> 01:13:14,179
음,

1754
01:13:15,440 --> 01:13:18,600
그리고 openai 체육관 환경 에이전트

1755
01:13:18,600 --> 01:13:21,199
환경 루프입니다. 이 모든 것은

1756
01:13:21,199 --> 01:13:23,219
컴퓨터 과학에서 매우 깊이 논의되어

1757
01:13:23,219 --> 01:13:26,239


1758
01:13:27,300 --> 01:13:30,300
멋지지 않습니다. 음, 음,

1759
01:13:30,780 --> 01:13:34,219
다른 음

1760
01:13:34,219 --> 01:13:37,140
모티프나 인지 현상이 무엇인지,

1761
01:13:37,140 --> 01:13:40,260
아니면 pi mdp

1762
01:13:40,260 --> 01:13:44,219
개발 궤적을 어떻게 보시나요?  정교한 추론이 적용된 후에도 계속됩니다.

1763
01:13:44,219 --> 01:13:46,260


1764
01:13:46,260 --> 01:13:47,520


1765
01:13:47,520 --> 01:13:49,140
예 음,

1766
01:13:49,140 --> 01:13:50,040


1767
01:13:50,040 --> 01:13:51,780
Pym DP에는 원래

1768
01:13:51,780 --> 01:13:53,960
기능과

1769
01:13:53,960 --> 01:13:56,280


1770
01:13:56,280 --> 01:13:58,980


1771
01:13:58,980 --> 01:14:00,960
정책 공간 등을 사용하여 일반 활성 추론 에이전트를 구현하거나 시뮬레이션하는 기능이 있었고 이를 통해

1772
01:14:00,960 --> 01:14:03,860
커뮤니티의 많은 사람들이  음이

1773
01:14:03,860 --> 01:14:08,219
아닌 사람은 아니고

1774
01:14:08,219 --> 01:14:08,760


1775
01:14:08,760 --> 01:14:10,760


1776
01:14:10,760 --> 01:14:13,500
복잡한 코딩 등에 익숙한 사람

1777
01:14:13,500 --> 01:14:17,219
심리학 정신과 및 모든

1778
01:14:17,219 --> 01:14:19,199
일을 제대로 하는 사람 그래서 누구든지

1779
01:14:19,199 --> 01:14:22,560
올라와 시도하고 싶은 사람 mdp를 통한 적극적인 추론 구현이

1780
01:14:22,560 --> 01:14:26,280
가능하고 나는 그것을 바라고 있습니다

1781
01:14:26,280 --> 01:14:28,500
이 모듈은 시험해 보고 싶은 사람들이 사용할 수 있도록 하므로

1782
01:14:28,500 --> 01:14:30,620


1783
01:14:30,620 --> 01:14:32,820
특정 도메인에서 친구 실험에 적용할 수 있으므로

1784
01:14:32,820 --> 01:14:35,820
시간을 들여 Prime DP 작동 방식의

1785
01:14:35,820 --> 01:14:37,560
구조에 익숙해지면

1786
01:14:37,560 --> 01:14:40,800


1787
01:14:40,800 --> 01:14:43,920
다른 모든 것은 최소한의 작업으로 Jupiter 노트북을 작성하는 것입니다.

1788
01:14:43,920 --> 01:14:46,800
이를 시뮬레이션할 수 있는 코드가 있으므로

1789
01:14:46,800 --> 01:14:49,980


1790
01:14:49,980 --> 01:14:53,100
도메인에 특정 작업이 있는 경우 초보자가 시도하고 코딩하는 데 문제가 없을 것 같습니다.

1791
01:14:53,100 --> 01:14:55,920


1792
01:14:55,920 --> 01:14:58,199
사람들이

1793
01:14:58,199 --> 01:15:01,080
다양한 실험에 이 모듈을 사용하는 것을 보니 매우 기쁩니다.

1794
01:15:01,080 --> 01:15:03,480
사람들이

1795
01:15:03,480 --> 01:15:05,699
pi mdp를 사용하기 시작하고 정교한

1796
01:15:05,699 --> 01:15:08,659
추론이 시작되는 것과 마찬가지로

1797
01:15:08,659 --> 01:15:12,840
이것이

1798
01:15:12,840 --> 01:15:15,719
어떻게 활성 추론을 수행하는 방법인지에 대해

1799
01:15:15,719 --> 01:15:17,820
널리 이야기되고 있으며

1800
01:15:17,820 --> 01:15:20,340
다양한 도메인의 사람들이 이 모듈을 사용하기 시작

1801
01:15:20,340 --> 01:15:22,320
하고 그들의  실험

1802
01:15:22,320 --> 01:15:24,480
과 피딩을 기대합니다.

1803
01:15:24,480 --> 01:15:27,540
예, IMDb가 2년 전에 수행한 작업입니다.

1804
01:15:27,540 --> 01:15:29,460
이 모듈이 수프 상태에서 활성 입력을 모델링하려는 사람들에게 도움이 되기를 바랍니다.

1805
01:15:29,460 --> 01:15:32,580


1806
01:15:32,580 --> 01:15:34,940


1807
01:15:34,980 --> 01:15:39,179
개방형 AI 체육관과

1808
01:15:39,179 --> 01:15:41,520
표준화된 형식에 대해 언급하셨는데요.  어떤

1809
01:15:41,520 --> 01:15:45,420
벤치마크를 사용합니까?

1810
01:15:45,420 --> 01:15:47,640
어떤 종류의 테스트 스위트를

1811
01:15:47,640 --> 01:15:49,140
비교하고

1812
01:15:49,140 --> 01:15:51,900
있으며

1813
01:15:51,900 --> 01:15:54,960


1814
01:15:54,960 --> 01:15:58,739


1815
01:15:58,739 --> 01:16:00,239
다른

1816
01:16:00,239 --> 01:16:03,540
음 기술이 수행하지 않는 방식으로 실제로 초과하거나 탁월한 생성 모델을 만들었는지 어떻게 알 수 있습니까?

1817
01:16:03,540 --> 01:16:05,880
예, 그렇다면

1818
01:16:05,880 --> 01:16:10,140
음 개방형 AI 체육관 웹사이트로 갈 수도 있습니다.

1819
01:16:10,140 --> 01:16:12,179
음 우리는 거기에서 몇 가지 실험을 진행하고 있습니다.

1820
01:16:12,179 --> 01:16:13,739


1821
01:16:13,739 --> 01:16:15,120


1822
01:16:15,120 --> 01:16:16,980
음 지금 이 화면에 보이는 달 착륙선과 같은 고전적인 상환 학습 예제가 있으므로

1823
01:16:16,980 --> 01:16:19,679
활성

1824
01:16:19,679 --> 01:16:22,320
추론을 통해 Inception은 작업을

1825
01:16:22,320 --> 01:16:24,960
확장하는 데 문제가 발생했습니다.

1826
01:16:24,960 --> 01:16:27,600
그것은 그

1827
01:16:27,600 --> 01:16:29,340
자체로 능동 추론에 대한 연구 분야이며,

1828
01:16:29,340 --> 01:16:30,360


1829
01:16:30,360 --> 01:16:32,040
음 활성 입력을 확장하고 이것이

1830
01:16:32,040 --> 01:16:34,260
심층 능동 추론이 음 이와 같은 작업을

1831
01:16:34,260 --> 01:16:35,820
대신하게 된 이유 중 하나이므로

1832
01:16:35,820 --> 01:16:38,100


1833
01:16:38,100 --> 01:16:39,659


1834
01:16:39,659 --> 01:16:42,239
음 지금도 정교한

1835
01:16:42,239 --> 01:16:43,920
추론이 처리할 수 없는 벤치마크가 있습니다.

1836
01:16:43,920 --> 01:16:46,020
상태 공간과 개인적으로 이것이

1837
01:16:46,020 --> 01:16:48,480
내 박사 과정의 연구입니다. 저는 실제로 두 가지 환경을 확장할 수 있는 정교한 추론 알고리즘

1838
01:16:48,480 --> 01:16:49,860


1839
01:16:49,860 --> 01:16:52,620
에서 최적의 최적화 계산을 보고

1840
01:16:52,620 --> 01:16:54,600


1841
01:16:54,600 --> 01:16:57,239


1842
01:16:57,239 --> 01:16:59,699
있지만

1843
01:16:59,699 --> 01:17:02,280
시작하려면

1844
01:17:02,280 --> 01:17:04,199
코드를 작성하고 작동하는지 확인해야 합니다.

1845
01:17:04,199 --> 01:17:07,679
환경에 대해 작동하지 않는지 살펴보고 확장하기 위해

1846
01:17:07,679 --> 01:17:09,659
메소드 단어를 살펴봐야 합니다.

1847
01:17:09,659 --> 01:17:12,659
따라서

1848
01:17:12,659 --> 01:17:14,699
벤치마크가 정교하고 Princess에 대해 이야기하는 경우

1849
01:17:14,699 --> 01:17:16,860


1850
01:17:16,860 --> 01:17:19,080
RL 알고리즘만큼 우수합니다.

1851
01:17:19,080 --> 01:17:21,840
음 이 상태 공간에 대해서는 작습니다.

1852
01:17:21,840 --> 01:17:23,460
문제는 어떤 게이트 입구가

1853
01:17:23,460 --> 01:17:26,580
작동하는지 정말 좋지만

1854
01:17:26,580 --> 01:17:29,100
이와 같은 고차원 문제의 경우 음

1855
01:17:29,100 --> 01:17:31,020
제가

1856
01:17:31,020 --> 01:17:33,239
방금 보여드린 고전적인 구현이 작동하지 않을 수도 있지만

1857
01:17:33,239 --> 01:17:36,120
괜찮은 실험에는 충분하지만

1858
01:17:36,120 --> 01:17:38,040
규모를 확장하고 싶다면 여전히

1859
01:17:38,040 --> 01:17:40,199
열려 있고  새로운 연구 분야

1860
01:17:40,199 --> 01:17:43,040
와 당신이 하는 일이 차세대

1861
01:17:43,040 --> 01:17:46,020
중요한 논문이 될 수도 있습니다. 그래서 제가

1862
01:17:46,020 --> 01:17:49,520
말할 수 있는 것은 그게 전부입니다.

1863
01:17:49,940 --> 01:17:52,260


1864
01:17:52,260 --> 01:17:53,580


1865
01:17:53,580 --> 01:17:54,840


1866
01:17:54,840 --> 01:17:57,960
어 컴퓨터 자원과 같이 어떤 조치를 찾고 있다고 생각하시나요?

1867
01:17:57,960 --> 01:18:00,000
아니면 이를 위한 조치가 무엇인가요?

1868
01:18:00,000 --> 01:18:04,020
이렇게 다양한 방법을 병치하는 감각이 있죠.

1869
01:18:04,020 --> 01:18:09,120
개방형 AI 체육관은

1870
01:18:09,120 --> 01:18:12,600
다양한 어 알고리즘을 비교하기 위해 설계되었으므로

1871
01:18:12,600 --> 01:18:15,900
개방형은 정의상

1872
01:18:15,900 --> 01:18:18,179
많은 환경의 집합이므로 제

1873
01:18:18,179 --> 01:18:19,620
데모에서 저는 그리드 환경에 대해 이야기하고 있었습니다.

1874
01:18:19,620 --> 01:18:22,440
open iigm은 단지

1875
01:18:22,440 --> 01:18:24,719


1876
01:18:24,719 --> 01:18:26,460


1877
01:18:26,460 --> 01:18:29,360


1878
01:18:29,360 --> 01:18:31,980
Environment.step 함수를 사용하여 해당 환경과 상호 작용할 수 있게 해주는 많은 환경 모음

1879
01:18:31,980 --> 01:18:32,699
음

1880
01:18:32,699 --> 01:18:34,500
예, 여기에는

1881
01:18:34,500 --> 01:18:36,719


1882
01:18:36,719 --> 01:18:39,060
달 착륙선과 상호 작용할 수 있게 해주는 Environment.step 함수가 있고

1883
01:18:39,060 --> 01:18:42,120
해당 특정 작업에는

1884
01:18:42,120 --> 01:18:44,040


1885
01:18:44,040 --> 01:18:46,500
음 판단할 수 있는 매트릭스가 있습니다.

1886
01:18:46,500 --> 01:18:50,100
이 달 착륙선 문제에서 알고리즘이 얼마나 좋은지 나쁜지

1887
01:18:50,100 --> 01:18:52,080


1888
01:18:52,080 --> 01:18:54,659


1889
01:18:54,659 --> 01:18:57,900
연료를 최소화하는 등의 비용을 지출하여 이 두 플래그 사이에 로버를 최적으로 착륙시킬 수 있으므로 해당

1890
01:18:57,900 --> 01:19:01,920
매트릭스는 매우 구체적인 작업이고

1891
01:19:01,920 --> 01:19:03,780
이것이

1892
01:19:03,780 --> 01:19:07,679
취할 수 있는 한 방향입니다.  어 매트릭스에서 RL 알고리즘과 경쟁하려고 시도

1893
01:19:07,679 --> 01:19:10,739
하지만

1894
01:19:10,739 --> 01:19:12,960
음 정교한 추론 모델링 지능형 행동에서 올바른 잠재력 또는 잠재적

1895
01:19:12,960 --> 01:19:16,080
IC는

1896
01:19:16,080 --> 01:19:19,020
RL에서

1897
01:19:19,020 --> 01:19:21,300
초점이 이 작업을 수행하기 위해 작업을 수행하는 것이지만

1898
01:19:21,300 --> 01:19:23,340
실제로 설명할 수는 없습니다.

1899
01:19:23,340 --> 01:19:25,679
특히 D 병렬 및 딥 러닝

1900
01:19:25,679 --> 01:19:27,719
방법이지만 능동적 추론에서는

1901
01:19:27,719 --> 01:19:29,159
확장할 수 있다면

1902
01:19:29,159 --> 01:19:31,620
설명이 가능하며 음

1903
01:19:31,620 --> 01:19:33,719


1904
01:19:33,719 --> 01:19:36,540
시간이 지남에 따라 지능이 어떻게 나타나는지 이해할 수 있게 해 줄 것입니다.

1905
01:19:36,540 --> 01:19:39,300


1906
01:19:39,300 --> 01:19:41,340
음 RL과 경쟁하는 것보다 더 흥미로울 것입니다. 왜냐하면 당신의

1907
01:19:41,340 --> 01:19:44,219
초점이 일을 완료하는 것이라면  어쩌면

1908
01:19:44,219 --> 01:19:46,320
엔지니어링이 올바른 방법이고

1909
01:19:46,320 --> 01:19:49,460
활성 보험이 아닐 수도 있습니다 음

1910
01:19:50,699 --> 01:19:55,219
다른 의견이나 생각이

1911
01:20:02,159 --> 01:20:04,199
있습니까 오스만 다른 의견이나

1912
01:20:04,199 --> 01:20:05,340
생각이 있습니까

1913
01:20:05,340 --> 01:20:09,300
아니요 저는 매우 기쁩니다 음

1914
01:20:09,300 --> 01:20:10,980
코드를 명확하게 설명했으면 좋겠습니다. 어쩌면

1915
01:20:10,980 --> 01:20:13,020
너무 복잡하거나 단순했을 수도 있습니다.

1916
01:20:13,020 --> 01:20:14,400
레벨이

1917
01:20:14,400 --> 01:20:16,380
음, 하지만

1918
01:20:16,380 --> 01:20:19,080
이것을 사용

1919
01:20:19,080 --> 01:20:21,179
하고 코드를 작성하는 사람 중 적어도 한 명에게 도움이 되었기를 바랍니다. 시간 내주셔서 정말 감사합니다.

1920
01:20:21,179 --> 01:20:23,520


1921
01:20:23,520 --> 01:20:25,440
기회를 주셔서 감사합니다.

1922
01:20:25,440 --> 01:20:28,080
다음에 뵙도록 해주셔서

1923
01:20:28,080 --> 01:20:29,159


1924
01:20:29,159 --> 01:20:32,780
감사합니다.  안녕히 계세요.

1925
01:20:37,860 --> 01:20:40,639


1926
01:20:45,060 --> 01:20:48,320


1927
01:20:48,780 --> 01:20:52,219
다음에 만날 때까지 한국에 인사드립니다.

