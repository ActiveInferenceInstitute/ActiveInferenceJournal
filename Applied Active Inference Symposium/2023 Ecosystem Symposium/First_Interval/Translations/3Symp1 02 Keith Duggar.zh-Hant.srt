1
00:00:01,290 --> 00:00:04,494
好的，下一位是

2
00:00:04,532 --> 00:00:06,606
Keith Dugger，他提交了一段預先錄製的

3
00:00:06,628 --> 00:00:09,118
視頻。 預先錄製的視頻

4
00:00:09,204 --> 00:00:11,694
稱為主動推理。 還有

5
00:00:11,732 --> 00:00:14,765
演員模型所以我現在就提出這個問題

6
00:00:14,788 --> 00:00:15,920
。

7
00:00:29,430 --> 00:00:32,958
好的，這是 Keith

8
00:00:33,134 --> 00:00:35,910
預先錄製的有關主動推理

9
00:00:35,990 --> 00:00:37,660
和 Actor 模型的視頻。

10
00:00:44,240 --> 00:00:46,956
主動推理和演員模型。

11
00:00:47,138 --> 00:00:49,608
你好。 你好。 我是 Keith Thugger 博士，是

12
00:00:49,704 --> 00:00:52,684
擴展現實人工智能 X Ray 的平台首席技術官

13
00:00:52,732 --> 00:00:56,464
。 公司，也是

14
00:00:56,502 --> 00:00:58,880
機器學習街頭談話播客的聯合主持人。

15
00:00:59,780 --> 00:01:02,624
現在，當我們都致力於建立一個

16
00:01:02,662 --> 00:01:05,536
基於主動推理的生態系統時，

17
00:01:05,728 --> 00:01:08,324
軟件顯然將在充分利用主動推理方面發揮

18
00:01:08,362 --> 00:01:11,363
基礎作用

19
00:01:11,402 --> 00:01:13,204
。 我們需要使用

20
00:01:13,242 --> 00:01:15,524


21
00:01:15,562 --> 00:01:17,636
符合主動

22
00:01:17,668 --> 00:01:20,136
推理原則的軟件工程範式，我認為有一種

23
00:01:20,238 --> 00:01:22,664
範式適合我們的需求。 這就是所謂的

24
00:01:22,702 --> 00:01:26,084
演員模型。 主動推理

25
00:01:26,132 --> 00:01:28,356
和演員模型是

26
00:01:28,388 --> 00:01:30,750
對世界的兩種緊密相連的理解。

27
00:01:31,280 --> 00:01:34,204
它們提供了

28
00:01:34,242 --> 00:01:36,280
處理複雜

29
00:01:36,360 --> 00:01:39,624
系統動態的基礎框架，重點關注

30
00:01:39,672 --> 00:01:42,672
在嵌套系統生態中交互的自主代理

31
00:01:42,726 --> 00:01:46,283
。 我想探討

32
00:01:46,332 --> 00:01:47,916
它們的一些關鍵聯繫，

33
00:01:48,108 --> 00:01:50,050
包括代理

34
00:01:50,500 --> 00:01:53,040
並發性、自主性、

35
00:01:53,380 --> 00:01:57,300
不確定性和行為適應的作用。

36
00:01:58,680 --> 00:02:00,596
我們將看到主動推理和

37
00:02:00,618 --> 00:02:03,184
主動模型都是范式

38
00:02:03,232 --> 00:02:06,300
轉變，從確定性的、

39
00:02:06,480 --> 00:02:10,392
集中的、逐步的思維轉向

40
00:02:10,446 --> 00:02:14,004
分散的網絡並發

41
00:02:14,052 --> 00:02:17,751
計算和

42
00:02:17,806 --> 00:02:21,052
認知視角。

43
00:02:21,106 --> 00:02:25,100
關於 Actor 模型的一些歷史。 早在 1973 年，

44
00:02:25,250 --> 00:02:28,504
Karl Hewitt、Peter Bishop 和 Richard

45
00:02:28,552 --> 00:02:30,555
Steiger 都在

46
00:02:30,578 --> 00:02:33,676
麻省理工學院的 AI

47
00:02:33,708 --> 00:02:37,804
實驗室工作，研究

48
00:02:37,852 --> 00:02:40,972
並發計算的概念，包括

49
00:02:41,036 --> 00:02:44,304
結構和適應性

50
00:02:44,352 --> 00:02:46,020
算法執行。

51
00:02:47,480 --> 00:02:49,744
當時的傳統方法缺乏

52
00:02:49,792 --> 00:02:52,224
穩健性和可靠的數學

53
00:02:52,272 --> 00:02:55,263
基礎。 他們的共同努力

54
00:02:55,312 --> 00:02:57,576
最終導致了

55
00:02:57,598 --> 00:03:01,076
Actor 模型的創建。 當時，

56
00:03:01,108 --> 00:03:03,224
由於其

57
00:03:03,262 --> 00:03:05,764
增強的容錯

58
00:03:05,812 --> 00:03:08,784
能力和分佈式計算

59
00:03:08,852 --> 00:03:12,236
能力的特點，它被認為是革命性的。 在整個 20 世紀 80 年代和

60
00:03:12,258 --> 00:03:15,388
90 年代，Actor 模型成為

61
00:03:15,394 --> 00:03:18,476
眾多研究項目

62
00:03:18,498 --> 00:03:20,856
和實際項目的基礎，因其

63
00:03:20,888 --> 00:03:23,184
靈活性和

64
00:03:23,222 --> 00:03:25,516
直觀的並發

65
00:03:25,548 --> 00:03:29,648
計算方法而廣受歡迎。 它主要用於

66
00:03:29,734 --> 00:03:32,240
人工智能和多代理

67
00:03:32,310 --> 00:03:34,400
系統。 聽起來有點熟？

68
00:03:35,880 --> 00:03:38,784
新的基於 Actor 的語言（例如 Actor、

69
00:03:38,912 --> 00:03:42,116
Saulson 和 Erlang）為

70
00:03:42,138 --> 00:03:44,356
模型的完善做出了貢獻，將其塑造

71
00:03:44,378 --> 00:03:47,203
成一種更強大、更靈活的並發

72
00:03:47,332 --> 00:03:50,148
計算方法，並且

73
00:03:50,244 --> 00:03:52,164
在當今的計算機科學中仍然存在

74
00:03:52,212 --> 00:03:55,272
。 最近，Actor 模型重新引起了人們的興趣，主要是由於對分佈式系統、雲計算和邊緣計算的需求不斷增長，推動了物聯網和 Web 30。這些計算機任務非常適合利用 ACA 模型的架構，它的設計目的是一方面對大量數據進行並發處理建模，另一方面對細粒度的不同自治系統進行建模。 

75
00:03:55,326 --> 00:03:57,796


76
00:03:57,828 --> 00:03:59,944


77
00:03:59,992 --> 00:04:02,904


78
00:04:02,952 --> 00:04:05,036


79
00:04:05,058 --> 00:04:07,310


80
00:04:08,480 --> 00:04:11,351


81
00:04:11,416 --> 00:04:13,436


82
00:04:13,468 --> 00:04:16,800


83
00:04:16,950 --> 00:04:20,368


84
00:04:20,534 --> 00:04:23,409


85
00:04:23,800 --> 00:04:26,752


86
00:04:26,816 --> 00:04:28,710


87
00:04:29,640 --> 00:04:32,003
Actor模型的這種應用

88
00:04:32,042 --> 00:04:34,436
對Twitter、Facebook、LinkedIn等利用其原理處理大數據問題的各大公司產生了深遠的影響，

89
00:04:34,538 --> 00:04:36,904


90
00:04:36,942 --> 00:04:38,936


91
00:04:38,958 --> 00:04:41,348


92
00:04:41,524 --> 00:04:45,256
那麼這

93
00:04:45,278 --> 00:04:47,636
與主動推理有什麼關係呢？ 我

94
00:04:47,668 --> 00:04:49,368
猜您已經

95
00:04:49,374 --> 00:04:51,656
在簡介中聽過一些相似之處。 但讓我們

96
00:04:51,688 --> 00:04:53,656
首先看看

97
00:04:53,688 --> 00:04:56,396
參與者模型的一些核心原則以及

98
00:04:56,418 --> 00:04:58,568
它們與主動推理原則的關係

99
00:04:58,584 --> 00:05:01,236
。 讓我們從

100
00:05:01,288 --> 00:05:04,832
隔離的概念開始。 隔離意味著

101
00:05:04,886 --> 00:05:07,664
參與者模型中的參與者

102
00:05:07,702 --> 00:05:10,464
不與任何其他參與者共享其狀態

103
00:05:10,502 --> 00:05:14,212
。 它只能通過

104
00:05:14,266 --> 00:05:17,060
接收消息來影響。 它只能

105
00:05:17,130 --> 00:05:19,524


106
00:05:19,562 --> 00:05:22,164
通過發送有限數量的

107
00:05:22,202 --> 00:05:25,776
消息作為響應來影響其他參與者狀態的變化。 從軟件工程的角度來看，這種隔離原則將操作的潛在副作用限制在單個參與者身上，從而提高了系統的整體可預測性可靠性，最重要的是，如果完全接受，實際上可以簡化設計。

108
00:05:25,808 --> 00:05:27,512


109
00:05:27,566 --> 00:05:30,051


110
00:05:30,116 --> 00:05:33,111


111
00:05:33,166 --> 00:05:35,924


112
00:05:35,972 --> 00:05:39,072


113
00:05:39,236 --> 00:05:42,104


114
00:05:42,232 --> 00:05:44,910


115
00:05:46,560 --> 00:05:48,636
查看該圖，我們看到一個

116
00:05:48,658 --> 00:05:51,616
參與者的生態系統，該

117
00:05:51,638 --> 00:05:54,635
參與者向特定參與者發送消息，該特定參與者又將

118
00:05:54,668 --> 00:05:57,040
消息發送回其他參與者。

119
00:05:58,340 --> 00:06:00,690
主動推理在哪裡？ 好吧，

120
00:06:01,300 --> 00:06:03,816
讓我們將接收和發送

121
00:06:03,868 --> 00:06:07,392
消息重新定義為感知動作週期，

122
00:06:07,536 --> 00:06:09,620
並表示外部、

123
00:06:10,200 --> 00:06:13,539
內部、感覺和

124
00:06:13,610 --> 00:06:17,112
活動狀態。 現在我們顯然已經具備了馬爾可夫毯子

125
00:06:17,166 --> 00:06:19,956
主動推理的必要基礎

126
00:06:19,988 --> 00:06:22,600
。

127
00:06:23,660 --> 00:06:26,436
參與者模型的參與者

128
00:06:26,468 --> 00:06:28,848
直接映射到主動推理的代理

129
00:06:28,884 --> 00:06:32,840
。 此外，有限性，

130
00:06:33,000 --> 00:06:35,676
即參與者只能發送

131
00:06:35,698 --> 00:06:39,003
有限數量的消息作為響應，也是

132
00:06:39,042 --> 00:06:41,150
一個重要的共享屬性。

133
00:06:41,940 --> 00:06:44,780
由於主動推理對現實進行建模，因此

134
00:06:44,940 --> 00:06:47,452
它必然尊重

135
00:06:47,516 --> 00:06:50,704
真實係統的資源限制。 這

136
00:06:50,742 --> 00:06:53,376
很好地融入了主動模型的基礎中

137
00:06:53,398 --> 00:06:56,496
。 我們再來看看

138
00:06:56,528 --> 00:06:59,860
異步消息傳遞的另一個核心原理。

139
00:07:00,840 --> 00:07:03,012
參與者之間的通信是

140
00:07:03,066 --> 00:07:05,936
異步的。 這意味著參與者

141
00:07:05,968 --> 00:07:07,832
在發送消息後不會等待響應

142
00:07:07,886 --> 00:07:10,680
。 可以說，它繼續工作，

143
00:07:10,830 --> 00:07:13,210
繼續生活。

144
00:07:13,820 --> 00:07:17,256
這是至關重要的，因為它將參與者解耦

145
00:07:17,278 --> 00:07:20,284
，從而使系統

146
00:07:20,322 --> 00:07:23,020


147
00:07:23,090 --> 00:07:25,948
即使在系統的某些部分速度

148
00:07:26,034 --> 00:07:28,551
緩慢甚至暫時

149
00:07:28,616 --> 00:07:31,964
不可用時也可以繼續運行、運行並取得進展。 弗里斯頓教授

150
00:07:32,012 --> 00:07:34,028
說過，自由能原理

151
00:07:34,124 --> 00:07:38,240
是終極的存在問題，如果

152
00:07:38,310 --> 00:07:41,490
事物存在，它們必須做什麼？

153
00:07:42,660 --> 00:07:45,412
嗯，演員模型聲稱他們

154
00:07:45,466 --> 00:07:47,350
不能等待別人。

155
00:07:48,360 --> 00:07:51,572
當然，演員可以選擇等待

156
00:07:51,626 --> 00:07:55,284
別人，但

157
00:07:55,322 --> 00:07:58,808
在模型中絕對不能強迫這樣做。 必須是可以自由

158
00:07:58,894 --> 00:07:59,770
選擇的。

159
00:08:01,820 --> 00:08:04,004
這使我們得出另一個關鍵

160
00:08:04,052 --> 00:08:06,456
原則，即兩種模型共享

161
00:08:06,558 --> 00:08:09,719
自主權。 自由能

162
00:08:09,790 --> 00:08:12,860
原理是物理現實的模型，

163
00:08:13,280 --> 00:08:15,547
畢竟我們的現實是

164
00:08:15,634 --> 00:08:18,904
同時存在的。 在整個無限

165
00:08:18,952 --> 00:08:21,572
空間中，系統都

166
00:08:21,656 --> 00:08:24,048
根據其局部

167
00:08:24,134 --> 00:08:27,696
動態同時演化。 因此，這

168
00:08:27,718 --> 00:08:29,344
反映在自由

169
00:08:29,382 --> 00:08:33,024
能原理的核心。 當然，

170
00:08:33,062 --> 00:08:35,796
計算模型不必將自身限制於

171
00:08:35,818 --> 00:08:38,784
物理。 但休伊特等人。 我們正在尋求

172
00:08:38,832 --> 00:08:41,395
開發一個模型來模擬

173
00:08:41,418 --> 00:08:43,664
分佈式並發

174
00:08:43,712 --> 00:08:47,056
系統的現實。 對我們來說幸運的是，

175
00:08:47,088 --> 00:08:50,824


176
00:08:50,862 --> 00:08:53,352
從隔離原則和

177
00:08:53,486 --> 00:08:56,500
參與者自治原則來看，參與者模型同時支持並發性，使其

178
00:08:56,580 --> 00:08:58,040
與主動推理兼容。

179
00:08:59,200 --> 00:09:01,820
接下來我們來築巢。

180
00:09:02,640 --> 00:09:05,532
參與者模型不僅允許參與者

181
00:09:05,586 --> 00:09:08,552
接收和發送有限

182
00:09:08,616 --> 00:09:11,984
數量的消息來感知和採取行動，

183
00:09:12,182 --> 00:09:15,292
還允許作為一個動作創建

184
00:09:15,356 --> 00:09:18,240
有限數量的新參與者。

185
00:09:19,220 --> 00:09:21,504
這些參與者可以嵌套在

186
00:09:21,542 --> 00:09:24,336
父代（例如動物細胞的一部分）內

187
00:09:24,368 --> 00:09:26,564
，也可以

188
00:09:26,602 --> 00:09:29,076
作為獨立的參與者釋放到環境中。 從那時

189
00:09:29,098 --> 00:09:32,336
起，根據這個原則，該模型非常適合

190
00:09:32,368 --> 00:09:34,628


191
00:09:34,714 --> 00:09:37,960
多尺度嵌套和主動推理的美麗概念。

192
00:09:38,940 --> 00:09:41,460
這使得參與者能夠包含自下而上的

193
00:09:41,540 --> 00:09:44,791
參與者生態系統

194
00:09:44,846 --> 00:09:47,290
。

195
00:09:49,200 --> 00:09:51,976
最後，我想介紹另外兩個 Actor

196
00:09:52,008 --> 00:09:55,436
模型設計原則：行為改變

197
00:09:55,618 --> 00:09:57,020
和持久性。

198
00:09:59,040 --> 00:10:01,664
參與者有能力改變自己的

199
00:10:01,702 --> 00:10:04,450
行為以響應消息。

200
00:10:05,140 --> 00:10:08,192
這種適應性允許構建可以

201
00:10:08,246 --> 00:10:10,924


202
00:10:10,972 --> 00:10:14,130
隨時間演變的複雜有狀態實體。

203
00:10:14,760 --> 00:10:17,492
事實上，它允許整個

204
00:10:17,626 --> 00:10:21,584
生態系統進化出新的湧現

205
00:10:21,632 --> 00:10:25,263
行為。 當用於軟件

206
00:10:25,312 --> 00:10:28,264
工程時，這增加了

207
00:10:28,382 --> 00:10:31,800
管理複雜動態系統的強大工具。

208
00:10:32,700 --> 00:10:35,412
當然，主動推理將這

209
00:10:35,476 --> 00:10:39,304
一點發揮到了極致。

210
00:10:39,352 --> 00:10:42,363
事物的本質是不斷嘗試

211
00:10:42,402 --> 00:10:45,324
預測和適應環境，

212
00:10:45,362 --> 00:10:48,439
從而繼續存在，以

213
00:10:48,520 --> 00:10:52,828
在激烈的活動海洋中維持馬爾可夫毯子

214
00:10:53,004 --> 00:10:56,736
。 隨之而來的還有

215
00:10:56,758 --> 00:10:58,912


216
00:10:58,966 --> 00:11:02,444
持久性的概念。 持久性允許參與者

217
00:11:02,492 --> 00:11:05,524
保存他們的狀態並在以後恢復或

218
00:11:05,562 --> 00:11:08,640
修改它，這是

219
00:11:08,720 --> 00:11:11,300
體現記憶原理的功能。

220
00:11:11,800 --> 00:11:14,675
記憶是學習和適應的先決條件

221
00:11:14,778 --> 00:11:18,504
。 智能體的

222
00:11:18,622 --> 00:11:21,640
預測能力取決於其

223
00:11:21,710 --> 00:11:24,356
記住過去經歷的能力，從而最大限度地

224
00:11:24,388 --> 00:11:27,176
減少與意外相關的意外情況

225
00:11:27,198 --> 00:11:30,520
。

226
00:11:30,600 --> 00:11:34,056
當我們假設主體

227
00:11:34,088 --> 00:11:36,199
具有歸納先驗（

228
00:11:36,280 --> 00:11:39,100
來自經驗或遺傳）並

229
00:11:39,440 --> 00:11:41,470
有助於他們的世界模型時，記憶的重要作用也得到了強調。

230
00:11:42,340 --> 00:11:44,464
這個世界模型既指導他們

231
00:11:44,502 --> 00:11:47,291
當前的行為，又

232
00:11:47,356 --> 00:11:50,028
根據

233
00:11:50,204 --> 00:11:52,939
有助於他們不斷適應

234
00:11:53,020 --> 00:11:54,240
和存在的新經驗不斷更新。

235
00:11:56,600 --> 00:11:59,684
好的，太好了。 你說

236
00:11:59,722 --> 00:12:02,308
演員模型和主動推理之間有清晰而深刻的聯繫

237
00:12:02,394 --> 00:12:06,424
。 但這對

238
00:12:06,462 --> 00:12:08,756
我們活躍的推理

239
00:12:08,788 --> 00:12:11,988
社區有什麼幫助呢？ 嗯，首先，

240
00:12:12,084 --> 00:12:14,084
在我看來，這是

241
00:12:14,132 --> 00:12:16,520
我們應該擁抱的軟件工程範例。

242
00:12:16,860 --> 00:12:19,340
如果我們這樣做，當然還有我們可以使用的

243
00:12:19,410 --> 00:12:21,815
Actor 模型庫和框架，

244
00:12:21,848 --> 00:12:25,448
例如 ACA、

245
00:12:25,624 --> 00:12:29,752
Orleans、thespian Actix

246
00:12:29,896 --> 00:12:33,055
Protoactor 等等，我們可以

247
00:12:33,078 --> 00:12:35,516
在構建主動

248
00:12:35,548 --> 00:12:37,872
推理軟件模塊和

249
00:12:37,926 --> 00:12:41,596
應用程序時立即使用它們。 還有一些庫、

250
00:12:41,708 --> 00:12:43,944
語言甚至語言功能

251
00:12:44,012 --> 00:12:46,016
與參與者

252
00:12:46,048 --> 00:12:49,380
模型原則非常一致，例如 Zero、

253
00:12:49,450 --> 00:12:52,640
MQ、tokyo 和 Rust、

254
00:12:52,800 --> 00:12:56,284
Erlang、Async、Await 和 C. Sharp

255
00:12:56,432 --> 00:13:00,104
等。 但比

256
00:13:00,142 --> 00:13:04,712
我們今天可用的工具更重要的是

257
00:13:04,766 --> 00:13:07,544
軟件設計思維，它將

258
00:13:07,582 --> 00:13:10,136
指導我們創建

259
00:13:10,168 --> 00:13:13,996
未來的主動推理軟件。

260
00:13:14,018 --> 00:13:16,764
參與者模型提供了

261
00:13:16,802 --> 00:13:20,588
軟件設計和工程的範例，這是

262
00:13:20,754 --> 00:13:24,064
我們對於主動推理最完美的匹配

263
00:13:24,102 --> 00:13:28,160
。 這

264
00:13:28,580 --> 00:13:30,876
不僅從

265
00:13:30,908 --> 00:13:34,084
我們之前討論的核心原則的一致性中顯而易見，而且從

266
00:13:34,122 --> 00:13:37,055


267
00:13:37,088 --> 00:13:39,156
參與者模型中的主動推理給

268
00:13:39,178 --> 00:13:42,916
彼此帶來的見解中也可見一斑。 例如，考慮

269
00:13:42,938 --> 00:13:46,604
現在所謂的休伊特定律。 非正式地

270
00:13:46,672 --> 00:13:49,800
說，一切都無處不在，

271
00:13:51,260 --> 00:13:54,824
該定律意味著

272
00:13:54,942 --> 00:13:57,844
在真正的異步分佈式

273
00:13:57,892 --> 00:14:00,652
系統中，

274
00:14:00,706 --> 00:14:03,532
消息從一個

275
00:14:03,586 --> 00:14:07,032
地方到達另一個地方可能需要任意時間，並且任何參與者都

276
00:14:07,096 --> 00:14:10,364
必須為該事件做好準備。 在這樣的系統中

277
00:14:10,402 --> 00:14:13,900
根本不存在瞬時這樣的事情

278
00:14:13,980 --> 00:14:17,888
，並且沒有任何組件可以

279
00:14:17,974 --> 00:14:20,384
對

280
00:14:20,422 --> 00:14:23,548
另一個組件的操作的時間做出假設。 事實上，

281
00:14:23,734 --> 00:14:26,980
人們必須表現得好像消息

282
00:14:27,050 --> 00:14:30,819
永遠不會到達一樣。 這具有重要

283
00:14:30,890 --> 00:14:34,644
意義。 這表明

284
00:14:34,682 --> 00:14:36,744


285
00:14:36,782 --> 00:14:39,176


286
00:14:39,198 --> 00:14:42,569
在任何給定時間都不可能準確一致地確定整個系統的狀態，

287
00:14:43,260 --> 00:14:45,464
因為信息可能還

288
00:14:45,502 --> 00:14:48,410
沒有在整個系統中傳播。

289
00:14:49,760 --> 00:14:52,904
並且嘗試實現全局

290
00:14:52,952 --> 00:14:55,400
同步也不可避免地會

291
00:14:55,480 --> 00:14:57,864
引入瓶頸並降低

292
00:14:57,912 --> 00:15:01,844
效率。 休伊特定律強調

293
00:15:01,912 --> 00:15:04,976
系統設計時需要

294
00:15:04,998 --> 00:15:07,580
能夠有效處理

295
00:15:07,660 --> 00:15:09,504
這些不可避免的延遲和

296
00:15:09,542 --> 00:15:11,776
不確定性，強調

297
00:15:11,798 --> 00:15:14,424
穩健的無阻塞

298
00:15:14,492 --> 00:15:17,540
通信機制和本地決策

299
00:15:17,690 --> 00:15:21,284
能力的重要性。 簡而言之，

300
00:15:21,482 --> 00:15:24,240
赫克托模型系統本質上是

301
00:15:24,400 --> 00:15:27,944
不確定的。 這聽起來

302
00:15:27,982 --> 00:15:31,800
很熟悉嗎？ 還有什麼其他範式強調

303
00:15:32,140 --> 00:15:34,616
不確定性下的運營以及

304
00:15:34,638 --> 00:15:36,904
儘管環境如何仍能繼續自主

305
00:15:36,942 --> 00:15:40,328
？ 主動推理和

306
00:15:40,334 --> 00:15:43,767
自由能原理？ 主動推理

307
00:15:43,864 --> 00:15:46,552
反映了

308
00:15:46,616 --> 00:15:48,792
我們的軟件系統

309
00:15:48,856 --> 00:15:51,920
運行的不可預測的世界的現實。

310
00:15:51,990 --> 00:15:55,136
由於

311
00:15:55,158 --> 00:15:57,756
事件以隨機、

312
00:15:57,868 --> 00:16:01,644
不可預測的順序發生，相同的初始條件可能會產生不同的結果。 這是

313
00:16:01,692 --> 00:16:04,310
我們都熟知的驚喜概念，

314
00:16:05,000 --> 00:16:07,572
當智能體收到的感官輸入與其預測不符時，它會更新其對世界的信念

315
00:16:07,626 --> 00:16:10,404


316
00:16:10,442 --> 00:16:13,060
。

317
00:16:13,720 --> 00:16:15,856
演員模型和主動

318
00:16:15,888 --> 00:16:18,328
推理都承認世界是

319
00:16:18,414 --> 00:16:21,624
不可預測的。 這些

320
00:16:21,662 --> 00:16:24,632
模型不僅承認這一點，而且還接受這種

321
00:16:24,686 --> 00:16:27,688
不確定性是給定的，而不是

322
00:16:27,774 --> 00:16:29,530
可以消除的東西。

323
00:16:30,780 --> 00:16:33,752
事實上，正如我們在自由能原理中所知

324
00:16:33,806 --> 00:16:36,204
，我們

325
00:16:36,242 --> 00:16:38,459
在模型中保持的不確定性賦予了我們

326
00:16:38,530 --> 00:16:41,020
適應的靈活性。

327
00:16:43,540 --> 00:16:46,555
也許這只是我個人

328
00:16:46,588 --> 00:16:49,199
的幻想，但我想像在未來，

329
00:16:49,270 --> 00:16:51,596
由主動推理引導的軟件模塊將

330
00:16:51,628 --> 00:16:54,976
取消硬編碼的錯誤

331
00:16:55,008 --> 00:16:57,792
處理，並替換為

332
00:16:57,856 --> 00:17:00,672


333
00:17:00,736 --> 00:17:03,200
隨著錯誤情況的

334
00:17:03,280 --> 00:17:07,316
發展而優化自身的概率學習算法。 模塊是強大的

335
00:17:07,428 --> 00:17:11,268
、自我修復的分佈式系統，

336
00:17:11,364 --> 00:17:13,672
沒有單點故障，

337
00:17:13,726 --> 00:17:17,716
專注於預測性災難避免

338
00:17:17,907 --> 00:17:21,659
而不是反應性災難恢復。

339
00:17:23,040 --> 00:17:25,308
展望未來，我們作為一個

340
00:17:25,314 --> 00:17:28,044
社區有潛力突破

341
00:17:28,082 --> 00:17:31,700
主動印記理論

342
00:17:31,880 --> 00:17:34,576
和

343
00:17:34,598 --> 00:17:37,611
行動者模型實際實施的界限。 通過結合利用

344
00:17:37,676 --> 00:17:40,096
這兩種範式的優勢，我們可以

345
00:17:40,118 --> 00:17:42,860
創建健壯、

346
00:17:43,020 --> 00:17:45,876
適應性強且更符合

347
00:17:45,898 --> 00:17:48,500
其實際運行的物理世界的軟件系統

348
00:17:48,650 --> 00:17:52,100
。 想像一下未來，在

349
00:17:52,170 --> 00:17:54,976


350
00:17:55,008 --> 00:17:57,112
參與者模型中使用主動推理的軟件組件可以

351
00:17:57,166 --> 00:18:00,344
預測潛在問題，從

352
00:18:00,382 --> 00:18:04,024
過去的錯誤中學習，並實時適應

353
00:18:04,062 --> 00:18:07,144
環境變化。 通過這種

354
00:18:07,182 --> 00:18:09,212
方法，我們可以構建

355
00:18:09,266 --> 00:18:11,996
從根本上更具彈性和

356
00:18:12,018 --> 00:18:15,084
效率的系統。

357
00:18:15,122 --> 00:18:17,784


358
00:18:17,912 --> 00:18:21,052


359
00:18:21,106 --> 00:18:24,044


360
00:18:24,092 --> 00:18:27,264


361
00:18:27,302 --> 00:18:30,060


362
00:18:30,220 --> 00:18:32,416


363
00:18:32,438 --> 00:18:36,420
在我看來，這可以帶來軟件可靠性、性能和可擴展性的巨大變化，並預示著計算的新時代，將生物學和認知原理編織到我們軟件系統的結構中，使它們在這個過程中更接近生活。 總之，

364
00:18:37,160 --> 00:18:39,636
主動推理與

365
00:18:39,658 --> 00:18:42,803
參與者模型的耦合提供了一個強大的新

366
00:18:42,842 --> 00:18:44,564
鏡頭，通過它我們可以觀察

367
00:18:44,602 --> 00:18:46,820
軟件設計和工程。

368
00:18:47,180 --> 00:18:49,412
無論我們利用

369
00:18:49,476 --> 00:18:51,476
與主動推理相一致的現有語言和庫

370
00:18:51,508 --> 00:18:54,728
還是發明新的語言和庫，

371
00:18:54,894 --> 00:18:58,056
我們都站在

372
00:18:58,078 --> 00:19:01,944
令人興奮的前沿的邊緣。 因此，讓我們抓緊

373
00:19:01,992 --> 00:19:05,068
時間，看看 Actor 模型

374
00:19:05,154 --> 00:19:06,776
及其與主動

375
00:19:06,808 --> 00:19:09,484
推理的關係，讓我們一起塑造

376
00:19:09,522 --> 00:19:11,980
智能分佈式計算的未來。

377
00:19:13,040 --> 00:19:14,460
感謝您的聆聽。

378
00:19:17,790 --> 00:19:21,050
驚人的。 基思的演講很棒

379
00:19:21,120 --> 00:19:23,126
。 謝謝基思發送

380
00:19:23,158 --> 00:19:25,985
該信息。聊天中出現了一些評論

381
00:19:26,008 --> 00:19:28,978
。 所以，基思，如果你想在

382
00:19:28,984 --> 00:19:32,641
未來的某個時間參加問答，那麼可能會，但

383
00:19:32,696 --> 00:19:33,949
演講真的很酷。

