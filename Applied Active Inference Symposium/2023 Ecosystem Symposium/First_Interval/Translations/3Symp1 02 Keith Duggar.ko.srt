1
00:00:01,290 --> 00:00:04,494
좋습니다. 다음은

2
00:00:04,532 --> 00:00:06,606
사전 녹화된 동영상을 제출한 Keith Dugger입니다

3
00:00:06,628 --> 00:00:09,118
.  사전 녹화된 영상을

4
00:00:09,204 --> 00:00:11,694
능동 추론이라고 합니다.  그리고

5
00:00:11,732 --> 00:00:14,765
배우 모델에 대해서는

6
00:00:14,788 --> 00:00:15,920
지금 바로 언급하겠습니다.

7
00:00:29,430 --> 00:00:32,958
자, 여기

8
00:00:33,134 --> 00:00:35,910
능동 추론과 배우 모델에 대한 Keith의 사전 녹화된 비디오가 있습니다

9
00:00:35,990 --> 00:00:37,660
.

10
00:00:44,240 --> 00:00:46,956
능동적 추론과 행위자 모델.

11
00:00:47,138 --> 00:00:49,608
안녕하세요.  안녕하세요.  저는

12
00:00:49,704 --> 00:00:52,684
확장 현실 AI인 X Ray의 플랫폼 CTO인 Keith Thugger 박사입니다

13
00:00:52,732 --> 00:00:56,464
.  회사이자

14
00:00:56,502 --> 00:00:58,880
Machine Learning Street Talk 팟캐스트의 공동 진행자입니다.

15
00:00:59,780 --> 00:01:02,624
이제 우리 모두는

16
00:01:02,662 --> 00:01:05,536
능동 추론을 기반으로 한 생태계를 구축하기 위해 노력하고 있으므로

17
00:01:05,728 --> 00:01:08,324
소프트웨어는 분명히 능동 추론을

18
00:01:08,362 --> 00:01:11,363
최대한 활용하는 데 근본적인 역할을 할 것입니다

19
00:01:11,402 --> 00:01:13,204
.  우리는

20
00:01:13,242 --> 00:01:15,524


21
00:01:15,562 --> 00:01:17,636
능동적 추론의 원칙에 부합하는 소프트웨어 엔지니어링 패러다임을 사용해야 하며

22
00:01:17,668 --> 00:01:20,136
,

23
00:01:20,238 --> 00:01:22,664
우리의 요구에 맞게 만들어진 하나의 솔루션이 있다고 생각합니다.

24
00:01:22,702 --> 00:01:26,084
배우 모델이라고 합니다.  능동 추론

25
00:01:26,132 --> 00:01:28,356
과 행위자 모델은

26
00:01:28,388 --> 00:01:30,750
세계에 대해 깊게 연결된 두 가지 이해입니다.

27
00:01:31,280 --> 00:01:34,204
이는

28
00:01:34,242 --> 00:01:36,280
중첩 시스템의

29
00:01:36,360 --> 00:01:39,624


30
00:01:39,672 --> 00:01:42,672
생태계에서 상호 작용하는 자율 에이전트에 중점을 두고

31
00:01:42,726 --> 00:01:46,283
복잡한 시스템의 역학을 처리하기 위한 기본 프레임워크를 제공합니다.  나는

32
00:01:46,332 --> 00:01:47,916


33
00:01:48,108 --> 00:01:50,050
에이전트

34
00:01:50,500 --> 00:01:53,040
동시성, 자율성,

35
00:01:53,380 --> 00:01:57,300
불확실성 및 행동 적응의 역할을 포함하여 이들의 주요 연관성 중 일부를 탐구하고 싶습니다.

36
00:01:58,680 --> 00:02:00,596
우리는 능동 추론과

37
00:02:00,618 --> 00:02:03,184
능동 모델이 모두

38
00:02:03,232 --> 00:02:06,300
결정론적,

39
00:02:06,480 --> 00:02:10,392
중앙 집중식, 단계별 사고에서 계산과 인지 모두에 대한

40
00:02:10,446 --> 00:02:14,004
분산형 네트워크 동시

41
00:02:14,052 --> 00:02:17,751
관점으로의 패러다임 전환임을 알게 될 것입니다

42
00:02:17,806 --> 00:02:21,052
.

43
00:02:21,106 --> 00:02:25,100
Actor 모델에 대한 약간의 역사입니다.  1973년에

44
00:02:25,250 --> 00:02:28,504
칼 휴이트(Karl Hewitt), 피터 비숍(Peter Bishop), 리처드 스타이거(Richard

45
00:02:28,552 --> 00:02:30,555
Steiger)는 모두 매사추세츠 공과대학(

46
00:02:30,578 --> 00:02:33,676
Massachusetts Institute of Technology) AI

47
00:02:33,708 --> 00:02:37,804
연구소에서

48
00:02:37,852 --> 00:02:40,972


49
00:02:41,036 --> 00:02:44,304
구조와 적응 가능한

50
00:02:44,352 --> 00:02:46,020
알고리즘 실행을 모두 포함하는 동시 계산 개념인 기초화를 위해 연구하고 있었습니다.

51
00:02:47,480 --> 00:02:49,744
당시의 기존 방법에는

52
00:02:49,792 --> 00:02:52,224
견고성과 안전한 수학적

53
00:02:52,272 --> 00:02:55,263
기초가 부족했습니다.  그들의 공동 노력은

54
00:02:55,312 --> 00:02:57,576
궁극적으로 배우 모델의 탄생으로 이어졌습니다

55
00:02:57,598 --> 00:03:01,076
.  당시에는

56
00:03:01,108 --> 00:03:03,224


57
00:03:03,262 --> 00:03:05,764
향상된 오류

58
00:03:05,812 --> 00:03:08,784
허용성과 분산 계산

59
00:03:08,852 --> 00:03:12,236
능력이라는 특성으로 인해 혁명적인 것으로 간주되었습니다.  1980년대와

60
00:03:12,258 --> 00:03:15,388
1990년대에 걸쳐 Actor 모델은

61
00:03:15,394 --> 00:03:18,476
수많은 연구 프로젝트와

62
00:03:18,498 --> 00:03:20,856
실제 프로젝트의 기초가 되었으며

63
00:03:20,888 --> 00:03:23,184


64
00:03:23,222 --> 00:03:25,516
동시 계산에 대한 유연성과 직관적인 접근 방식으로 인기를 얻었습니다

65
00:03:25,548 --> 00:03:29,648
.  주로

66
00:03:29,734 --> 00:03:32,240
인공지능과 다중 에이전트

67
00:03:32,310 --> 00:03:34,400
시스템에 사용되었습니다.  익숙한 것 같나요?

68
00:03:35,880 --> 00:03:38,784
Actor, Saulson 및 Erlang과 같은 새로운 Actor 기반 언어는

69
00:03:38,912 --> 00:03:42,116


70
00:03:42,138 --> 00:03:44,356
모델을 개선하여 동시 컴퓨팅에 대한

71
00:03:44,378 --> 00:03:47,203
보다 강력하고 유연한 접근 방식을 형성하는 데 기여했으며 오늘날

72
00:03:47,332 --> 00:03:50,148


73
00:03:50,244 --> 00:03:52,164
컴퓨터 과학에서 여전히 살아 있습니다

74
00:03:52,212 --> 00:03:55,272
.  최근에는

75
00:03:55,326 --> 00:03:57,796


76
00:03:57,828 --> 00:03:59,944
분산

77
00:03:59,992 --> 00:04:02,904
시스템, 클라우드 컴퓨팅, 엣지

78
00:04:02,952 --> 00:04:05,036
컴퓨팅에 대한 수요가 증가하고

79
00:04:05,058 --> 00:04:07,310
사물 인터넷과 웹 30을 촉진하면서 행위자 모델이 새로운 관심을 받고 있습니다.

80
00:04:08,480 --> 00:04:11,351
이러한 컴퓨터 작업은

81
00:04:11,416 --> 00:04:13,436
ACA 모델의 아키텍처를 활용하는 데 이상적으로 적합합니다.

82
00:04:13,468 --> 00:04:16,800
이는 대용량 데이터의

83
00:04:16,950 --> 00:04:20,368
동시 처리

84
00:04:20,534 --> 00:04:23,409


85
00:04:23,800 --> 00:04:26,752
와 세분화된 서로 다른 자율

86
00:04:26,816 --> 00:04:28,710
시스템을 동시에 모델링하기 위해 정확하게 설계되었습니다.

87
00:04:29,640 --> 00:04:32,003
행위자 모델의 이러한 적용은 Twitter, Facebook, LinkedIn과 같은 빅 데이터 문제를 처리하기 위해 해당 원칙을 활용하는

88
00:04:32,042 --> 00:04:34,436
주요 회사에 깊은 영향을 미쳤습니다.

89
00:04:34,538 --> 00:04:36,904


90
00:04:36,942 --> 00:04:38,936


91
00:04:38,958 --> 00:04:41,348


92
00:04:41,524 --> 00:04:45,256
그렇다면 이것이

93
00:04:45,278 --> 00:04:47,636
능동적 추론과 어떤 관련이 있습니까?  나는

94
00:04:47,668 --> 00:04:49,368
당신이 이미

95
00:04:49,374 --> 00:04:51,656
도입부에서 비슷한 점을 들어본 적이 있을 것이라고 생각합니다.  먼저

96
00:04:51,688 --> 00:04:53,656


97
00:04:53,688 --> 00:04:56,396
행위자 모델의 몇 가지 핵심 원칙과 이러한

98
00:04:56,418 --> 00:04:58,568
원칙이 능동 추론 원칙과 어떻게 관련되는지 살펴보겠습니다

99
00:04:58,584 --> 00:05:01,236
.  격리의 개념부터 시작해 보겠습니다

100
00:05:01,288 --> 00:05:04,832
.  격리란

101
00:05:04,886 --> 00:05:07,664
행위자 모델의 행위자가 자신의

102
00:05:07,702 --> 00:05:10,464
상태를 다른 행위자와 공유하지 않는다는 것을 의미합니다

103
00:05:10,502 --> 00:05:14,212
.  메시지 수신을 통해서만 영향을 받을 수 있습니다

104
00:05:14,266 --> 00:05:17,060
.  그리고 응답으로 제한된 수의 메시지를 보내면

105
00:05:17,130 --> 00:05:19,524
다른 행위자의 상태 변화에만 영향을 미칠 수 있습니다

106
00:05:19,562 --> 00:05:22,164


107
00:05:22,202 --> 00:05:25,776
.  소프트웨어

108
00:05:25,808 --> 00:05:27,512
엔지니어링 관점에서 볼 때 이

109
00:05:27,566 --> 00:05:30,051
격리 원칙은

110
00:05:30,116 --> 00:05:33,111
작업의 잠재적인 부작용을 단일

111
00:05:33,166 --> 00:05:35,924
행위자로 제한하여 시스템의

112
00:05:35,972 --> 00:05:39,072
전반적인 예측 가능성 신뢰성을 향상시키며,

113
00:05:39,236 --> 00:05:42,104
가장 중요한 것은 완전히 수용할 경우

114
00:05:42,232 --> 00:05:44,910
실제로 설계를 단순화할 수 있다는 것입니다.

115
00:05:46,560 --> 00:05:48,636
다이어그램을 보면

116
00:05:48,658 --> 00:05:51,616
행위자가 특정 행위자에게 메시지를 보내고

117
00:05:51,638 --> 00:05:54,635
, 이 행위자가 다시

118
00:05:54,668 --> 00:05:57,040
다른 행위자에게 다시 메시지를 보내는 생태계를 볼 수 있습니다.

119
00:05:58,340 --> 00:06:00,690
능동적 추론은 어디에 있나요?  자, 메시지

120
00:06:01,300 --> 00:06:03,816
수신 및 전송을

121
00:06:03,868 --> 00:06:07,392
인식 활동 주기로 재구성하여

122
00:06:07,536 --> 00:06:09,620
외부,

123
00:06:10,200 --> 00:06:13,539
내부, 감각 및

124
00:06:13,610 --> 00:06:17,112
활성 상태를 표시해 보겠습니다.  이제 우리는

125
00:06:17,166 --> 00:06:19,956


126
00:06:19,988 --> 00:06:22,600
Markov 담요라는 능동적 추론에 필요한 기초를 확실히 갖게 되었습니다.

127
00:06:23,660 --> 00:06:26,436
행위자 모델의 행위자는

128
00:06:26,468 --> 00:06:28,848
능동 추론 에이전트에 직접 매핑됩니다

129
00:06:28,884 --> 00:06:32,840
.  또한

130
00:06:33,000 --> 00:06:35,676
행위자가

131
00:06:35,698 --> 00:06:39,003
응답으로 제한된 수의 메시지만 보낼 수 있다는 유한성

132
00:06:39,042 --> 00:06:41,150
도 중요한 공유 속성입니다.

133
00:06:41,940 --> 00:06:44,780
능동 추론은 현실을 모델링하기 때문에

134
00:06:44,940 --> 00:06:47,452
반드시

135
00:06:47,516 --> 00:06:50,704
실제 시스템의 리소스 제약을 존중합니다.  그리고 이는 활성 모델

136
00:06:50,742 --> 00:06:53,376
의 기초에 훌륭하게 반영되어 있습니다

137
00:06:53,398 --> 00:06:56,496
.  또 다른 핵심

138
00:06:56,528 --> 00:06:59,860
원칙인 비동기 메시지 전달을 살펴보겠습니다.

139
00:07:00,840 --> 00:07:03,012
행위자 간의 통신은

140
00:07:03,066 --> 00:07:05,936
비동기식입니다.  이는 행위자가 메시지를 보낸

141
00:07:05,968 --> 00:07:07,832
후 응답을 기다리지 않는다는 것을 의미합니다

142
00:07:07,886 --> 00:07:10,680
.  그것은 계속해서 일하고,

143
00:07:10,830 --> 00:07:13,210
그대로 살아갑니다.

144
00:07:13,820 --> 00:07:17,256
이는 액터를 분리하여

145
00:07:17,278 --> 00:07:20,284


146
00:07:20,322 --> 00:07:23,020


147
00:07:23,090 --> 00:07:25,948
시스템의 일부가

148
00:07:26,034 --> 00:07:28,551
느리거나 일시적으로 사용할

149
00:07:28,616 --> 00:07:31,964
수 없는 경우에도 계속 기능하고 유지하며 발전할 수 있는 시스템으로 이어지기 때문에 매우 중요합니다.  프리스턴 교수는

150
00:07:32,012 --> 00:07:34,028
자유 에너지 원리가

151
00:07:34,124 --> 00:07:38,240


152
00:07:38,310 --> 00:07:41,490
사물이 존재한다면 무엇을 해야 하는지에 대한 궁극적인 실존적 질문이라고 말했습니다.

153
00:07:42,660 --> 00:07:45,412
글쎄요, 배우 모델은

154
00:07:45,466 --> 00:07:47,350
다른 사람을 기다려서는 안 된다고 주장합니다.

155
00:07:48,360 --> 00:07:51,572
물론 배우는 다른 사람을 기다리기로 선택할 수

156
00:07:51,626 --> 00:07:55,284
있지만,

157
00:07:55,322 --> 00:07:58,808
모델에서는 그렇게 강요해서는 안 된다.  자유롭게

158
00:07:58,894 --> 00:07:59,770
선택할 수 있어야 합니다.

159
00:08:01,820 --> 00:08:04,004
이는 두 모델이 자율성을 공유한다는 또 다른 중요한 원칙으로 이어집니다

160
00:08:04,052 --> 00:08:06,456


161
00:08:06,558 --> 00:08:09,719
.  자유 에너지

162
00:08:09,790 --> 00:08:12,860
원리는 물리적 현실의 모델

163
00:08:13,280 --> 00:08:15,547
이며 우리의 현실은 결국

164
00:08:15,634 --> 00:08:18,904
동시적입니다.  무한한 공간 전체에서

165
00:08:18,952 --> 00:08:21,572
시스템은

166
00:08:21,656 --> 00:08:24,048
로컬 역학에 따라 동시에 진화하고 있습니다

167
00:08:24,134 --> 00:08:27,696
.  그러므로 이것은

168
00:08:27,718 --> 00:08:29,344
자유 에너지 원리의 핵심에 반영됩니다

169
00:08:29,382 --> 00:08:33,024
.  물론

170
00:08:33,062 --> 00:08:35,796
계산 모델이 물리학에만 국한될 필요는 없습니다

171
00:08:35,818 --> 00:08:38,784
.  그러나 Hewitt et al.  우리는

172
00:08:38,832 --> 00:08:41,395


173
00:08:41,418 --> 00:08:43,664
분산 동시 시스템의 현실을 모델링하는 모델을 개발하려고 했습니다

174
00:08:43,712 --> 00:08:47,056
.  그리고 다행스럽게도 행위자

175
00:08:47,088 --> 00:08:50,824
모델은 격리 원칙과 행위자 자율성의 원칙에서 볼 수 있는 동시성을 모두 수용하여

176
00:08:50,862 --> 00:08:53,352


177
00:08:53,486 --> 00:08:56,500


178
00:08:56,580 --> 00:08:58,040
능동 추론과 호환됩니다.

179
00:08:59,200 --> 00:09:01,820
다음으로 중첩에 대해 설명합니다.

180
00:09:02,640 --> 00:09:05,532
행위자 모델을 통해 행위자는

181
00:09:05,586 --> 00:09:08,552
유한한

182
00:09:08,616 --> 00:09:11,984
수의 메시지를 수신하고 전송하여 인식하고 행동할 수 있을 뿐만 아니라

183
00:09:12,182 --> 00:09:15,292
행위로서

184
00:09:15,356 --> 00:09:18,240
유한한 수의 새로운 행위자를 생성할 수도 있습니다.

185
00:09:19,220 --> 00:09:21,504
이러한 액터는

186
00:09:21,542 --> 00:09:24,336
부모(예: 동물 세포의 일부) 내에 중첩되거나 독립 액터로 환경

187
00:09:24,368 --> 00:09:26,564
에 방출될 수 있습니다

188
00:09:26,602 --> 00:09:29,076
.

189
00:09:29,098 --> 00:09:32,336
그때부터 이 원칙은 모델이

190
00:09:32,368 --> 00:09:34,628


191
00:09:34,714 --> 00:09:37,960
다중 규모 중첩 및 활성 추론이라는 아름다운 개념에 잘 들어맞습니다.

192
00:09:38,940 --> 00:09:41,460
이를 통해 행위자는

193
00:09:41,540 --> 00:09:44,791


194
00:09:44,846 --> 00:09:47,290
아래쪽과 위쪽 모두에서 행위자의 생태계를 포함할 수 있습니다.

195
00:09:49,200 --> 00:09:51,976
마지막으로 행위자

196
00:09:52,008 --> 00:09:55,436
모델 설계 원칙인 행동 변화

197
00:09:55,618 --> 00:09:57,020
와 지속성을 두 가지 더 다루고 싶습니다.

198
00:09:59,040 --> 00:10:01,664
행위자는

199
00:10:01,702 --> 00:10:04,450
메시지에 응답하여 자신의 행동을 변경할 수 있는 능력이 있습니다.

200
00:10:05,140 --> 00:10:08,192
이러한 적응성을 통해

201
00:10:08,246 --> 00:10:10,924


202
00:10:10,972 --> 00:10:14,130
시간이 지남에 따라 발전할 수 있는 복잡한 상태 저장 엔터티를 구축할 수 있습니다.

203
00:10:14,760 --> 00:10:17,492
그리고 실제로 전체

204
00:10:17,626 --> 00:10:21,584
생태계가 새로운 새로운

205
00:10:21,632 --> 00:10:25,263
행동을 진화시킬 수 있습니다.  소프트웨어 엔지니어링에 사용하면

206
00:10:25,312 --> 00:10:28,264


207
00:10:28,382 --> 00:10:31,800
복잡한 동적 시스템을 관리하기 위한 강력한 도구가 추가됩니다.

208
00:10:32,700 --> 00:10:35,412
물론 능동적 추론은

209
00:10:35,476 --> 00:10:39,304
이를 극단적으로 포용합니다.  사물성의 본질은

210
00:10:39,352 --> 00:10:42,363


211
00:10:42,402 --> 00:10:45,324
환경을 예측하고 그에 적응하여

212
00:10:45,362 --> 00:10:48,439


213
00:10:48,520 --> 00:10:52,828
맹렬한 활동의 ​​바다에서 자신의 마르코프 담요를 유지하기 위해 계속 존재하려는 지속적인 시도입니다

214
00:10:53,004 --> 00:10:56,736
.

215
00:10:56,758 --> 00:10:58,912
이와 함께 지속성이라는 개념도 등장합니다

216
00:10:58,966 --> 00:11:02,444
.  지속성을 통해 행위자는

217
00:11:02,492 --> 00:11:05,524
자신의 상태를 저장하고

218
00:11:05,562 --> 00:11:08,640
나중에

219
00:11:08,720 --> 00:11:11,300
기억의 원리를 구현하는 기능을 복원하거나 수정할 수 있습니다.

220
00:11:11,800 --> 00:11:14,675
기억은 학습과 적응의 전제조건입니다

221
00:11:14,778 --> 00:11:18,504
.  에이전트의 예측 능력은

222
00:11:18,622 --> 00:11:21,640


223
00:11:21,710 --> 00:11:24,356
과거 경험을 기억하여 예상치 못한 것과

224
00:11:24,388 --> 00:11:27,176
관련된 놀라움을 최소화하는 능력에 따라 달라집니다

225
00:11:27,198 --> 00:11:30,520
.  에이전트가

226
00:11:30,600 --> 00:11:34,056


227
00:11:34,088 --> 00:11:36,199


228
00:11:36,280 --> 00:11:39,100
경험이나 상속을 통해

229
00:11:39,440 --> 00:11:41,470
세계 모델에 기여하는 귀납적 사전 요인을 가지고 있다고 가정할 때 기억의 중요한 역할도 강조됩니다.

230
00:11:42,340 --> 00:11:44,464
이 세계 모델은

231
00:11:44,502 --> 00:11:47,291
현재의 행동을 안내하고

232
00:11:47,356 --> 00:11:50,028


233
00:11:50,204 --> 00:11:52,939
지속적인 적응

234
00:11:53,020 --> 00:11:54,240
과 존재에 기여하는 새로운 경험을 기반으로 지속적으로 업데이트됩니다.

235
00:11:56,600 --> 00:11:59,684
알았어, 좋아.

236
00:11:59,722 --> 00:12:02,308
행위자 모델과 능동적 추론 사이에는 명확하고 깊은 연관성이 있다고 말씀하셨습니다

237
00:12:02,394 --> 00:12:06,424
.  하지만

238
00:12:06,462 --> 00:12:08,756
이것이 활발한 추론 커뮤니티에서 우리에게 어떻게 도움이 될까요

239
00:12:08,788 --> 00:12:11,988
?  글쎄요, 첫째,

240
00:12:12,084 --> 00:12:14,084
제 생각에는 이것이

241
00:12:14,132 --> 00:12:16,520
우리가 수용해야 할 소프트웨어 엔지니어링 패러다임입니다.

242
00:12:16,860 --> 00:12:19,340
그리고 그렇게 한다면

243
00:12:19,410 --> 00:12:21,815


244
00:12:21,848 --> 00:12:25,448
ACA,

245
00:12:25,624 --> 00:12:29,752
Orleans, Thespian Actix

246
00:12:29,896 --> 00:12:33,055
Protoactor 등과 같이 사용할 수 있는 액터 모델 라이브러리 및 프레임워크가 있으며, 이는

247
00:12:33,078 --> 00:12:35,516
활성

248
00:12:35,548 --> 00:12:37,872
추론 소프트웨어 모듈 및

249
00:12:37,926 --> 00:12:41,596
애플리케이션을 구축할 때 즉시 사용할 수 있습니다.

250
00:12:41,708 --> 00:12:43,944


251
00:12:44,012 --> 00:12:46,016


252
00:12:46,048 --> 00:12:49,380
Zero,

253
00:12:49,450 --> 00:12:52,640
MQ, tokyo 및 Rust,

254
00:12:52,800 --> 00:12:56,284
Erlang, Async, Await 및 C. Sharp 등과 같은 행위자 모델 원칙과 매우 잘 일치하는 라이브러리, 언어 및 언어 기능도 있습니다

255
00:12:56,432 --> 00:13:00,104
.  그러나

256
00:13:00,142 --> 00:13:04,712
오늘날 우리가 사용할 수 있는 도구보다 더 중요한 것은

257
00:13:04,766 --> 00:13:07,544


258
00:13:07,582 --> 00:13:10,136


259
00:13:10,168 --> 00:13:13,996
미래의 능동적 추론 소프트웨어를 만드는 데 지침이 될 소프트웨어 설계 사고방식입니다.

260
00:13:14,018 --> 00:13:16,764
행위자 모델은 능동적 추론에 가장 완벽하게 일치하는 소프트웨어 설계 및 엔지니어링의 패러다임을 제공합니다

261
00:13:16,802 --> 00:13:20,588


262
00:13:20,754 --> 00:13:24,064


263
00:13:24,102 --> 00:13:28,160
.  이는

264
00:13:28,580 --> 00:13:30,876


265
00:13:30,908 --> 00:13:34,084
앞서 논의한 핵심 원칙의 정렬뿐만 아니라

266
00:13:34,122 --> 00:13:37,055


267
00:13:37,088 --> 00:13:39,156
행위자 모델의 능동적 추론이

268
00:13:39,178 --> 00:13:42,916
서로에게 제공하는 통찰력에서도 분명합니다.  예를 들어,

269
00:13:42,938 --> 00:13:46,604
현재 휴이트의 법칙이라고 불리는 것을 생각해 보십시오.

270
00:13:46,672 --> 00:13:49,800
모든 것이 어디에나 있다는 비공식적으로 표현된

271
00:13:51,260 --> 00:13:54,824
이 법칙은

272
00:13:54,942 --> 00:13:57,844
진정한 비동기식 분산 시스템에서는

273
00:13:57,892 --> 00:14:00,652


274
00:14:00,706 --> 00:14:03,532
메시지가 한 곳에서 다른 곳으로 이동하는 데 임의의 시간이 걸릴 수

275
00:14:03,586 --> 00:14:07,032
있으며 모든 행위자가

276
00:14:07,096 --> 00:14:10,364
해당 이벤트에 대비해야 한다는 아이디어를 의미합니다.

277
00:14:10,402 --> 00:14:13,900


278
00:14:13,980 --> 00:14:17,888
이러한 시스템에는 즉각적인 것이 없으며 어떤 구성 요소도

279
00:14:17,974 --> 00:14:20,384


280
00:14:20,422 --> 00:14:23,548
다른 구성 요소의 작업 타이밍에 대해 가정할 수 없습니다.  실제로

281
00:14:23,734 --> 00:14:26,980
메시지가 절대 도착하지 않을 것처럼 행동해야 합니다

282
00:14:27,050 --> 00:14:30,819
.  이는 중요한 의미를 갖습니다

283
00:14:30,890 --> 00:14:34,644
.  이는 정보가 시스템 전체에 전파되지 않았을 수도 있기 때문에 주어진 시간에 전체 시스템

284
00:14:34,682 --> 00:14:36,744


285
00:14:36,782 --> 00:14:39,176
의 상태를 정확하고 일관되게 확인하는 것이 불가능하다는 것을 의미합니다

286
00:14:39,198 --> 00:14:42,569


287
00:14:43,260 --> 00:14:45,464


288
00:14:45,502 --> 00:14:48,410
.

289
00:14:49,760 --> 00:14:52,904
또한 전역 동기화를 구현하려는 시도는

290
00:14:52,952 --> 00:14:55,400
필연적으로

291
00:14:55,480 --> 00:14:57,864
병목 현상을 일으키고

292
00:14:57,912 --> 00:15:01,844
효율성을 저하시킵니다.  휴이트의 법칙은

293
00:15:01,912 --> 00:15:04,976


294
00:15:04,998 --> 00:15:07,580


295
00:15:07,660 --> 00:15:09,504
이러한 피할 수 없는 지연과

296
00:15:09,542 --> 00:15:11,776
불확실성을 효과적으로 처리할 수 있는 방식으로 시스템을 설계해야 한다는 점을 강조하고

297
00:15:11,798 --> 00:15:14,424
강력한 비차단

298
00:15:14,492 --> 00:15:17,540
통신 메커니즘과 로컬 의사 결정

299
00:15:17,690 --> 00:15:21,284
능력의 중요성을 강조합니다.  간단히 말해서,

300
00:15:21,482 --> 00:15:24,240
Hector 모델 시스템은 본질적으로

301
00:15:24,400 --> 00:15:27,944
비결정적입니다.

302
00:15:27,982 --> 00:15:31,800
익숙한 것 같나요?

303
00:15:32,140 --> 00:15:34,616
불확실성 하에서의 운영과 환경

304
00:15:34,638 --> 00:15:36,904
에도 불구하고 계속되는 자율성을 강조하는 또 다른 패러다임은 무엇입니까

305
00:15:36,942 --> 00:15:40,328
?  능동 추론과

306
00:15:40,334 --> 00:15:43,767
자유 에너지 원리?  능동적 추론은 소프트웨어 시스템이 작동하는

307
00:15:43,864 --> 00:15:46,552
예측할 수 없는 세계의 현실을 반영합니다

308
00:15:46,616 --> 00:15:48,792


309
00:15:48,856 --> 00:15:51,920
.  무작위적이고

310
00:15:51,990 --> 00:15:55,136


311
00:15:55,158 --> 00:15:57,756


312
00:15:57,868 --> 00:16:01,644
예측할 수 없는 순서로 이벤트가 발생하기 때문에 동일한 초기 조건에서도 다른 결과가 발생할 수 있습니다.  이것은

313
00:16:01,692 --> 00:16:04,310
우리 모두가 잘 알고 있는 놀라움의 개념으로,

314
00:16:05,000 --> 00:16:07,572
에이전트가

315
00:16:07,626 --> 00:16:10,404


316
00:16:10,442 --> 00:16:13,060
수신한 감각 입력이 예측과 일치하지 않을 때 에이전트가 세상에 대한 믿음을 업데이트하는 것입니다.

317
00:16:13,720 --> 00:16:15,856
행위자 모델과 능동

318
00:16:15,888 --> 00:16:18,328
추론 모두 세상이 예측 불가능하다는 점을 인정합니다

319
00:16:18,414 --> 00:16:21,624
.

320
00:16:21,662 --> 00:16:24,632
모델은 이를 인정하는 것 이상으로 이러한

321
00:16:24,686 --> 00:16:27,688
불확실성을 관리할 대상이 아니라 주어진 것으로 받아들입니다

322
00:16:27,774 --> 00:16:29,530
.

323
00:16:30,780 --> 00:16:33,752
실제로 우리가 자유 에너지 원리에서 알고 있듯이

324
00:16:33,806 --> 00:16:36,204


325
00:16:36,242 --> 00:16:38,459
모델에서 유지되는 불확실성은 우리에게

326
00:16:38,530 --> 00:16:41,020
적응할 수 있는 유연성을 제공합니다.

327
00:16:43,540 --> 00:16:46,555
아마도 이것은 내 개인적인 환상일지도 모르지만

328
00:16:46,588 --> 00:16:49,199
, 나는

329
00:16:49,270 --> 00:16:51,596
능동 추론에 의해 유도되는 소프트웨어 모듈이

330
00:16:51,628 --> 00:16:54,976
하드 코딩된 오류 처리를 없애고

331
00:16:55,008 --> 00:16:57,792


332
00:16:57,856 --> 00:17:00,672


333
00:17:00,736 --> 00:17:03,200
오류 환경이 발전함에 따라 스스로를 최적화하는 확률적 학습 알고리즘으로 교체되는 미래를 상상합니다

334
00:17:03,280 --> 00:17:07,316
.  사후적 재해 복구보다는 예측적 재해 방지에 중점을 두고 단일 장애 지점이 없는 강력

335
00:17:07,428 --> 00:17:11,268
하고 자체 치유되는 분산 시스템인 모듈입니다

336
00:17:11,364 --> 00:17:13,672


337
00:17:13,726 --> 00:17:17,716


338
00:17:17,907 --> 00:17:21,659
.

339
00:17:23,040 --> 00:17:25,308
미래를 내다보면, 커뮤니티로서 우리는

340
00:17:25,314 --> 00:17:28,044


341
00:17:28,082 --> 00:17:31,700
활성 각인 이론

342
00:17:31,880 --> 00:17:34,576
과

343
00:17:34,598 --> 00:17:37,611
행위자 모델의 실제 구현 모두의 경계를 넓힐 수 있는 잠재력을 가지고 있습니다.

344
00:17:37,676 --> 00:17:40,096
이 두 패러다임의 장점을 함께 활용함으로써 우리는

345
00:17:40,118 --> 00:17:42,860
강력하고

346
00:17:43,020 --> 00:17:45,876
적응력이 뛰어나며

347
00:17:45,898 --> 00:17:48,500
실제로 작동하는 물리적 세계에 더욱 잘 맞는 소프트웨어 시스템을 만들 수 있습니다

348
00:17:48,650 --> 00:17:52,100
.  행위자 모델에서

349
00:17:52,170 --> 00:17:54,976
능동 추론을 사용하는 소프트웨어 구성 요소가

350
00:17:55,008 --> 00:17:57,112


351
00:17:57,166 --> 00:18:00,344
잠재적인 문제를 예측하고 과거의 실수로부터 학습하며

352
00:18:00,382 --> 00:18:04,024


353
00:18:04,062 --> 00:18:07,144
환경 변화에 실시간으로 적응할 수 있는 미래를 상상해 보세요.  이러한

354
00:18:07,182 --> 00:18:09,212
접근 방식을 통해 우리는

355
00:18:09,266 --> 00:18:11,996
근본적으로 더 탄력적이고

356
00:18:12,018 --> 00:18:15,084
효율적인 시스템을 구축할 수 있습니다.  제 생각에는 이는

357
00:18:15,122 --> 00:18:17,784
소프트웨어 신뢰성

358
00:18:17,912 --> 00:18:21,052
과 성능, 확장성에 단계적 변화를 가져올 수 있으며

359
00:18:21,106 --> 00:18:24,044
컴퓨팅의 새로운 시대를 예고하고

360
00:18:24,092 --> 00:18:27,264
생물학과 인지의 원리를

361
00:18:27,302 --> 00:18:30,060
소프트웨어 시스템의 구조에 접목하여

362
00:18:30,220 --> 00:18:32,416
그 과정에서 생명력을 더 가깝게 만들 수 있습니다

363
00:18:32,438 --> 00:18:36,420
.  결론적으로, 행위자 모델에 대한

364
00:18:37,160 --> 00:18:39,636
능동 추론의 결합은

365
00:18:39,658 --> 00:18:42,803


366
00:18:42,842 --> 00:18:44,564


367
00:18:44,602 --> 00:18:46,820
소프트웨어 설계와 엔지니어링을 살펴볼 수 있는 강력하고 새로운 렌즈를 제공합니다.  능동적 추론에 맞춰

368
00:18:47,180 --> 00:18:49,412
기존 언어

369
00:18:49,476 --> 00:18:51,476
와 라이브러리를 활용하든,

370
00:18:51,508 --> 00:18:54,728
새로운 언어와 라이브러리를 개발하든

371
00:18:54,894 --> 00:18:58,056
우리는 흥미로운 개척의 문턱에 서 있습니다

372
00:18:58,078 --> 00:19:01,944
.  그럼

373
00:19:01,992 --> 00:19:05,068
오늘의 기회를 잡고 행위자 모델

374
00:19:05,154 --> 00:19:06,776
과 능동 추론과의 관계를 살펴보고

375
00:19:06,808 --> 00:19:09,484


376
00:19:09,522 --> 00:19:11,980
지능형 분산 컴퓨팅의 미래를 만들어 보겠습니다.

377
00:19:13,040 --> 00:19:14,460
들어 주셔서 감사합니다.

378
00:19:17,790 --> 00:19:21,050
엄청난.  Keith의 훌륭한 연설

379
00:19:21,120 --> 00:19:23,126
.  보내주신 Keith님, 감사합니다

380
00:19:23,158 --> 00:19:25,985
. 채팅에 몇 가지 댓글이 있었습니다

381
00:19:26,008 --> 00:19:28,978
.  Keith 씨,

382
00:19:28,984 --> 00:19:32,641
나중에 A-Q-A에 참여하고 싶으시다면

383
00:19:32,696 --> 00:19:33,949
정말 멋진 프레젠테이션이 될 것 같아요.

