1
00:00:00,840 --> 00:00:02,820
以此为基础，

2
00:00:02,820 --> 00:00:05,880
今晚与我们分享，所以

3
00:00:05,880 --> 00:00:07,859
非常感谢您邀请我直到

4
00:00:07,859 --> 00:00:09,900
下次再见，谢谢您，再见，

5
00:00:09,900 --> 00:00:12,179


6
00:00:12,179 --> 00:00:14,480


7
00:00:16,800 --> 00:00:19,440


8
00:00:19,440 --> 00:00:20,699
好吧，很棒的

9
00:00:20,699 --> 00:00:23,640
谈话，购买这个，现在

10
00:00:23,640 --> 00:00:25,980
欢迎阿什温，

11
00:00:25,980 --> 00:00:27,359
你好吗，嗨，

12
00:00:27,359 --> 00:00:29,820
丹尼尔，我很好 对于你

13
00:00:29,820 --> 00:00:31,260
来说，

14
00:00:31,260 --> 00:00:33,320


15
00:00:33,559 --> 00:00:37,559
嗯，是的，听起来不错，嗯，是的，

16
00:00:37,559 --> 00:00:39,719
期待你的关于

17
00:00:39,719 --> 00:00:42,420
pi mdp 复杂推理的研讨会，

18
00:00:42,420 --> 00:00:46,440
所以它可以是 um 长达 90 分钟，或者

19
00:00:46,440 --> 00:00:48,239
如果时间较短也完全可以，我们可以

20
00:00:48,239 --> 00:00:51,420
短暂休息一下，但请嗯

21
00:00:51,420 --> 00:00:53,100
把它拿走，让我知道，

22
00:00:53,100 --> 00:00:54,600
但是我可以提供帮助，

23
00:00:54,600 --> 00:00:55,739
非常

24
00:00:55,739 --> 00:00:57,480
感谢，

25
00:00:57,480 --> 00:01:00,539
也许我会分享我的屏幕并开始，

26
00:01:00,539 --> 00:01:02,280
所以

27
00:01:02,280 --> 00:01:04,860
关于我们在这里所做的事情的结构，

28
00:01:04,860 --> 00:01:05,820


29
00:01:05,820 --> 00:01:08,760
我假设稍后看到这个的人

30
00:01:08,760 --> 00:01:11,040
可能想尝试一下

31
00:01:11,040 --> 00:01:13,080
结合教程或其他内容进行实践，这就是

32
00:01:13,080 --> 00:01:15,780
我牢记的结构，

33
00:01:15,780 --> 00:01:19,380
所以我会慢慢讲，请耐心听我说，所以

34
00:01:19,380 --> 00:01:21,180
呃欢迎大家参加这个关于

35
00:01:21,180 --> 00:01:23,340


36
00:01:23,340 --> 00:01:26,640
IMDb 中复杂推理的会议，所以在这里我们将 尝试对

37
00:01:26,640 --> 00:01:28,920
一些复杂的推理

38
00:01:28,920 --> 00:01:31,080
模拟进行建模，尤其是

39
00:01:31,080 --> 00:01:33,960
原始论文中使用 prime DP 模块的模型，

40
00:01:33,960 --> 00:01:36,299
以及它现在不是我的 mdp 的一部分，

41
00:01:36,299 --> 00:01:38,700
但我们正在

42
00:01:38,700 --> 00:01:40,560
向 prime DB 模块添加复杂的推理

43
00:01:40,560 --> 00:01:43,320
，我正在 我将主要

44
00:01:43,320 --> 00:01:46,340
讨论我开发的

45
00:01:46,340 --> 00:01:49,079
用于添加该功能的代码，

46
00:01:49,079 --> 00:01:52,920
所以我是 Ashwin Paul，我最终是

47
00:01:52,920 --> 00:01:56,040
莫纳什大学的博士候选人，

48
00:01:56,040 --> 00:01:58,259
我主要使用主动推理

49
00:01:58,259 --> 00:02:00,360
模型并尝试了解

50
00:02:00,360 --> 00:02:03,840
如何使用它们 作为一个可解释的模型，

51
00:02:03,840 --> 00:02:05,240


52
00:02:05,240 --> 00:02:07,380
基本上可以理解

53
00:02:07,380 --> 00:02:10,020
智能行为的出现，所以让我们深入研究

54
00:02:10,020 --> 00:02:12,360


55
00:02:12,360 --> 00:02:16,140
我所做的材料，以便介绍自由能

56
00:02:16,140 --> 00:02:18,180
原理，我相信你们所有人

57
00:02:18,180 --> 00:02:20,280
现在都了解

58
00:02:20,280 --> 00:02:23,220
它是什么，但核心是 想法是，一个

59
00:02:23,220 --> 00:02:26,700
代理总是试图最小化

60
00:02:26,700 --> 00:02:28,920
它的观察的熵，所以

61
00:02:28,920 --> 00:02:31,800
如果一个观察

62
00:02:31,800 --> 00:02:34,680
在你的脑海中具有非常低的概率，并且

63
00:02:34,680 --> 00:02:36,720
这种情况发生，那么你可能会感到

64
00:02:36,720 --> 00:02:39,660
惊讶，反之亦然，所以

65
00:02:39,660 --> 00:02:41,940
这里的熵 被定义

66
00:02:41,940 --> 00:02:44,420
为信息论熵，

67
00:02:44,420 --> 00:02:47,400
如果你的概率很低，那么

68
00:02:47,400 --> 00:02:49,260
自动这是一个高惊喜或

69
00:02:49,260 --> 00:02:51,000
高熵观察

70
00:02:51,000 --> 00:02:53,700
，众所周知，主动推理

71
00:02:53,700 --> 00:02:56,580
也为我们提供了一种方法来定义

72
00:02:56,580 --> 00:02:58,980
我们所说的代理环境循环，

73
00:02:58,980 --> 00:03:02,040
这让 我们定义

74
00:03:02,040 --> 00:03:04,140
我们正在查看的代理是什么，以及

75
00:03:04,140 --> 00:03:08,180
代理在给定

76
00:03:08,180 --> 00:03:11,099
周围环境的情况下的行为是什么，等等，这样

77
00:03:11,099 --> 00:03:12,959
您也熟悉

78
00:03:12,959 --> 00:03:15,300
Marco 毯子的想法，这很重要，

79
00:03:15,300 --> 00:03:18,000
因为我们始终必须记住 我的意思是

80
00:03:18,000 --> 00:03:20,040
必须记住

81
00:03:20,040 --> 00:03:21,599
生成过程和

82
00:03:21,599 --> 00:03:25,260
生成模型之间的区别，这是不

83
00:03:25,260 --> 00:03:27,599
活跃婴儿文学中一个非常著名的混淆点，

84
00:03:27,599 --> 00:03:29,280
对于那些一开始就

85
00:03:29,280 --> 00:03:31,080
试图理解它的人来说，

86
00:03:31,080 --> 00:03:33,540
所以核心

87
00:03:33,540 --> 00:03:35,580
问题是，如何 代理呃

88
00:03:35,580 --> 00:03:37,800
最小化熵，因为

89
00:03:37,800 --> 00:03:39,900
代理如何知道哪个观察

90
00:03:39,900 --> 00:03:42,420
是慢的或高概率的，

91
00:03:42,420 --> 00:03:44,519
所以这是通过维护生成

92
00:03:44,519 --> 00:03:46,920
模型，生成模型会

93
00:03:46,920 --> 00:03:49,319
告诉你哪个是高概率

94
00:03:49,319 --> 00:03:51,360
观察，哪个是低

95
00:03:51,360 --> 00:03:53,519
概率观察，所以 这个想法是，

96
00:03:53,519 --> 00:03:56,459
代理可以访问的所有内容都是

97
00:03:56,459 --> 00:03:58,799
来自

98
00:03:58,799 --> 00:04:00,599
代理

99
00:04:00,599 --> 00:04:03,299
无法直接观察的生成过程的观察，并且呃，

100
00:04:03,299 --> 00:04:05,459
智能代理将尝试

101
00:04:05,459 --> 00:04:08,220
在其头脑中建立一个生成模型，呃，这是

102
00:04:08,220 --> 00:04:09,060


103
00:04:09,060 --> 00:04:11,640
隐藏的模型 状态和

104
00:04:11,640 --> 00:04:14,340
它可以访问的观察结果，它可以

105
00:04:14,340 --> 00:04:16,260
希望

106
00:04:16,260 --> 00:04:18,660
使用这个生成模型正确地计算概率，但

107
00:04:18,660 --> 00:04:21,060
存在一个问题，一般来说，

108
00:04:21,060 --> 00:04:23,460


109
00:04:23,460 --> 00:04:25,320
边缘化

110
00:04:25,320 --> 00:04:26,880
生成模型中的观察结果的概率是一个棘手的问题，

111
00:04:26,880 --> 00:04:29,100
并且 这就是为什么我们必须定义

112
00:04:29,100 --> 00:04:31,620


113
00:04:31,620 --> 00:04:33,720
代理试图最小化的惊喜的上限，并且

114
00:04:33,720 --> 00:04:35,400
出现了自由能的概念，所以

115
00:04:35,400 --> 00:04:37,620
代理

116
00:04:37,620 --> 00:04:40,560
最小化的这个上限就是自由能，这就是

117
00:04:40,560 --> 00:04:42,840
为什么它是自由能原理

118
00:04:42,840 --> 00:04:44,880
这里我们有一个新术语，称为资本

119
00:04:44,880 --> 00:04:48,000
Qs，它可以解释为

120
00:04:48,000 --> 00:04:49,740
相信代理维持

121
00:04:49,740 --> 00:04:51,900
其生成模型中的隐藏步骤，

122
00:04:51,900 --> 00:04:54,840
这个量就是自由

123
00:04:54,840 --> 00:04:57,479
能，传统上我们看到这种

124
00:04:57,479 --> 00:04:59,100
变分自由能被

125
00:04:59,100 --> 00:05:00,660
解释为

126
00:05:00,660 --> 00:05:02,880
呃 在大多数机器学习方式中，

127
00:05:02,880 --> 00:05:05,040
它是

128
00:05:05,040 --> 00:05:07,259
模型的复杂性和准确性之间的平衡，因此当

129
00:05:07,259 --> 00:05:09,300
最小化自由能时，代理

130
00:05:09,300 --> 00:05:11,520
试图提出一个单一的模型，

131
00:05:11,520 --> 00:05:13,320
但同时也是一个准确的模型，

132
00:05:13,320 --> 00:05:15,419
因为这里它是一个负号

133
00:05:15,419 --> 00:05:16,860
正确率也可以

134
00:05:16,860 --> 00:05:19,919
用物理方式来解释，即

135
00:05:19,919 --> 00:05:23,039
代理总是试图最小化

136
00:05:23,039 --> 00:05:25,979
模型的能量，但同时

137
00:05:25,979 --> 00:05:27,720
最大化模型的熵，

138
00:05:27,720 --> 00:05:29,580
这

139
00:05:29,580 --> 00:05:32,280
与经典的最大熵原理等相结合

140
00:05:32,280 --> 00:05:35,340
文献中认为，

141
00:05:35,340 --> 00:05:37,740
生成模型的想法非常

142
00:05:37,740 --> 00:05:38,820
重要，

143
00:05:38,820 --> 00:05:41,220
从软件的角度来看，这是

144
00:05:41,220 --> 00:05:42,840
您可能想要

145
00:05:42,840 --> 00:05:44,580
做的第一件事，为代理定义一个生成模型，该模型

146
00:05:44,580 --> 00:05:46,440


147
00:05:46,440 --> 00:05:47,100


148
00:05:47,100 --> 00:05:49,259
是否被通知

149
00:05:49,259 --> 00:05:51,720
取决于 实验

150
00:05:51,720 --> 00:05:53,460
你试图建模所以在经典的

151
00:05:53,460 --> 00:05:56,060
主动推理中，决策通常

152
00:05:56,060 --> 00:05:58,979
是根据策略来定义的，

153
00:05:58,979 --> 00:06:02,220
例如，如果你是这个环境中的代理，

154
00:06:02,220 --> 00:06:04,620
那么在马里奥游戏中，

155
00:06:04,620 --> 00:06:06,720
马里奥是代理，其他一切

156
00:06:06,720 --> 00:06:09,240
都是环境，

157
00:06:09,240 --> 00:06:11,100
马里奥有

158
00:06:11,100 --> 00:06:13,740
三个可用的动作，

159
00:06:13,740 --> 00:06:16,139
奔跑、跳跃或留在这个环境中，

160
00:06:16,139 --> 00:06:19,199
策略的经典定义是，

161
00:06:19,199 --> 00:06:21,360
它是时间上的一系列动作，

162
00:06:21,360 --> 00:06:24,060
所以如果你有一个资本 T 的时间范围，

163
00:06:24,060 --> 00:06:27,120
那么策略只不过是一系列

164
00:06:27,120 --> 00:06:29,220
动作 你可能会及时采取这样的跑跑

165
00:06:29,220 --> 00:06:33,300
跳跃等等所以这是上

166
00:06:33,300 --> 00:06:36,419
标是动作所以这里是

167
00:06:36,419 --> 00:06:39,000
跳跃跑等等下标是

168
00:06:39,000 --> 00:06:41,400
时间

169
00:06:41,400 --> 00:06:44,100
然后你可以拥有的是一个策略空间，

170
00:06:44,100 --> 00:06:45,720
它是一个集合 许多这样的

171
00:06:45,720 --> 00:06:46,940
品质中的

172
00:06:46,940 --> 00:06:50,520
一小堆，以及您

173
00:06:50,520 --> 00:06:52,020
在主动推理中做出决策的基本做法，

174
00:06:52,020 --> 00:06:55,199
计算，而不是优化，计算

175
00:06:55,199 --> 00:06:58,139


176
00:06:58,139 --> 00:07:01,680
策略空间中每个策略的预期自由能，

177
00:07:01,680 --> 00:07:04,199
基本上可以解释为

178
00:07:04,199 --> 00:07:07,860
风险和模糊性之间的平衡

179
00:07:07,860 --> 00:07:10,560
嗯，是的，

180
00:07:10,560 --> 00:07:12,840
所以当你计算这个

181
00:07:12,840 --> 00:07:14,580
预期的自由能时，你要做的

182
00:07:14,580 --> 00:07:18,600
就是最小化风险，这就是你

183
00:07:18,600 --> 00:07:21,720
对

184
00:07:21,720 --> 00:07:24,300
观察的信念与你之前的

185
00:07:24,300 --> 00:07:27,240
偏好有多么不同，所以这也是

186
00:07:27,240 --> 00:07:28,800
生成的一部分 当你

187
00:07:28,800 --> 00:07:30,900
试图对控制进行建模时，同时

188
00:07:30,900 --> 00:07:32,280
你试图最小

189
00:07:32,280 --> 00:07:34,440
化模糊性，呃，当你选择一个

190
00:07:34,440 --> 00:07:36,419
具有最小呃预期

191
00:07:36,419 --> 00:07:38,699
自由能的策略时，这个公式

192
00:07:38,699 --> 00:07:40,860
有一个问题，即策略空间

193
00:07:40,860 --> 00:07:43,259
很快就会变得棘手

194
00:07:43,259 --> 00:07:47,460


195
00:07:47,460 --> 00:07:49,319
在你的政策空间中可能存在大量的小型 pis 或政策，

196
00:07:49,319 --> 00:07:51,000
并且计算

197
00:07:51,000 --> 00:07:53,580
所有这些政策的预期自由能，即使是在

198
00:07:53,580 --> 00:07:57,860
很短的时间内，地平线也是不可能的，但

199
00:07:57,860 --> 00:08:00,240
呃，这是

200
00:08:00,240 --> 00:08:02,639
IMDb 中实施的经典结构 尽管如此，

201
00:08:02,639 --> 00:08:06,360
我们在 pi mdp 中有不同的模块，

202
00:08:06,360 --> 00:08:10,020
这意味着呃

203
00:08:10,020 --> 00:08:11,880
实现行为的不同方面，

204
00:08:11,880 --> 00:08:15,000
例如呃对于推理

205
00:08:15,000 --> 00:08:17,160
或感知，我们相信

206
00:08:17,160 --> 00:08:19,039
传播定点迭代

207
00:08:19,039 --> 00:08:23,180
边缘消息传递以及控制模块

208
00:08:23,180 --> 00:08:26,099
中推理模块中实现的所有内容

209
00:08:26,099 --> 00:08:29,819
我们有不同的

210
00:08:29,819 --> 00:08:32,099
方法来评估政策的预期自由能，

211
00:08:32,099 --> 00:08:34,140
一种取决于

212
00:08:34,140 --> 00:08:36,299
预期效用，另一种

213
00:08:36,299 --> 00:08:38,760
取决于

214
00:08:38,760 --> 00:08:41,399
我刚刚解释的经典方法，

215
00:08:41,399 --> 00:08:44,459
然后我们有一个学习模块，因此我们可以

216
00:08:44,459 --> 00:08:46,680
学习 pom DP 中的参数，例如

217
00:08:46,680 --> 00:08:49,019
大写 a 大写 B 所以似然

218
00:08:49,019 --> 00:08:51,240
转换动态等等，然后

219
00:08:51,240 --> 00:08:53,540
我们有在

220
00:08:53,540 --> 00:08:56,279


221
00:08:56,279 --> 00:08:59,519
算法模块中实现所有这些的算法，然后

222
00:08:59,519 --> 00:09:01,620
pi mdp 现在最强大的东西是

223
00:09:01,620 --> 00:09:04,080
亚洲类，您可以轻松

224
00:09:04,080 --> 00:09:06,540
地定义代理环境

225
00:09:06,540 --> 00:09:08,760
循环，

226
00:09:08,760 --> 00:09:11,459
我们正在尝试建立呃，所以今天

227
00:09:11,459 --> 00:09:12,959
我要讨论一个实现复杂推理的代理类，

228
00:09:12,959 --> 00:09:15,140


229
00:09:15,140 --> 00:09:17,279
而不是

230
00:09:17,279 --> 00:09:20,519
我们刚刚看到的经典主动推理​​，

231
00:09:20,519 --> 00:09:21,660
所以

232
00:09:21,660 --> 00:09:24,060
正如我提到的，

233
00:09:24,060 --> 00:09:26,100
可以定义多少个有效策略

234
00:09:26,100 --> 00:09:28,140
经典主动影响力中的时间范围为 15，

235
00:09:28,140 --> 00:09:29,519


236
00:09:29,519 --> 00:09:31,800
所以第一个策略当然是

237
00:09:31,800 --> 00:09:34,279
第一个动作的系列，即跳跃，

238
00:09:34,279 --> 00:09:37,380
然后您可以更改最后一个调用的最后一个

239
00:09:37,380 --> 00:09:39,660
动作，并且您已经可以

240
00:09:39,660 --> 00:09:41,880
看到可以有 n 组合的数量

241
00:09:41,880 --> 00:09:44,880
，对于这个简单的情况，

242
00:09:44,880 --> 00:09:47,220
策略空间有 10 的 13 次方那么大，

243
00:09:47,220 --> 00:09:49,200
在随机问题

244
00:09:49,200 --> 00:09:52,080
设置中，没有办法

245
00:09:52,080 --> 00:09:54,120
想出这个策略空间的一个小子集，

246
00:09:54,120 --> 00:09:56,519
这样你就可以 解决

247
00:09:56,519 --> 00:09:59,339
计算复杂性的问题呃，

248
00:09:59,339 --> 00:10:01,500
是的，正如我在随机

249
00:10:01,500 --> 00:10:03,360
问题设置中提到的，这是一个棘手的

250
00:10:03,360 --> 00:10:06,120
大小策略空间呃，出现了

251
00:10:06,120 --> 00:10:09,300
复杂推理的想法，我们

252
00:10:09,300 --> 00:10:11,940
正在考虑以不同的方式正确地采取这个实例，而

253
00:10:11,940 --> 00:10:13,500
不是

254
00:10:13,500 --> 00:10:15,420
考虑 及时采取行动的顺序，

255
00:10:15,420 --> 00:10:17,820


256
00:10:17,820 --> 00:10:20,100
当我们看到某件事时，我们可以直接想到要做什么，呃，这取决于

257
00:10:20,100 --> 00:10:21,959
我们对当前状态的信念和

258
00:10:21,959 --> 00:10:23,880
对未来的信念，所以如果我

259
00:10:23,880 --> 00:10:25,680
看到自己处于当前情况，

260
00:10:25,680 --> 00:10:28,080
我应该做什么，这更像是

261
00:10:28,080 --> 00:10:30,480
直接思考

262
00:10:30,480 --> 00:10:33,420
如何采取行动，这里的

263
00:10:33,420 --> 00:10:35,459
预期自由能

264
00:10:35,459 --> 00:10:37,980
预期自由能的结构是相同的，但

265
00:10:37,980 --> 00:10:40,320
我们不是评估

266
00:10:40,320 --> 00:10:43,440
呃政策的预期自由能而是

267
00:10:43,440 --> 00:10:45,540
呃观察行动组合的预期自由能

268
00:10:45,540 --> 00:10:48,060
所以如果我看到

269
00:10:48,060 --> 00:10:49,860
如果我这样做的话，预期的

270
00:10:49,860 --> 00:10:51,600
自由能是多少，这就是我试图

271
00:10:51,600 --> 00:10:56,220
最小化的，这就是我试图

272
00:10:56,220 --> 00:10:58,860
在这个设置中优化的，所以

273
00:10:58,860 --> 00:11:01,500
这里我们再次有风险项，

274
00:11:01,500 --> 00:11:03,300
我们试图最小化

275
00:11:03,300 --> 00:11:05,040
信念和先验

276
00:11:05,040 --> 00:11:07,320
偏好之间的偏差，我们还有模糊项

277
00:11:07,320 --> 00:11:10,560
uh，这共同构成了

278
00:11:10,560 --> 00:11:13,079


279
00:11:13,079 --> 00:11:16,019
在时间 T 的这个时间点 uh 的预期自由能，但我们也

280
00:11:16,019 --> 00:11:18,360
对

281
00:11:18,360 --> 00:11:20,760
下一个时间步长的预期自由能有一个期望

282
00:11:20,760 --> 00:11:22,680
嗯，要评估

283
00:11:22,680 --> 00:11:24,660
下一个时间步骤的预期自由能，您将必须再次使用

284
00:11:24,660 --> 00:11:27,360
OT 加 2 计算该方程，

285
00:11:27,360 --> 00:11:29,220
为此，您必须再次使用

286
00:11:29,220 --> 00:11:32,160
OT 加 3 计算该方程，

287
00:11:32,160 --> 00:11:34,200
依此类推，这会自动成为

288
00:11:34,200 --> 00:11:36,779
研究的对象 由于

289
00:11:36,779 --> 00:11:39,779
这个方程是用递归方式定义的，并且它

290
00:11:39,779 --> 00:11:41,220
有自己的问题，但是有一些

291
00:11:41,220 --> 00:11:44,160
聪明的方法可以解决它们，

292
00:11:44,160 --> 00:11:46,500
这就是我们今天将在代码中讨论的问题，

293
00:11:46,500 --> 00:11:48,899
所以考虑到

294
00:11:48,899 --> 00:11:51,600
这里的复杂推理结构，正如我

295
00:11:51,600 --> 00:11:54,060
提到的研究一样 替换

296
00:11:54,060 --> 00:11:56,160
我们所

297
00:11:56,160 --> 00:11:58,620
看到的额外积极影响的政策空间，

298
00:11:58,620 --> 00:12:00,779
因此在本次

299
00:12:00,779 --> 00:12:04,019
研讨会中，我关注的是

300
00:12:04,019 --> 00:12:07,740
如何定义生成模型

301
00:12:07,740 --> 00:12:10,980
并给定一个环境，

302
00:12:10,980 --> 00:12:13,440
例如这是被

303
00:12:13,440 --> 00:12:16,200
刺激的网格呃 在原始论文中进行了模拟，

304
00:12:16,200 --> 00:12:19,140
我们将讨论如何

305
00:12:19,140 --> 00:12:21,240
为该网格建立一个生成模型，该模型

306
00:12:21,240 --> 00:12:22,740
可用于

307
00:12:22,740 --> 00:12:24,660
主要 DP 模块中的复杂推理

308
00:12:24,660 --> 00:12:27,600
，

309
00:12:27,600 --> 00:12:29,279
所以基本上我想讨论的

310
00:12:29,279 --> 00:12:31,740
是 环境将有

311
00:12:31,740 --> 00:12:34,320
一个步骤函数，它

312
00:12:34,320 --> 00:12:37,680
从 pi MDB 中的代理采取操作，代理

313
00:12:37,680 --> 00:12:40,019
将从该操作中获得观察结果，

314
00:12:40,019 --> 00:12:42,180
我们将讨论这个

315
00:12:42,180 --> 00:12:44,579
特定的函数代理点步骤，

316
00:12:44,579 --> 00:12:46,860
代理点步骤将采取步骤

317
00:12:46,860 --> 00:12:49,320
观察并尝试

318
00:12:49,320 --> 00:12:50,760
为下一个时间步骤正确提出一个动作，

319
00:12:50,760 --> 00:12:55,079
这会创建一个循环，并且

320
00:12:55,079 --> 00:12:58,200
巧妙地设计这个循环将让

321
00:12:58,200 --> 00:13:00,240
您看到

322
00:13:00,240 --> 00:13:02,820
在复杂的打印设置中出现有目的的行为，

323
00:13:02,820 --> 00:13:05,339
例如在这个特定的网格中

324
00:13:05,339 --> 00:13:06,839
充分的规划地平线，你将能够

325
00:13:06,839 --> 00:13:08,639
看到代理能够

326
00:13:08,639 --> 00:13:10,740
在这个网格中导航等等，所以

327
00:13:10,740 --> 00:13:12,540
这是我

328
00:13:12,540 --> 00:13:16,440
今天演讲中要重点讨论的例子，

329
00:13:16,440 --> 00:13:18,000
所以

330
00:13:18,000 --> 00:13:22,339
我想抱歉，

331
00:13:25,380 --> 00:13:29,180
我想马上 跳到代码中，

332
00:13:29,180 --> 00:13:32,459
这样我们就有了

333
00:13:32,459 --> 00:13:36,360
pi mdp home，我希望

334
00:13:36,360 --> 00:13:38,639
你熟悉它，所以我们有这个

335
00:13:38,639 --> 00:13:41,399
GitHub 存储库，其中有 pi

336
00:13:41,399 --> 00:13:43,079
MTP 模块

337
00:13:43,079 --> 00:13:46,320
和内部时间 DP 模块，我们有

338
00:13:46,320 --> 00:13:48,480
几个呃

339
00:13:48,480 --> 00:13:50,820
部分，所以在这里 我们

340
00:13:50,820 --> 00:13:52,980
在原来的 Prime DP 模块中有代理，它

341
00:13:52,980 --> 00:13:55,019
实现了所谓的经典

342
00:13:55,019 --> 00:13:57,200
主动推理​​，我们有几个

343
00:13:57,200 --> 00:13:59,760
环境，我们有辅助

344
00:13:59,760 --> 00:14:02,399
功能，例如在当前地图中学习等等，

345
00:14:02,399 --> 00:14:05,160
所以这是时间 DP 的模块，

346
00:14:05,160 --> 00:14:09,120
但在父文件夹中 我们还有一些

347
00:14:09,120 --> 00:14:11,459
示例，其中

348
00:14:11,459 --> 00:14:14,700
有关于如何使用

349
00:14:14,700 --> 00:14:17,220
引擎类、如何处理

350
00:14:17,220 --> 00:14:20,220
环境等的教程，所以如果您

351
00:14:20,220 --> 00:14:22,620
查看拉取请求，那么我们

352
00:14:22,620 --> 00:14:25,500
现在正在尝试将复杂的

353
00:14:25,500 --> 00:14:27,720
推理合并到原始的 Prime DP

354
00:14:27,720 --> 00:14:29,579
模块中 今天我将

355
00:14:29,579 --> 00:14:31,500
讨论这个完整请求中的代码，所以

356
00:14:31,500 --> 00:14:34,320
如果你想尝试一下这个动手

357
00:14:34,320 --> 00:14:36,839
操作，你可能想转到这个

358
00:14:36,839 --> 00:14:39,959
页面，其中有这个拉取请求，

359
00:14:39,959 --> 00:14:41,760
并且

360
00:14:41,760 --> 00:14:44,940
它具有相同的时间结构 DB

361
00:14:44,940 --> 00:14:48,420
基本上是使用 piondp 设计的，

362
00:14:48,420 --> 00:14:50,699
这里我们还有一个

363
00:14:50,699 --> 00:14:53,639
代理 SI，它是一个复杂的

364
00:14:53,639 --> 00:14:55,740
企业代理，它以复杂的推理方式执行所有操作

365
00:14:55,740 --> 00:14:58,320
以及规划和决策，

366
00:14:58,320 --> 00:15:00,480
在

367
00:15:00,480 --> 00:15:02,399
父文件夹中还有一个用于

368
00:15:02,399 --> 00:15:04,860
复杂的示例文件夹 uh

369
00:15:04,860 --> 00:15:07,620
推理演示，我

370
00:15:07,620 --> 00:15:09,540
今天要做的就是引导您完成本

371
00:15:09,540 --> 00:15:12,300
替代推理教程，并且在

372
00:15:12,300 --> 00:15:14,519
我将要讨论的

373
00:15:14,519 --> 00:15:18,320
方式中，在我引用

374
00:15:18,320 --> 00:15:21,060
帮助程序代码的地方，我将转到

375
00:15:21,060 --> 00:15:22,740
该代码并尝试 解释

376
00:15:22,740 --> 00:15:24,540
实际发生的情况以及我们如何完成

377
00:15:24,540 --> 00:15:27,360
代理环境循环，我们可以在其中

378
00:15:27,360 --> 00:15:31,860
看到有目的的行为，所以

379
00:15:31,860 --> 00:15:35,040
是的，这就是主要的 DP 主页然后我

380
00:15:35,040 --> 00:15:37,560
也谈到了拉取请求，所以

381
00:15:37,560 --> 00:15:40,199
让我们立即进入 Jupiter

382
00:15:40,199 --> 00:15:43,680
笔记本，这是我的

383
00:15:43,680 --> 00:15:46,320
该存储库的本地副本，因此我更容易

384
00:15:46,320 --> 00:15:47,880
运行它并在我的个人计算机中显示它，

385
00:15:47,880 --> 00:15:50,339
所以这是

386
00:15:50,339 --> 00:15:53,279
带有 pi mdp 和示例的模式文件夹，在内部

387
00:15:53,279 --> 00:15:55,440
示例中，我有一个用于

388
00:15:55,440 --> 00:15:57,120
复杂推理的演示支架，这是

389
00:15:57,120 --> 00:15:59,480
笔记本 I' 我说的是对的，所以

390
00:15:59,480 --> 00:16:02,579
在这个例子中，我们要做的

391
00:16:02,579 --> 00:16:04,760
是

392
00:16:04,800 --> 00:16:06,480
处理原始复杂推理论文中的这个特定的网格

393
00:16:06,480 --> 00:16:08,699
任务，

394
00:16:08,699 --> 00:16:12,480
并让这个代理或

395
00:16:12,480 --> 00:16:14,880
使这个代理能够导航到这个

396
00:16:14,880 --> 00:16:17,339
红点，这被认为是黄金

397
00:16:17,339 --> 00:16:19,860
状态 这个特定的任务给定了我们

398
00:16:19,860 --> 00:16:21,720
像这样的优先偏好，所以这个

399
00:16:21,720 --> 00:16:24,240
高偏好在我们写的意义上是非常有用的，

400
00:16:24,240 --> 00:16:26,760
我们可以看到

401
00:16:26,760 --> 00:16:28,560
这是最优选的状态，

402
00:16:28,560 --> 00:16:30,420
白色和周围的状态

403
00:16:30,420 --> 00:16:33,360
是不太

404
00:16:33,360 --> 00:16:35,459
优选的，但比 远处的是正确的，

405
00:16:35,459 --> 00:16:37,920
所以这是我们正在尝试使用的网格世界任务，

406
00:16:37,920 --> 00:16:39,120


407
00:16:39,120 --> 00:16:42,199
因此第一个单元格正在

408
00:16:42,199 --> 00:16:45,139
导入所有必要的库

409
00:16:45,139 --> 00:16:48,779
和一些有用的库，如 numpy 和

410
00:16:48,779 --> 00:16:51,839
matplotlib，最重要的是

411
00:16:51,839 --> 00:16:55,259
prime DB，所以我是 实际上，现在使用复杂的推理实现调用

412
00:16:55,259 --> 00:16:57,360
我的 Prime DB 的本地副本，而

413
00:16:57,360 --> 00:16:58,800


414
00:16:58,800 --> 00:17:01,740
不是尚未合并的原始副本，

415
00:17:01,740 --> 00:17:04,439
我想谈论的第一件事

416
00:17:04,439 --> 00:17:06,720
是环境本身，所以

417
00:17:06,720 --> 00:17:09,839
环境点步骤部分，如果我

418
00:17:09,839 --> 00:17:11,880
采取一些行动 环境是如何

419
00:17:11,880 --> 00:17:13,740
工作的，

420
00:17:13,740 --> 00:17:16,859
在这个文件夹中我

421
00:17:16,859 --> 00:17:18,839
有一个文件，这是一个很棒的环境

422
00:17:18,839 --> 00:17:23,280
uh SI Dot py，这基本上是一个

423
00:17:23,280 --> 00:17:25,319
环境类，所以不用担心

424
00:17:25,319 --> 00:17:27,299
这个环境是如何实际

425
00:17:27,299 --> 00:17:29,340
实现的，这是唯一需要担心的事情

426
00:17:29,340 --> 00:17:31,380
关于是

427
00:17:31,380 --> 00:17:32,340


428
00:17:32,340 --> 00:17:34,919
我们将要使用的这个函数，

429
00:17:34,919 --> 00:17:38,760
它是环境点步骤，因此该

430
00:17:38,760 --> 00:17:41,520
函数将对其采取操作，并且

431
00:17:41,520 --> 00:17:43,919
根据环境的当前状态，

432
00:17:43,919 --> 00:17:45,840
它将计算给定代理的

433
00:17:45,840 --> 00:17:48,900
此操作的最可能的下一个状态是什么

434
00:17:48,900 --> 00:17:51,360
这就是想法，

435
00:17:51,360 --> 00:17:53,880


436
00:17:53,880 --> 00:17:57,960
如果它不是目标状态，它还会计算一些可忽略不计的负值的奖励，

437
00:17:57,960 --> 00:18:00,179
如果它是

438
00:18:00,179 --> 00:18:02,220
目标状态，

439
00:18:02,220 --> 00:18:04,320
它将给出 10 的奖励，这就是

440
00:18:04,320 --> 00:18:06,900
环境的设计方式，它将

441
00:18:06,900 --> 00:18:08,700
更新 当前状态到新

442
00:18:08,700 --> 00:18:10,500
状态，基本上它将返回

443
00:18:10,500 --> 00:18:13,080
一个新状态，具体取决于您的

444
00:18:13,080 --> 00:18:14,220
操作，

445
00:18:14,220 --> 00:18:16,080
嗯该操作的奖励以及

446
00:18:16,080 --> 00:18:17,940
它是否是剧集的结束等等，

447
00:18:17,940 --> 00:18:20,700
所以这个实现是

448
00:18:20,700 --> 00:18:22,500
标准的 openai 环境

449
00:18:22,500 --> 00:18:24,660
实现，这个

450
00:18:24,660 --> 00:18:26,520
environment.step 函数是否正确，因此在

451
00:18:26,520 --> 00:18:28,440
此网格中，

452
00:18:28,440 --> 00:18:31,320
例如，如果我现在处于此

453
00:18:31,320 --> 00:18:34,140
状态，并且如果我向上采取行动，那么我

454
00:18:34,140 --> 00:18:36,120
有四个可用的行动，

455
00:18:36,120 --> 00:18:38,460
北东南和西，所以如果我

456
00:18:38,460 --> 00:18:41,100
向北走，那么环境点 步骤

457
00:18:41,100 --> 00:18:43,620
将确保我处于与

458
00:18:43,620 --> 00:18:46,620
该州有关的州，如果我向东

459
00:18:46,620 --> 00:18:48,960
或向西走，那么我会留在这里或向南并

460
00:18:48,960 --> 00:18:52,679
留在这里，这就是想法，是的，

461
00:18:52,679 --> 00:18:54,780
这里的剧集长度限制

462
00:18:54,780 --> 00:18:57,960
为八 这意味着我将

463
00:18:57,960 --> 00:19:00,179


464
00:19:00,179 --> 00:19:01,140


465
00:19:01,140 --> 00:19:03,179
每集的长度限制为八，

466
00:19:03,179 --> 00:19:05,039
这是达到黄金状态的理想长度，

467
00:19:05,039 --> 00:19:06,840
只是为了避免混淆，

468
00:19:06,840 --> 00:19:09,179
因此在这种环境中，经过八次

469
00:19:09,179 --> 00:19:11,059
操作后，环境将终止

470
00:19:11,059 --> 00:19:13,740
，如果您必须达到此

471
00:19:13,740 --> 00:19:16,380
规则 在最佳时间点状态，

472
00:19:16,380 --> 00:19:18,480
这就是环境如何

473
00:19:18,480 --> 00:19:23,100
实现的想法好吧呃我希望这是清楚的，

474
00:19:23,100 --> 00:19:25,799
并且在这个环境中有很多有用的功能，

475
00:19:25,799 --> 00:19:27,780
比如

476
00:19:27,780 --> 00:19:29,220
嗯

477
00:19:29,220 --> 00:19:32,100
渲染呃环境

478
00:19:32,100 --> 00:19:33,660
在这个环境中渲染优先偏好矩阵

479
00:19:33,660 --> 00:19:34,860
所以如果你设计 一个

480
00:19:34,860 --> 00:19:36,679
优先的朋友，这个环境可以以

481
00:19:36,679 --> 00:19:39,720
图形的方式展示你

482
00:19:39,720 --> 00:19:41,940
之前的偏好，你将

483
00:19:41,940 --> 00:19:44,039
在下面的笔记本中看到，

484
00:19:44,039 --> 00:19:46,440
所以现在是时候我们

485
00:19:46,440 --> 00:19:48,120
为复杂的推理代理定义一个生成模型了，在

486
00:19:48,120 --> 00:19:50,340


487
00:19:50,340 --> 00:19:51,179


488
00:19:51,179 --> 00:19:54,020
这之前让我们

489
00:19:54,720 --> 00:19:56,580
定义结构

490
00:19:56,580 --> 00:19:58,200
我们希望智能体记住的生成模型

491
00:19:58,200 --> 00:19:59,940


492
00:19:59,940 --> 00:20:01,919
是为这个特定环境量身定制的，

493
00:20:01,919 --> 00:20:05,120
所以在这个

494
00:20:05,120 --> 00:20:08,580
特定的网格世界任务中，我们有 25 个

495
00:20:08,580 --> 00:20:10,559
有效状态

496
00:20:10,559 --> 00:20:12,480
，从这个状态开始，

497
00:20:12,480 --> 00:20:16,320
这条路径中的所有黑色状态都是有效

498
00:20:16,320 --> 00:20:18,960
状态 因此，有 25 个有效状态，

499
00:20:18,960 --> 00:20:20,700
然后代理有四种可用的操作，即

500
00:20:20,700 --> 00:20:23,580
北、东南和西，

501
00:20:23,580 --> 00:20:25,799
所以这是我们生成模型的一部分，

502
00:20:25,799 --> 00:20:30,120
这也符合

503
00:20:30,120 --> 00:20:32,700
网格的实际情况，但这与

504
00:20:32,700 --> 00:20:34,620
代理在其中的内容有关 它的想法是正确的，

505
00:20:34,620 --> 00:20:38,160
然后观察到的只是

506
00:20:38,160 --> 00:20:41,460
状态空间，代理是呃，

507
00:20:41,460 --> 00:20:43,200
问题是完全可观察的，所以

508
00:20:43,200 --> 00:20:46,020
没有歧义，然后

509
00:20:46,020 --> 00:20:49,620
我们基本上定义了状态的数量，

510
00:20:49,620 --> 00:20:51,918
外国的状态的

511
00:20:54,980 --> 00:20:58,080
数量，这是

512
00:20:58,080 --> 00:21:00,840
你的状态空间的列表

513
00:21:00,840 --> 00:21:03,660
因素的数量现在是 1，因为

514
00:21:03,660 --> 00:21:05,340
这里只有一个热和状态演员，

515
00:21:05,340 --> 00:21:07,740
然后是控制的数量，这

516
00:21:07,740 --> 00:21:10,260
将是 4 呃，这是针对可用的

517
00:21:10,260 --> 00:21:13,440
动作和你的观察空间，

518
00:21:13,440 --> 00:21:15,179
所以这就是你的

519
00:21:15,179 --> 00:21:18,299
生成模型的结构，让我们

520
00:21:18,299 --> 00:21:21,840
现在看看pomdb中参数的结构，

521
00:21:21,840 --> 00:21:24,780
第一个是似然

522
00:21:24,780 --> 00:21:27,120
函数，

523
00:21:27,120 --> 00:21:31,380
通常用大写A表示，

524
00:21:31,380 --> 00:21:33,240
这里它是

525
00:21:33,240 --> 00:21:35,340
我有多少个观察模态和

526
00:21:35,340 --> 00:21:37,799
我有多少个状态模态的函数，所以如果

527
00:21:37,799 --> 00:21:41,340
我 运行这个单元是的，我必须运行

528
00:21:41,340 --> 00:21:43,140
父单元

529
00:21:43,140 --> 00:21:45,600
以确保一切正常，

530
00:21:45,600 --> 00:21:48,900
所以我运行肮脏的环境，

531
00:21:48,900 --> 00:21:50,280
嗯生成模型的结构，

532
00:21:50,280 --> 00:21:53,280
这里我有大写的 A 矩阵，

533
00:21:53,280 --> 00:21:56,400
其结构为 25 25 这意味着

534
00:21:56,400 --> 00:21:58,799
我有 25 个状态 25 个调查，

535
00:21:58,799 --> 00:22:01,860
在这里，因为它是完全可观察的，所以我将

536
00:22:01,860 --> 00:22:04,020
其初始化为大小为 25 的恒等矩阵，这就是

537
00:22:04,020 --> 00:22:07,200


538
00:22:07,200 --> 00:22:10,500
我

539
00:22:10,500 --> 00:22:13,260
为这个特定网格

540
00:22:13,260 --> 00:22:16,559
任务初始化的似然矩阵，然后第二个元素是

541
00:22:16,559 --> 00:22:18,900
过渡矩阵，所以请

542
00:22:18,900 --> 00:22:21,240
注意，我 正在使用所有现有的

543
00:22:21,240 --> 00:22:24,299
时间数据库功能来定义一个

544
00:22:24,299 --> 00:22:25,679
随机矩阵，

545
00:22:25,679 --> 00:22:28,919
然后在此基础上使用单位矩阵，

546
00:22:28,919 --> 00:22:32,460
所以是的，我

547
00:22:32,460 --> 00:22:35,400
在这里没有做任何新的事情，这是现有的

548
00:22:35,400 --> 00:22:38,220
时间数据库功能，那么我现在可以做的

549
00:22:38,220 --> 00:22:41,580
是 定义 B 矩阵，也

550
00:22:41,580 --> 00:22:43,500
称为转换矩阵，因此

551
00:22:43,500 --> 00:22:45,960
转换矩阵对转换进行编码，

552
00:22:45,960 --> 00:22:48,000
就像

553
00:22:48,000 --> 00:22:49,799
如果我从特定

554
00:22:49,799 --> 00:22:52,440
状态开始并采取行动，那么我将来会在哪里结束，这就是

555
00:22:52,440 --> 00:22:55,320
它取决于状态数量的想法

556
00:22:55,320 --> 00:22:56,640
状态是隐藏的状态

557
00:22:56,640 --> 00:22:59,640
模式和控件数量，因此它

558
00:22:59,640 --> 00:23:02,159
具有状态操作状态的结构，

559
00:23:02,159 --> 00:23:04,320
如果我从一个特定的状态采取一个操作，

560
00:23:04,320 --> 00:23:05,640
我将

561
00:23:05,640 --> 00:23:08,340
最终达到这个状态，所以这也是一个未来的状态，

562
00:23:08,340 --> 00:23:09,780
所以

563
00:23:09,780 --> 00:23:12,980
我 将把它初始化为真实的

564
00:23:12,980 --> 00:23:15,480
环境状态，所以现在这是

565
00:23:15,480 --> 00:23:17,039
我构建的环境的一部分，它将

566
00:23:17,039 --> 00:23:19,380
给出 b 矩阵，

567
00:23:19,380 --> 00:23:21,179
嗯，看看

568
00:23:21,179 --> 00:23:24,740
这个 B 矩阵的结构可能是值得的，

569
00:23:25,380 --> 00:23:29,340
所以这里，嗯，我们有 25  25 4 所以这意味着

570
00:23:29,340 --> 00:23:32,820
如果我从一个

571
00:23:32,820 --> 00:23:34,500
特定的状态采取一个行动，我将

572
00:23:34,500 --> 00:23:38,220
最终达到这个状态，并且我们

573
00:23:38,220 --> 00:23:40,140
通过设计为这个特定的网格拥有真正的过渡动力学，

574
00:23:40,140 --> 00:23:42,840
所以有一个名为 get

575
00:23:42,840 --> 00:23:46,020
ruby​​ 的函数，它将给出 我们是系统的真实B，

576
00:23:46,020 --> 00:23:47,700
代理可以

577
00:23:47,700 --> 00:23:51,000
使用它，所以理想情况下，我们希望

578
00:23:51,000 --> 00:23:52,919
代理能够学习这一点，但出于

579
00:23:52,919 --> 00:23:55,620
本演示的目的，我们假设

580
00:23:55,620 --> 00:23:57,900
代理已经知道结构

581
00:23:57,900 --> 00:24:00,960
，然后是先前的足迹

582
00:24:00,960 --> 00:24:03,840
呃，这里很有趣，

583
00:24:03,840 --> 00:24:05,039
因为

584
00:24:05,039 --> 00:24:08,280
它被定义为你离

585
00:24:08,280 --> 00:24:10,200
目标状态有多近，所以如果你处于黄金

586
00:24:10,200 --> 00:24:12,720
状态，那么呃，很明显，这是

587
00:24:12,720 --> 00:24:15,539
你最喜欢的最受欢迎的状态，

588
00:24:15,539 --> 00:24:18,840
以及你如何喜欢

589
00:24:18,840 --> 00:24:20,220
邻近的状态 说得对，所以这

590
00:24:20,220 --> 00:24:23,220
取决于距离的平方根，

591
00:24:23,220 --> 00:24:25,200
或者基本上是与

592
00:24:25,200 --> 00:24:27,960
特定目标状态的距离，

593
00:24:27,960 --> 00:24:30,860
所以你定义一个

594
00:24:30,860 --> 00:24:34,679
8 交叉 8 的网格，其大小与这个

595
00:24:34,679 --> 00:24:39,419
特定的网格任务相同，然后我们有一种

596
00:24:39,419 --> 00:24:43,440
方法可以添加 值是

597
00:24:43,440 --> 00:24:45,059
您对每个状态的偏好，

598
00:24:45,059 --> 00:24:48,240
如果您渲染特定的 C

599
00:24:48,240 --> 00:24:49,919
矩阵，您可以看到与

600
00:24:49,919 --> 00:24:53,039
此结构相同的结构，其中该黄金状态

601
00:24:53,039 --> 00:24:55,140
更受青睐，而周围的

602
00:24:55,140 --> 00:24:57,780
状态准备不足，依此类推，

603
00:24:57,780 --> 00:25:00,539
所以现在我们有了 C 矩阵 也以

604
00:25:00,539 --> 00:25:03,419
经典的时间 DP 方式定义

605
00:25:03,419 --> 00:25:06,840
，然后我将 c 矩阵初始化为

606
00:25:06,840 --> 00:25:09,299
我们在前一个单元中评估的 C 矩阵，

607
00:25:09,299 --> 00:25:11,940
它是这个

608
00:25:11,940 --> 00:25:13,740
特定 C 矩阵上的小 C 好吧

609
00:25:13,740 --> 00:25:16,799
，最后对于生成模型，

610
00:25:16,799 --> 00:25:19,140
我们有资本 D，这是你的先验

611
00:25:19,140 --> 00:25:21,000
在隐藏状态上，为此我

612
00:25:21,000 --> 00:25:23,640
使用了一个统一的对象数组，这

613
00:25:23,640 --> 00:25:26,039
意味着我没有先验的

614
00:25:26,039 --> 00:25:29,700
开始位置，所以让我运行待处理的

615
00:25:29,700 --> 00:25:32,120
单元格，

616
00:25:32,700 --> 00:25:35,100
所以这里的 D 矩阵是

617
00:25:35,100 --> 00:25:37,140
隐藏状态上的均匀分布 I 不

618
00:25:37,140 --> 00:25:38,460
知道我要从哪里开始

619
00:25:38,460 --> 00:25:41,460
模拟，所以这是

620
00:25:41,460 --> 00:25:43,679
生成模型的基本结构，

621
00:25:43,679 --> 00:25:46,799
然后我们有代理类，我

622
00:25:46,799 --> 00:25:48,500
想像

623
00:25:48,500 --> 00:25:51,659
环境一样单独讨论它，所以给定

624
00:25:51,659 --> 00:25:54,600
这些环境参数，你会如何

625
00:25:54,600 --> 00:25:57,419
期望 工作的代理类，那么

626
00:25:57,419 --> 00:25:59,880
这个文件夹结构中的代理类在哪里呢？在

627
00:25:59,880 --> 00:26:01,260


628
00:26:01,260 --> 00:26:05,100
pmdp 模块文件夹中，我们

629
00:26:05,100 --> 00:26:07,940
有一个代理 SI dot p y，

630
00:26:07,940 --> 00:26:12,179
它基本上又是一个类，与

631
00:26:12,179 --> 00:26:14,419


632
00:26:14,419 --> 00:26:17,880
这里的环境类类似，我们还有一个步骤函数，其中

633
00:26:17,880 --> 00:26:21,900
这个 将对

634
00:26:21,900 --> 00:26:25,500
函数进行观察，并标记

635
00:26:25,500 --> 00:26:28,020
是否学习环境，这

636
00:26:28,020 --> 00:26:30,840
是可选的，因此如果禁用它，它将

637
00:26:30,840 --> 00:26:33,419
不会学习生成模型，如果

638
00:26:33,419 --> 00:26:35,400
启用它，它将更新生成

639
00:26:35,400 --> 00:26:37,500
模型的参数 生成模型，

640
00:26:37,500 --> 00:26:39,240
它基本上所做的是它将返回

641
00:26:39,240 --> 00:26:42,299
此时要采取的操作，

642
00:26:42,299 --> 00:26:44,880
并且环境

643
00:26:44,880 --> 00:26:47,400
基本上可以正确使用该操作，因此在

644
00:26:47,400 --> 00:26:49,080
这个文件中我们有代理类，

645
00:26:49,080 --> 00:26:51,960
我将详细解释它，

646
00:26:51,960 --> 00:26:54,960
所以我 基本上

647
00:26:54,960 --> 00:26:57,740
在这个单元格中导入该代理类，

648
00:26:57,740 --> 00:27:00,539
然后我们将尝试

649
00:27:00,539 --> 00:27:03,000
从状态原始入口论文中重现此行为结果，

650
00:27:03,000 --> 00:27:05,820


651
00:27:05,820 --> 00:27:09,659


652
00:27:09,659 --> 00:27:12,480
因此我们期望的是，鉴于此

653
00:27:12,480 --> 00:27:14,760
先前的偏好结构，

654
00:27:14,760 --> 00:27:16,919
在此先前的性能中存在局部最大值

655
00:27:16,919 --> 00:27:18,539
因此，如果你从这个

656
00:27:18,539 --> 00:27:21,419
特定的点开始，如果你没有足够深入的计划，

657
00:27:21,419 --> 00:27:24,419
你最终会出现在

658
00:27:24,419 --> 00:27:26,640
这些局部极大值之一中，你看不到

659
00:27:26,640 --> 00:27:28,919
有一个高度优先的

660
00:27:28,919 --> 00:27:31,200
观察结果，比如说四步，

661
00:27:31,200 --> 00:27:34,080
所以如果你 在这个特定的州，

662
00:27:34,080 --> 00:27:36,539
你将看到的是当地的马克西玛

663
00:27:36,539 --> 00:27:38,340
，你会去坐在那里，因为

664
00:27:38,340 --> 00:27:39,779
邻近的州不太

665
00:27:39,779 --> 00:27:42,059
受欢迎，而这个更

666
00:27:42,059 --> 00:27:43,980
受欢迎的州由于

667
00:27:43,980 --> 00:27:47,279
世界或城墙结构而无法进入，所以你

668
00:27:47,279 --> 00:27:49,320
必须采取 转弯并穿过

669
00:27:49,320 --> 00:27:51,840
不太喜欢的州，你需要深入的

670
00:27:51,840 --> 00:27:54,059
规划，以便使代理能够

671
00:27:54,059 --> 00:27:56,220
做到这一点，代理应该能够

672
00:27:56,220 --> 00:27:57,779


673
00:27:57,779 --> 00:28:00,360
及时模拟嗯四个时间步骤，以看到有

674
00:28:00,360 --> 00:28:02,880
这个呃非常有价值的

675
00:28:02,880 --> 00:28:06,080
观察即将到来 采取这种

676
00:28:06,080 --> 00:28:08,700
行动，这就是我们

677
00:28:08,700 --> 00:28:09,720
试图

678
00:28:09,720 --> 00:28:13,919
在这个特定演示中看到的点，因此对于呃

679
00:28:13,919 --> 00:28:17,220
低规划深度，它基本上会

680
00:28:17,220 --> 00:28:19,559
陷入本地马克西玛之一，但如果

681
00:28:19,559 --> 00:28:21,179
有足够的规划深度，它将

682
00:28:21,179 --> 00:28:23,520
导航到黄金状态，所以 这就是

683
00:28:23,520 --> 00:28:25,919
我们想要看到的，所以我们

684
00:28:25,919 --> 00:28:28,440
有不同的规划视野

685
00:28:28,440 --> 00:28:31,440
，我们基本上做的是给

686
00:28:31,440 --> 00:28:34,440
代理一个生成模型，

687
00:28:34,440 --> 00:28:37,020
我们现在定义了矩阵

688
00:28:37,020 --> 00:28:39,960
B 矩阵 C 矩阵 V 矩阵 然后我们有

689
00:28:39,960 --> 00:28:42,480
资本 N 的规划视野 所以

690
00:28:42,480 --> 00:28:44,940
这里我迭代规划

691
00:28:44,940 --> 00:28:48,000
深度，所以循环的 n 将为 1 3 和 4

692
00:28:48,000 --> 00:28:50,580
然后我们有行动精度，

693
00:28:50,580 --> 00:28:53,100
在主动影响力文献中通常用 Alpha 表示，

694
00:28:53,100 --> 00:28:55,320
以便确定

695
00:28:55,320 --> 00:28:58,080
要采取哪个行动，从而实现高度

696
00:28:58,080 --> 00:29:01,200
精确的行动过程 意味着它将

697
00:29:01,200 --> 00:29:03,620
坚持

698
00:29:03,620 --> 00:29:07,080
预期自由能最低的动作，但重音

699
00:29:07,080 --> 00:29:08,400
动作较低。精度是一种

700
00:29:08,400 --> 00:29:10,320
概率性的，它还会

701
00:29:10,320 --> 00:29:12,480
考虑其他动作，然后我们有一个

702
00:29:12,480 --> 00:29:14,159
规划精度，它是

703
00:29:14,159 --> 00:29:16,620
我们将讨论的规划函数的一部分，这

704
00:29:16,620 --> 00:29:18,120
通常是 在文献中表示为

705
00:29:18,120 --> 00:29:20,159
gamma 那么我们还有一个搜索

706
00:29:20,159 --> 00:29:21,960
阈值，这

707
00:29:21,960 --> 00:29:24,600
对于复杂的推理非常重要，因为正如

708
00:29:24,600 --> 00:29:26,880
我们所看到的，研究中的复杂推理

709
00:29:26,880 --> 00:29:28,559


710
00:29:28,559 --> 00:29:32,399
和研究是不好的，因为它

711
00:29:32,399 --> 00:29:34,740
可以进行大量计算，但您

712
00:29:34,740 --> 00:29:36,480
必须定义一个阈值 有点

713
00:29:36,480 --> 00:29:39,179
忽略让它

714
00:29:39,179 --> 00:29:41,159
发挥作用的许多可能性，这就是我们

715
00:29:41,159 --> 00:29:44,340
也将讨论的想法，所以在

716
00:29:44,340 --> 00:29:47,820
我们进入代理

717
00:29:47,820 --> 00:29:51,480
类之前先预览一下我们要做的就是在一个

718
00:29:51,480 --> 00:29:55,200
循环中我们将调用代理点

719
00:29:55,200 --> 00:29:57,240
步骤 和环境点串联，

720
00:29:57,240 --> 00:30:00,179
因此代理将看到一个观察结果，它将

721
00:30:00,179 --> 00:30:01,559
采取行动，该行动

722
00:30:01,559 --> 00:30:03,960
将进入环境，

723
00:30:03,960 --> 00:30:06,419
环境将返回新的

724
00:30:06,419 --> 00:30:08,940
观察结果，并且这个循环继续下去，

725
00:30:08,940 --> 00:30:11,600
我们希望随着时间的推移，这个循环如何演变为

726
00:30:11,600 --> 00:30:14,820
有目的的行为，

727
00:30:14,820 --> 00:30:18,419
如果代理有能力做到

728
00:30:18,419 --> 00:30:20,720
这一点，那么在我揭示结果之前，

729
00:30:20,720 --> 00:30:24,480
让我们讨论一下代理类，

730
00:30:24,480 --> 00:30:27,360
以便在给出观察结果时采取行动，

731
00:30:27,360 --> 00:30:30,179
代理应该

732
00:30:30,179 --> 00:30:33,120
有计划等等，所以

733
00:30:33,120 --> 00:30:35,700
这里是 代理复杂的

734
00:30:35,700 --> 00:30:38,340
推理代理，

735
00:30:38,340 --> 00:30:40,799
我们实际上正在使用

736
00:30:40,799 --> 00:30:43,320
现有的 Prime DB 代理来实现某些

737
00:30:43,320 --> 00:30:46,320
功能，因此在 Pym DP 中，我们已经

738
00:30:46,320 --> 00:30:50,580
有了一个写得很好的函数，

739
00:30:50,580 --> 00:30:52,200
用于感知

740
00:30:52,200 --> 00:30:55,200
和学习，所以我们唯一

741
00:30:55,200 --> 00:30:57,600
想要替换的是如何 代理

742
00:30:57,600 --> 00:30:59,640
正在进行规划以及代理如何

743
00:30:59,640 --> 00:31:03,360
对策略做出决策，因此

744
00:31:03,360 --> 00:31:05,600


745
00:31:05,779 --> 00:31:09,419
我们在这里使用该父代理

746
00:31:09,419 --> 00:31:11,640
类，因此

747
00:31:11,640 --> 00:31:14,340
从 dp.agent 开始，我们正在导入位于

748
00:31:14,340 --> 00:31:15,620


749
00:31:15,620 --> 00:31:19,500


750
00:31:19,500 --> 00:31:21,960
我们现在正在讨论的 SI 代理旁边的代理类，

751
00:31:21,960 --> 00:31:23,279
并且

752
00:31:23,279 --> 00:31:25,919
基本上，我们

753
00:31:25,919 --> 00:31:28,679
从主程序中获取该类工作的生成模型结构，

754
00:31:28,679 --> 00:31:30,480


755
00:31:30,480 --> 00:31:33,299
即 a b c 和 d 以及

756
00:31:33,299 --> 00:31:35,460
我提到的所有精度和阈值参数，

757
00:31:35,460 --> 00:31:36,480


758
00:31:36,480 --> 00:31:39,140
然后它是一种

759
00:31:39,140 --> 00:31:41,880
规范化我们

760
00:31:41,880 --> 00:31:45,240
在主程序中提到的先前会议，所以这里

761
00:31:45,240 --> 00:31:50,220
如果我看看 C 的结构是如何用

762
00:31:50,220 --> 00:31:52,620


763
00:31:52,620 --> 00:31:55,320
数字来定义的，并且

764
00:31:55,320 --> 00:31:56,940
通常会解释先验偏好，或者它应该是一个

765
00:31:56,940 --> 00:31:58,679
概率分布，以便

766
00:31:58,679 --> 00:32:01,020
计算正常工作，所以

767
00:32:01,020 --> 00:32:02,580
我们将把它标准化为

768
00:32:02,580 --> 00:32:05,460
概率分布，

769
00:32:05,460 --> 00:32:06,779
而不是 嗯，嗯，

770
00:32:06,779 --> 00:32:09,059
有一些数字

771
00:32:09,059 --> 00:32:11,340
加起来不等于一，所以这就是正在发生的事情，

772
00:32:11,340 --> 00:32:13,620
这里我们使用 softmax 来做到这一点，

773
00:32:13,620 --> 00:32:15,600
那么我们正在做的是，我们

774
00:32:15,600 --> 00:32:16,860


775
00:32:16,860 --> 00:32:20,159
用这些生成模型参数初始化现有的时间数据库代理，

776
00:32:20,159 --> 00:32:23,220
我们

777
00:32:23,220 --> 00:32:27,240
是什么 打算做的是

778
00:32:27,240 --> 00:32:28,860
为给定的规划范围

779
00:32:28,860 --> 00:32:32,039
和给定的三秒 um 阈值编写一个规划函数，

780
00:32:32,039 --> 00:32:35,399
所以

781
00:32:35,399 --> 00:32:37,740
这个代理类中有三个函数，

782
00:32:37,740 --> 00:32:39,720
第一个是用于规划的辅助函数，

783
00:32:39,720 --> 00:32:42,240
我们现在将讨论它，然后是

784
00:32:42,240 --> 00:32:45,120
一个规划函数本身 这将

785
00:32:45,120 --> 00:32:48,179
使用研究来进行规划，

786
00:32:48,179 --> 00:32:50,220
然后因为这是一项递归研究，

787
00:32:50,220 --> 00:32:52,260
我们将需要一个额外的

788
00:32:52,260 --> 00:32:54,980
函数来实现递归

789
00:32:54,980 --> 00:32:58,559
评估，我们将在函数本身内部调用

790
00:32:58,559 --> 00:33:00,799
这个函数，称为前向搜索，

791
00:33:00,799 --> 00:33:04,200
所以我们

792
00:33:04,200 --> 00:33:05,700
调用这个函数 在这个

793
00:33:05,700 --> 00:33:07,740
函数内部，这样就是计算

794
00:33:07,740 --> 00:33:09,240
下一步的预期自由能

795
00:33:09,240 --> 00:33:11,279
，它会在下一步再次调用它，

796
00:33:11,279 --> 00:33:13,740
直到我们到达我们的规划地平线，

797
00:33:13,740 --> 00:33:16,940
这就是递归循环的想法

798
00:33:16,940 --> 00:33:20,460
，最后它将返回

799
00:33:20,460 --> 00:33:23,460
所有动作的预期自由能 嗯，给定和

800
00:33:23,460 --> 00:33:25,679
观察，然后我们只需实现

801
00:33:25,679 --> 00:33:28,080
步骤函数，在该函数中按顺序编写给

802
00:33:28,080 --> 00:33:29,640


803
00:33:29,640 --> 00:33:32,460
定公告要执行的操作好吧，

804
00:33:32,460 --> 00:33:37,519
那么回到

805
00:33:38,279 --> 00:33:43,500
这里的演示，我们有第一个想法，您可以在哪里

806
00:33:43,500 --> 00:33:46,799
获得观察并给出一个

807
00:33:46,799 --> 00:33:49,860
操作，所以让我们转到 代理点阶跃

808
00:33:49,860 --> 00:33:52,260
函数并想象

809
00:33:52,260 --> 00:33:56,039
如果时间 t 等于 0 或在

810
00:33:56,039 --> 00:33:59,460
实验开始时会发生什么，

811
00:33:59,460 --> 00:34:01,019
理想情况下它首先应该做的

812
00:34:01,019 --> 00:34:03,779
是使用其观察来进入该状态，

813
00:34:03,779 --> 00:34:06,600
所以我们是什么 给它

814
00:34:06,600 --> 00:34:09,899
一个观察并使用

815
00:34:09,899 --> 00:34:12,899
进入的模块，它将提出

816
00:34:12,899 --> 00:34:16,619
一个信念 Qs，这是一个

817
00:34:16,619 --> 00:34:19,560
关于状态的信念，好吧，所以自点 Qs

818
00:34:19,560 --> 00:34:23,159
是对代理内部的信念，

819
00:34:23,159 --> 00:34:25,500
一旦它对它在哪里有了信念

820
00:34:25,500 --> 00:34:28,379
现在它可以实施计划点

821
00:34:28,379 --> 00:34:31,080
研究，即现在为

822
00:34:31,080 --> 00:34:33,839
隐藏状态的这种特定信念进行规划，

823
00:34:33,839 --> 00:34:36,359
一旦完成规划，

824
00:34:36,359 --> 00:34:39,239
它就可以使用

825
00:34:39,239 --> 00:34:42,239
IMDb 中的示例动作函数做出决定，并基本上

826
00:34:42,239 --> 00:34:45,540
返回它，呃返回该动作，如果

827
00:34:45,540 --> 00:34:48,000
它和其他每个时间步骤的

828
00:34:48,000 --> 00:34:50,580
序列保持相同，但

829
00:34:50,580 --> 00:34:52,139
如果您

830
00:34:52,139 --> 00:34:55,080
在地平线类中启用学习，那么它也会学习结构，

831
00:34:55,080 --> 00:34:56,639


832
00:34:56,639 --> 00:35:01,260
这就是步骤函数，但

833
00:35:01,260 --> 00:35:04,859
为了规划它的作用，它会进行某种

834
00:35:04,859 --> 00:35:06,599
重组

835
00:35:06,599 --> 00:35:08,880
任意数量的热和

836
00:35:08,880 --> 00:35:10,680
状态模态以及任意数量的

837
00:35:10,680 --> 00:35:12,240
观察模态的生成模型结构，

838
00:35:12,240 --> 00:35:16,320
因此为了讨论熔化是如何工作的，我

839
00:35:16,320 --> 00:35:17,760
想谈谈

840
00:35:17,760 --> 00:35:20,640
新的 a 矩阵和 B 矩阵，

841
00:35:20,640 --> 00:35:22,920
它评估用于实施该

842
00:35:22,920 --> 00:35:24,720
规划，

843
00:35:24,720 --> 00:35:27,780
让我们理解这

844
00:35:27,780 --> 00:35:31,380
一点 让我们回到最初的

845
00:35:31,380 --> 00:35:31,980


846
00:35:31,980 --> 00:35:34,440
隐藏状态因子，所以这里我们只有

847
00:35:34,440 --> 00:35:36,780
一个隐藏状态因子，

848
00:35:36,780 --> 00:35:39,599
这就是为什么 d0 是正确的，而 B1

849
00:35:39,599 --> 00:35:43,200
不存在，因为我们只有一个

850
00:35:43,200 --> 00:35:45,660
隐藏状态因子，但想象一下，如果

851
00:35:45,660 --> 00:35:47,880
我有两个隐藏状态参与者

852
00:35:47,880 --> 00:35:50,880
具有相同的大小，也许

853
00:35:50,880 --> 00:35:53,460
嗯，所以这里可能是一个位置，

854
00:35:53,460 --> 00:35:56,880
也许是代理头脑中的其他东西

855
00:35:56,880 --> 00:35:57,660


856
00:35:57,660 --> 00:36:00,780
，我们也应该

857
00:36:00,780 --> 00:36:05,180
对这两个隐藏的状态因素进行控制，就像

858
00:36:05,220 --> 00:36:06,300
嗯，

859
00:36:06,300 --> 00:36:08,700
所以应该对每个

860
00:36:08,700 --> 00:36:10,920
热量和状态因素进行控制，如果你' 熟悉

861
00:36:10,920 --> 00:36:13,859
主动推理

862
00:36:13,859 --> 00:36:17,040
思想，然后也许观察

863
00:36:17,040 --> 00:36:18,540
空间也可以

864
00:36:18,540 --> 00:36:20,640
直接观察这两个辐射

865
00:36:20,640 --> 00:36:21,900
率因子，

866
00:36:21,900 --> 00:36:24,420
所以这是一个

867
00:36:24,420 --> 00:36:26,040
具有多个隐藏状态

868
00:36:26,040 --> 00:36:29,579
和多个观察模式的新生成模型结构，

869
00:36:29,579 --> 00:36:32,040
您可以立即看到参数

870
00:36:32,040 --> 00:36:33,660
的维度

871
00:36:33,660 --> 00:36:37,500
发生变化 你有 25 个观测值，来自

872
00:36:37,500 --> 00:36:39,300


873
00:36:39,300 --> 00:36:43,320
25 个隐藏状态乘以 25 个，如果你

874
00:36:43,320 --> 00:36:44,520
看看第一个

875
00:36:44,520 --> 00:36:47,220
观测模态的结构，它是相同的，但

876
00:36:47,220 --> 00:36:49,920
我们想要的是一个新的矩阵，其中它将

877
00:36:49,920 --> 00:36:54,240
是 25 呃，不是两个隐藏

878
00:36:54,240 --> 00:36:55,920
状态，而是一个 在状态之间，这

879
00:36:55,920 --> 00:36:58,320
只是

880
00:36:58,320 --> 00:37:01,440
生成模型的重组，但

881
00:37:01,440 --> 00:37:03,660
计算本质上保持相同，

882
00:37:03,660 --> 00:37:04,380


883
00:37:04,380 --> 00:37:06,900
所以这就是

884
00:37:06,900 --> 00:37:09,180
这个辅助函数

885
00:37:09,180 --> 00:37:11,940
试图做的事情，

886
00:37:11,940 --> 00:37:13,800
当我们有多个隐藏状态模态时，这将使我们的事情变得更容易，

887
00:37:13,800 --> 00:37:15,720


888
00:37:15,720 --> 00:37:18,180
所以

889
00:37:18,180 --> 00:37:19,859
如果你有多个隐藏状态

890
00:37:19,859 --> 00:37:21,060
模态

891
00:37:21,060 --> 00:37:23,280
我们将计算

892
00:37:23,280 --> 00:37:25,320
您拥有的总状态数，这是

893
00:37:25,320 --> 00:37:27,720


894
00:37:27,720 --> 00:37:29,760
每种模态中写入状态数量的乘积，所以如果您

895
00:37:29,760 --> 00:37:32,280
在一种模态中有 25 个隐藏状态，

896
00:37:32,280 --> 00:37:33,960
在另一种模态中有 25 个隐藏状态，那么

897
00:37:33,960 --> 00:37:37,380
总共将有 625 个状态

898
00:37:37,380 --> 00:37:40,079
如果每个模态都有 4 个

899
00:37:40,079 --> 00:37:43,020
动作，那么

900
00:37:43,020 --> 00:37:45,660
总共有 16 个动作，这

901
00:37:45,660 --> 00:37:47,700
只不过是

902
00:37:47,700 --> 00:37:51,119
模态中每个动作的这四个动作的组合所以

903
00:37:51,119 --> 00:37:53,220
你将有 4 次 4 16 个

904
00:37:53,220 --> 00:37:55,560
动作，如果你 有两种模式，

905
00:37:55,560 --> 00:37:57,599
基本上是

906
00:37:57,599 --> 00:38:00,140
要构建一个生成模型，

907
00:38:00,140 --> 00:38:03,300
该

908
00:38:03,300 --> 00:38:05,640
模型参数相同，但

909
00:38:05,640 --> 00:38:07,380
维度结构不同，这样

910
00:38:07,380 --> 00:38:09,240
我们就更容易计算

911
00:38:09,240 --> 00:38:10,260
预期，所以

912
00:38:10,260 --> 00:38:14,640
现在我们有一个新的 a 和新的 B

913
00:38:14,640 --> 00:38:17,520
以及一个新的信念 这只不过是

914
00:38:17,520 --> 00:38:20,880
张量积，所以现有的参数

915
00:38:20,880 --> 00:38:23,460
和信念，所以它只是一个新的

916
00:38:23,460 --> 00:38:27,359
大矩阵，没有别的了，好吧，这

917
00:38:27,359 --> 00:38:29,820
不是转移，不是变化，

918
00:38:29,820 --> 00:38:32,579
只是结构的转换，

919
00:38:32,579 --> 00:38:36,420
给定 a b 和 Q，我们将

920
00:38:36,420 --> 00:38:38,520
预测会发生什么

921
00:38:38,520 --> 00:38:41,520
未来发生的事情并评估他们的预期支付

922
00:38:41,520 --> 00:38:43,680
能量，因此

923
00:38:43,680 --> 00:38:46,440
为了进行规划，这是

924
00:38:46,440 --> 00:38:48,060
我们要做的第二个函数，

925
00:38:48,060 --> 00:38:50,760
首先调用第一个函数，它将

926
00:38:50,760 --> 00:38:52,800
为我们进行熔化并

927
00:38:52,800 --> 00:38:55,380
在中建立生成模型 在良好的

928
00:38:55,380 --> 00:38:59,040
维度 cc 中进行计算，那么我们就有了

929
00:38:59,040 --> 00:39:01,500
所有动作的预期自由能本身，

930
00:39:01,500 --> 00:39:02,579


931
00:39:02,579 --> 00:39:07,040
然后我们就有了

932
00:39:07,040 --> 00:39:09,300
依赖于这些动作的预期自由能的概率，

933
00:39:09,300 --> 00:39:11,579
那么为什么它只是

934
00:39:11,579 --> 00:39:13,680
动作而不是观察，因为

935
00:39:13,680 --> 00:39:16,619
我们在这里 为了评估给定观察的预期

936
00:39:16,619 --> 00:39:18,960
行动自由

937
00:39:18,960 --> 00:39:22,140
能，所以

938
00:39:22,140 --> 00:39:23,460
让我

939
00:39:23,460 --> 00:39:26,280
回到

940
00:39:26,280 --> 00:39:29,240
幻灯片并以

941
00:39:29,240 --> 00:39:31,920
图解的方式讨论这个，以使事情变得更容易，所以

942
00:39:31,920 --> 00:39:33,960
这里我们有网格，我们有

943
00:39:33,960 --> 00:39:36,119
更高的足迹以及我们正在尝试

944
00:39:36,119 --> 00:39:38,640
实现的内容 就是如果你

945
00:39:38,640 --> 00:39:41,700
在时间 T 观察到一些观察，那么你将

946
00:39:41,700 --> 00:39:44,460
考虑给定

947
00:39:44,460 --> 00:39:47,640
该观察的你的行为的后果，因为

948
00:39:47,640 --> 00:39:49,980
你可以预测将会发生什么，

949
00:39:49,980 --> 00:39:51,599
因为在你的生成模型中，你

950
00:39:51,599 --> 00:39:53,700
有过渡动力学，它会

951
00:39:53,700 --> 00:39:57,000
告诉你给定这个状态，如果 我采取这个

952
00:39:57,000 --> 00:39:58,380
行动，我最终会得到正确的结果，

953
00:39:58,380 --> 00:40:00,359
所以这基本上是预测

954
00:40:00,359 --> 00:40:03,180
未来会发生什么，你

955
00:40:03,180 --> 00:40:05,760
现在正在考虑

956
00:40:05,760 --> 00:40:09,839
你的阿森纳中可用行动的后果，

957
00:40:09,839 --> 00:40:12,540
然后如果你采取行动，那么你可以

958
00:40:12,540 --> 00:40:14,280
预测下一步将发生什么

959
00:40:14,280 --> 00:40:16,440
作为新的观察，

960
00:40:16,440 --> 00:40:18,960
这样你就有一个概率

961
00:40:18,960 --> 00:40:20,760
分布，告诉你

962
00:40:20,760 --> 00:40:23,460
这个观察是最有可能的，

963
00:40:23,460 --> 00:40:25,320
而其他观察不太

964
00:40:25,320 --> 00:40:27,839
可能，那么你要做的

965
00:40:27,839 --> 00:40:30,359
就是你做的 你再次考虑根据

966
00:40:30,359 --> 00:40:32,220


967
00:40:32,220 --> 00:40:34,740
该特定观察采取行动的后果，并且这会

968
00:40:34,740 --> 00:40:37,440
在你的计划深度中继续进行，因此

969
00:40:37,440 --> 00:40:39,780
这可以被认为是也许你

970
00:40:39,780 --> 00:40:42,480
想去健身房，那么你将

971
00:40:42,480 --> 00:40:44,460
考虑所有后果

972
00:40:44,460 --> 00:40:46,740
如果我穿鞋，如果我

973
00:40:46,740 --> 00:40:49,800
不穿鞋，如果我开车，

974
00:40:49,800 --> 00:40:52,140
如果我不开车，那么你会意识到，

975
00:40:52,140 --> 00:40:54,300
好吧，我必须穿鞋，然后

976
00:40:54,300 --> 00:40:56,700
你会考虑

977
00:40:56,700 --> 00:40:59,520
我的后果 我现在准备好去健身房了，我

978
00:40:59,520 --> 00:41:01,680
去健身房最终会在

979
00:41:01,680 --> 00:41:03,660
健身房里，所以这个想法就像你

980
00:41:03,660 --> 00:41:05,760
考虑你现在所处位置的后果

981
00:41:05,760 --> 00:41:08,760
，你可以按照你的预测去尽可能多的地方

982
00:41:08,760 --> 00:41:10,740
所以在一场国际

983
00:41:10,740 --> 00:41:12,420
象棋比赛中，你可能处于一个

984
00:41:12,420 --> 00:41:14,220
特定的状态，你考虑你的

985
00:41:14,220 --> 00:41:16,440
后果，你看到未来，你

986
00:41:16,440 --> 00:41:18,480
考虑未来的后果

987
00:41:18,480 --> 00:41:21,660
，你可以

988
00:41:21,660 --> 00:41:23,099


989
00:41:23,099 --> 00:41:23,700


990
00:41:23,700 --> 00:41:25,920
根据你的计算

991
00:41:25,920 --> 00:41:27,839
能力走多深，嗯嗯，这就是你的情况

992
00:41:27,839 --> 00:41:31,740
尝试在这个代理类中实现，

993
00:41:31,740 --> 00:41:36,500
我们正在考虑后果，

994
00:41:36,780 --> 00:41:38,880
是的，

995
00:41:38,880 --> 00:41:40,200
所以

996
00:41:40,200 --> 00:41:42,240
对于每种模式，我们将

997
00:41:42,240 --> 00:41:44,460
考虑动作的预期自由能，

998
00:41:44,460 --> 00:41:46,859


999
00:41:46,859 --> 00:41:49,260
这基本上会调用下一个

1000
00:41:49,260 --> 00:41:51,420
函数，即前向搜索，所以

1001
00:41:51,420 --> 00:41:53,579
前向搜索正在实现

1002
00:41:53,579 --> 00:41:55,560
我想要的东西 刚刚提到，

1003
00:41:55,560 --> 00:41:58,440
嗯，考虑后果，在前向

1004
00:41:58,440 --> 00:42:00,000
搜索中，您基本上

1005
00:42:00,000 --> 00:42:04,020
所做的是针对每个动作，因此在第 149 行中，

1006
00:42:04,020 --> 00:42:06,119
我有一个循环遍历每个

1007
00:42:06,119 --> 00:42:07,140
动作，

1008
00:42:07,140 --> 00:42:08,760
然后我将考虑

1009
00:42:08,760 --> 00:42:11,640


1010
00:42:11,640 --> 00:42:14,400
我使用的所有这些动作的后验或后果 转移

1011
00:42:14,400 --> 00:42:16,619
概率来评估

1012
00:42:16,619 --> 00:42:17,880
后果

1013
00:42:17,880 --> 00:42:19,260
然后我将预测

1014
00:42:19,260 --> 00:42:21,000
观察结果，因为我之前的

1015
00:42:21,000 --> 00:42:23,520
偏好是根据

1016
00:42:23,520 --> 00:42:25,980
观察结果定义的我将预测我的

1017
00:42:25,980 --> 00:42:28,260
观察结果，然后评估

1018
00:42:28,260 --> 00:42:29,720
预期的自由能，

1019
00:42:29,720 --> 00:42:33,960
这是风险和模糊性的总和，

1020
00:42:33,960 --> 00:42:37,320
好吧，我希望 这是有道理的，就像在这里，

1021
00:42:37,320 --> 00:42:39,540
您已经考虑了考虑

1022
00:42:39,540 --> 00:42:41,040
后果，即

1023
00:42:41,040 --> 00:42:43,320
未来的后果，即

1024
00:42:43,320 --> 00:42:45,180
后或后的结果，

1025
00:42:45,180 --> 00:42:47,280
并且您基本上

1026
00:42:47,280 --> 00:42:49,800
是根据您的

1027
00:42:49,800 --> 00:42:52,140
预期范围来评估后验的好坏，并且这成为

1028
00:42:52,140 --> 00:42:53,880
该特定事故的预期自由能，并且

1029
00:42:53,880 --> 00:42:56,160
你对所有动作都这样做，

1030
00:42:56,160 --> 00:42:57,359


1031
00:42:57,359 --> 00:43:01,260
好吧，为什么这很强大，

1032
00:43:01,260 --> 00:43:03,540
因为你可以随心所欲地深入，

1033
00:43:03,540 --> 00:43:07,020
所以在下一步中，你会转到这个

1034
00:43:07,020 --> 00:43:07,980
战利品，

1035
00:43:07,980 --> 00:43:11,819
在那里你将检查我是否跨越了我的

1036
00:43:11,819 --> 00:43:14,520
深层计划或深度 规划，

1037
00:43:14,520 --> 00:43:16,380
然后你做的事情基本上是

1038
00:43:16,380 --> 00:43:18,780
相同的，给定后验，

1039
00:43:18,780 --> 00:43:20,520


1040
00:43:20,520 --> 00:43:22,500
特定后验的行动的结果是什么，所以

1041
00:43:22,500 --> 00:43:23,339
在这里

1042
00:43:23,339 --> 00:43:24,900
考虑我们再次

1043
00:43:24,900 --> 00:43:28,020
调用 um 父函数，所以

1044
00:43:28,020 --> 00:43:30,599
相同的函数向前搜索来考虑

1045
00:43:30,599 --> 00:43:33,180
这些组合的后果，

1046
00:43:33,180 --> 00:43:34,980
它基本上会回来并加到

1047
00:43:34,980 --> 00:43:37,380
您预期的自由能上，所以在

1048
00:43:37,380 --> 00:43:40,140
这个序列中发生的事情是您

1049
00:43:40,140 --> 00:43:43,319
考虑一些或所有未来的后果

1050
00:43:43,319 --> 00:43:46,579
，然后所有这些值都会

1051
00:43:46,579 --> 00:43:48,720
滴到

1052
00:43:48,720 --> 00:43:51,420
您的树上，您的

1053
00:43:51,420 --> 00:43:53,400
预期自由能的总和会告诉您 哪个

1054
00:43:53,400 --> 00:43:55,140
行动是好的，哪个行动是坏的，

1055
00:43:55,140 --> 00:43:56,940
您可以

1056
00:43:56,940 --> 00:43:58,980
采取嗯，看看您喜欢的

1057
00:43:58,980 --> 00:44:00,240
观察结果，这就是

1058
00:44:00,240 --> 00:44:02,520
实施研究的想法，

1059
00:44:02,520 --> 00:44:05,819
我还将

1060
00:44:05,819 --> 00:44:09,180
在这里讨论呃这个阈值的重要性呃，

1061
00:44:09,180 --> 00:44:11,819
这就是这使得这个

1062
00:44:11,819 --> 00:44:13,980
算法是可能的，所以如果没有这个

1063
00:44:13,980 --> 00:44:16,140
阈值，这个算法将无法

1064
00:44:16,140 --> 00:44:19,200
工作，我将明确地讨论为什么会出现这种

1065
00:44:19,200 --> 00:44:21,960
情况，然后

1066
00:44:21,960 --> 00:44:23,819
一旦你评估了给定当前状态的

1067
00:44:23,819 --> 00:44:26,460
所有可用动作的预期自由能，

1068
00:44:26,460 --> 00:44:28,800
你基本上可以

1069
00:44:28,800 --> 00:44:30,420
计算

1070
00:44:30,420 --> 00:44:32,420
你所说的动作分布

1071
00:44:32,420 --> 00:44:36,240
这就是我的行动的可能性有多大，或者

1072
00:44:36,240 --> 00:44:37,800
我应该如何采取行动，

1073
00:44:37,800 --> 00:44:40,740
所以我们也有这个行动的

1074
00:44:40,740 --> 00:44:43,560
精度参数 Alpha，所以如果 Alpha

1075
00:44:43,560 --> 00:44:46,740
非常高，那么它基本上是一个

1076
00:44:46,740 --> 00:44:48,839
高度倾斜的分布，您

1077
00:44:48,839 --> 00:44:50,099
将始终选择

1078
00:44:50,099 --> 00:44:52,920
最小化预期的行动 自由能，如果 Alpha

1079
00:44:52,920 --> 00:44:55,800
确实很低，那么它将是一个

1080
00:44:55,800 --> 00:44:56,700
更加

1081
00:44:56,700 --> 00:44:59,400
稀疏或分散的分布，

1082
00:44:59,400 --> 00:45:00,599
然后您可以使用此动作

1083
00:45:00,599 --> 00:45:02,339
分布

1084
00:45:02,339 --> 00:45:07,200
来对动作进行采样，因此在亚洲

1085
00:45:07,200 --> 00:45:09,720
环境循环中，我们刚刚完成了

1086
00:45:09,720 --> 00:45:12,180
规划和计算该动作

1087
00:45:12,180 --> 00:45:14,460
分布 然后使用该动作

1088
00:45:14,460 --> 00:45:16,980
分布，您可以

1089
00:45:16,980 --> 00:45:19,440
从策略空间中采样一个动作，所以让我们看看

1090
00:45:19,440 --> 00:45:21,060
这个生成模型中的策略空间，

1091
00:45:21,060 --> 00:45:23,040


1092
00:45:23,040 --> 00:45:25,619
所以我切换回带有

1093
00:45:25,619 --> 00:45:27,480
一个隐藏状态因子的原始生成模型，

1094
00:45:27,480 --> 00:45:28,760


1095
00:45:28,760 --> 00:45:30,660


1096
00:45:30,660 --> 00:45:33,720
让我们进行规划

1097
00:45:33,720 --> 00:45:35,599
，也许

1098
00:45:35,599 --> 00:45:38,819
初始化这个代理

1099
00:45:38,819 --> 00:45:41,400
我只是想初始化这个代理来

1100
00:45:41,400 --> 00:45:44,460
查看策略空间而不是运行值，

1101
00:45:44,460 --> 00:45:47,000
所以

1102
00:45:49,800 --> 00:45:52,440
我初始化这个代理，比如说规划

1103
00:45:52,440 --> 00:45:56,099
深度为一，如果我查看

1104
00:45:56,099 --> 00:45:59,300
代理点

1105
00:46:04,079 --> 00:46:05,520
策略，

1106
00:46:05,520 --> 00:46:07,920
我可以说我基本上有四个

1107
00:46:07,920 --> 00:46:10,800
可用的操作，呃，这不是

1108
00:46:10,800 --> 00:46:13,560
东南和 West，如果我有一个

1109
00:46:13,560 --> 00:46:15,780
行动分布，呃，它会告诉我

1110
00:46:15,780 --> 00:46:18,060
采取该行动的可能性有多大，所以

1111
00:46:18,060 --> 00:46:19,260
如果我看一下

1112
00:46:19,260 --> 00:46:22,040


1113
00:46:23,339 --> 00:46:27,420
Pi 的代理，那么好吧，所以这没有定义，

1114
00:46:27,420 --> 00:46:30,540
因为我还没有做计划，但我

1115
00:46:30,540 --> 00:46:32,160
可以做计划，然后它会 被

1116
00:46:32,160 --> 00:46:34,578
定义

1117
00:46:38,700 --> 00:46:41,460
是的，所以我通过研究实施了规划

1118
00:46:41,460 --> 00:46:43,079
，然后现在我有了一个行动

1119
00:46:43,079 --> 00:46:45,119
分布，所以对于这个特定的

1120
00:46:45,119 --> 00:46:47,339
场景，我将采取我的第三个

1121
00:46:47,339 --> 00:46:48,900
行动最多，

1122
00:46:48,900 --> 00:46:52,200
即 0.99 基本上，这就是

1123
00:46:52,200 --> 00:46:54,300


1124
00:46:54,300 --> 00:46:56,099
在这个特定情况下我的南北和东部的概率

1125
00:46:56,099 --> 00:46:58,400
只是想让

1126
00:46:58,400 --> 00:47:01,800
您熟悉矩阵，但我们

1127
00:47:01,800 --> 00:47:03,359
现在将看到

1128
00:47:03,359 --> 00:47:05,760
代理环境循环的运行，

1129
00:47:05,760 --> 00:47:07,500


1130
00:47:07,500 --> 00:47:09,000
是的，

1131
00:47:09,000 --> 00:47:12,359
现在您可以从

1132
00:47:12,359 --> 00:47:15,180
示例操作函数中采样操作，然后

1133
00:47:15,180 --> 00:47:17,099
使用

1134
00:47:17,099 --> 00:47:19,560
标准 Pym DP 方式实现学习 我将根据我所看到的和我的信念等来更新

1135
00:47:19,560 --> 00:47:21,720
我的过渡动态和类似的

1136
00:47:21,720 --> 00:47:23,880
动态，所以

1137
00:47:23,880 --> 00:47:26,099
我的

1138
00:47:26,099 --> 00:47:31,280
重点是决策部分，

1139
00:47:38,220 --> 00:47:40,980
所以一旦你对一个动作进行采样，那么该

1140
00:47:40,980 --> 00:47:43,520
动作基本上就会回到

1141
00:47:43,520 --> 00:47:46,940
环境，好吧，所以现在 让我们在

1142
00:47:46,940 --> 00:47:49,800
规划深度为 1 的情况下实现这一点，

1143
00:47:49,800 --> 00:47:53,099
看看智能体的行为

1144
00:47:53,099 --> 00:47:55,920
如何，如果规划深度为 1，

1145
00:47:55,920 --> 00:47:57,960
则意味着智能体只

1146
00:47:57,960 --> 00:47:59,760
考虑一次

1147
00:47:59,760 --> 00:48:01,920
Step Ahead 的结果，只是看到近期的

1148
00:48:01,920 --> 00:48:05,040
规划未来 是的，所以我

1149
00:48:05,040 --> 00:48:08,040
给出的规划深度为一，

1150
00:48:08,040 --> 00:48:09,900
我正在重置

1151
00:48:09,900 --> 00:48:11,700
代理将从

1152
00:48:11,700 --> 00:48:14,099
初始启动状态开始的环境，

1153
00:48:14,099 --> 00:48:16,260


1154
00:48:16,260 --> 00:48:18,900
并且在循环中它将

1155
00:48:18,900 --> 00:48:20,960


1156
00:48:22,079 --> 00:48:24,359
得到观察，

1157
00:48:24,359 --> 00:48:27,300
采取该操作，返回一个操作，然后

1158
00:48:27,300 --> 00:48:29,060
我们将查看动作概率，

1159
00:48:29,060 --> 00:48:31,920
并且我们还将将该动作返回

1160
00:48:31,920 --> 00:48:33,119
给环境，取回观察

1161
00:48:33,119 --> 00:48:35,040
结果，这个循环将继续，直到

1162
00:48:35,040 --> 00:48:37,740
情节终止，我将

1163
00:48:37,740 --> 00:48:39,780
情节长度设置为 8 只是为了

1164
00:48:39,780 --> 00:48:42,900
查看税收的结果，

1165
00:48:42,900 --> 00:48:46,920
所以 当我们运行这个循环时，这些矩阵

1166
00:48:46,920 --> 00:48:48,780
只不过是

1167
00:48:48,780 --> 00:48:51,900
每个动作被执行的可能性的动作分布，

1168
00:48:51,900 --> 00:48:54,960
这就是代理在

1169
00:48:54,960 --> 00:48:58,020
最后一个文本中结束的地方，好吧，所以让我们

1170
00:48:58,020 --> 00:49:00,900
也可以启用一个将显示的环境或

1171
00:49:00,900 --> 00:49:03,839
渲染 我们的代理

1172
00:49:03,839 --> 00:49:06,000
在每个时间步都在哪里，

1173
00:49:06,000 --> 00:49:08,880
所以最初代理在这个

1174
00:49:08,880 --> 00:49:11,400
位置，我们在这里有一个动作

1175
00:49:11,400 --> 00:49:14,400
分布，所以不是

1176
00:49:14,400 --> 00:49:16,440
东南和西，所以代理知道它

1177
00:49:16,440 --> 00:49:19,260
应该向北，为什么，因为如果我看看

1178
00:49:19,260 --> 00:49:21,720
之前的偏好

1179
00:49:21,720 --> 00:49:23,940
嗯，这个状态比

1180
00:49:23,940 --> 00:49:25,800
这个状态更受欢迎，所以代理

1181
00:49:25,800 --> 00:49:27,720
成功计算了预期的

1182
00:49:27,720 --> 00:49:30,540
自由能，并推断出我

1183
00:49:30,540 --> 00:49:33,480
应该进入这个状态而不是停留在

1184
00:49:33,480 --> 00:49:35,220
这个状态，因为它具有

1185
00:49:35,220 --> 00:49:36,780


1186
00:49:36,780 --> 00:49:39,060
可用的转换生成模型，所以它可以推断出我 应该

1187
00:49:39,060 --> 00:49:41,640
采取行动向北去州，

1188
00:49:41,640 --> 00:49:42,540


1189
00:49:42,540 --> 00:49:45,540
这样很好，代理向北走，

1190
00:49:45,540 --> 00:49:47,880
在这个特定的州，

1191
00:49:47,880 --> 00:49:49,920
代理推断它应该去

1192
00:49:49,920 --> 00:49:52,800
东北，所以它将采取向东的行动，

1193
00:49:52,800 --> 00:49:53,819


1194
00:49:53,819 --> 00:49:56,460
呃，它将去这里和在 此时，

1195
00:49:56,460 --> 00:49:59,520
呃，我希望您注意，

1196
00:49:59,520 --> 00:50:01,200
行动分布在

1197
00:50:01,200 --> 00:50:04,260
北部和东部的可能性相同，这是为什么，

1198
00:50:04,260 --> 00:50:06,599
因为智能体只着眼于

1199
00:50:06,599 --> 00:50:08,640
不久的将来，所以让我们回到

1200
00:50:08,640 --> 00:50:09,839


1201
00:50:09,839 --> 00:50:12,599
先前的偏好，即智能体现在

1202
00:50:12,599 --> 00:50:15,420
在这里

1203
00:50:15,420 --> 00:50:18,240
或 是在这里吗 是的，现在就

1204
00:50:18,240 --> 00:50:20,700
在这个特定的状态，如果

1205
00:50:20,700 --> 00:50:22,260
智能体正在考虑

1206
00:50:22,260 --> 00:50:25,020
一个动作的直接后果，那么

1207
00:50:25,020 --> 00:50:27,900
这两个状态对于下一步来说同样有利，

1208
00:50:27,900 --> 00:50:30,599
所以

1209
00:50:30,599 --> 00:50:33,240
这两个状态之间没有区别，如果

1210
00:50:33,240 --> 00:50:34,680
它只是着眼于不久的

1211
00:50:34,680 --> 00:50:37,260
将来，所以这意味着预期的

1212
00:50:37,260 --> 00:50:39,660
自由能将得出结论，我

1213
00:50:39,660 --> 00:50:41,460
应该去北方或东方，

1214
00:50:41,460 --> 00:50:43,800
如果我只看一次并不重要，

1215
00:50:43,800 --> 00:50:47,760
向前一步，好吧，这就是想法，

1216
00:50:47,760 --> 00:50:53,040
并且出于概率 它要去这里，

1217
00:50:53,040 --> 00:50:56,640
它采取行动向东，从这个

1218
00:50:56,640 --> 00:50:57,420
嗯

1219
00:50:57,420 --> 00:50:59,220
州，当它进行推理时，它

1220
00:50:59,220 --> 00:51:01,740
推断出这个州更好，

1221
00:51:01,740 --> 00:51:03,780
基本上它最终会到达这个

1222
00:51:03,780 --> 00:51:06,960
当地的马克西玛州，

1223
00:51:06,960 --> 00:51:10,740
这是一个特定的州，

1224
00:51:10,740 --> 00:51:12,599
邻近的州准备不足，并且

1225
00:51:12,599 --> 00:51:14,940
这是墙，你不能去

1226
00:51:14,940 --> 00:51:16,980
那里，因为

1227
00:51:16,980 --> 00:51:19,440
结构禁止代理，所以它基本上

1228
00:51:19,440 --> 00:51:21,839
会永远坐在那里，它只能

1229
00:51:21,839 --> 00:51:25,619
看到本地优先级最大值

1230
00:51:25,619 --> 00:51:27,300
，

1231
00:51:27,300 --> 00:51:30,960
让我们看看如果你

1232
00:51:30,960 --> 00:51:33,839
有更高的规划可能会发生什么 深度，所以如果我进入

1233
00:51:33,839 --> 00:51:37,800
三微米的规划深度，

1234
00:51:37,800 --> 00:51:39,480
那么这意味着

1235
00:51:39,480 --> 00:51:42,240
代理实际上

1236
00:51:42,240 --> 00:51:45,599
在最后一个时间步达到了黄金状态，但仍然在

1237
00:51:45,599 --> 00:51:46,980
第三个时间点，

1238
00:51:46,980 --> 00:51:49,859
它有

1239
00:51:49,859 --> 00:51:53,520
两个概率动作，也没有钢琴家，所以

1240
00:51:53,520 --> 00:51:56,700
从这个特定的状态开始

1241
00:51:56,700 --> 00:51:59,880
它采取向北行动的概率，但

1242
00:51:59,880 --> 00:52:01,980
它不能同样采取向东行动

1243
00:52:01,980 --> 00:52:04,200
并最终到达这个局部最大值，所以让我们

1244
00:52:04,200 --> 00:52:06,780
再次运行，可能它最终会到达

1245
00:52:06,780 --> 00:52:10,260
这个局部最大值好吧，并且

1246
00:52:10,260 --> 00:52:12,300
仅适用于四的规划深度，

1247
00:52:12,300 --> 00:52:15,119
这已经足够了呃 这

1248
00:52:15,119 --> 00:52:18,900
对于这个特定的网格是必要的，

1249
00:52:18,900 --> 00:52:21,599
嗯，代理完全确定

1250
00:52:21,599 --> 00:52:24,540
在每个时间点要做什么，它完全确定

1251
00:52:24,540 --> 00:52:28,140
要做什么，呃，它必须先向北，

1252
00:52:28,140 --> 00:52:31,559
然后向东，东北，东北，

1253
00:52:31,559 --> 00:52:34,500
向南，到达这个特定的状态 因此，

1254
00:52:34,500 --> 00:52:36,119
只有时间步长

1255
00:52:36,119 --> 00:52:39,300
um 或计划深度 n 等于 4 时，它才能

1256
00:52:39,300 --> 00:52:41,819
成功导航该网格

1257
00:52:41,819 --> 00:52:44,599
um，

1258
00:52:44,599 --> 00:52:47,339
这就是

1259
00:52:47,339 --> 00:52:50,160
我希望

1260
00:52:50,160 --> 00:52:51,059
您得到的实现的想法，所以

1261
00:52:51,059 --> 00:52:53,400
还有行动精度的想法，

1262
00:52:53,400 --> 00:52:55,319
所以这里有一个高行动

1263
00:52:55,319 --> 00:52:58,319
精度，即 为什么它采取的

1264
00:52:58,319 --> 00:53:01,319
行动是从概率开始的，如果

1265
00:53:01,319 --> 00:53:03,180
它是一个低行动精度，

1266
00:53:03,180 --> 00:53:05,460
嗯，那么

1267
00:53:05,460 --> 00:53:09,780
好的行动更有可能发生，但这

1268
00:53:09,780 --> 00:53:12,540
并不意味着它会

1269
00:53:12,540 --> 00:53:16,800
在这里采取正确的行动，因为它正在采取

1270
00:53:16,800 --> 00:53:19,079
正确的行动，并且 达到状态，但

1271
00:53:19,079 --> 00:53:21,000
这里的概率是大多数通过的，但

1272
00:53:21,000 --> 00:53:23,700


1273
00:53:23,700 --> 00:53:27,059
如果

1274
00:53:27,059 --> 00:53:29,520
你控制这个动作过程，你也会在更多的试验中看到类似的探索行为，所以我将

1275
00:53:29,520 --> 00:53:31,859
它设置为一个高值，以确保

1276
00:53:31,859 --> 00:53:33,780
代理达到

1277
00:53:33,780 --> 00:53:36,180
这个特定的目标 问题，但它

1278
00:53:36,180 --> 00:53:38,760
值得玩，而且很重要，

1279
00:53:38,760 --> 00:53:40,500


1280
00:53:40,500 --> 00:53:42,180


1281
00:53:42,180 --> 00:53:42,720


1282
00:53:42,720 --> 00:53:45,480
好吧，是的，所以对于不同的规划

1283
00:53:45,480 --> 00:53:47,760
深度，例如这个问题中的一三和四，

1284
00:53:47,760 --> 00:53:49,980
这是

1285
00:53:49,980 --> 00:53:52,740
您期望的较低规划深度的行为，

1286
00:53:52,740 --> 00:53:54,660
这还不够，代理最终会

1287
00:53:54,660 --> 00:53:58,140
出现在本地 Maximus 和

1288
00:53:58,140 --> 00:54:00,420
/或 预期自由能的局部最小值

1289
00:54:00,420 --> 00:54:03,420
或油炸蓝图的局部最大值，但

1290
00:54:03,420 --> 00:54:05,280
有足够的规划，它

1291
00:54:05,280 --> 00:54:08,099
能够导航并达到目标，

1292
00:54:08,099 --> 00:54:12,180
这样我们就到了本教程的最后一点，

1293
00:54:12,180 --> 00:54:14,160


1294
00:54:14,160 --> 00:54:15,420


1295
00:54:15,420 --> 00:54:19,880
为什么在评估复杂推理时有一个阈值很重要，

1296
00:54:19,880 --> 00:54:22,640


1297
00:54:22,640 --> 00:54:26,400
所以

1298
00:54:26,400 --> 00:54:29,339
通过阈值，我们的意思是，我们可以

1299
00:54:29,339 --> 00:54:31,859
在两个层面上忽略未来的可能性，

1300
00:54:31,859 --> 00:54:34,200
你可以忽略

1301
00:54:34,200 --> 00:54:36,900


1302
00:54:36,900 --> 00:54:39,300
本研究中不太可能的行动或不太可能的观察，但如果你

1303
00:54:39,300 --> 00:54:41,300
考虑

1304
00:54:41,300 --> 00:54:44,220
所有行动和观察的后果，这

1305
00:54:44,220 --> 00:54:46,020
意味着你必须考虑

1306
00:54:46,020 --> 00:54:48,240
首先有四个后果，那么您

1307
00:54:48,240 --> 00:54:50,040
将不得不考虑下

1308
00:54:50,040 --> 00:54:52,559
一个时间步中动作状态的四倍，

1309
00:54:52,559 --> 00:54:55,140
然后所有这些都

1310
00:54:55,140 --> 00:54:56,760
乘以动作数量

1311
00:54:56,760 --> 00:54:59,579
，这项研究变得棘手，

1312
00:54:59,579 --> 00:55:02,400
直到爆炸，甚至比

1313
00:55:02,400 --> 00:55:04,079
经典的主动推理策略

1314
00:55:04,079 --> 00:55:07,140
空间问题，但是通过定义一个

1315
00:55:07,140 --> 00:55:10,260
甚至很小的值的阈值，我们将

1316
00:55:10,260 --> 00:55:12,000
忽略可能性，

1317
00:55:12,000 --> 00:55:15,420
那么

1318
00:55:15,420 --> 00:55:18,540
在前向搜索和算法中实现的可能性在哪里，

1319
00:55:18,540 --> 00:55:21,900
我们正在考虑

1320
00:55:21,900 --> 00:55:23,760
只有动作概率大于

1321
00:55:23,760 --> 00:55:26,339
特定阈值的动作我 我将

1322
00:55:26,339 --> 00:55:29,280
其定义为 1 x 16。呃，在

1323
00:55:29,280 --> 00:55:33,119
父论文中也是 1 x 16。

1324
00:55:33,119 --> 00:55:36,240
嗯，动作概率

1325
00:55:36,240 --> 00:55:39,839
好，所以如果它是 0，那么这意味着

1326
00:55:39,839 --> 00:55:42,180
它将考虑未来的所有后果，

1327
00:55:42,180 --> 00:55:46,200
并且是可交互的，因此您

1328
00:55:46,200 --> 00:55:48,540
可以忽略以下动作 是不可能的，

1329
00:55:48,540 --> 00:55:52,440
并且还忽略可能性较小的状态，

1330
00:55:52,440 --> 00:55:56,040
或者只考虑

1331
00:55:56,040 --> 00:55:57,780
概率大于此特定

1332
00:55:57,780 --> 00:56:00,240
阈值的状态，这显着

1333
00:56:00,240 --> 00:56:02,099
降低了计算复杂性，

1334
00:56:02,099 --> 00:56:03,720
您将只考虑

1335
00:56:03,720 --> 00:56:06,119
未来呃树中可能存在的组合

1336
00:56:06,119 --> 00:56:09,540
，这让您可以

1337
00:56:09,540 --> 00:56:12,900
深入你的规划范围，

1338
00:56:12,900 --> 00:56:16,020
这是这里的一个重要点，如果

1339
00:56:16,020 --> 00:56:17,400
你比较

1340
00:56:17,400 --> 00:56:18,359


1341
00:56:18,359 --> 00:56:21,619
更深层次的规划所需的时间，

1342
00:56:21,619 --> 00:56:24,980
搜索阈值为零，

1343
00:56:24,980 --> 00:56:28,619
所以阈值呃搜索阈值 0 0

1344
00:56:28,619 --> 00:56:30,780
意味着你将考虑所有

1345
00:56:30,780 --> 00:56:33,300
后果，并且

1346
00:56:33,300 --> 00:56:35,880
更深入 你计划

1347
00:56:35,880 --> 00:56:38,640
嗯，需要的时间就越多，如果你看到

1348
00:56:38,640 --> 00:56:42,480
呃，只考虑第一个未来或

1349
00:56:42,480 --> 00:56:44,579
最近的未来，需要 0.01

1350
00:56:44,579 --> 00:56:45,900
秒，

1351
00:56:45,900 --> 00:56:48,720
或者考虑未来的三种可能性，

1352
00:56:48,720 --> 00:56:50,880
需要 3 秒，考虑

1353
00:56:50,880 --> 00:56:53,099
四种可能性，需要 300 秒，你

1354
00:56:53,099 --> 00:56:54,960
可以看到 计算时间呈

1355
00:56:54,960 --> 00:56:59,579
指数级增长，但如果你有一个

1356
00:56:59,579 --> 00:57:02,819
非常小的阈值搜索阈值，

1357
00:57:02,819 --> 00:57:08,280
那么你的计算时间对于

1358
00:57:08,280 --> 00:57:11,940


1359
00:57:11,940 --> 00:57:15,420
现实世界中的实现来说是有意义的，所以这里对于 n 等于

1360
00:57:15,420 --> 00:57:17,880
4，也就是未来的四个时间步长，

1361
00:57:17,880 --> 00:57:20,640
它只是 花费 0.1 秒，

1362
00:57:20,640 --> 00:57:22,440
没关系，我仍然可以进行

1363
00:57:22,440 --> 00:57:25,440
这种复杂性的模拟，但是

1364
00:57:25,440 --> 00:57:28,079
我无法谈论这是如何的，

1365
00:57:28,079 --> 00:57:29,400


1366
00:57:29,400 --> 00:57:31,020
计算

1367
00:57:31,020 --> 00:57:34,020
复杂性有多低，它真正取决于呃，

1368
00:57:34,020 --> 00:57:35,700
你先前的偏好和实际环境的性质，

1369
00:57:35,700 --> 00:57:37,980
但是这个搜索

1370
00:57:37,980 --> 00:57:40,619
阈值实际上在现实生活中起作用

1371
00:57:40,619 --> 00:57:43,140
，我们刚刚看到，在我们的模拟中，

1372
00:57:43,140 --> 00:57:46,559
对于 n 等于 4，

1373
00:57:46,559 --> 00:57:50,040
在我们的模拟中只花费了 0.3 秒，但如果将

1374
00:57:50,040 --> 00:57:53,220
搜索阈值设置为零，则

1375
00:57:53,220 --> 00:57:55,559
完成

1376
00:57:55,559 --> 00:57:58,880
全步规划已经是 300 秒 如果我设置呃

1377
00:57:58,880 --> 00:58:01,800
规划深度为五那么它

1378
00:58:01,800 --> 00:58:04,200
基本上会永远运行也许再次我我

1379
00:58:04,200 --> 00:58:06,960
将无法做公民

1380
00:58:06,960 --> 00:58:10,619
所以这就是搜索阈值的想法

1381
00:58:10,619 --> 00:58:13,440
嗯所以实际上就是这样

1382
00:58:13,440 --> 00:58:16,260
嗯我想解释

1383
00:58:16,260 --> 00:58:18,300
代理类

1384
00:58:18,300 --> 00:58:20,520
环境类和 特定的

1385
00:58:20,520 --> 00:58:24,420
演示，是的，

1386
00:58:24,420 --> 00:58:27,180
如果有人在听的话，也许现在是提问的好时机，呃，

1387
00:58:27,180 --> 00:58:29,760
我希望人们

1388
00:58:29,760 --> 00:58:33,359
能够使用这段代码，

1389
00:58:33,359 --> 00:58:35,819
看看教程，

1390
00:58:35,819 --> 00:58:38,280
实现这个并构建

1391
00:58:38,280 --> 00:58:40,260
这样的生成模型，所以这个特定的

1392
00:58:40,260 --> 00:58:41,640
例子是

1393
00:58:41,640 --> 00:58:43,920
如何 你是否为这个网格任务构建一个生成模型

1394
00:58:43,920 --> 00:58:45,359


1395
00:58:45,359 --> 00:58:47,640
，看看智能体如何能够采取

1396
00:58:47,640 --> 00:58:51,839
有意义的行动，但在这里我们

1397
00:58:51,839 --> 00:58:54,299
在

1398
00:58:54,299 --> 00:58:57,000
B 矩阵和矩阵等中给出了环境的真实结构，但

1399
00:58:57,000 --> 00:59:00,299
你也可以尝试

1400
00:59:00,299 --> 00:59:03,480
学习 从某种意义上说，在

1401
00:59:03,480 --> 00:59:04,740
定义

1402
00:59:04,740 --> 00:59:09,380
代理点步骤时，您可以添加一个标志，

1403
00:59:09,380 --> 00:59:14,420
表示学习等于 true，

1404
00:59:14,420 --> 00:59:18,059
如果您从不知情的 a b

1405
00:59:18,059 --> 00:59:20,520
等开始，您可以尝试

1406
00:59:20,520 --> 00:59:22,380
代理如何学习该环境，

1407
00:59:22,380 --> 00:59:24,420
您可以在此处查看 B 矩阵一

1408
00:59:24,420 --> 00:59:26,099
开始你可以在

1409
00:59:26,099 --> 00:59:28,559
10 次试验后查看 B 矩阵，看看

1410
00:59:28,559 --> 00:59:31,140
学习是如何发生的，这并不

1411
00:59:31,140 --> 00:59:33,059
重要，因为代理知道

1412
00:59:33,059 --> 00:59:35,760
结构，它不会学到太多，但如果

1413
00:59:35,760 --> 00:59:37,260
它从

1414
00:59:37,260 --> 00:59:39,660
未知结构开始 然后还有

1415
00:59:39,660 --> 00:59:42,180
学习范围需要实现，并且它

1416
00:59:42,180 --> 00:59:44,640
已经实现了，因为

1417
00:59:44,640 --> 00:59:47,700
我们正在使用现有的时间 DP

1418
00:59:47,700 --> 00:59:50,520
功能来学习 A 和 B，

1419
00:59:50,520 --> 00:59:51,960
它已经是步骤函数的一部分，

1420
00:59:51,960 --> 00:59:52,980


1421
00:59:52,980 --> 00:59:54,780
所以我希望

1422
00:59:54,780 --> 00:59:57,000
步骤函数是明确的，

1423
00:59:57,000 --> 00:59:58,500
这是唯一的事情 你需要

1424
00:59:58,500 --> 00:59:59,819
知道你是否正在尝试实现

1425
00:59:59,819 --> 01:00:02,040
复杂的推理，

1426
01:00:02,040 --> 01:00:03,839
如果你想

1427
01:00:03,839 --> 01:00:07,380
探究它们并查看它们，只需要知道这些矩阵的名称，是的，我

1428
01:00:07,380 --> 01:00:10,880
希望这次会议有用，所以我感谢

1429
01:00:10,880 --> 01:00:13,460
我的合作者和

1430
01:00:13,460 --> 01:00:16,140
维护 5mdp 的 Corner，还有

1431
01:00:16,140 --> 01:00:18,540
Brandon 他负责管理主要的 DP Fellowship，

1432
01:00:18,540 --> 01:00:21,720
我也是其中的一员，我在那里

1433
01:00:21,720 --> 01:00:23,579
致力于

1434
01:00:23,579 --> 01:00:26,599
在 IMDb 中实现源票证推理，它将

1435
01:00:26,599 --> 01:00:30,299
很快成为原始 Pi mdp 模块的一部分，我

1436
01:00:30,299 --> 01:00:32,760
希望人们可以开始使用这个模块

1437
01:00:32,760 --> 01:00:34,500
来模拟关联的推理

1438
01:00:34,500 --> 01:00:37,680
实验和 这基本上变成了，

1439
01:00:37,680 --> 01:00:39,420
也许现在是讨论

1440
01:00:39,420 --> 01:00:41,579
问题或澄清代码的好时机，

1441
01:00:41,579 --> 01:00:43,559
或者也许是休息一下的好时机，因为

1442
01:00:43,559 --> 01:00:46,280
是的，

1443
01:00:47,880 --> 01:00:50,640
谢谢，太棒了，

1444
01:00:50,640 --> 01:00:52,799
我有几个不同的问题

1445
01:00:52,799 --> 01:00:55,500
，我会

1446
01:00:55,500 --> 01:00:58,380
从 实时聊天，所以我首先去

1447
01:00:58,380 --> 01:01:00,660
实时聊天，然后嗯

1448
01:01:00,660 --> 01:01:02,579
问这些问题，然后问一些其他

1449
01:01:02,579 --> 01:01:04,980
问题，所以戴夫问

1450
01:01:04,980 --> 01:01:06,960
你如何看待

1451
01:01:06,960 --> 01:01:09,839
递归的神经实现大脑似乎并没有

1452
01:01:09,839 --> 01:01:11,579


1453
01:01:11,579 --> 01:01:13,559
比计算机硬件风格的递归更深层次地实现

1454
01:01:13,559 --> 01:01:15,660
除了严重过度学习的

1455
01:01:15,660 --> 01:01:18,299
任务之外，我们可以限制

1456
01:01:18,299 --> 01:01:20,220
自己询问递归，以便

1457
01:01:20,220 --> 01:01:22,619
探索适度

1458
01:01:22,619 --> 01:01:24,780
深度的状态空间，及时向前搜索，

1459
01:01:24,780 --> 01:01:27,119
那么我们如何协调

1460
01:01:27,119 --> 01:01:30,359
这种真正美丽、优雅和计算

1461
01:01:30,359 --> 01:01:32,579
高效的

1462
01:01:32,579 --> 01:01:36,839
全面深度研究 具有

1463
01:01:36,839 --> 01:01:41,099
多尺度规划的生物学基础是

1464
01:01:41,099 --> 01:01:42,540
的，嗯，

1465
01:01:42,540 --> 01:01:43,260


1466
01:01:43,260 --> 01:01:45,660
所以我不是神经

1467
01:01:45,660 --> 01:01:48,420
计算方面的专家，但答案是，嗯，

1468
01:01:48,420 --> 01:01:49,559


1469
01:01:49,559 --> 01:01:50,460


1470
01:01:50,460 --> 01:01:52,319
基本上，你一次只进行一场

1471
01:01:52,319 --> 01:01:55,619
比赛，而你所

1472
01:01:55,619 --> 01:01:58,140
拥有的或你所需要的就是 一些内存

1473
01:01:58,140 --> 01:02:01,740
来存储你的信念并使用这些呃

1474
01:02:01,740 --> 01:02:03,540
信念再次进行相同的

1475
01:02:03,540 --> 01:02:06,059
计算所以

1476
01:02:06,059 --> 01:02:08,940
嗯我们不是在谈论呃神经我的

1477
01:02:08,940 --> 01:02:11,160
意思是这个硬核递归

1478
01:02:11,160 --> 01:02:13,380
实现我们一次只进行本地

1479
01:02:13,380 --> 01:02:15,780
计算并且只是

1480
01:02:15,780 --> 01:02:17,700
因为结构 生成模型

1481
01:02:17,700 --> 01:02:21,660
和我们，因为我们有记忆，

1482
01:02:21,660 --> 01:02:23,819
嗯，这是可以做到的，而且我不

1483
01:02:23,819 --> 01:02:27,599
明白为什么呃大脑不能做到这一点，即使

1484
01:02:27,599 --> 01:02:29,520
单个神经元可能无法

1485
01:02:29,520 --> 01:02:32,099
做到这一点，主脑有记忆，

1486
01:02:32,099 --> 01:02:34,319
大脑有 存储记忆的能力

1487
01:02:34,319 --> 01:02:36,420
和做梦的能力

1488
01:02:36,420 --> 01:02:39,240
模拟的能力 嗯，它知道行为的后果

1489
01:02:39,240 --> 01:02:41,819
，你每天都会这样做，嗯，

1490
01:02:41,819 --> 01:02:43,500


1491
01:02:43,500 --> 01:02:46,140
你计划你的未来并决定

1492
01:02:46,140 --> 01:02:48,960
做什么是正确的，所以在单个神经元水平上

1493
01:02:48,960 --> 01:02:50,460
我是 不太确定

1494
01:02:50,460 --> 01:02:52,559
如何回答这个问题，但我

1495
01:02:52,559 --> 01:02:54,359
真的不明白为什么大脑不能

1496
01:02:54,359 --> 01:02:57,859
作为一个有机体做到这一点，

1497
01:02:58,740 --> 01:03:00,839
很酷，

1498
01:03:00,839 --> 01:03:03,480
嗯，代码没问题，我想我有几个

1499
01:03:03,480 --> 01:03:05,700
问题，让我们回到

1500
01:03:05,700 --> 01:03:08,058
迷宫

1501
01:03:10,740 --> 01:03:13,020
吧 当然，如果其他人

1502
01:03:13,020 --> 01:03:16,920
在实时聊天中有疑问，那就去问吧，嗯，

1503
01:03:16,920 --> 01:03:17,640


1504
01:03:17,640 --> 01:03:21,839
那么在迷宫中，呃，

1505
01:03:21,839 --> 01:03:24,900
可能的动作

1506
01:03:24,900 --> 01:03:28,200
是如何反映的，

1507
01:03:28,200 --> 01:03:31,380
它更新到什么阶段了，例如，它

1508
01:03:31,380 --> 01:03:33,480
最初知道它可以 只能向上，

1509
01:03:33,480 --> 01:03:36,000
然后我只能向右或向下，

1510
01:03:36,000 --> 01:03:38,160
这反映在什么地方，即功能可供性的

1511
01:03:38,160 --> 01:03:40,680


1512
01:03:40,680 --> 01:03:43,260
关系方面的更新，

1513
01:03:43,260 --> 01:03:45,059
甚至可以做什么

1514
01:03:45,059 --> 01:03:47,760
，然后它在深度树搜索中如何评估

1515
01:03:47,760 --> 01:03:49,680


1516
01:03:49,680 --> 01:03:53,819
它是否需要知道

1517
01:03:53,819 --> 01:03:56,460
未来会发生什么或不会发生什么事情，

1518
01:03:56,460 --> 01:03:58,640


1519
01:03:59,819 --> 01:04:01,140
所以如果我正确理解了这些问题，那么很重要，

1520
01:04:01,140 --> 01:04:02,339


1521
01:04:02,339 --> 01:04:03,000


1522
01:04:03,000 --> 01:04:05,099


1523
01:04:05,099 --> 01:04:06,420
生成

1524
01:04:06,420 --> 01:04:08,880
过程和生成模型之间存在重要区别，

1525
01:04:08,880 --> 01:04:11,579
所以在伟大的世界中，

1526
01:04:11,579 --> 01:04:15,119
嗯 是生成过程，

1527
01:04:15,119 --> 01:04:17,160
嗯，我们已经手动实现了所有这些，

1528
01:04:17,160 --> 01:04:19,619
我们有这个过渡

1529
01:04:19,619 --> 01:04:21,540
动态，

1530
01:04:21,540 --> 01:04:22,680
嗯，它

1531
01:04:22,680 --> 01:04:25,380
已经知道如果你

1532
01:04:25,380 --> 01:04:27,660
从一个状态采取行动会发生什么，所以它就像

1533
01:04:27,660 --> 01:04:30,599
一个知道如何工作的环境，

1534
01:04:30,599 --> 01:04:32,700
所以它就像一个现实，其中

1535
01:04:32,700 --> 01:04:34,380
动作会产生后果，而且它

1536
01:04:34,380 --> 01:04:37,619
已经存在，但是该信息

1537
01:04:37,619 --> 01:04:40,680
可供代理使用，成为

1538
01:04:40,680 --> 01:04:43,440
其生成模型的一部分，在

1539
01:04:43,440 --> 01:04:45,240
生成模型中，它基本上所做的

1540
01:04:45,240 --> 01:04:48,119
就是使用

1541
01:04:48,119 --> 01:04:51,119
给定或学习的过渡动力学来模拟可能

1542
01:04:51,119 --> 01:04:54,299
发生的情况 未来好吧，所以一旦我有了

1543
01:04:54,299 --> 01:04:56,460
那个过渡动力学，

1544
01:04:56,460 --> 01:04:58,200
嗯，如果我去抱歉，

1545
01:04:58,200 --> 01:05:00,359


1546
01:05:00,359 --> 01:05:02,700
如果我去那个研究，它

1547
01:05:02,700 --> 01:05:05,160
本质上做的是评估给

1548
01:05:05,160 --> 01:05:08,640
定特定状态和

1549
01:05:08,640 --> 01:05:11,700
动作基因的后验，所以从我的生成

1550
01:05:11,700 --> 01:05:14,520
模型我知道，如果我 从这个

1551
01:05:14,520 --> 01:05:16,799
状态开始，如果我采取这个行动，我会去

1552
01:05:16,799 --> 01:05:19,680
这个帖子区域，我会考虑所有的

1553
01:05:19,680 --> 01:05:22,319
后果，如果

1554
01:05:22,319 --> 01:05:24,540
在生成模型中，

1555
01:05:24,540 --> 01:05:27,119
如果我向东走，我不太可能不去那里，

1556
01:05:27,119 --> 01:05:29,220
等等，基本上它是

1557
01:05:29,220 --> 01:05:31,920
自动的 反映在预期的

1558
01:05:31,920 --> 01:05:33,780
自由能中，

1559
01:05:33,780 --> 01:05:34,319


1560
01:05:34,319 --> 01:05:37,140
所以我希望回答这个问题，所以

1561
01:05:37,140 --> 01:05:39,980


1562
01:05:40,020 --> 01:05:42,000
如果我将动作精度设置为

1563
01:05:42,000 --> 01:05:42,960
高

1564
01:05:42,960 --> 01:05:44,400
并且

1565
01:05:44,400 --> 01:05:48,000
还启用环境，

1566
01:05:48,000 --> 01:05:50,599


1567
01:05:50,960 --> 01:05:53,579
那么最初我处于这个特定的

1568
01:05:53,579 --> 01:05:56,700
状态，并且我们就

1569
01:05:56,700 --> 01:05:58,559
预期的自由能而言，我是什么 我正在做的是，

1570
01:05:58,559 --> 01:06:00,960
我正在使用我的生成模型来预测

1571
01:06:00,960 --> 01:06:03,599
如果我采取四个行动会发生什么，

1572
01:06:03,599 --> 01:06:06,180
我的预测会说，如果我

1573
01:06:06,180 --> 01:06:08,460
采取北方，我会去这里，如果我采取

1574
01:06:08,460 --> 01:06:10,740
所有其他行动，我会留在这里，

1575
01:06:10,740 --> 01:06:12,839
因为在我的 优先偏好 North

1576
01:06:12,839 --> 01:06:15,480
更优先 我可以推断出，不仅仅是

1577
01:06:15,480 --> 01:06:16,680


1578
01:06:16,680 --> 01:06:19,619
我应该执行的呃动作，所以这就是

1579
01:06:19,619 --> 01:06:20,640
想法，所以

1580
01:06:20,640 --> 01:06:22,920
这里将网格结构提供给

1581
01:06:22,920 --> 01:06:24,240
代理，这可能有点

1582
01:06:24,240 --> 01:06:26,039
令人困惑，但代理也可以学习

1583
01:06:26,039 --> 01:06:27,780
脚本结构和 如果这

1584
01:06:27,780 --> 01:06:30,059
行得通，那么一旦我知道网格结构

1585
01:06:30,059 --> 01:06:32,339
作为代理，我就可以模拟未来

1586
01:06:32,339 --> 01:06:34,920
并正确考虑行动的后果，

1587
01:06:34,920 --> 01:06:36,000


1588
01:06:36,000 --> 01:06:39,000
这就是正在发生的事情，一旦我

1589
01:06:39,000 --> 01:06:40,319
处于状态，我将考虑

1590
01:06:40,319 --> 01:06:42,780
所有四个行动的结果，我

1591
01:06:42,780 --> 01:06:44,640
将推断 好吧，嗯，

1592
01:06:44,640 --> 01:06:46,380
向东更好，因为那

1593
01:06:46,380 --> 01:06:48,480
会带我进入这种状态，

1594
01:06:48,480 --> 01:06:50,460
所以之间总是有区别的，

1595
01:06:50,460 --> 01:06:52,319
或者你应该记住

1596
01:06:52,319 --> 01:06:54,059
生成模型和生成过程

1597
01:06:54,059 --> 01:06:55,619
是两个不同的东西，

1598
01:06:55,619 --> 01:06:58,559
而代理所知道的可能不是

1599
01:06:58,559 --> 01:07:00,240
现实，也可能是现实 现实

1600
01:07:00,240 --> 01:07:03,660
取决于你给它的东西，嗯，

1601
01:07:03,660 --> 01:07:05,579


1602
01:07:05,579 --> 01:07:08,099
很酷，所以

1603
01:07:08,099 --> 01:07:10,740
如果你要着手

1604
01:07:10,740 --> 01:07:13,380
创建一个

1605
01:07:13,380 --> 01:07:15,059
你想要进行

1606
01:07:15,059 --> 01:07:16,920
生成建模的新情况，

1607
01:07:16,920 --> 01:07:20,400
你是否倾向于从现有的

1608
01:07:20,400 --> 01:07:23,280
工作 Pi mdp 笔记本开始并开始

1609
01:07:23,280 --> 01:07:26,220
修改状态空间，或者你会绘制 把它

1610
01:07:26,220 --> 01:07:28,380
放在画布上，就像除了复制这里显示的内容之外，你会如何

1611
01:07:28,380 --> 01:07:30,000
推荐其他人让我们

1612
01:07:30,000 --> 01:07:32,819


1613
01:07:32,819 --> 01:07:34,079
说我们对

1614
01:07:34,079 --> 01:07:37,079
不完全是迷宫的东西感兴趣，

1615
01:07:37,079 --> 01:07:42,660
我们该怎么做才能让我们的头脑围绕

1616
01:07:42,660 --> 01:07:44,880
我们应该如何进行是的，

1617
01:07:44,880 --> 01:07:46,140


1618
01:07:46,140 --> 01:07:49,260
好问题，所以 如果你试图

1619
01:07:49,260 --> 01:07:52,859
模拟一个新环境，你

1620
01:07:52,859 --> 01:07:55,680
需要做的繁重工作就是为

1621
01:07:55,680 --> 01:07:57,720


1622
01:07:57,720 --> 01:07:59,280
代理定义生成模型，

1623
01:07:59,280 --> 01:08:01,260
你可以定义

1624
01:08:01,260 --> 01:08:02,819
代理可以学习的各个部分生成模型，

1625
01:08:02,819 --> 01:08:05,039
但你必须定义

1626
01:08:05,039 --> 01:08:06,980
以下结构： 结构应该在那里，

1627
01:08:06,980 --> 01:08:10,140
并且只有使用该结构，代理

1628
01:08:10,140 --> 01:08:13,260
才能学习生成模型，所以在这里，

1629
01:08:13,260 --> 01:08:15,780
嗯，您可以利用这个代码单元

1630
01:08:15,780 --> 01:08:17,880
来了解我如何定义

1631
01:08:17,880 --> 01:08:19,080
网格的结构，

1632
01:08:19,080 --> 01:08:21,719
所以我正在为其代理定义一个结构

1633
01:08:21,719 --> 01:08:24,060
要利用我

1634
01:08:24,060 --> 01:08:26,460
说的是有 25 个有效状态

1635
01:08:26,460 --> 01:08:29,339
，有四个可用操作，

1636
01:08:29,339 --> 01:08:31,920
这是

1637
01:08:31,920 --> 01:08:33,000


1638
01:08:33,000 --> 01:08:36,540
在时间 DB 中定义状态空间的标准方法，您还必须为代理定义

1639
01:08:36,540 --> 01:08:40,020
中央参数 a b c 和 d

1640
01:08:40,020 --> 01:08:42,779
刺激，所以在这里我

1641
01:08:42,779 --> 01:08:43,859


1642
01:08:43,859 --> 01:08:46,380
使用我的状态空间和

1643
01:08:46,380 --> 01:08:49,560
观察空间来定义 um a，但是

1644
01:08:49,560 --> 01:08:52,439
给予它或告诉它它是

1645
01:08:52,439 --> 01:08:55,198
单位矩阵的这一步是我在建模中的决策选择

1646
01:08:55,198 --> 01:08:58,259
我不必为模拟执行此操作

1647
01:08:58,259 --> 01:09:01,620
我可以看到如果 代理

1648
01:09:01,620 --> 01:09:04,920
从随机的 a 矩阵中学习它，或者

1649
01:09:04,920 --> 01:09:06,420
当它从随机图像矩阵开始时，

1650
01:09:06,420 --> 01:09:07,198


1651
01:09:07,198 --> 01:09:10,679
类似地，对于这个 B 矩阵，定义了这个

1652
01:09:10,679 --> 01:09:12,060
结构，

1653
01:09:12,060 --> 01:09:15,540
并且有

1654
01:09:15,540 --> 01:09:17,040
这样的函数可以给你一个随机的 B

1655
01:09:17,040 --> 01:09:19,080
矩阵，但这是一个建模选择，

1656
01:09:19,080 --> 01:09:21,600
其中 如果我想给它网格

1657
01:09:21,600 --> 01:09:22,979
结构或不给它网格

1658
01:09:22,979 --> 01:09:25,259
结构，我可以从随机 B

1659
01:09:25,259 --> 01:09:27,420
矩阵开始，让代理学习并查看

1660
01:09:27,420 --> 01:09:29,759
学习到的光束，只是为了

1661
01:09:29,759 --> 01:09:31,799
演示的目的，我给了它

1662
01:09:31,799 --> 01:09:33,660
最好的结构来启用 它采取

1663
01:09:33,660 --> 01:09:36,540
行动，但它不是强制性

1664
01:09:36,540 --> 01:09:38,880
的，所以这个笔记本很有用，

1665
01:09:38,880 --> 01:09:40,679
因为您知道要做什么，但

1666
01:09:40,679 --> 01:09:42,299
绝对您应该尝试

1667
01:09:42,299 --> 01:09:46,198
可能不是强制性的步骤，所以

1668
01:09:46,198 --> 01:09:49,140
如果我优先考虑此

1669
01:09:49,140 --> 01:09:51,299
状态 是最大值，那么您可以看到

1670
01:09:51,299 --> 01:09:53,520
代理将尝试并正确到达那里的行为，

1671
01:09:53,520 --> 01:09:55,320


1672
01:09:55,320 --> 01:09:58,860
因此，这个先验偏好是与

1673
01:09:58,860 --> 01:10:00,660
这是目标状态一起定义的，

1674
01:10:00,660 --> 01:10:03,060
但这可能不是冷状态，

1675
01:10:03,060 --> 01:10:05,040
在不同的任务中，先验

1676
01:10:05,040 --> 01:10:06,780
偏好的含义是 根据环境的不同而不同，

1677
01:10:06,780 --> 01:10:08,760


1678
01:10:08,760 --> 01:10:11,100
嗯，所以这也是存在的，也是你

1679
01:10:11,100 --> 01:10:13,199
之前的，所以一旦你定义了你必须做的生成

1680
01:10:13,199 --> 01:10:15,900
模型，你就

1681
01:10:15,900 --> 01:10:18,840
不能从中运行，那么一切都是

1682
01:10:18,840 --> 01:10:21,540
自动化的，代理

1683
01:10:21,540 --> 01:10:22,260
嗯

1684
01:10:22,260 --> 01:10:26,699
只需要使用代理点 步骤给

1685
01:10:26,699 --> 01:10:28,860
它从环境中观察到的

1686
01:10:28,860 --> 01:10:31,080
代理知道如何采取行动，

1687
01:10:31,080 --> 01:10:33,600
然后代理内部发生的一切

1688
01:10:33,600 --> 01:10:36,000
你实际上不必担心

1689
01:10:36,000 --> 01:10:37,500
嗯是的

1690
01:10:37,500 --> 01:10:39,900
所以这个结构我相信

1691
01:10:39,900 --> 01:10:42,420
对于你的特定任务是有用的

1692
01:10:42,420 --> 01:10:47,300
尝试在你的模型中建模，

1693
01:10:47,460 --> 01:10:49,760


1694
01:10:51,540 --> 01:10:54,659
嗯，是的，非常有趣，你会如何

1695
01:10:54,659 --> 01:10:57,900
对比它或指出

1696
01:10:57,900 --> 01:10:59,580
与如何

1697
01:10:59,580 --> 01:11:01,560
在主动推理之外追求这一点的任何相似或差异，

1698
01:11:01,560 --> 01:11:03,780
就像有人要

1699
01:11:03,780 --> 01:11:06,360


1700
01:11:06,360 --> 01:11:09,360
在迷宫中使用另一种深层策略代理一样

1701
01:11:09,360 --> 01:11:11,340
例如，流程的哪些部分是

1702
01:11:11,340 --> 01:11:12,600
熟悉的，

1703
01:11:12,600 --> 01:11:15,480
哪些部分会需要大量

1704
01:11:15,480 --> 01:11:17,340
非预期的工作，或者

1705
01:11:17,340 --> 01:11:18,780
跳过需要大量工作的部分，

1706
01:11:18,780 --> 01:11:20,040
否则，

1707
01:11:20,040 --> 01:11:21,780


1708
01:11:21,780 --> 01:11:24,360
是的，所以一般结构

1709
01:11:24,360 --> 01:11:26,640
对于做事情的人来说非常熟悉

1710
01:11:26,640 --> 01:11:30,780
就像强化学习中的这样，

1711
01:11:30,780 --> 01:11:33,179
嗯，这是一个代理点步骤

1712
01:11:33,179 --> 01:11:35,699
和环境点步骤的想法，所以这是

1713
01:11:35,699 --> 01:11:38,340


1714
01:11:38,340 --> 01:11:41,280
编写环境的标准开放人工智能吉姆方式和

1715
01:11:41,280 --> 01:11:43,800
编写代理的标准开放人工智能方式

1716
01:11:43,800 --> 01:11:46,380
好吧，所以如果你有队列学习 呃，

1717
01:11:46,380 --> 01:11:48,780
代理做同样的尝试

1718
01:11:48,780 --> 01:11:51,480
导航，那么你必须定义

1719
01:11:51,480 --> 01:11:54,600
Q 矩阵的方式是繁重的工作，

1720
01:11:54,600 --> 01:11:58,320
它只是一个状态动作映射，与

1721
01:11:58,320 --> 01:12:00,719
主动推理相反，你

1722
01:12:00,719 --> 01:12:02,280
必须想出一个

1723
01:12:02,280 --> 01:12:04,440
你想要的生成模型 在主动

1724
01:12:04,440 --> 01:12:06,360
推理中，生成模型是

1725
01:12:06,360 --> 01:12:08,520
核心，没有

1726
01:12:08,520 --> 01:12:10,760
生成模型，

1727
01:12:10,760 --> 01:12:13,739
主动影响中的有目的行为就没有意义，

1728
01:12:13,739 --> 01:12:17,460
所以

1729
01:12:17,460 --> 01:12:20,159
对于来自

1730
01:12:20,159 --> 01:12:21,780
强化学习这样的领域的人来说，唯一不熟悉的部分是

1731
01:12:21,780 --> 01:12:23,760
生成模型的结构，但

1732
01:12:23,760 --> 01:12:25,320
除了习惯它之外别无他法，

1733
01:12:25,320 --> 01:12:29,100
它是形式 DP 结构

1734
01:12:29,100 --> 01:12:31,020
占主导地位，但如果你正在进行深度

1735
01:12:31,020 --> 01:12:33,659
主动推理，所有这些都将

1736
01:12:33,659 --> 01:12:36,300
是神经网络，而手掌 DPS 也不

1737
01:12:36,300 --> 01:12:38,400
活跃 打印

1738
01:12:38,400 --> 01:12:40,800
嗯，事情是对的，这是一个工业

1739
01:12:40,800 --> 01:12:43,380
工程，所以 pom DPS 对于

1740
01:12:43,380 --> 01:12:45,000


1741
01:12:45,000 --> 01:12:46,020
来自计算机科学

1742
01:12:46,020 --> 01:12:49,739
背景的人来说也一定很熟悉，只是

1743
01:12:49,739 --> 01:12:52,140
代理中真正发生的事情是

1744
01:12:52,140 --> 01:12:54,179
主动推理部分，我们

1745
01:12:54,179 --> 01:12:55,980
期望自由能和变分

1746
01:12:55,980 --> 01:12:57,960
自由能，如果你想了解

1747
01:12:57,960 --> 01:13:00,540
这一点，那么你必须去找

1748
01:13:00,540 --> 01:13:03,060
代理，看看它是如何工作的，看看

1749
01:13:03,060 --> 01:13:04,620
矩阵的数字，看看

1750
01:13:04,620 --> 01:13:07,440
发生了什么，但我不处于

1751
01:13:07,440 --> 01:13:09,239
你想要开始的水平，我不

1752
01:13:09,239 --> 01:13:12,120
看到任何问题，所有这些都是

1753
01:13:12,120 --> 01:13:14,179
嗯

1754
01:13:15,440 --> 01:13:18,600
和 openai 健身房环境代理

1755
01:13:18,600 --> 01:13:21,199
环境循环所有这些

1756
01:13:21,199 --> 01:13:23,219
在计算机科学中进行了非常深入的讨论，

1757
01:13:23,219 --> 01:13:26,239
这并不

1758
01:13:27,300 --> 01:13:30,300
酷

1759
01:13:30,780 --> 01:13:34,219
嗯那么还有哪些其他 um

1760
01:13:34,219 --> 01:13:37,140
主题或认知现象让您感到

1761
01:13:37,140 --> 01:13:40,260
兴奋或者您如何看待 pi mdp

1762
01:13:40,260 --> 01:13:44,219
发展轨迹 在

1763
01:13:44,219 --> 01:13:46,260
您完成复杂的推理之后继续，

1764
01:13:46,260 --> 01:13:47,520


1765
01:13:47,520 --> 01:13:49,140
是的，

1766
01:13:49,140 --> 01:13:50,040


1767
01:13:50,040 --> 01:13:51,780
因此 Pym DP 具有原始

1768
01:13:51,780 --> 01:13:53,960
功能以及

1769
01:13:53,960 --> 01:13:56,280


1770
01:13:56,280 --> 01:13:58,980


1771
01:13:58,980 --> 01:14:00,960
通过策略空间等实现或模拟通用主动推理代理的功能，这

1772
01:14:00,960 --> 01:14:03,860
使得社区中的很多人能够

1773
01:14:03,860 --> 01:14:08,219
不是那些不

1774
01:14:08,219 --> 01:14:08,760


1775
01:14:08,760 --> 01:14:10,760
熟悉

1776
01:14:10,760 --> 01:14:13,500
复杂编码的人等等，那些

1777
01:14:13,500 --> 01:14:17,219
从事心理学、精神病学以及所有

1778
01:14:17,219 --> 01:14:19,199
正确的事情的人，所以无论谁想

1779
01:14:19,199 --> 01:14:22,560
上来尝试通过 mdp 实现主动推理，都可以实现

1780
01:14:22,560 --> 01:14:26,280
这一点，我希望

1781
01:14:26,280 --> 01:14:28,500
这个模块将使那些想要

1782
01:14:28,500 --> 01:14:30,620
尝试的人能够将其坚持在

1783
01:14:30,620 --> 01:14:32,820
他们特定领域的朋友实验中，

1784
01:14:32,820 --> 01:14:35,820
因此，如果您花一些时间并

1785
01:14:35,820 --> 01:14:37,560
熟悉

1786
01:14:37,560 --> 01:14:40,800
Prime DP 工作原理的结构，那么其他一切都

1787
01:14:40,800 --> 01:14:43,920
只是用最少的代码编写一个 Jupiter 笔记本

1788
01:14:43,920 --> 01:14:46,800
正确的代码来模拟这个，

1789
01:14:46,800 --> 01:14:49,980
所以如果你在你的领域中有一个特定的任务

1790
01:14:49,980 --> 01:14:53,100
呃我不认为

1791
01:14:53,100 --> 01:14:55,920
初学者尝试和编码它有什么问题，

1792
01:14:55,920 --> 01:14:58,199
我很高兴看到人们

1793
01:14:58,199 --> 01:15:01,080
使用这个模块进行各种

1794
01:15:01,080 --> 01:15:03,480
实验 就像人们如何开始

1795
01:15:03,480 --> 01:15:05,699
使用 pi mdp 和复杂的

1796
01:15:05,699 --> 01:15:08,659
推理起飞一样，现在人们

1797
01:15:08,659 --> 01:15:12,840
广泛讨论它是如何

1798
01:15:12,840 --> 01:15:15,719
进行主动

1799
01:15:15,719 --> 01:15:17,820
推理的方式，我真的希望

1800
01:15:17,820 --> 01:15:20,340
各个领域的人们开始使用

1801
01:15:20,340 --> 01:15:22,320
这个模块并看到他们的 实验，

1802
01:15:22,320 --> 01:15:24,480
我期待着喂食，

1803
01:15:24,480 --> 01:15:27,540
是的，所以 IMDb 两年前所做的，我

1804
01:15:27,540 --> 01:15:29,460
希望这个模块能够帮助那些

1805
01:15:29,460 --> 01:15:32,580
试图在汤状态下对主动输入进行建模的人，

1806
01:15:32,580 --> 01:15:34,940


1807
01:15:34,980 --> 01:15:39,179
所以你提到了开放式 AI 健身房和

1808
01:15:39,179 --> 01:15:41,520
标准化格式，以及

1809
01:15:41,520 --> 01:15:45,420
你使用什么基准或者你是

1810
01:15:45,420 --> 01:15:47,640
什么类型的测试套件，你在比较什么样的测试套件，

1811
01:15:47,640 --> 01:15:49,140


1812
01:15:49,140 --> 01:15:51,900
我们如何真正知道我们何时

1813
01:15:51,900 --> 01:15:54,960
创建了一个

1814
01:15:54,960 --> 01:15:58,739
真正超越或超越

1815
01:15:58,739 --> 01:16:00,239
其他

1816
01:16:00,239 --> 01:16:03,540
嗯技术无法做到的生成模型是的，

1817
01:16:03,540 --> 01:16:05,880
所以如果 我

1818
01:16:05,880 --> 01:16:10,140
可能会去开放的人工智能健身房网站，

1819
01:16:10,140 --> 01:16:12,179
我们在那里做了几个实验，

1820
01:16:12,179 --> 01:16:13,739
经典的报销学习

1821
01:16:13,739 --> 01:16:15,120
示例，

1822
01:16:15,120 --> 01:16:16,980
就像你现在在这个屏幕上看到的月球着陆器，

1823
01:16:16,980 --> 01:16:19,679
所以主动

1824
01:16:19,679 --> 01:16:22,320
推理允许 Inception 面临着将

1825
01:16:22,320 --> 01:16:24,960


1826
01:16:24,960 --> 01:16:27,600
um 扩展到任务的问题，这已经 这

1827
01:16:27,600 --> 01:16:29,340
本身就是主动推理的研究领域，

1828
01:16:29,340 --> 01:16:30,360


1829
01:16:30,360 --> 01:16:32,040
即缩放主动输入，这也是

1830
01:16:32,040 --> 01:16:34,260
深度主动推理

1831
01:16:34,260 --> 01:16:35,820
接管

1832
01:16:35,820 --> 01:16:38,100
处理此类任务的原因之一，因此

1833
01:16:38,100 --> 01:16:39,659


1834
01:16:39,659 --> 01:16:42,239
即使现在也有一些基准，复杂的

1835
01:16:42,239 --> 01:16:43,920
推理可能无法处理

1836
01:16:43,920 --> 01:16:46,020
状态空间，就我个人而言，这是我

1837
01:16:46,020 --> 01:16:48,480
在博士学位中的研究，我实际上正在研究

1838
01:16:48,480 --> 01:16:49,860


1839
01:16:49,860 --> 01:16:52,620


1840
01:16:52,620 --> 01:16:54,600
复杂推理中的最佳优化计算

1841
01:16:54,600 --> 01:16:57,239
算法，它可以让你扩展两个

1842
01:16:57,239 --> 01:16:59,699
这样的环境，但首先

1843
01:16:59,699 --> 01:17:02,280
你必须编写

1844
01:17:02,280 --> 01:17:04,199
代码并看看它是否有效 对于一个

1845
01:17:04,199 --> 01:17:07,679
环境，然后看看它是否

1846
01:17:07,679 --> 01:17:09,659
不起作用，然后你必须查看方法

1847
01:17:09,659 --> 01:17:12,659
词来扩展它等等，所以

1848
01:17:12,659 --> 01:17:14,699
如果我谈论的是

1849
01:17:14,699 --> 01:17:16,860
复杂的基准，Princess 和

1850
01:17:16,860 --> 01:17:19,080
任何 RL 算法一样好，

1851
01:17:19,080 --> 01:17:21,840
对于这个状态空间来说，所以对于小

1852
01:17:21,840 --> 01:17:23,460
问题，所以哪个门入口可以

1853
01:17:23,460 --> 01:17:26,580
工作，它真的很好，但是对于

1854
01:17:26,580 --> 01:17:29,100
像这样的高维问题，嗯，

1855
01:17:29,100 --> 01:17:31,020
我

1856
01:17:31,020 --> 01:17:33,239
刚刚展示的经典实现可能行不通，但它对于

1857
01:17:33,239 --> 01:17:36,120
任何像样的实验来说已经足够好了，但如果

1858
01:17:36,120 --> 01:17:38,040
你想扩大规模，那么它仍然是

1859
01:17:38,040 --> 01:17:40,199
开放的，而且它是 一个新的研究领域

1860
01:17:40,199 --> 01:17:43,040
以及你所做的事情可能会成为下一篇新的

1861
01:17:43,040 --> 01:17:46,020
重要论文，所以这就是我

1862
01:17:46,020 --> 01:17:49,520
在这方面所能告诉你的，

1863
01:17:49,940 --> 01:17:52,260
你认为你会寻找什么措施，

1864
01:17:52,260 --> 01:17:53,580


1865
01:17:53,580 --> 01:17:54,840
比如

1866
01:17:54,840 --> 01:17:57,960
呃计算资源，或者

1867
01:17:57,960 --> 01:18:00,000
甚至可以采取什么措施 并

1868
01:18:00,000 --> 01:18:04,020
置这些不同的方法是有道理的，

1869
01:18:04,020 --> 01:18:09,120
是的，所以开放式人工智能健身房是为

1870
01:18:09,120 --> 01:18:12,600
比较不同的算法而设计的，

1871
01:18:12,600 --> 01:18:15,900
所以开放想象一下，根据定义，呃是

1872
01:18:15,900 --> 01:18:18,179
许多环境的集合，所以在我的

1873
01:18:18,179 --> 01:18:19,620
演示中，我谈论的是网格

1874
01:18:19,620 --> 01:18:22,440
环境，开放式iigm只不过是一个

1875
01:18:22,440 --> 01:18:24,719
许多环境的集合，它

1876
01:18:24,719 --> 01:18:26,460
可以让你使用environment.step函数与这些环境进行交互，

1877
01:18:26,460 --> 01:18:29,360


1878
01:18:29,360 --> 01:18:31,980


1879
01:18:31,980 --> 01:18:32,699


1880
01:18:32,699 --> 01:18:34,500
是的，所以这里我们有

1881
01:18:34,500 --> 01:18:36,719
environment.step函数，它可以让

1882
01:18:36,719 --> 01:18:39,060
你与月球着陆器交互，并且

1883
01:18:39,060 --> 01:18:42,120
该特定任务将有矩阵

1884
01:18:42,120 --> 01:18:44,040
让你进行

1885
01:18:44,040 --> 01:18:46,500
判断 你的算法有多好或多坏，

1886
01:18:46,500 --> 01:18:50,100
所以在这个月球着陆器问题中，

1887
01:18:50,100 --> 01:18:52,080
你如何通过最大限度地减少燃料等来最佳地将你的月球车着陆

1888
01:18:52,080 --> 01:18:54,659
在这两个标志之间，

1889
01:18:54,659 --> 01:18:57,900
所以这些

1890
01:18:57,900 --> 01:19:01,920
矩阵是非常特定的任务，

1891
01:19:01,920 --> 01:19:03,780
这是你必须采取的一个方向，

1892
01:19:03,780 --> 01:19:07,679
你可以采取 嗯，尝试与

1893
01:19:07,679 --> 01:19:10,739
矩阵中的 RL 算法竞争，但是在

1894
01:19:10,739 --> 01:19:12,960


1895
01:19:12,960 --> 01:19:16,080
复杂的推理建模

1896
01:19:16,080 --> 01:19:19,020
智能行为中，正确的潜力或潜在的 IC 是在 RL 中的

1897
01:19:19,020 --> 01:19:21,300
重点是完成工作以实现这项

1898
01:19:21,300 --> 01:19:23,340
工作，但这并不能真正解释，

1899
01:19:23,340 --> 01:19:25,679
尤其是 D 并行和深度学习

1900
01:19:25,679 --> 01:19:27,719
方法，但在主动推理中，如果你

1901
01:19:27,719 --> 01:19:29,159
设法扩大规模，它们是

1902
01:19:29,159 --> 01:19:31,620
可以解释的，而且它们

1903
01:19:31,620 --> 01:19:33,719
会让你理解

1904
01:19:33,719 --> 01:19:36,540
智能是如何随着时间的推移而出现的，我

1905
01:19:36,540 --> 01:19:39,300
认为这比

1906
01:19:39,300 --> 01:19:41,340
与 RL 竞争更有趣，因为如果你的

1907
01:19:41,340 --> 01:19:44,219
重点是把事情做好，那么 也许

1908
01:19:44,219 --> 01:19:46,320
工程是正确的方式，而不是

1909
01:19:46,320 --> 01:19:49,460
积极的保险，

1910
01:19:50,699 --> 01:19:55,219
嗯，任何其他评论或想法

1911
01:20:02,159 --> 01:20:04,199
奥斯曼，你有任何其他评论或

1912
01:20:04,199 --> 01:20:05,340
想法吗，

1913
01:20:05,340 --> 01:20:09,300
不，我很高兴，我希望嗯，我

1914
01:20:09,300 --> 01:20:10,980
清楚地解释了代码，也许它

1915
01:20:10,980 --> 01:20:13,020
太复杂或太简单，具体取决于

1916
01:20:13,020 --> 01:20:14,400
你的水平

1917
01:20:14,400 --> 01:20:16,380
嗯，但我希望它对至少

1918
01:20:16,380 --> 01:20:19,080
一个开始使用它

1919
01:20:19,080 --> 01:20:21,179
并编写代码的人有用，所以非常感谢你

1920
01:20:21,179 --> 01:20:23,520
的时间，太棒了，谢谢你给我这个

1921
01:20:23,520 --> 01:20:25,440
机会，

1922
01:20:25,440 --> 01:20:28,080
谢谢你的加入，下次再见，

1923
01:20:28,080 --> 01:20:29,159


1924
01:20:29,159 --> 01:20:32,780
谢谢你，所以 再见，

1925
01:20:37,860 --> 01:20:40,639
好的，

1926
01:20:45,060 --> 01:20:48,320
问候韩国，

1927
01:20:48,780 --> 01:20:52,219
下次再见

