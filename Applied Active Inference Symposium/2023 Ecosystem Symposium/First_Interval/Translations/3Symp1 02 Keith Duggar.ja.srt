1
00:00:01,290 --> 00:00:04,494
さて、次は、事前に

2
00:00:04,532 --> 00:00:06,606
録画したビデオを提出した Keith Dugger です

3
00:00:06,628 --> 00:00:09,118
。 事前に記録されたビデオは

4
00:00:09,204 --> 00:00:11,694
アクティブ推論と呼ばれます。 そして

5
00:00:11,732 --> 00:00:14,765
俳優モデル それでは、

6
00:00:14,788 --> 00:00:15,920
今すぐそれを取り上げます。

7
00:00:29,430 --> 00:00:32,958
さて、

8
00:00:33,134 --> 00:00:35,910
アクティブ推論とアクター モデルに関する Keith の事前録画ビデオがここにあります

9
00:00:35,990 --> 00:00:37,660
。

10
00:00:44,240 --> 00:00:46,956
能動推論とアクター モデル。

11
00:00:47,138 --> 00:00:49,608
こんにちは。 こんにちは。 私は、

12
00:00:49,704 --> 00:00:52,684
拡張現実 AI である X Ray のプラットフォーム CTO である Keith Thugger 博士です

13
00:00:52,732 --> 00:00:56,464
。 同社であり、

14
00:00:56,502 --> 00:00:58,880
Machine Learning Street Talk ポッドキャストの共同ホストです。

15
00:00:59,780 --> 00:01:02,624
現在、私たち全員が

16
00:01:02,662 --> 00:01:05,536
アクティブ推論に基づくエコシステムの構築に取り組んでおり、

17
00:01:05,728 --> 00:01:08,324
ソフトウェアがアクティブ推論を

18
00:01:08,362 --> 00:01:11,363
最大限に活用するための基礎的な役割を果たすことは明らかです

19
00:01:11,402 --> 00:01:13,204
。 私たちは、能動推論の原則に沿ったソフトウェア エンジニアリング パラダイムを使用する必要があります

20
00:01:13,242 --> 00:01:15,524


21
00:01:15,562 --> 00:01:17,636


22
00:01:17,668 --> 00:01:20,136
が、

23
00:01:20,238 --> 00:01:22,664
私たちのニーズに合わせて作られたパラダイムが 1 つあると思います。

24
00:01:22,702 --> 00:01:26,084
アクターモデルといいます。 能動推論

25
00:01:26,132 --> 00:01:28,356
とアクター モデルは、

26
00:01:28,388 --> 00:01:30,750
世界についての 2 つの深く関連した理解です。

27
00:01:31,280 --> 00:01:34,204
これらは、入れ子になったシステムの生態系で相互作用する自律エージェントに焦点を当て、複雑なシステムのダイナミクスを扱うための基本的なフレームワークを提供します

28
00:01:34,242 --> 00:01:36,280


29
00:01:36,360 --> 00:01:39,624


30
00:01:39,672 --> 00:01:42,672


31
00:01:42,726 --> 00:01:46,283
。

32
00:01:46,332 --> 00:01:47,916


33
00:01:48,108 --> 00:01:50,050
エージェントの

34
00:01:50,500 --> 00:01:53,040
同時実行性、自律性、

35
00:01:53,380 --> 00:01:57,300
不確実性、行動適応の役割など、それらの重要なつながりのいくつかを探ってみたいと思います。

36
00:01:58,680 --> 00:02:00,596
アクティブ推論と

37
00:02:00,618 --> 00:02:03,184
アクティブ モデルはどちらも、

38
00:02:03,232 --> 00:02:06,300
決定論

39
00:02:06,480 --> 00:02:10,392
的で集中的な段階的な思考から、

40
00:02:10,446 --> 00:02:14,004


41
00:02:14,052 --> 00:02:17,751
計算と認識の両方を同時に行う分散ネットワークの視点へのパラダイム シフトであることがわかります

42
00:02:17,806 --> 00:02:21,052
。

43
00:02:21,106 --> 00:02:25,100
Actor モデルの歴史を少しだけ説明します。  1973 年に遡ると、

44
00:02:25,250 --> 00:02:28,504
カール ヒューイット、ピーター ビショップ、リチャード

45
00:02:28,552 --> 00:02:30,555
シュタイガーは全員、

46
00:02:30,578 --> 00:02:33,676
マサチューセッツ工科大学の AI

47
00:02:33,708 --> 00:02:37,804
ラボで、

48
00:02:37,852 --> 00:02:40,972


49
00:02:41,036 --> 00:02:44,304
構造と適応可能な

50
00:02:44,352 --> 00:02:46,020
アルゴリズムの実行の両方を含む同時計算の概念を基礎化するために働いていました。

51
00:02:47,480 --> 00:02:49,744
当時の従来の手法には

52
00:02:49,792 --> 00:02:52,224
堅牢性と安全な数学的

53
00:02:52,272 --> 00:02:55,263
基盤が欠けていました。 彼らの共同作業は、

54
00:02:55,312 --> 00:02:57,576
最終的にアクター モデルの作成につながりました

55
00:02:57,598 --> 00:03:01,076
。 当時は、

56
00:03:01,108 --> 00:03:03,224


57
00:03:03,262 --> 00:03:05,764
エラー

58
00:03:05,812 --> 00:03:08,784
耐性の向上と分散された計算

59
00:03:08,852 --> 00:03:12,236
能力の両方の特徴により、革新的なものとみなされていました。  1980 年代から

60
00:03:12,258 --> 00:03:15,388
1990 年代にかけて、アクター モデルは実用的な

61
00:03:15,394 --> 00:03:18,476
プロジェクトだけでなく数多くの研究プロジェクトの基礎となり

62
00:03:18,498 --> 00:03:20,856
、同時計算に対する

63
00:03:20,888 --> 00:03:23,184
その柔軟性と

64
00:03:23,222 --> 00:03:25,516
直感的なアプローチで人気を博しました

65
00:03:25,548 --> 00:03:29,648
。 主に

66
00:03:29,734 --> 00:03:32,240
人工知能とマルチエージェント

67
00:03:32,310 --> 00:03:34,400
システムで使用されていました。 おなじみですね？

68
00:03:35,880 --> 00:03:38,784
Actor、Saulson、Erlang などの新しいアクター ベースの言語は、

69
00:03:38,912 --> 00:03:42,116


70
00:03:42,138 --> 00:03:44,356
モデルの改良に貢献し、同時コンピューティングに対する

71
00:03:44,378 --> 00:03:47,203
より堅牢で柔軟なアプローチを形作り、今日のコンピューター サイエンスで

72
00:03:47,332 --> 00:03:50,148
生き続けています

73
00:03:50,244 --> 00:03:52,164


74
00:03:52,212 --> 00:03:55,272
。 最近では、

75
00:03:55,326 --> 00:03:57,796
主に

76
00:03:57,828 --> 00:03:59,944
分散

77
00:03:59,992 --> 00:04:02,904
システム、クラウド コンピューティング、エッジ

78
00:04:02,952 --> 00:04:05,036
コンピューティング、

79
00:04:05,058 --> 00:04:07,310
モノのインターネットと Web 30 の需要の高まりにより、アクター モデルが新たな関心を集めています。

80
00:04:08,480 --> 00:04:11,351
これらのコンピューター タスクは、ACA モデルのアーキテクチャを活用するのに理想的に適しています。

81
00:04:11,416 --> 00:04:13,436


82
00:04:13,468 --> 00:04:16,800
これは、一方では大量のデータ、もう一方ではきめの細かい異種自律システム

83
00:04:16,950 --> 00:04:20,368
の両方の同時処理をモデル化するために正確に設計されています

84
00:04:20,534 --> 00:04:23,409


85
00:04:23,800 --> 00:04:26,752


86
00:04:26,816 --> 00:04:28,710
。

87
00:04:29,640 --> 00:04:32,003
アクター モデルのこの適用は、Twitter、Facebook、LinkedIn などのビッグ データの問題を処理するためにその原則を利用している

88
00:04:32,042 --> 00:04:34,436
大手企業に多大な影響を与えています。

89
00:04:34,538 --> 00:04:36,904


90
00:04:36,942 --> 00:04:38,936


91
00:04:38,958 --> 00:04:41,348


92
00:04:41,524 --> 00:04:45,256
では、これは能動推論とどのような関係があるのでしょうか

93
00:04:45,278 --> 00:04:47,636
? イントロの

94
00:04:47,668 --> 00:04:49,368
いくつかの類似点をすでに聞いたことがあると思います

95
00:04:49,374 --> 00:04:51,656
。 ただし、

96
00:04:51,688 --> 00:04:53,656


97
00:04:53,688 --> 00:04:56,396
アクター モデルのいくつかの核となる原則と、

98
00:04:56,418 --> 00:04:58,568
それらが能動推論の原則にどのように関連するかを見てみましょう

99
00:04:58,584 --> 00:05:01,236
。 分離の概念から始めましょう

100
00:05:01,288 --> 00:05:04,832
。 分離とは、

101
00:05:04,886 --> 00:05:07,664
アクター モデル内のアクターが

102
00:05:07,702 --> 00:05:10,464
その状態を他のアクターと共有しないことを意味します

103
00:05:10,502 --> 00:05:14,212
。

104
00:05:14,266 --> 00:05:17,060
メッセージを受信した場合にのみ影響を受けます。 そして、応答として

105
00:05:17,130 --> 00:05:19,524


106
00:05:19,562 --> 00:05:22,164
有限数のメッセージを送信することによってのみ、他のアクターの状態の変化に影響を与えることができます

107
00:05:22,202 --> 00:05:25,776
。 ソフトウェア

108
00:05:25,808 --> 00:05:27,512
エンジニアリングの観点から見ると、この

109
00:05:27,566 --> 00:05:30,051
分離原則は、操作の潜在的な

110
00:05:30,116 --> 00:05:33,111
副作用を単一の

111
00:05:33,166 --> 00:05:35,924
アクターに制限するため、システム全体の予測可能性の信頼性が向上します。

112
00:05:35,972 --> 00:05:39,072


113
00:05:39,236 --> 00:05:42,104
また、最も重要なことは、完全に採用されれば、

114
00:05:42,232 --> 00:05:44,910
実際に設計を簡素化できることです。

115
00:05:46,560 --> 00:05:48,636
この図を見ると、特定のアクター

116
00:05:48,658 --> 00:05:51,616
にメッセージを送信し

117
00:05:51,638 --> 00:05:54,635
、そのアクターが

118
00:05:54,668 --> 00:05:57,040
他のアクターにメッセージを送り返すアクターのエコシステムがわかります。

119
00:05:58,340 --> 00:06:00,690
能動的推論はどこにあるのでしょうか? さて、

120
00:06:01,300 --> 00:06:03,816


121
00:06:03,868 --> 00:06:07,392
メッセージの送受信を知覚行動サイクルに置き換えて、外部

122
00:06:07,536 --> 00:06:09,620
、

123
00:06:10,200 --> 00:06:13,539
内部、感覚、および

124
00:06:13,610 --> 00:06:17,112
活動状態を示しましょう。 そして現在、マルコフブランケットという能動推論に必要な基盤が明らかに整っています

125
00:06:17,166 --> 00:06:19,956


126
00:06:19,988 --> 00:06:22,600
。

127
00:06:23,660 --> 00:06:26,436
アクター モデルのアクターは、

128
00:06:26,468 --> 00:06:28,848
アクティブな推論のエージェントに直接マッピングされます

129
00:06:28,884 --> 00:06:32,840
。 さらに、有限性、つまり

130
00:06:33,000 --> 00:06:35,676
アクターが

131
00:06:35,698 --> 00:06:39,003
応答として有限数のメッセージしか送信できないという事実も、

132
00:06:39,042 --> 00:06:41,150
重要な共有プロパティです。

133
00:06:41,940 --> 00:06:44,780
能動推論は現実をモデル化するため、

134
00:06:44,940 --> 00:06:47,452
必然的に

135
00:06:47,516 --> 00:06:50,704
実際のシステムのリソース制約が尊重されます。 そして、これはアクティブなモデル

136
00:06:50,742 --> 00:06:53,376
の基礎にうまく組み込まれています

137
00:06:53,398 --> 00:06:56,496
。 もう 1 つの基本

138
00:06:56,528 --> 00:06:59,860
原則である非同期メッセージ パッシングを見てみましょう。

139
00:07:00,840 --> 00:07:03,012
アクター間の通信は

140
00:07:03,066 --> 00:07:05,936
非同期です。 これは、アクターがメッセージの送信

141
00:07:05,968 --> 00:07:07,832
後に応答を待たないことを意味します

142
00:07:07,886 --> 00:07:10,680
。 いわば、働き続け、

143
00:07:10,830 --> 00:07:13,210
生き続けます。

144
00:07:13,820 --> 00:07:17,256
これは、

145
00:07:17,278 --> 00:07:20,284
アクターを切り離し、

146
00:07:20,322 --> 00:07:23,020


147
00:07:23,090 --> 00:07:25,948
システムの一部が

148
00:07:26,034 --> 00:07:28,551
遅くなったり、一時的に利用

149
00:07:28,616 --> 00:07:31,964
できなくなったりした場合でも、システムが機能し、存続し、進歩し続けることができるようにするため、非常に重要です。 フリストン教授は、

150
00:07:32,012 --> 00:07:34,028
フリーエネルギー原理は、

151
00:07:34,124 --> 00:07:38,240
もし物が存在するなら、何をしなければならないかという究極の実存的問題である、と述べました。

152
00:07:38,310 --> 00:07:41,490


153
00:07:42,660 --> 00:07:45,412
そうですね、俳優モデルは

154
00:07:45,466 --> 00:07:47,350
他人を待ってはいけないと主張しています。

155
00:07:48,360 --> 00:07:51,572
もちろん、俳優は他の人を待つことを選択できます

156
00:07:51,626 --> 00:07:55,284
が、

157
00:07:55,322 --> 00:07:58,808
モデル内でそうすることを強制してはなりません。 それは自由

158
00:07:58,894 --> 00:07:59,770
に選択できるはずです。

159
00:08:01,820 --> 00:08:04,004
これは、両方のモデルが自律性を共有するという別の重要な原則につながります

160
00:08:04,052 --> 00:08:06,456


161
00:08:06,558 --> 00:08:09,719
。 フリーエネルギー

162
00:08:09,790 --> 00:08:12,860
原理は物理的現実のモデルであり、

163
00:08:13,280 --> 00:08:15,547
結局のところ、私たちの現実は

164
00:08:15,634 --> 00:08:18,904
同時に存在します。 無限の宇宙全体にわたって

165
00:08:18,952 --> 00:08:21,572
、システムはローカルなダイナミクスに従って同時に進化しています

166
00:08:21,656 --> 00:08:24,048


167
00:08:24,134 --> 00:08:27,696
。 したがって、これは

168
00:08:27,718 --> 00:08:29,344
フリーエネルギー原理の中心に反映されています

169
00:08:29,382 --> 00:08:33,024
。 もちろん、

170
00:08:33,062 --> 00:08:35,796
計算モデルは物理学に制約される必要はありません

171
00:08:35,818 --> 00:08:38,784
。 しかしヒューイットらは、 私たちは、分散型同時システムの現実を

172
00:08:38,832 --> 00:08:41,395
モデル化するモデルの開発を模索していました

173
00:08:41,418 --> 00:08:43,664


174
00:08:43,712 --> 00:08:47,056
。 そして幸運なことに、アクター

175
00:08:47,088 --> 00:08:50,824
モデルは分離の

176
00:08:50,862 --> 00:08:53,352
原則から見た同時実行性と

177
00:08:53,486 --> 00:08:56,500
アクターの自律性の両方を採用しており、

178
00:08:56,580 --> 00:08:58,040
能動推論と互換性があります。

179
00:08:59,200 --> 00:09:01,820
次に巣作りに移ります。

180
00:09:02,640 --> 00:09:05,532
アクター モデルを使用すると、アクターは

181
00:09:05,586 --> 00:09:08,552
有限

182
00:09:08,616 --> 00:09:11,984
数のメッセージを送受信して認識し、行動できるだけでなく、

183
00:09:12,182 --> 00:09:15,292
アクションとして

184
00:09:15,356 --> 00:09:18,240
有限数の新しいアクターを作成することもできます。

185
00:09:19,220 --> 00:09:21,504
これらのアクターは、親 (動物細胞の一部など) 内に入れ子にすることも

186
00:09:21,542 --> 00:09:24,336


187
00:09:24,368 --> 00:09:26,564
、

188
00:09:26,602 --> 00:09:29,076
独立したアクターとして環境に放出することもできます。 それ

189
00:09:29,098 --> 00:09:32,336
以降、この原則は、モデルが

190
00:09:32,368 --> 00:09:34,628


191
00:09:34,714 --> 00:09:37,960
マルチスケール ネスティングとアクティブ推論の美しい概念にうまく適合するようになりました。

192
00:09:38,940 --> 00:09:41,460
これにより、アクターは

193
00:09:41,540 --> 00:09:44,791
アクターのエコシステムを

194
00:09:44,846 --> 00:09:47,290
下位と上位の両方に含めることができます。

195
00:09:49,200 --> 00:09:51,976
最後に、さらに 2 つのアクター

196
00:09:52,008 --> 00:09:55,436
モデルの設計原則、動作の変化

197
00:09:55,618 --> 00:09:57,020
と永続性について説明したいと思います。

198
00:09:59,040 --> 00:10:01,664
アクターは、

199
00:10:01,702 --> 00:10:04,450
メッセージに応じて動作を変えることができます。

200
00:10:05,140 --> 00:10:08,192
この適応性により、

201
00:10:08,246 --> 00:10:10,924


202
00:10:10,972 --> 00:10:14,130
時間の経過とともに進化する複雑なステートフル エンティティの構築が可能になります。

203
00:10:14,760 --> 00:10:17,492
そして実際、それによって

204
00:10:17,626 --> 00:10:21,584
エコシステム全体が新たな新たな行動を進化させることが可能になります

205
00:10:21,632 --> 00:10:25,263
。 ソフトウェア エンジニアリングに使用すると

206
00:10:25,312 --> 00:10:28,264
、

207
00:10:28,382 --> 00:10:31,800
複雑な動的システムを管理するための強力なツールが追加されます。

208
00:10:32,700 --> 00:10:35,412
もちろん、能動的推論は

209
00:10:35,476 --> 00:10:39,304
これを最大限に受け入れます。

210
00:10:39,352 --> 00:10:42,363
物事の本質は、

211
00:10:42,402 --> 00:10:45,324
環境を予測して適応し、それによって活動の海の中でマルコフブランケットを

212
00:10:45,362 --> 00:10:48,439
維持するために存在し続ける継続的な試みです

213
00:10:48,520 --> 00:10:52,828


214
00:10:53,004 --> 00:10:56,736
。 これに加えて、永続性

215
00:10:56,758 --> 00:10:58,912
の概念も登場します

216
00:10:58,966 --> 00:11:02,444
。 永続性により、アクターは

217
00:11:02,492 --> 00:11:05,524
自分の状態を保存し、

218
00:11:05,562 --> 00:11:08,640


219
00:11:08,720 --> 00:11:11,300
記憶の原理を具体化する機能として後でそれを復元または変更することができます。

220
00:11:11,800 --> 00:11:14,675
記憶は学習と適応の前提条件です

221
00:11:14,778 --> 00:11:18,504
。 エージェントの予測能力は、

222
00:11:18,622 --> 00:11:21,640


223
00:11:21,710 --> 00:11:24,356
過去の経験を記憶し、

224
00:11:24,388 --> 00:11:27,176


225
00:11:27,198 --> 00:11:30,520
予期せぬことに伴う驚きを最小限に抑える能力に依存します。 記憶の重要な役割は、

226
00:11:30,600 --> 00:11:34,056


227
00:11:34,088 --> 00:11:36,199
エージェントが経験または継承から帰納的事前分布を持っており

228
00:11:36,280 --> 00:11:39,100
、

229
00:11:39,440 --> 00:11:41,470
その世界モデルに貢献していると仮定するときにも強調されます。

230
00:11:42,340 --> 00:11:44,464
この世界モデルは彼らの

231
00:11:44,502 --> 00:11:47,291
現在の行動を導くものであり、

232
00:11:47,356 --> 00:11:50,028


233
00:11:50,204 --> 00:11:52,939
彼らの継続的な適応

234
00:11:53,020 --> 00:11:54,240
と生存に貢献する新しい経験に基づいて継続的に更新されます。

235
00:11:56,600 --> 00:11:59,684
わかりました、素晴らしいです。

236
00:11:59,722 --> 00:12:02,308
アクターモデルと能動推論の間には明確で深いつながりがあるとおっしゃっていましたね

237
00:12:02,394 --> 00:12:06,424
。 しかし、

238
00:12:06,462 --> 00:12:08,756
これはアクティブな推論コミュニティでどのように役立つのでしょうか

239
00:12:08,788 --> 00:12:11,988
? まず、

240
00:12:12,084 --> 00:12:14,084
私の意見では、これは

241
00:12:14,132 --> 00:12:16,520
私たちが採用すべきソフトウェア エンジニアリングのパラダイムです。

242
00:12:16,860 --> 00:12:19,340
そして、そうする場合、もちろん、

243
00:12:19,410 --> 00:12:21,815


244
00:12:21,848 --> 00:12:25,448
ACA、

245
00:12:25,624 --> 00:12:29,752
Orleans、thespian Actix

246
00:12:29,896 --> 00:12:33,055
Protoactor など、使用できるアクター モデル ライブラリとフレームワークがあり、

247
00:12:33,078 --> 00:12:35,516
アクティブな推論ソフトウェア モジュールとアプリケーションを構築するときにすぐに使用できます

248
00:12:35,548 --> 00:12:37,872


249
00:12:37,926 --> 00:12:41,596
。 また、

250
00:12:41,708 --> 00:12:43,944


251
00:12:44,012 --> 00:12:46,016


252
00:12:46,048 --> 00:12:49,380
Zero、

253
00:12:49,450 --> 00:12:52,640
MQ、tokyo、Rust、

254
00:12:52,800 --> 00:12:56,284
Erlang、Async、Await、C. Sharp などのアクター モデルの原則と非常によく一致するライブラリ、言語、さらには言語機能もあります

255
00:12:56,432 --> 00:13:00,104
。 しかし、現在利用できるツールよりも重要なのは、

256
00:13:00,142 --> 00:13:04,712


257
00:13:04,766 --> 00:13:07,544


258
00:13:07,582 --> 00:13:10,136


259
00:13:10,168 --> 00:13:13,996
明日のアクティブ推論ソフトウェアの作成を導くソフトウェア設計の考え方です。

260
00:13:14,018 --> 00:13:16,764
アクター モデルは、アクティブ推論に最も完璧に適合するソフトウェア設計とエンジニアリングのパラダイムを提供します

261
00:13:16,802 --> 00:13:20,588


262
00:13:20,754 --> 00:13:24,064


263
00:13:24,102 --> 00:13:28,160
。 これは、以前に説明した

264
00:13:28,580 --> 00:13:30,876
中心原則の整合性からだけでなく、

265
00:13:30,908 --> 00:13:34,084


266
00:13:34,122 --> 00:13:37,055


267
00:13:37,088 --> 00:13:39,156
アクター モデルの能動推論が

268
00:13:39,178 --> 00:13:42,916
相互にもたらす洞察からも明らかです。 たとえば、

269
00:13:42,938 --> 00:13:46,604
現在ヒューイットの法則と呼ばれているものを考えてみましょう。

270
00:13:46,672 --> 00:13:49,800
あらゆるものがどこにでもあると非公式に述べられた

271
00:13:51,260 --> 00:13:54,824
この法律は、

272
00:13:54,942 --> 00:13:57,844
真の非同期分散システムでは

273
00:13:57,892 --> 00:14:00,652
、

274
00:14:00,706 --> 00:14:03,532
メッセージがある場所から別の場所に送信されるまでに任意の時間がかかる可能性があり

275
00:14:03,586 --> 00:14:07,032
、アクターは

276
00:14:07,096 --> 00:14:10,364
そのイベントに備えなければならないという考えを意味します。 このようなシステムでは

277
00:14:10,402 --> 00:14:13,900
瞬間的なものはまったく存在せず

278
00:14:13,980 --> 00:14:17,888
、どのコンポーネントも

279
00:14:17,974 --> 00:14:20,384


280
00:14:20,422 --> 00:14:23,548
別のコンポーネントの動作のタイミングについて推測することはできません。 実際、

281
00:14:23,734 --> 00:14:26,980
メッセージは決して届かないかのように行動しなければなりません

282
00:14:27,050 --> 00:14:30,819
。 これには重要な意味があります

283
00:14:30,890 --> 00:14:34,644
。 これは、情報が

284
00:14:34,682 --> 00:14:36,744


285
00:14:36,782 --> 00:14:39,176


286
00:14:39,198 --> 00:14:42,569
システム全体に

287
00:14:43,260 --> 00:14:45,464


288
00:14:45,502 --> 00:14:48,410
伝播すらしていない可能性があるため、いつでもシステム全体の状態を正確かつ一貫して判断することは不可能であることを示唆しています。

289
00:14:49,760 --> 00:14:52,904
また、グローバル同期を実装しようとすると、

290
00:14:52,952 --> 00:14:55,400
必然的に

291
00:14:55,480 --> 00:14:57,864
ボトルネックが発生し、効率が低下します

292
00:14:57,912 --> 00:15:01,844
。 ヒューイットの法則は、

293
00:15:01,912 --> 00:15:04,976


294
00:15:04,998 --> 00:15:07,580


295
00:15:07,660 --> 00:15:09,504
これらの避けられない遅延や

296
00:15:09,542 --> 00:15:11,776
不確実性に効果的に対処できるようにシステムを設計する必要性を強調し、

297
00:15:11,798 --> 00:15:14,424
堅牢なノンブロッキング

298
00:15:14,492 --> 00:15:17,540
通信メカニズムとローカルな意思

299
00:15:17,690 --> 00:15:21,284
決定能力の重要性を強調しています。 つまり、

300
00:15:21,482 --> 00:15:24,240
Hector モデル システムは本質的に

301
00:15:24,400 --> 00:15:27,944
非決定的です。 これには聞き覚えがあるでしょうか

302
00:15:27,982 --> 00:15:31,800
？

303
00:15:32,140 --> 00:15:34,616
不確実性の下での運用と、環境に

304
00:15:34,638 --> 00:15:36,904
もかかわらず継続する自律性を強調するパラダイムが他にあるでしょうか

305
00:15:36,942 --> 00:15:40,328
? 能動推論と

306
00:15:40,334 --> 00:15:43,767
フリーエネルギー原理? 能動推論は、ソフトウェア システムが動作する予測

307
00:15:43,864 --> 00:15:46,552
不可能な世界の現実を反映しています

308
00:15:46,616 --> 00:15:48,792


309
00:15:48,856 --> 00:15:51,920
。 イベントがランダムで予測不可能な順序で発生するため、同じ初期条件から異なる結果が生じる可能性があります

310
00:15:51,990 --> 00:15:55,136


311
00:15:55,158 --> 00:15:57,756


312
00:15:57,868 --> 00:16:01,644
。 これは

313
00:16:01,692 --> 00:16:04,310
私たち全員がよく知っている驚きの概念であり、

314
00:16:05,000 --> 00:16:07,572
エージェントは、

315
00:16:07,626 --> 00:16:10,404


316
00:16:10,442 --> 00:16:13,060
受け取った感覚入力がその予測と一致しない場合に、世界についての信念を更新します。

317
00:16:13,720 --> 00:16:15,856
アクター モデルと能動的推論は両方とも、

318
00:16:15,888 --> 00:16:18,328
世界が予測不可能であることを認識しています

319
00:16:18,414 --> 00:16:21,624
。

320
00:16:21,662 --> 00:16:24,632
モデルはそれを認めるだけでなく、この

321
00:16:24,686 --> 00:16:27,688
不確実性を所与のものとして受け入れ、取り除かれるべきものではありません

322
00:16:27,774 --> 00:16:29,530
。

323
00:16:30,780 --> 00:16:33,752
実際、フリーエネルギー原理で知られているように

324
00:16:33,806 --> 00:16:36,204
、

325
00:16:36,242 --> 00:16:38,459
モデル内で維持される不確実性によって、

326
00:16:38,530 --> 00:16:41,020
適応する柔軟性が得られます。

327
00:16:43,540 --> 00:16:46,555
おそらくこれは私の個人的

328
00:16:46,588 --> 00:16:49,199
な空想にすぎませんが、

329
00:16:49,270 --> 00:16:51,596
能動的推論によって導かれるソフトウェア モジュールが

330
00:16:51,628 --> 00:16:54,976
ハードコードされたエラー処理を廃止し

331
00:16:55,008 --> 00:16:57,792
、エラー状況の進化に応じて自らを

332
00:16:57,856 --> 00:17:00,672
最適化する確率的学習アルゴリズムに交換する未来を想像しています

333
00:17:00,736 --> 00:17:03,200


334
00:17:03,280 --> 00:17:07,316
。 単一障害点のない堅牢な

335
00:17:07,428 --> 00:17:11,268
自己修復型分散システムであり、事後

336
00:17:11,364 --> 00:17:13,672


337
00:17:13,726 --> 00:17:17,716


338
00:17:17,907 --> 00:17:21,659
的な災害復旧ではなく、予測的な災害回避に重点を置いたモジュールです。

339
00:17:23,040 --> 00:17:25,308
将来に目を向けると、私たちはコミュニティとして、

340
00:17:25,314 --> 00:17:28,044


341
00:17:28,082 --> 00:17:31,700
アクティブインプリント理論

342
00:17:31,880 --> 00:17:34,576
とアクターモデルの実践的な実装の両方の境界を押し広げる可能性を持っています

343
00:17:34,598 --> 00:17:37,611
。

344
00:17:37,676 --> 00:17:40,096
これら 2 つのパラダイムの強みを一緒に活用することで、

345
00:17:40,118 --> 00:17:42,860
堅牢で

346
00:17:43,020 --> 00:17:45,876
適応性があり、

347
00:17:45,898 --> 00:17:48,500
実際に

348
00:17:48,650 --> 00:17:52,100
動作する物理世界により適合したソフトウェア システムを作成できます。 アクター モデルで

349
00:17:52,170 --> 00:17:54,976
アクティブ推論を使用するソフトウェア コンポーネントが

350
00:17:55,008 --> 00:17:57,112


351
00:17:57,166 --> 00:18:00,344
潜在的な問題を予測し、

352
00:18:00,382 --> 00:18:04,024
過去の間違いから学習し、環境の変化にリアルタイムで適応できる未来を想像してみてください

353
00:18:04,062 --> 00:18:07,144
。 この

354
00:18:07,182 --> 00:18:09,212
アプローチにより、

355
00:18:09,266 --> 00:18:11,996
根本的により回復力があり、より

356
00:18:12,018 --> 00:18:15,084
効率的なシステムを構築できます。 私の意見では、これは

357
00:18:15,122 --> 00:18:17,784
ソフトウェアの信頼性

358
00:18:17,912 --> 00:18:21,052
、パフォーマンス、スケーラビリティに大きな変化をもたらす可能性があり、

359
00:18:21,106 --> 00:18:24,044


360
00:18:24,092 --> 00:18:27,264
生物学と認知の原理を

361
00:18:27,302 --> 00:18:30,060
ソフトウェア システムの構造に織り込み、

362
00:18:30,220 --> 00:18:32,416
その過程でそれらを現実のものに近づけるコンピューティングの新時代の到来を告げるものです

363
00:18:32,438 --> 00:18:36,420
。 結論として、

364
00:18:37,160 --> 00:18:39,636
アクティブ推論を

365
00:18:39,658 --> 00:18:42,803
アクター モデルに組み合わせることで、ソフトウェアの設計とエンジニアリングを観察できる強力な新しいレンズが提供されます

366
00:18:42,842 --> 00:18:44,564


367
00:18:44,602 --> 00:18:46,820
。 能動推論に合わせて

368
00:18:47,180 --> 00:18:49,412
既存の言語

369
00:18:49,476 --> 00:18:51,476
やライブラリを活用するか、

370
00:18:51,508 --> 00:18:54,728
新しい言語やライブラリを発明するかにかかわらず、

371
00:18:54,894 --> 00:18:58,056
私たちはエキサイティングなフロンティアの瀬戸際に立っているのです

372
00:18:58,078 --> 00:19:01,944
。 それでは、今日を利用して

373
00:19:01,992 --> 00:19:05,068
、アクター モデル

374
00:19:05,154 --> 00:19:06,776
とその能動

375
00:19:06,808 --> 00:19:09,484
推論との関係を見て、インテリジェントな分散コンピューティングの未来を形作ってみましょう

376
00:19:09,522 --> 00:19:11,980
。 ご

377
00:19:13,040 --> 00:19:14,460
聴取ありがとうございました。

378
00:19:17,790 --> 00:19:21,050
素晴らしい。 キースの素晴らしい講演

379
00:19:21,120 --> 00:19:23,126
。 キースさん、送ってくれてありがとう

380
00:19:23,158 --> 00:19:25,985
。チャットにいくつかコメントがありました

381
00:19:26,008 --> 00:19:28,978
。 それで、キース、もし

382
00:19:28,984 --> 00:19:32,641
将来 A-Q-A に参加したいのであれば、

383
00:19:32,696 --> 00:19:33,949
本当に素晴らしいプレゼンテーションです。

