1
00:00:01,290 --> 00:00:04,494
Also gut, als nächstes kommt

2
00:00:04,532 --> 00:00:06,606
Keith Dugger, der ein vorab aufgezeichnetes Video eingereicht hat

3
00:00:06,628 --> 00:00:09,118
.  Das vorab aufgezeichnete Video

4
00:00:09,204 --> 00:00:11,694
wird als aktive Inferenz bezeichnet.  Und das

5
00:00:11,732 --> 00:00:14,765
Schauspielermodell. Das werde ich

6
00:00:14,788 --> 00:00:15,920
gleich ansprechen.

7
00:00:29,430 --> 00:00:32,958
Okay, hier kommt Keiths

8
00:00:33,134 --> 00:00:35,910
vorab aufgezeichnetes Video über aktive Inferenz

9
00:00:35,990 --> 00:00:37,660
und das Schauspielermodell.

10
00:00:44,240 --> 00:00:46,956
Aktive Inferenz und das Akteurmodell.

11
00:00:47,138 --> 00:00:49,608
Hallo.  Hallo.  Ich bin Dr. Keith Thugger,

12
00:00:49,704 --> 00:00:52,684
Plattform-CTO bei X Ray, einer erweiterten

13
00:00:52,732 --> 00:00:56,464
Realitäts-KI.  Unternehmen und Co-Moderator des

14
00:00:56,502 --> 00:00:58,880
Machine Learning Street Talk-Podcasts.

15
00:00:59,780 --> 00:01:02,624
Jetzt, da wir alle daran arbeiten, ein

16
00:01:02,662 --> 00:01:05,536
Ökosystem aufzubauen, das auf aktiver Inferenz basiert,

17
00:01:05,728 --> 00:01:08,324
wird Software offensichtlich eine

18
00:01:08,362 --> 00:01:11,363
grundlegende Rolle dabei spielen, das Beste aus

19
00:01:11,402 --> 00:01:13,204
aktiver Inferenz herauszuholen.  Wir müssen

20
00:01:13,242 --> 00:01:15,524
Software-Engineering-Paradigmen verwenden, die

21
00:01:15,562 --> 00:01:17,636
mit den Prinzipien der aktiven

22
00:01:17,668 --> 00:01:20,136
Inferenz übereinstimmen, und ich denke, es gibt eines, das

23
00:01:20,238 --> 00:01:22,664
auf unsere Bedürfnisse zugeschnitten ist.  Man nennt es

24
00:01:22,702 --> 00:01:26,084
das Schauspielermodell.  Aktive Inferenz

25
00:01:26,132 --> 00:01:28,356
und das Akteurmodell sind zwei eng miteinander

26
00:01:28,388 --> 00:01:30,750
verbundene Verständnisse der Welt.

27
00:01:31,280 --> 00:01:34,204
Sie bieten grundlegende Rahmenbedingungen für den

28
00:01:34,242 --> 00:01:36,280
Umgang mit der Dynamik komplexer

29
00:01:36,360 --> 00:01:39,624
Systeme, wobei der Schwerpunkt auf autonomen

30
00:01:39,672 --> 00:01:42,672
Agenten liegt, die in einer Ökologie

31
00:01:42,726 --> 00:01:46,283
verschachtelter Systeme interagieren.  Ich möchte

32
00:01:46,332 --> 00:01:47,916
einige ihrer wichtigsten Zusammenhänge untersuchen,

33
00:01:48,108 --> 00:01:50,050
einschließlich der Rolle der

34
00:01:50,500 --> 00:01:53,040
Parallelität, Autonomie,

35
00:01:53,380 --> 00:01:57,300
Unsicherheit und Verhaltensanpassung von Agenten.

36
00:01:58,680 --> 00:02:00,596
Wir werden sehen, dass sowohl die aktive Inferenz als auch

37
00:02:00,618 --> 00:02:03,184
das aktive Modell einen Paradigmenwechsel

38
00:02:03,232 --> 00:02:06,300
weg von einem deterministischen,

39
00:02:06,480 --> 00:02:10,392
zentralisierten, schrittweisen Denken hin zu

40
00:02:10,446 --> 00:02:14,004
einer dezentralen, netzwerkkonkurrierenden

41
00:02:14,052 --> 00:02:17,751
Perspektive sowohl der Berechnung als auch der

42
00:02:17,806 --> 00:02:21,052
Erkenntnis darstellen.  Nur ein kleiner Teil der Geschichte

43
00:02:21,106 --> 00:02:25,100
des Actor-Modells.  Im Jahr 1973 arbeiteten

44
00:02:25,250 --> 00:02:28,504
Karl Hewitt, Peter Bishop und Richard

45
00:02:28,552 --> 00:02:30,555
Steiger alle im

46
00:02:30,578 --> 00:02:33,676
KI-Labor des Massachusetts Institute of Technology an der

47
00:02:33,708 --> 00:02:37,804
Fundamentalisierung, einem Konzept

48
00:02:37,852 --> 00:02:40,972
der gleichzeitigen Berechnung, das

49
00:02:41,036 --> 00:02:44,304
sowohl Struktur als auch anpassbare

50
00:02:44,352 --> 00:02:46,020
Algorithmenausführung umfasste.

51
00:02:47,480 --> 00:02:49,744
Konventionellen Methoden mangelte es damals an

52
00:02:49,792 --> 00:02:52,224
Robustheit und sicheren mathematischen

53
00:02:52,272 --> 00:02:55,263
Grundlagen.  Ihre gemeinsame Anstrengung

54
00:02:55,312 --> 00:02:57,576
führte schließlich zur Entwicklung des

55
00:02:57,598 --> 00:03:01,076
Actor-Modells.  Damals galt es

56
00:03:01,108 --> 00:03:03,224
aufgrund seiner

57
00:03:03,262 --> 00:03:05,764
Merkmale einer erhöhten

58
00:03:05,812 --> 00:03:08,784
Fehlertoleranz und verteilten

59
00:03:08,852 --> 00:03:12,236
Rechenfähigkeiten als revolutionär.  In den 1980er und

60
00:03:12,258 --> 00:03:15,388
1990er Jahren wurde das Actor-Modell zur

61
00:03:15,394 --> 00:03:18,476
Grundlage zahlreicher Forschungs- und

62
00:03:18,498 --> 00:03:20,856
Praxisprojekte und erfreute sich

63
00:03:20,888 --> 00:03:23,184
aufgrund seiner Flexibilität und

64
00:03:23,222 --> 00:03:25,516
intuitiven Herangehensweise an gleichzeitige

65
00:03:25,548 --> 00:03:29,648
Berechnungen zunehmender Beliebtheit.  Es wurde hauptsächlich in

66
00:03:29,734 --> 00:03:32,240
künstlichen Intelligenz- und

67
00:03:32,310 --> 00:03:34,400
Multiagentensystemen eingesetzt.  Klingt bekannt?

68
00:03:35,880 --> 00:03:38,784
Neue Actor-basierte Sprachen wie Actor,

69
00:03:38,912 --> 00:03:42,116
Saulson und Erlang trugen zur

70
00:03:42,138 --> 00:03:44,356
Verfeinerung des Modells bei und formten es

71
00:03:44,378 --> 00:03:47,203
zu einem robusteren und flexibleren Ansatz

72
00:03:47,332 --> 00:03:50,148
für Concurrent Computing, und es ist auch heute noch

73
00:03:50,244 --> 00:03:52,164
in der Informatik lebendig und erfolgreich

74
00:03:52,212 --> 00:03:55,272
.  In jüngerer Zeit hat das Actor-Modell

75
00:03:55,326 --> 00:03:57,796
erneut an Interesse gewonnen, vor allem

76
00:03:57,828 --> 00:03:59,944
aufgrund des wachsenden Bedarfs an verteilten

77
00:03:59,992 --> 00:04:02,904
Systemen, Cloud Computing und Edge

78
00:04:02,952 --> 00:04:05,036
Computing, die das Internet der

79
00:04:05,058 --> 00:04:07,310
Dinge und das Web 30 vorantreiben.

80
00:04:08,480 --> 00:04:11,351
Diese Computeraufgaben sind ideal geeignet,

81
00:04:11,416 --> 00:04:13,436
um die Architektur des ACA-Modells zu nutzen

82
00:04:13,468 --> 00:04:16,800
, das genau

83
00:04:16,950 --> 00:04:20,368
auf die Modellierung des gleichzeitigen Umgangs mit

84
00:04:20,534 --> 00:04:23,409
großen Datenmengen einerseits

85
00:04:23,800 --> 00:04:26,752
und feinkörnigen, unterschiedlichen autonomen

86
00:04:26,816 --> 00:04:28,710
Systemen andererseits ausgelegt ist.

87
00:04:29,640 --> 00:04:32,003
Diese Anwendung des Actor-Modells

88
00:04:32,042 --> 00:04:34,436
hatte tiefgreifende Auswirkungen auf große Unternehmen wie Twitter, Facebook und LinkedIn,

89
00:04:34,538 --> 00:04:36,904
die seine Prinzipien zur

90
00:04:36,942 --> 00:04:38,936
Bewältigung von Big-Data-Problemen genutzt haben.

91
00:04:38,958 --> 00:04:41,348


92
00:04:41,524 --> 00:04:45,256
Was hat das also

93
00:04:45,278 --> 00:04:47,636
mit aktiver Inferenz zu tun?  Ich

94
00:04:47,668 --> 00:04:49,368
vermute, Sie haben einige

95
00:04:49,374 --> 00:04:51,656
der Parallelen bereits im Intro gehört.  Aber

96
00:04:51,688 --> 00:04:53,656
schauen wir uns zunächst einige

97
00:04:53,688 --> 00:04:56,396
Grundprinzipien des Akteurmodells an und wie

98
00:04:56,418 --> 00:04:58,568
sie sich auf die Prinzipien der aktiven

99
00:04:58,584 --> 00:05:01,236
Inferenz beziehen.  Beginnen wir mit dem Konzept

100
00:05:01,288 --> 00:05:04,832
der Isolation.  Isolation bedeutet,

101
00:05:04,886 --> 00:05:07,664
dass ein Akteur im Akteurmodell

102
00:05:07,702 --> 00:05:10,464
seinen Zustand mit keinem anderen

103
00:05:10,502 --> 00:05:14,212
Akteur teilt.  Es kann nur durch den

104
00:05:14,266 --> 00:05:17,060
Empfang einer Nachricht beeinflusst werden.  Und es kann

105
00:05:17,130 --> 00:05:19,524
Änderungen im Zustand anderer

106
00:05:19,562 --> 00:05:22,164
Akteure nur dadurch beeinflussen, dass es als Antwort eine begrenzte Anzahl von

107
00:05:22,202 --> 00:05:25,776
Nachrichten sendet.  Aus

108
00:05:25,808 --> 00:05:27,512
Sicht der Softwareentwicklung

109
00:05:27,566 --> 00:05:30,051
begrenzt dieses Isolationsprinzip potenzielle

110
00:05:30,116 --> 00:05:33,111
Nebenwirkungen einer Operation auf einen einzelnen

111
00:05:33,166 --> 00:05:35,924
Akteur, verbessert so die

112
00:05:35,972 --> 00:05:39,072
allgemeine Vorhersagbarkeitszuverlässigkeit des Systems

113
00:05:39,236 --> 00:05:42,104
und kann, was am wichtigsten ist, bei vollständiger Umsetzung

114
00:05:42,232 --> 00:05:44,910
das Design tatsächlich vereinfachen.  Wenn wir uns

115
00:05:46,560 --> 00:05:48,636
das Diagramm ansehen, sehen wir ein

116
00:05:48,658 --> 00:05:51,616
Ökosystem von Akteuren, die Nachrichten an

117
00:05:51,638 --> 00:05:54,635
einen bestimmten Akteur senden, der wiederum

118
00:05:54,668 --> 00:05:57,040
Nachrichten an andere Akteure zurücksendet.

119
00:05:58,340 --> 00:06:00,690
Wo ist aktive Inferenz?  Nun, lassen Sie uns das

120
00:06:01,300 --> 00:06:03,816
Empfangen und Senden von

121
00:06:03,868 --> 00:06:07,392
Nachrichten in einen Wahrnehmungs-Aktionszyklus umwandeln

122
00:06:07,536 --> 00:06:09,620
und externe,

123
00:06:10,200 --> 00:06:13,539
interne, sensorische und

124
00:06:13,610 --> 00:06:17,112
aktive Zustände bezeichnen.  Und wir haben jetzt eindeutig

125
00:06:17,166 --> 00:06:19,956
die notwendige Grundlage für aktive

126
00:06:19,988 --> 00:06:22,600
Schlussfolgerungen, eine Markov-Decke.

127
00:06:23,660 --> 00:06:26,436
Die Akteure des Akteurmodells werden

128
00:06:26,468 --> 00:06:28,848
direkt den Agenten der aktiven

129
00:06:28,884 --> 00:06:32,840
Inferenz zugeordnet.  Darüber hinaus ist die Endlichkeit, also

130
00:06:33,000 --> 00:06:35,676
die Tatsache, dass ein Akteur nur eine

131
00:06:35,698 --> 00:06:39,003
endliche Anzahl von Nachrichten als Antwort senden kann,

132
00:06:39,042 --> 00:06:41,150
eine wichtige gemeinsame Eigenschaft.

133
00:06:41,940 --> 00:06:44,780
Da aktive Inferenz die Realität modelliert,

134
00:06:44,940 --> 00:06:47,452
respektiert sie zwangsläufig die Ressourcenbeschränkungen

135
00:06:47,516 --> 00:06:50,704
realer Systeme.  Und dies ist

136
00:06:50,742 --> 00:06:53,376
gut in das Fundament des

137
00:06:53,398 --> 00:06:56,496
aktiven Modells eingebettet.  Schauen wir uns ein weiteres

138
00:06:56,528 --> 00:06:59,860
Grundprinzip der asynchronen Nachrichtenübermittlung an.  Die

139
00:07:00,840 --> 00:07:03,012
Kommunikation zwischen Akteuren ist

140
00:07:03,066 --> 00:07:05,936
asynchron.  Das bedeutet, dass ein Akteur

141
00:07:05,968 --> 00:07:07,832
nach dem Senden einer Nachricht nicht auf eine Antwort wartet

142
00:07:07,886 --> 00:07:10,680
.  Es arbeitet weiter,

143
00:07:10,830 --> 00:07:13,210
es lebt gewissermaßen weiter.

144
00:07:13,820 --> 00:07:17,256
Dies ist von entscheidender Bedeutung, da es die

145
00:07:17,278 --> 00:07:20,284
Akteure entkoppelt und zu einem System führt, das auch dann

146
00:07:20,322 --> 00:07:23,020
weiter funktionieren, leben und

147
00:07:23,090 --> 00:07:25,948
Fortschritte machen kann, wenn Teile des Systems

148
00:07:26,034 --> 00:07:28,551
langsam oder sogar vorübergehend

149
00:07:28,616 --> 00:07:31,964
nicht verfügbar sind.  Professor Friston

150
00:07:32,012 --> 00:07:34,028
hat gesagt, dass das Prinzip der freien Energie

151
00:07:34,124 --> 00:07:38,240
die ultimative existenzielle Frage ist: Wenn

152
00:07:38,310 --> 00:07:41,490
Dinge existieren, was müssen sie tun?

153
00:07:42,660 --> 00:07:45,412
Nun, das Schauspielermodell behauptet, dass man

154
00:07:45,466 --> 00:07:47,350
nicht auf andere warten dürfe.

155
00:07:48,360 --> 00:07:51,572
Natürlich kann sich ein Akteur dafür entscheiden,

156
00:07:51,626 --> 00:07:55,284
auf andere zu warten, aber er darf

157
00:07:55,322 --> 00:07:58,808
im Modell nicht dazu gezwungen werden.  Die Wahl muss frei sein

158
00:07:58,894 --> 00:07:59,770
.

159
00:08:01,820 --> 00:08:04,004
Dies führt uns zu einem weiteren entscheidenden

160
00:08:04,052 --> 00:08:06,456
Grundsatz, dass beide Modelle

161
00:08:06,558 --> 00:08:09,719
autonom sind.  Das Prinzip der freien Energie

162
00:08:09,790 --> 00:08:12,860
ist ein Modell der physikalischen Realität

163
00:08:13,280 --> 00:08:15,547
und unsere Realität ist schließlich

164
00:08:15,634 --> 00:08:18,904
gleichzeitig.  Überall im unendlichen

165
00:08:18,952 --> 00:08:21,572
Raum entwickeln sich Systeme

166
00:08:21,656 --> 00:08:24,048
gleichzeitig entsprechend ihrer lokalen

167
00:08:24,134 --> 00:08:27,696
Dynamik.  Und deshalb

168
00:08:27,718 --> 00:08:29,344
spiegelt sich dies im Kern des Prinzips der freien

169
00:08:29,382 --> 00:08:33,024
Energie wider.  Natürlich

170
00:08:33,062 --> 00:08:35,796
muss sich ein Rechenmodell nicht auf die

171
00:08:35,818 --> 00:08:38,784
Physik beschränken.  Aber Hewitt et al.  Wir wollten

172
00:08:38,832 --> 00:08:41,395
ein Modell entwickeln, das die

173
00:08:41,418 --> 00:08:43,664
Realität verteilter gleichzeitiger

174
00:08:43,712 --> 00:08:47,056
Systeme modelliert.  Und zum Glück für uns

175
00:08:47,088 --> 00:08:50,824
umfasst das Akteurmodell sowohl Parallelität, gesehen

176
00:08:50,862 --> 00:08:53,352
vom Prinzip der Isolation, als auch

177
00:08:53,486 --> 00:08:56,500
Akteurautonomie, wodurch es

178
00:08:56,580 --> 00:08:58,040
mit aktiver Inferenz kompatibel ist.

179
00:08:59,200 --> 00:09:01,820
Als nächstes kommen wir zum Nisten.

180
00:09:02,640 --> 00:09:05,532
Das Akteurmodell ermöglicht es einem Akteur,

181
00:09:05,586 --> 00:09:08,552
nicht nur eine endliche

182
00:09:08,616 --> 00:09:11,984
Anzahl von Nachrichten zu empfangen und zu senden, um sie wahrzunehmen und zu handeln, sondern

183
00:09:12,182 --> 00:09:15,292
ermöglicht auch als Aktion die Schaffung

184
00:09:15,356 --> 00:09:18,240
einer endlichen Anzahl neuer Akteure.

185
00:09:19,220 --> 00:09:21,504
Diese Akteure können entweder in

186
00:09:21,542 --> 00:09:24,336
der übergeordneten Zelle verschachtelt sein, beispielsweise in den Teilen einer

187
00:09:24,368 --> 00:09:26,564
Tierzelle, oder sie können

188
00:09:26,602 --> 00:09:29,076
als unabhängige Akteure in die Umgebung freigesetzt werden.  Von

189
00:09:29,098 --> 00:09:32,336
da an passt das Modell

190
00:09:32,368 --> 00:09:34,628
gut zu den schönen Konzepten der

191
00:09:34,714 --> 00:09:37,960
Multiskalenschachtelung und der aktiven Inferenz.

192
00:09:38,940 --> 00:09:41,460
Dies ermöglicht es den Akteuren,

193
00:09:41,540 --> 00:09:44,791
Ökosysteme von Akteuren sowohl nach

194
00:09:44,846 --> 00:09:47,290
unten als auch nach oben zu umfassen.

195
00:09:49,200 --> 00:09:51,976
Zuletzt möchte ich zwei weitere

196
00:09:52,008 --> 00:09:55,436
Prinzipien des Akteurmodelldesigns, Verhaltensänderung

197
00:09:55,618 --> 00:09:57,020
und Persistenz, behandeln.

198
00:09:59,040 --> 00:10:01,664
Akteure haben die Möglichkeit, ihr

199
00:10:01,702 --> 00:10:04,450
Verhalten als Reaktion auf eine Nachricht zu ändern.

200
00:10:05,140 --> 00:10:08,192
Diese Anpassungsfähigkeit ermöglicht die

201
00:10:08,246 --> 00:10:10,924
Konstruktion komplexer zustandsbehafteter

202
00:10:10,972 --> 00:10:14,130
Einheiten, die sich im Laufe der Zeit weiterentwickeln können.

203
00:10:14,760 --> 00:10:17,492
Und tatsächlich ermöglicht es ganzen

204
00:10:17,626 --> 00:10:21,584
Ökosystemen, neue Verhaltensweisen zu entwickeln

205
00:10:21,632 --> 00:10:25,263
.  Beim Einsatz für die

206
00:10:25,312 --> 00:10:28,264
Softwareentwicklung stellt dies ein leistungsstarkes Werkzeug

207
00:10:28,382 --> 00:10:31,800
zur Verwaltung komplexer dynamischer Systeme dar.

208
00:10:32,700 --> 00:10:35,412
Aktive Schlussfolgerungen umfassen

209
00:10:35,476 --> 00:10:39,304
dies natürlich bis zum Äußersten.  Das eigentliche Wesen

210
00:10:39,352 --> 00:10:42,363
der Dinghaftigkeit ist der ständige Versuch,

211
00:10:42,402 --> 00:10:45,324
eine Umgebung vorherzusagen und sich an sie anzupassen und

212
00:10:45,362 --> 00:10:48,439
dadurch weiter zu existieren, um

213
00:10:48,520 --> 00:10:52,828
in einem brodelnden Meer von Aktivitäten seine Markov-Decke aufrechtzuerhalten

214
00:10:53,004 --> 00:10:56,736
.  Damit einher

215
00:10:56,758 --> 00:10:58,912
geht auch das Konzept der

216
00:10:58,966 --> 00:11:02,444
Beharrlichkeit.  Persistenz ermöglicht es den Akteuren,

217
00:11:02,492 --> 00:11:05,524
ihren Zustand zu speichern und

218
00:11:05,562 --> 00:11:08,640
ihn später wiederherzustellen oder zu ändern, ein Merkmal,

219
00:11:08,720 --> 00:11:11,300
das das Prinzip der Erinnerung verkörpert.

220
00:11:11,800 --> 00:11:14,675
Gedächtnis ist eine Voraussetzung für Lernen

221
00:11:14,778 --> 00:11:18,504
und Anpassung.  Die Fähigkeit eines Agenten,

222
00:11:18,622 --> 00:11:21,640
Vorhersagen zu treffen, hängt von seiner Fähigkeit ab, sich an

223
00:11:21,710 --> 00:11:24,356
vergangene Erfahrungen zu erinnern und so

224
00:11:24,388 --> 00:11:27,176
die mit Unerwartetem einhergehende Überraschung zu minimieren

225
00:11:27,198 --> 00:11:30,520
.  Die entscheidende Rolle des Gedächtnisses

226
00:11:30,600 --> 00:11:34,056
wird auch hervorgehoben, wenn wir davon ausgehen,

227
00:11:34,088 --> 00:11:36,199
dass Agenten

228
00:11:36,280 --> 00:11:39,100
entweder aus Erfahrung oder durch Vererbung induktive Prioritäten haben, die

229
00:11:39,440 --> 00:11:41,470
zu ihrem Weltmodell beitragen.

230
00:11:42,340 --> 00:11:44,464
Dieses Weltmodell leitet ihr

231
00:11:44,502 --> 00:11:47,291
aktuelles Verhalten und wird

232
00:11:47,356 --> 00:11:50,028
auf der Grundlage neuer Erfahrungen, die

233
00:11:50,204 --> 00:11:52,939
zu ihrer fortlaufenden Anpassung

234
00:11:53,020 --> 00:11:54,240
und Existenz beitragen, kontinuierlich aktualisiert.

235
00:11:56,600 --> 00:11:59,684
OK großartig.  Sie sagen, dass es klare und

236
00:11:59,722 --> 00:12:02,308
tiefe Verbindungen zwischen dem Akteurmodell

237
00:12:02,394 --> 00:12:06,424
und der aktiven Schlussfolgerung gibt.  Aber wie

238
00:12:06,462 --> 00:12:08,756
hilft uns das in der aktiven Inferenz-

239
00:12:08,788 --> 00:12:11,988
Community?  Nun, erstens

240
00:12:12,084 --> 00:12:14,084
ist es meiner Meinung nach ein Software-

241
00:12:14,132 --> 00:12:16,520
Engineering-Paradigma, das wir annehmen sollten.

242
00:12:16,860 --> 00:12:19,340
Und wenn wir das tun, gibt es natürlich

243
00:12:19,410 --> 00:12:21,815
Akteurmodellbibliotheken und Frameworks,

244
00:12:21,848 --> 00:12:25,448
die wir verwenden können, wie ACA,

245
00:12:25,624 --> 00:12:29,752
Orleans, Thespian Actix

246
00:12:29,896 --> 00:12:33,055
Protoactor und viele mehr, die wir

247
00:12:33,078 --> 00:12:35,516
sofort beim Erstellen aktiver

248
00:12:35,548 --> 00:12:37,872
Inferenzsoftwaremodule und

249
00:12:37,926 --> 00:12:41,596
-anwendungen verwenden können.  Es gibt auch Bibliotheken,

250
00:12:41,708 --> 00:12:43,944
Sprachen und sogar Sprachfunktionen,

251
00:12:44,012 --> 00:12:46,016
die sehr gut mit den

252
00:12:46,048 --> 00:12:49,380
Prinzipien des Akteurmodells übereinstimmen, wie Zero,

253
00:12:49,450 --> 00:12:52,640
MQ, Tokyo und Rust,

254
00:12:52,800 --> 00:12:56,284
Erlang, Async, Await und C. Sharp

255
00:12:56,432 --> 00:13:00,104
usw.  Aber wichtiger als

256
00:13:00,142 --> 00:13:04,712
die Tools, die uns heute zur Verfügung stehen, ist

257
00:13:04,766 --> 00:13:07,544
die Einstellung zum Softwaredesign, die

258
00:13:07,582 --> 00:13:10,136
uns bei der Entwicklung der aktiven

259
00:13:10,168 --> 00:13:13,996
Inferenzsoftware von morgen leiten wird.  Das

260
00:13:14,018 --> 00:13:16,764
Akteurmodell stellt ein Paradigma für

261
00:13:16,802 --> 00:13:20,588
Software-Design und -Engineering dar, das am

262
00:13:20,754 --> 00:13:24,064
besten zu den aktiven Inferenzen passt, die wir haben

263
00:13:24,102 --> 00:13:28,160
.  Dies zeigt sich

264
00:13:28,580 --> 00:13:30,876
nicht nur an der Ausrichtung der

265
00:13:30,908 --> 00:13:34,084
zuvor besprochenen Grundprinzipien, sondern

266
00:13:34,122 --> 00:13:37,055
auch an den Erkenntnissen, die aktive

267
00:13:37,088 --> 00:13:39,156
Schlussfolgerungen im Akteurmodell zueinander bringen

268
00:13:39,178 --> 00:13:42,916
.  Betrachten Sie zum Beispiel das, was

269
00:13:42,938 --> 00:13:46,604
heute als Hewitt-Gesetz bezeichnet wird.  Informell

270
00:13:46,672 --> 00:13:49,800
ausgedrückt als „Alles ist überall“

271
00:13:51,260 --> 00:13:54,824
bedeutet dieses Gesetz die Idee, dass es

272
00:13:54,942 --> 00:13:57,844
in einem wirklich asynchronen verteilten

273
00:13:57,892 --> 00:14:00,652
System beliebig lange dauern kann,

274
00:14:00,706 --> 00:14:03,532
bis eine Nachricht von einem

275
00:14:03,586 --> 00:14:07,032
Ort zum anderen gelangt, und dass jeder Akteur

276
00:14:07,096 --> 00:14:10,364
auf dieses Ereignis vorbereitet sein muss.

277
00:14:10,402 --> 00:14:13,900


278
00:14:13,980 --> 00:14:17,888
In einem solchen System gibt es einfach keinen Augenblick, und keine Komponente kann

279
00:14:17,974 --> 00:14:20,384
eine Annahme über den Zeitpunkt der

280
00:14:20,422 --> 00:14:23,548
Aktionen einer anderen Komponente treffen.  Tatsächlich

281
00:14:23,734 --> 00:14:26,980
muss man so tun, als würde eine Nachricht möglicherweise

282
00:14:27,050 --> 00:14:30,819
nie ankommen.  Dies hat wichtige

283
00:14:30,890 --> 00:14:34,644
Auswirkungen.  Dies deutet darauf hin, dass es unmöglich ist,

284
00:14:34,682 --> 00:14:36,744


285
00:14:36,782 --> 00:14:39,176
den Zustand des

286
00:14:39,198 --> 00:14:42,569
gesamten Systems zu einem bestimmten Zeitpunkt genau und konsistent zu bestimmen,

287
00:14:43,260 --> 00:14:45,464
da die Informationen möglicherweise noch nicht einmal

288
00:14:45,502 --> 00:14:48,410
im gesamten System verbreitet wurden.

289
00:14:49,760 --> 00:14:52,904
Und auch Versuche, eine globale Synchronisierung zu implementieren, führen

290
00:14:52,952 --> 00:14:55,400
unweigerlich zu

291
00:14:55,480 --> 00:14:57,864
Engpässen und verringern die

292
00:14:57,912 --> 00:15:01,844
Effizienz.  Hewitts Gesetz betont

293
00:15:01,912 --> 00:15:04,976
die Notwendigkeit, Systeme so zu gestalten,

294
00:15:04,998 --> 00:15:07,580
dass sie

295
00:15:07,660 --> 00:15:09,504
diese unvermeidbaren Verzögerungen und

296
00:15:09,542 --> 00:15:11,776
Unsicherheiten effektiv bewältigen können, und unterstreicht die

297
00:15:11,798 --> 00:15:14,424
Bedeutung robuster, nicht blockierender

298
00:15:14,492 --> 00:15:17,540
Kommunikationsmechanismen und lokaler

299
00:15:17,690 --> 00:15:21,284
Entscheidungsfähigkeiten.  Kurz gesagt,

300
00:15:21,482 --> 00:15:24,240
Hector-Modellsysteme sind von Natur aus

301
00:15:24,400 --> 00:15:27,944
nichtdeterministisch.  Kommt Ihnen das

302
00:15:27,982 --> 00:15:31,800
bekannt vor?  Welches andere Paradigma unterstreicht den

303
00:15:32,140 --> 00:15:34,616
Betrieb unter Unsicherheit und die

304
00:15:34,638 --> 00:15:36,904
Autonomie, trotz der

305
00:15:36,942 --> 00:15:40,328
Umgebung fortzufahren?  Aktive Inferenz und das

306
00:15:40,334 --> 00:15:43,767
Prinzip der freien Energie?  Aktive Inferenz

307
00:15:43,864 --> 00:15:46,552
spiegelt die Realität einer unvorhersehbaren

308
00:15:46,616 --> 00:15:48,792
Welt wider, in der unsere Softwaresysteme

309
00:15:48,856 --> 00:15:51,920
funktionieren.

310
00:15:51,990 --> 00:15:55,136
Aufgrund

311
00:15:55,158 --> 00:15:57,756
des Auftretens von Ereignissen in zufälliger,

312
00:15:57,868 --> 00:16:01,644
unvorhersehbarer Reihenfolge können aus denselben Anfangsbedingungen unterschiedliche Ergebnisse resultieren.  Dies ist das Konzept

313
00:16:01,692 --> 00:16:04,310
der Überraschung, das wir alle gut kennen.

314
00:16:05,000 --> 00:16:07,572
Dabei aktualisiert ein Agent seine Überzeugungen über

315
00:16:07,626 --> 00:16:10,404
die Welt, wenn der sensorische Input, den er

316
00:16:10,442 --> 00:16:13,060
erhält, nicht mit seinen Vorhersagen übereinstimmt.

317
00:16:13,720 --> 00:16:15,856
Sowohl das Akteurmodell als auch die aktive

318
00:16:15,888 --> 00:16:18,328
Schlussfolgerung erkennen an, dass die Welt

319
00:16:18,414 --> 00:16:21,624
unvorhersehbar ist.

320
00:16:21,662 --> 00:16:24,632
Die Modelle erkennen diese Ungewissheit nicht nur an, sondern akzeptieren sie auch

321
00:16:24,686 --> 00:16:27,688
als gegeben und nicht als etwas, das man

322
00:16:27,774 --> 00:16:29,530
beseitigen kann.

323
00:16:30,780 --> 00:16:33,752
Tatsächlich ist es, wie wir beim Prinzip der freien Energie wissen

324
00:16:33,806 --> 00:16:36,204
, die Unsicherheit, die wir

325
00:16:36,242 --> 00:16:38,459
in unseren Modellen beibehalten, die uns

326
00:16:38,530 --> 00:16:41,020
die Flexibilität gibt, uns anzupassen.

327
00:16:43,540 --> 00:16:46,555
Vielleicht ist dies nur meine persönliche

328
00:16:46,588 --> 00:16:49,199
Fantasiereise, aber ich stelle mir eine Zukunft vor, in der

329
00:16:49,270 --> 00:16:51,596
durch aktive Inferenz gesteuerte Softwaremodule auf die

330
00:16:51,628 --> 00:16:54,976
fest codierte Fehlerbehandlung verzichten

331
00:16:55,008 --> 00:16:57,792
und probabilistische

332
00:16:57,856 --> 00:17:00,672
Lernalgorithmen einführen, die

333
00:17:00,736 --> 00:17:03,200
sich selbst optimieren, wenn sich die Fehlerlandschaft

334
00:17:03,280 --> 00:17:07,316
weiterentwickelt.  Module, bei denen es sich um robuste

335
00:17:07,428 --> 00:17:11,268
und selbstheilende verteilte Systeme

336
00:17:11,364 --> 00:17:13,672
ohne Single Points of Failure handelt, die sich eher

337
00:17:13,726 --> 00:17:17,716
auf die prädiktive Katastrophenvermeidung

338
00:17:17,907 --> 00:17:21,659
als auf die reaktive Notfallwiederherstellung konzentrieren.

339
00:17:23,040 --> 00:17:25,308
Mit Blick auf die Zukunft haben wir als

340
00:17:25,314 --> 00:17:28,044
Gemeinschaft das Potenzial, die

341
00:17:28,082 --> 00:17:31,700
Grenzen sowohl der Theorie der aktiven Prägung

342
00:17:31,880 --> 00:17:34,576
als auch der praktischen Umsetzung des

343
00:17:34,598 --> 00:17:37,611
Akteurmodells zu verschieben.  Indem wir die Stärken

344
00:17:37,676 --> 00:17:40,096
dieser beiden Paradigmen gemeinsam nutzen, können wir

345
00:17:40,118 --> 00:17:42,860
Softwaresysteme schaffen, die robust,

346
00:17:43,020 --> 00:17:45,876
anpassungsfähig und besser auf die

347
00:17:45,898 --> 00:17:48,500
physische Welt abgestimmt sind, in der sie tatsächlich

348
00:17:48,650 --> 00:17:52,100
funktionieren.  Stellen Sie sich eine Zukunft vor,

349
00:17:52,170 --> 00:17:54,976
in der Softwarekomponenten mithilfe aktiver

350
00:17:55,008 --> 00:17:57,112
Inferenz im Akteurmodell

351
00:17:57,166 --> 00:18:00,344
potenzielle Probleme antizipieren, aus

352
00:18:00,382 --> 00:18:04,024
Fehlern der Vergangenheit lernen und sich in Echtzeit an

353
00:18:04,062 --> 00:18:07,144
Umweltveränderungen anpassen können.  Mit diesem

354
00:18:07,182 --> 00:18:09,212
Ansatz können wir Systeme aufbauen, die

355
00:18:09,266 --> 00:18:11,996
grundsätzlich widerstandsfähiger und

356
00:18:12,018 --> 00:18:15,084
effizienter sind.  Meiner Meinung nach kann dies

357
00:18:15,122 --> 00:18:17,784
einen entscheidenden Wandel in der Zuverlässigkeit

358
00:18:17,912 --> 00:18:21,052
, Leistung und Skalierbarkeit von Software mit sich bringen und

359
00:18:21,106 --> 00:18:24,044
eine neue Ära der Datenverarbeitung einläuten, in der

360
00:18:24,092 --> 00:18:27,264
Prinzipien der Biologie und Kognition in

361
00:18:27,302 --> 00:18:30,060
das Gefüge unserer Softwaresysteme eingebunden werden und

362
00:18:30,220 --> 00:18:32,416
sie dadurch dem Leben näher kommen

363
00:18:32,438 --> 00:18:36,420
.  Zusammenfassend lässt sich sagen, dass

364
00:18:37,160 --> 00:18:39,636
die Kopplung der aktiven Inferenz mit dem

365
00:18:39,658 --> 00:18:42,803
Akteurmodell eine leistungsstarke neue

366
00:18:42,842 --> 00:18:44,564
Perspektive bietet, durch die wir

367
00:18:44,602 --> 00:18:46,820
Software-Design und -Engineering betrachten können.

368
00:18:47,180 --> 00:18:49,412
Ob wir bestehende Sprachen

369
00:18:49,476 --> 00:18:51,476
und Bibliotheken nutzen, die auf aktive

370
00:18:51,508 --> 00:18:54,728
Inferenz ausgerichtet sind, oder neue erfinden,

371
00:18:54,894 --> 00:18:58,056
wir stehen am Rande einer

372
00:18:58,078 --> 00:19:01,944
spannenden Grenze.  Nutzen wir also

373
00:19:01,992 --> 00:19:05,068
den Tag, werfen wir einen Blick auf das Akteurmodell

374
00:19:05,154 --> 00:19:06,776
und seine Beziehung zur aktiven

375
00:19:06,808 --> 00:19:09,484
Inferenz und gestalten wir die Zukunft des

376
00:19:09,522 --> 00:19:11,980
intelligenten verteilten Rechnens.

377
00:19:13,040 --> 00:19:14,460
Danke fürs Zuhören.

378
00:19:17,790 --> 00:19:21,050
Eindrucksvoll.  Toller Vortrag von

379
00:19:21,120 --> 00:19:23,126
Keith.  Vielen Dank, Keith, dass du uns

380
00:19:23,158 --> 00:19:25,985
das geschickt hast. Es gab einige Kommentare im

381
00:19:26,008 --> 00:19:28,978
Chat.  Also, Keith, möglicherweise, wenn Sie

382
00:19:28,984 --> 00:19:32,641
in der Zukunft an der A-Q-A teilnehmen möchten, aber

383
00:19:32,696 --> 00:19:33,949
wirklich coole Präsentation.

