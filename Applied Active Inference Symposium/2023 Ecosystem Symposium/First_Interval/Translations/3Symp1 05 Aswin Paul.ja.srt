1
00:00:00,840 --> 00:00:02,820
その仕事を基礎にして、

2
00:00:02,820 --> 00:00:05,880
今夜は私たちと分かち合っていただき、

3
00:00:05,880 --> 00:00:07,859
本当にありがとうございます、また会うときまでお付き合いいただき、

4
00:00:07,859 --> 00:00:09,900


5
00:00:09,900 --> 00:00:12,179
ありがとう、バイバイ、わかった、

6
00:00:12,179 --> 00:00:14,480


7
00:00:16,800 --> 00:00:19,440


8
00:00:19,440 --> 00:00:20,699
いい

9
00:00:20,699 --> 00:00:23,640
話だ、これを買って、ようこそ

10
00:00:23,640 --> 00:00:25,980
アシュウィン、元気か、こんにちは、

11
00:00:25,980 --> 00:00:27,359


12
00:00:27,359 --> 00:00:29,820
ダニエル、元気だよ

13
00:00:29,820 --> 00:00:31,260
ぶらぶらしているあなた、

14
00:00:31,260 --> 00:00:33,320


15
00:00:33,559 --> 00:00:37,559
ええと、そうですね、いいですね。ええと、

16
00:00:37,559 --> 00:00:39,719


17
00:00:39,719 --> 00:00:42,420
パイ mdp での洗練された推論に関するワークショップを楽しみにしています。

18
00:00:42,420 --> 00:00:46,440
だから、90 分まででも構いません。

19
00:00:46,440 --> 00:00:48,239
それより短くても全然大丈夫です。

20
00:00:48,239 --> 00:00:51,420
短い休憩を取っても構いませんが、どうぞ

21
00:00:51,420 --> 00:00:53,100
取ってください。 取り去って、知らせてください。

22
00:00:53,100 --> 00:00:54,600
でも、お手伝いできます。

23
00:00:54,600 --> 00:00:55,739


24
00:00:55,739 --> 00:00:57,480
ありがとうございます。

25
00:00:57,480 --> 00:01:00,539
えっと、画面を共有して始めましょう。それでは、

26
00:01:00,539 --> 00:01:02,280


27
00:01:02,280 --> 00:01:04,860


28
00:01:04,860 --> 00:01:05,820
ここで行っていることの構造についてですが、

29
00:01:05,820 --> 00:01:08,760


30
00:01:08,760 --> 00:01:11,040
後でこれを見た人が試してみたくなるかもしれないと思います。

31
00:01:11,040 --> 00:01:13,080
チュートリアルか何かに沿ったハンズオンです。

32
00:01:13,080 --> 00:01:15,780
これが私が念頭に置いた構成です。

33
00:01:15,780 --> 00:01:19,380
ゆっくりと進めていきます。まあ、我慢して

34
00:01:19,380 --> 00:01:21,180
ください。それでは、皆さん、IMDb の

35
00:01:21,180 --> 00:01:23,340
高度な推論に関するこのセッションへようこそ。そこで、

36
00:01:23,340 --> 00:01:26,640
ここで説明します。 ええと、

37
00:01:26,640 --> 00:01:28,920
いくつかの洗練された推論

38
00:01:28,920 --> 00:01:31,080
シミュレーション、特に

39
00:01:31,080 --> 00:01:33,960
プライム DP モジュールを使用した元の論文のシミュレーションをモデル化しようとしています。

40
00:01:33,960 --> 00:01:36,299
現在、それが私の mdp の一部ではありませんが、

41
00:01:36,299 --> 00:01:38,700


42
00:01:38,700 --> 00:01:40,560
プライム DB モジュールに洗練された推論を追加する過程にあり、

43
00:01:40,560 --> 00:01:43,320
私は 主に、その機能を追加するために

44
00:01:43,320 --> 00:01:46,340
私が開発したコードについて話します。それで、

45
00:01:46,340 --> 00:01:49,079


46
00:01:49,079 --> 00:01:52,920
私はアシュウィン ポールです。私は

47
00:01:52,920 --> 00:01:56,040
モナシュ大学の博士課程候補者で、

48
00:01:56,040 --> 00:01:58,259
主にアクティブ推論

49
00:01:58,259 --> 00:02:00,360
モデルを扱い、

50
00:02:00,360 --> 00:02:03,840
その使用方法を理解しようとしています。 インテリジェントな行動の出現を基本的に理解するための説明可能なモデルとして、

51
00:02:03,840 --> 00:02:05,240


52
00:02:05,240 --> 00:02:07,380


53
00:02:07,380 --> 00:02:10,020


54
00:02:10,020 --> 00:02:12,360


55
00:02:12,360 --> 00:02:16,140
フリーエネルギーの原理について説明するために、私がやっている内容に飛び込みましょう。

56
00:02:16,140 --> 00:02:18,180
皆さんは

57
00:02:18,180 --> 00:02:20,280
今、それが何であるか理解していると思いますが、

58
00:02:20,280 --> 00:02:23,220
中心的なものは異なります 考え方としては、

59
00:02:23,220 --> 00:02:26,700
エージェントは常に

60
00:02:26,700 --> 00:02:28,920
観測値のエントロピーを最小化しようとしているので、

61
00:02:28,920 --> 00:02:31,800
観測値の確率が非常に低いことが

62
00:02:31,800 --> 00:02:34,680
頭の中にあり、

63
00:02:34,680 --> 00:02:36,720
それが起こった場合、あなたはおそらく

64
00:02:36,720 --> 00:02:39,660
驚くでしょうし、その逆も同様です。つまり、

65
00:02:39,660 --> 00:02:41,940
ここでのエントロピーは これは、情報理論上のエントロピーとして定義されます。

66
00:02:41,940 --> 00:02:44,420


67
00:02:44,420 --> 00:02:47,400
確率が低い場合、

68
00:02:47,400 --> 00:02:49,260
これは自動的に高い驚きまたは

69
00:02:49,260 --> 00:02:51,000
高いエントロピーの観察になります。

70
00:02:51,000 --> 00:02:53,700
そして、誰もが知っているように、アクティブ推論は、

71
00:02:53,700 --> 00:02:56,580


72
00:02:56,580 --> 00:02:58,980
エージェント環境ループと呼ばれるものを定義するための方法論も提供します。

73
00:02:58,980 --> 00:03:02,040
これにより、 私たちが

74
00:03:02,040 --> 00:03:04,140
注目しているエージェントとは何か、その

75
00:03:04,140 --> 00:03:08,180
エージェントの周囲の環境を考慮した場合のエージェントの動作は何かなどを

76
00:03:08,180 --> 00:03:11,099
正しく定義します。そのため、

77
00:03:11,099 --> 00:03:12,959


78
00:03:12,959 --> 00:03:15,300
マルコ ブランケットのアイデアにも精通しており、これは

79
00:03:15,300 --> 00:03:18,000
常に覚えておく必要があるため重要です。 つまり、

80
00:03:18,000 --> 00:03:20,040


81
00:03:20,040 --> 00:03:21,599
生成プロセスと

82
00:03:21,599 --> 00:03:25,260
生成モデルの違いを覚えておく必要があります。これは、

83
00:03:25,260 --> 00:03:27,599
非活動的な

84
00:03:27,599 --> 00:03:29,280
幼児向けの文学や、

85
00:03:29,280 --> 00:03:31,080
それを最初から理解しようとする人々にとって、非常に有名な混乱のポイントです。

86
00:03:31,080 --> 00:03:33,540
それで、中心的な

87
00:03:33,540 --> 00:03:35,580
問題は、どうやって エージェントは、

88
00:03:35,580 --> 00:03:37,800
エントロピーを最小化します。

89
00:03:37,800 --> 00:03:39,900
なぜなら、エージェントはどの観測値

90
00:03:39,900 --> 00:03:42,420
が遅いか高いのか、確率的に正しいので、

91
00:03:42,420 --> 00:03:44,519


92
00:03:44,519 --> 00:03:46,920
生成モデルを維持することによってどのように認識するのでしょうか。生成モデルは、

93
00:03:46,920 --> 00:03:49,319
どれが高い確率的な

94
00:03:49,319 --> 00:03:51,360
観測でどれが低い

95
00:03:51,360 --> 00:03:53,519
確率的な観測であるかを教えてくれます。 アイデアとしては、

96
00:03:53,519 --> 00:03:56,459
エージェントがアクセスできるのは、

97
00:03:56,459 --> 00:03:58,799


98
00:03:58,799 --> 00:04:00,599
エージェントが

99
00:04:00,599 --> 00:04:03,299
直接観察できない生成プロセスから得られる観察だけであり、

100
00:04:03,299 --> 00:04:05,459
知的なエージェントは

101
00:04:05,459 --> 00:04:08,220
頭の中に生成モデルを構築しようとするでしょう、それは

102
00:04:08,220 --> 00:04:09,060


103
00:04:09,060 --> 00:04:11,640
隠れたもののモデルです。 状態と

104
00:04:11,640 --> 00:04:14,340
それがアクセスできる観測値を取得し、

105
00:04:14,340 --> 00:04:16,260


106
00:04:16,260 --> 00:04:18,660
この生成モデルを正しく使用して確率を計算することを期待できますが、

107
00:04:18,660 --> 00:04:21,060
一般に、

108
00:04:21,060 --> 00:04:23,460


109
00:04:23,460 --> 00:04:25,320


110
00:04:25,320 --> 00:04:26,880
生成モデルからの観測値の確率をある種の周辺に追いやるのは手に負えない問題であるという問題があります。

111
00:04:26,880 --> 00:04:29,100
これが、

112
00:04:29,100 --> 00:04:31,620


113
00:04:31,620 --> 00:04:33,720
エージェントが最小化しようとしている驚きの上限を定義する必要がある理由であり、そこに

114
00:04:33,720 --> 00:04:35,400
自由エネルギーの考え方が登場するため、

115
00:04:35,400 --> 00:04:37,620
エージェントがおそらく

116
00:04:37,620 --> 00:04:40,560
最小化しているこの上限が自由エネルギーであり、それが

117
00:04:40,560 --> 00:04:42,840
自由エネルギー原理である理由です

118
00:04:42,840 --> 00:04:44,880
ここで、Capital Qs と呼ばれる新しい用語があります。

119
00:04:44,880 --> 00:04:48,000
これは、

120
00:04:48,000 --> 00:04:49,740
エージェントが

121
00:04:49,740 --> 00:04:51,900
その生成モデルの隠れたステップについて維持しているという信念として解釈でき、

122
00:04:51,900 --> 00:04:54,840
この量は自由

123
00:04:54,840 --> 00:04:57,479
エネルギーであり、伝統的にこの

124
00:04:57,479 --> 00:04:59,100
変分自由エネルギーは次

125
00:04:59,100 --> 00:05:00,660
のように解釈されます。

126
00:05:00,660 --> 00:05:02,880
主に機械学習の方法で、

127
00:05:02,880 --> 00:05:05,040


128
00:05:05,040 --> 00:05:07,259
モデルの複雑さと精度のバランスを取るため、

129
00:05:07,259 --> 00:05:09,300
自由エネルギーを最小限に抑える場合、エージェントは

130
00:05:09,300 --> 00:05:11,520
単一のモデルを考え出すと

131
00:05:11,520 --> 00:05:13,320
同時に、正確なモデルを考え出そうとします。

132
00:05:13,320 --> 00:05:15,419
ここではマイナス記号が付いているためです。

133
00:05:15,419 --> 00:05:16,860
正確さは正しいですが、

134
00:05:16,860 --> 00:05:19,919


135
00:05:19,919 --> 00:05:23,039
エージェントが常に

136
00:05:23,039 --> 00:05:25,979
モデルのエネルギーを最小化しようとすると同時に、古典的な最大エントロピー原則などと連動してモデルの

137
00:05:25,979 --> 00:05:27,720
エントロピーを最大化しようとする物理学的な方法でも解釈できます。

138
00:05:27,720 --> 00:05:29,580


139
00:05:29,580 --> 00:05:32,280


140
00:05:32,280 --> 00:05:35,340
文献によると、

141
00:05:35,340 --> 00:05:37,740
この生成モデルの考え方はソフトウェアの観点から非常に

142
00:05:37,740 --> 00:05:38,820
重要であるため、エージェントの

143
00:05:38,820 --> 00:05:41,220


144
00:05:41,220 --> 00:05:42,840


145
00:05:42,840 --> 00:05:44,580
生成モデルを正しく定義するために最初に行うべきことは、

146
00:05:44,580 --> 00:05:46,440
エージェントに

147
00:05:46,440 --> 00:05:47,100


148
00:05:47,100 --> 00:05:49,259
応じて通知されるかどうかに応じて決まります。

149
00:05:49,259 --> 00:05:51,720


150
00:05:51,720 --> 00:05:53,460
モデル化しようとしている実験 古典的な

151
00:05:53,460 --> 00:05:56,060
能動推論では通常、意思決定は

152
00:05:56,060 --> 00:05:58,979
ポリシーの観点から定義されます。

153
00:05:58,979 --> 00:06:02,220
たとえば、あなたがこの環境のエージェントである場合、

154
00:06:02,220 --> 00:06:04,620
マリオ ゲームでは

155
00:06:04,620 --> 00:06:06,720
マリオがエージェントで、その他はすべて

156
00:06:06,720 --> 00:06:09,240
環境です。

157
00:06:09,240 --> 00:06:11,100
マリオには

158
00:06:11,100 --> 00:06:13,740
3 つの利用可能なアクションがあり、

159
00:06:13,740 --> 00:06:16,139
走る、ジャンプする、またはこの環境に留まることができます。

160
00:06:16,139 --> 00:06:19,199
ポリシーの古典的な定義は、

161
00:06:19,199 --> 00:06:21,360
時間内の一連のアクションであるため、

162
00:06:21,360 --> 00:06:24,060
大文字 T の時間軸がある場合、

163
00:06:24,060 --> 00:06:27,120
ポリシーは一連の

164
00:06:27,120 --> 00:06:29,220
アクションに他なりません。 時間内に run run Jump などを実行する可能性があります。

165
00:06:29,220 --> 00:06:33,300
これは上

166
00:06:33,300 --> 00:06:36,419
付き文字がアクションです。これは

167
00:06:36,419 --> 00:06:39,000
Jump run などです。下付き文字は

168
00:06:39,000 --> 00:06:41,400
時間です。

169
00:06:41,400 --> 00:06:44,100
その後、コレクションであるポリシー スペースを作成できます。

170
00:06:44,100 --> 00:06:45,720
そのような多くの

171
00:06:45,720 --> 00:06:46,940
性質の

172
00:06:46,940 --> 00:06:50,520
小さな山と、

173
00:06:50,520 --> 00:06:52,020
能動的推論で意思決定を行うために本質的に行うこと

174
00:06:52,020 --> 00:06:55,199
えー、計算する えー、最適化しない えー、

175
00:06:55,199 --> 00:06:58,139


176
00:06:58,139 --> 00:07:01,680
政策空間内のすべての政策の期待される自由エネルギーを計算する

177
00:07:01,680 --> 00:07:04,199
基本的に、それは

178
00:07:04,199 --> 00:07:07,860
リスクと曖昧さのバランスとして解釈できます

179
00:07:07,860 --> 00:07:10,560
そして、

180
00:07:10,560 --> 00:07:12,840
ええと、この

181
00:07:12,840 --> 00:07:14,580
期待される自由エネルギーを計算するとき、あなたがやろうとしているのは、

182
00:07:14,580 --> 00:07:18,600
リスクを最小限に抑えることです、それは、

183
00:07:18,600 --> 00:07:21,720


184
00:07:21,720 --> 00:07:24,300
観察についてのあなたの信念が以前の

185
00:07:24,300 --> 00:07:27,240
好みとどれだけ異なるかということです、大文字 C したがって、これも

186
00:07:27,240 --> 00:07:28,800
生成の一部です モデル

187
00:07:28,800 --> 00:07:30,900
制御をモデル化しようとするとき、同時に

188
00:07:30,900 --> 00:07:32,280


189
00:07:32,280 --> 00:07:34,440
曖昧さを最小限に抑えようとするとき、えー、

190
00:07:34,440 --> 00:07:36,419
最小限の期待される

191
00:07:36,419 --> 00:07:38,699
自由エネルギーを持つ政策を選択するとき、正しいですが、この定式化には

192
00:07:38,699 --> 00:07:40,860
政策空間が

193
00:07:40,860 --> 00:07:43,259
すぐに手に負えなくなるという問題があります。

194
00:07:43,259 --> 00:07:47,460


195
00:07:47,460 --> 00:07:49,319
ポリシー空間には膨大な数の小さな PI またはポリシーが存在する可能性があり、

196
00:07:49,319 --> 00:07:51,000


197
00:07:51,000 --> 00:07:53,580
たとえ短時間であっても座ってそのようなすべてのポリシーの予想される自由エネルギーを計算します。

198
00:07:53,580 --> 00:07:57,860
ホライズンは不可能ですが、

199
00:07:57,860 --> 00:08:00,240
これは

200
00:08:00,240 --> 00:08:02,639
IMDb で実装されている古典的な構造です それにもかかわらず、

201
00:08:02,639 --> 00:08:06,360
pi mdp にさまざまなモジュールがあり、

202
00:08:06,360 --> 00:08:10,020


203
00:08:10,020 --> 00:08:11,880


204
00:08:11,880 --> 00:08:15,000
動作のさまざまな側面を実装することを目的としているため、たとえば、推論

205
00:08:15,000 --> 00:08:17,160
または認識については、

206
00:08:17,160 --> 00:08:19,039
伝播固定点反復マージナル

207
00:08:19,039 --> 00:08:23,180
メッセージパッシングと、

208
00:08:23,180 --> 00:08:26,099


209
00:08:26,099 --> 00:08:29,819
制御モジュールの推論モジュールに実装されているすべてのものを信じています。 政策の

210
00:08:29,819 --> 00:08:32,099
期待される自由エネルギーを評価するためのさまざまな方法があります。1

211
00:08:32,099 --> 00:08:34,140
つは

212
00:08:34,140 --> 00:08:36,299
期待される効用に依存し、もう 1 つは

213
00:08:36,299 --> 00:08:38,760


214
00:08:38,760 --> 00:08:41,399
先ほど説明した古典的な方法に依存

215
00:08:41,399 --> 00:08:44,459
します。学習用のモジュールがあるので、

216
00:08:44,459 --> 00:08:46,680


217
00:08:46,680 --> 00:08:49,019
資本 a のような pom DP のパラメータを学習します。 大文字の B なので、尤度

218
00:08:49,019 --> 00:08:51,240
遷移ダイナミクスなど、そして

219
00:08:51,240 --> 00:08:53,540


220
00:08:53,540 --> 00:08:56,279
これらすべてをアルゴリズム モジュールに実装するためのアルゴリズムがあります。

221
00:08:56,279 --> 00:08:59,519
そして、

222
00:08:59,519 --> 00:09:01,620
現時点で pi mdp で最も強力なものは、

223
00:09:01,620 --> 00:09:04,080


224
00:09:04,080 --> 00:09:06,540
エージェント環境を簡単に定義できるアジア クラスです。

225
00:09:06,540 --> 00:09:08,760
ループして、

226
00:09:08,760 --> 00:09:11,459
構築しようとしています えー、今日は、

227
00:09:11,459 --> 00:09:12,959


228
00:09:12,959 --> 00:09:15,140


229
00:09:15,140 --> 00:09:17,279


230
00:09:17,279 --> 00:09:20,519
先ほど見た古典的な能動推論ではなく、洗練された

231
00:09:20,519 --> 00:09:21,660


232
00:09:21,660 --> 00:09:24,060


233
00:09:24,060 --> 00:09:26,100
推論を実装するエージェント クラスについて話します

234
00:09:26,100 --> 00:09:28,140
古典的なアクティブな影響における 15 の時間軸です、

235
00:09:28,140 --> 00:09:29,519


236
00:09:29,519 --> 00:09:31,800
そうですね、最初のポリシーはもちろん

237
00:09:31,800 --> 00:09:34,279
ジャンプです、最初のアクションのシリーズです、

238
00:09:34,279 --> 00:09:37,380
それから最後の呼び出しの最後の

239
00:09:37,380 --> 00:09:39,660
アクションを変更することができます。そして、すでに

240
00:09:39,660 --> 00:09:41,880
n があることがわかります。

241
00:09:41,880 --> 00:09:44,880
組み合わせの数と、この単純なケースの場合、

242
00:09:44,880 --> 00:09:47,220
ポリシー空間は 10 の 13 乗と同じくらい大きく、

243
00:09:47,220 --> 00:09:49,200
確率論的な問題設定では、

244
00:09:49,200 --> 00:09:52,080


245
00:09:52,080 --> 00:09:54,120
このポリシー空間の小さなサブセットを思いつく方法はありません。

246
00:09:54,120 --> 00:09:56,519
この

247
00:09:56,519 --> 00:09:59,339
計算の複雑さの問題に取り組みましょう

248
00:09:59,339 --> 00:10:01,500
そうですね、確率論的な問題の設定で述べたように、

249
00:10:01,500 --> 00:10:03,360
それは手に負えない

250
00:10:03,360 --> 00:10:06,120
サイズのポリシー空間です えー、

251
00:10:06,120 --> 00:10:09,300
高度な推論のアイデアが登場し、

252
00:10:09,300 --> 00:10:11,940
このインスタンスを別の方法で正しく解釈することを考えています。

253
00:10:11,940 --> 00:10:13,500


254
00:10:13,500 --> 00:10:15,420


255
00:10:15,420 --> 00:10:17,820
時間内の一連の行動 私たちは

256
00:10:17,820 --> 00:10:20,100
何かを見たときに何をすべきかを直接考えることができます ええと、

257
00:10:20,100 --> 00:10:21,959
現在の状態についての信念と

258
00:10:21,959 --> 00:10:23,880
将来についての信念に応じて正しくなります。つまり、

259
00:10:23,880 --> 00:10:25,680
現在の状況に自分を見た場合、

260
00:10:25,680 --> 00:10:28,080
私は何をすべきか、そしてそれはより似ています

261
00:10:28,080 --> 00:10:30,480
えー、

262
00:10:30,480 --> 00:10:33,420
行動を起こす方法と、ここで

263
00:10:33,420 --> 00:10:35,459
期待される自由エネルギーについて

264
00:10:35,459 --> 00:10:37,980
単純に考えます。 期待される自由エネルギーの構造は同じですが、

265
00:10:37,980 --> 00:10:40,320
私たちは、えー、政策の期待される自由エネルギーを評価しているのではなく、えー、

266
00:10:40,320 --> 00:10:43,440


267
00:10:43,440 --> 00:10:45,540
観察行動の組み合わせの期待される自由エネルギーを評価しています。

268
00:10:45,540 --> 00:10:48,060
何かをして、

269
00:10:48,060 --> 00:10:49,860
これを行うと予想される自由

270
00:10:49,860 --> 00:10:51,600
エネルギーは何ですか、そしてそれが私が

271
00:10:51,600 --> 00:10:56,220
最小化しようとしているものです、それが私が

272
00:10:56,220 --> 00:10:58,860
最適化しようとしているものです、この設定で正しいので、

273
00:10:58,860 --> 00:11:01,500
ここでも最小化しようとしているリスク項があります

274
00:11:01,500 --> 00:11:03,300


275
00:11:03,300 --> 00:11:05,040
信念と以前の

276
00:11:05,040 --> 00:11:07,320
好みとの間の偏差には、曖昧さ項もあります。

277
00:11:07,320 --> 00:11:10,560
これを合わせて、

278
00:11:10,560 --> 00:11:13,079
時間 T でのえーこの時点の自由エネルギーの期待値を構成します

279
00:11:13,079 --> 00:11:16,019
が、

280
00:11:16,019 --> 00:11:18,360


281
00:11:18,360 --> 00:11:20,760
次のタイム ステップでの期待される自由エネルギーがいくらになるかについての期待値もあります。 そして、

282
00:11:20,760 --> 00:11:22,680


283
00:11:22,680 --> 00:11:24,660
次のタイムステップの予想される自由エネルギーを評価するには、

284
00:11:24,660 --> 00:11:27,360
この方程式を OT プラス 2 で再度計算する必要があり、そのためには、

285
00:11:27,360 --> 00:11:29,220


286
00:11:29,220 --> 00:11:32,160
この方程式を OT プラス 3 などで再度計算する必要があり、

287
00:11:32,160 --> 00:11:34,200
これが自動的に

288
00:11:34,200 --> 00:11:36,779
研究になります。 この方程式は再帰的な方法で

289
00:11:36,779 --> 00:11:39,779
定義されており、それ

290
00:11:39,779 --> 00:11:41,220
自体に問題が伴いますが、

291
00:11:41,220 --> 00:11:44,160
それらを回避する賢い方法があります。

292
00:11:44,160 --> 00:11:46,500
それについては

293
00:11:46,500 --> 00:11:48,899
今日のコードで説明します。研究について述べたように、

294
00:11:48,899 --> 00:11:51,600
ここで洗練された推論の構造を考慮すると、

295
00:11:51,600 --> 00:11:54,060


296
00:11:54,060 --> 00:11:56,160
私たちが

297
00:11:56,160 --> 00:11:58,620
使用している追加のアクティブな影響の

298
00:11:58,620 --> 00:12:00,779
ために見た政策空間を置き換えます。この

299
00:12:00,779 --> 00:12:04,019
ワークショップで私が焦点を当てているのは、

300
00:12:04,019 --> 00:12:07,740
生成モデル

301
00:12:07,740 --> 00:12:10,980
と与えられた環境を定義する方法です。

302
00:12:10,980 --> 00:12:13,440
たとえば、これは

303
00:12:13,440 --> 00:12:16,200
刺激されるグリッドです。 元の論文でシミュレーションされており、

304
00:12:16,200 --> 00:12:19,140


305
00:12:19,140 --> 00:12:21,240


306
00:12:21,240 --> 00:12:22,740


307
00:12:22,740 --> 00:12:24,660
プライム DP モジュールの高度な推論で使用できる、このグリッドの生成モデルを構築する方法について話します。

308
00:12:24,660 --> 00:12:27,600


309
00:12:27,600 --> 00:12:29,279
つまり、基本的に私が話そうとしているのは、

310
00:12:29,279 --> 00:12:31,740
環境には、

311
00:12:31,740 --> 00:12:34,320


312
00:12:34,320 --> 00:12:37,680
pi MDB のエージェントからアクションを取得するステップ関数があり、エージェントは

313
00:12:37,680 --> 00:12:40,019
そのアクションから観察を取得します。

314
00:12:40,019 --> 00:12:42,180
この特定の関数について説明します。

315
00:12:42,180 --> 00:12:44,579
エージェント ドット ステップと

316
00:12:44,579 --> 00:12:46,860
エージェント ドット ステップがステップで取り上げます。

317
00:12:46,860 --> 00:12:49,320
観察して、

318
00:12:49,320 --> 00:12:50,760
次のタイム ステップのアクションを考え出すのをやめようとする

319
00:12:50,760 --> 00:12:55,079
と、ループが作成されます。

320
00:12:55,079 --> 00:12:58,200
このループを巧みに設計すると、

321
00:12:58,200 --> 00:13:00,240


322
00:13:00,240 --> 00:13:02,820
洗練された印刷設定で目的のある動作が現れることがわかります。

323
00:13:02,820 --> 00:13:05,339
たとえば、この特定のグリッドでは、

324
00:13:05,339 --> 00:13:06,839
十分な計画を立ててください。Horizo​​n を実行すると、

325
00:13:06,839 --> 00:13:08,639
エージェントが

326
00:13:08,639 --> 00:13:10,740
このグリッド内をナビゲートできることなどを確認できるようになります。したがって、

327
00:13:10,740 --> 00:13:12,540
これが

328
00:13:12,540 --> 00:13:16,440
今日のこの講演で焦点を当てようとしている例なので、失礼します。

329
00:13:16,440 --> 00:13:18,000


330
00:13:18,000 --> 00:13:22,339


331
00:13:25,380 --> 00:13:29,180
すぐに説明したいと思います。 コードにジャンプして、

332
00:13:29,180 --> 00:13:32,459


333
00:13:32,459 --> 00:13:36,360
pi mdp ホームを用意します。これについては

334
00:13:36,360 --> 00:13:38,639
ご存知かと思いますが、この

335
00:13:38,639 --> 00:13:41,399
GitHub リポジトリに pi

336
00:13:41,399 --> 00:13:43,079
MTP モジュール

337
00:13:43,079 --> 00:13:46,320
と内部 DP モジュールがあり、そのための

338
00:13:46,320 --> 00:13:48,480
いくつかの

339
00:13:48,480 --> 00:13:50,820
部分があるので、ここに示します

340
00:13:50,820 --> 00:13:52,980
オリジナルの Prime DP モジュールには、

341
00:13:52,980 --> 00:13:55,019
いわゆる古典的な

342
00:13:55,019 --> 00:13:57,200
アクティブ推論を実装するエージェントがあります。いくつかの

343
00:13:57,200 --> 00:13:59,760
環境があり、

344
00:13:59,760 --> 00:14:02,399
現在のマップでの学習などのヘルパー関数があるため、

345
00:14:02,399 --> 00:14:05,160
これは時間 DP のモジュールです

346
00:14:05,160 --> 00:14:09,120
が、親フォルダーにあります また、

347
00:14:09,120 --> 00:14:11,459


348
00:14:11,459 --> 00:14:14,700


349
00:14:14,700 --> 00:14:17,220
エンジン クラスの使用方法

350
00:14:17,220 --> 00:14:20,220
や環境への対処方法などについてのチュートリアルがある例もあります。

351
00:14:20,220 --> 00:14:22,620
プル リクエストを見ると、

352
00:14:22,620 --> 00:14:25,500
現在、洗練された

353
00:14:25,500 --> 00:14:27,720
推論をオリジナルの Prime DP

354
00:14:27,720 --> 00:14:29,579
モジュールにマージしようとしています。 今日は

355
00:14:29,579 --> 00:14:31,500
この完全なリクエストのコードについてお話します。そのため、

356
00:14:31,500 --> 00:14:34,320
このハンズオンを試してみたい場合は、

357
00:14:34,320 --> 00:14:36,839


358
00:14:36,839 --> 00:14:39,959
このプル リクエストがあり、

359
00:14:39,959 --> 00:14:41,760


360
00:14:41,760 --> 00:14:44,940
時間の構造が同じであるこのページに移動するとよいでしょう。  DBは

361
00:14:44,940 --> 00:14:48,420
基本的にpiondpを使用して設計されており、

362
00:14:48,420 --> 00:14:50,699
ここでさらに持っているのは、洗練された推論方法で

363
00:14:50,699 --> 00:14:53,639


364
00:14:53,639 --> 00:14:55,740
すべてを実行し、

365
00:14:55,740 --> 00:14:58,320
計画と意思決定も行う洗練されたエンタープライズエージェントであるエージェントSIです。

366
00:14:58,320 --> 00:15:00,480


367
00:15:00,480 --> 00:15:02,399
親フォルダーには、

368
00:15:02,399 --> 00:15:04,860
洗練されたサンプルフォルダーもあります

369
00:15:04,860 --> 00:15:07,620
推論のデモです。今日私がやろうとしているのは、

370
00:15:07,620 --> 00:15:09,540


371
00:15:09,540 --> 00:15:12,300
置換推論のチュートリアルを説明することです。

372
00:15:12,300 --> 00:15:14,519


373
00:15:14,519 --> 00:15:18,320
途中でヘルパー コードを参照する箇所について説明します。

374
00:15:18,320 --> 00:15:21,060


375
00:15:21,060 --> 00:15:22,740
そのコードにアクセスして試してみます。

376
00:15:22,740 --> 00:15:24,540
実際に何が起こっているのか、そしてエージェント環境をどのように完成させるのかを説明します。

377
00:15:24,540 --> 00:15:27,360


378
00:15:27,360 --> 00:15:31,860
目的のある動作を正しく確認できるループです。

379
00:15:31,860 --> 00:15:35,040
そう、これが DP の主要なホームです。その後、

380
00:15:35,040 --> 00:15:37,560
プル リクエストについても話しました。

381
00:15:37,560 --> 00:15:40,199
すぐに Jupiter ノートブックに進みましょう。

382
00:15:40,199 --> 00:15:43,680
これが私のノートです。 このリポジトリのローカル コピーな

383
00:15:43,680 --> 00:15:46,320
ので、

384
00:15:46,320 --> 00:15:47,880
実行して自分のコンピュータで表示するのが簡単です。

385
00:15:47,880 --> 00:15:50,339
これが

386
00:15:50,339 --> 00:15:53,279
pi mdp とサンプルを含むパターン フォルダーです。サンプルの内部には、

387
00:15:53,279 --> 00:15:55,440


388
00:15:55,440 --> 00:15:57,120
高度な推論のためのデモ ホルダーがあります。これが The

389
00:15:57,120 --> 00:15:59,480
Notebook I です。 正しいことを話しているので、

390
00:15:59,480 --> 00:16:02,579
この例で私たちがやろうとしていることは、

391
00:16:02,579 --> 00:16:04,760


392
00:16:04,800 --> 00:16:06,480


393
00:16:06,480 --> 00:16:08,699
元の洗練された推論論文からのこの特定のグリッドタスクを処理し

394
00:16:08,699 --> 00:16:12,480
、このエージェントを作成するか、

395
00:16:12,480 --> 00:16:14,880
このエージェントが

396
00:16:14,880 --> 00:16:17,339
おそらくゴールドステートであるこの赤い点に移動できるようにすることです

397
00:16:17,339 --> 00:16:19,860
この特定のタスクには、

398
00:16:19,860 --> 00:16:21,720
このような事前の優先設定が与えられているため、この

399
00:16:21,720 --> 00:16:24,240
高い優先設定は、

400
00:16:24,240 --> 00:16:26,760


401
00:16:26,760 --> 00:16:28,560
これが最も好ましい状態であることがわかります。

402
00:16:28,560 --> 00:16:30,420
白色とその周囲の状態は、

403
00:16:30,420 --> 00:16:33,360
やや優先度が低いですが、

404
00:16:33,360 --> 00:16:35,459
優先度よりも優先されます。 遠くのものは正しい

405
00:16:35,459 --> 00:16:37,920
ので、これは私たちが使用しようとしているグリッドワールドタスクです。

406
00:16:37,920 --> 00:16:39,120


407
00:16:39,120 --> 00:16:42,199
最初のセルは

408
00:16:42,199 --> 00:16:45,139
必要なすべてのライブラリ

409
00:16:45,139 --> 00:16:48,779
と、numpyやmatplotlibのようないくつかの便利なライブラリをインポートしています。

410
00:16:48,779 --> 00:16:51,839
そして最も重要なものは

411
00:16:51,839 --> 00:16:55,259
プライムDBです。 実際には、まだ

412
00:16:55,259 --> 00:16:57,360


413
00:16:57,360 --> 00:16:58,800


414
00:16:58,800 --> 00:17:01,740
マージされていないオリジナルの実装ではなく、洗練された推論実装を使用して Prime DB のローカル コピーを呼び出しています。

415
00:17:01,740 --> 00:17:04,439
最初に話したいのは、

416
00:17:04,439 --> 00:17:06,720
環境自体が正しいため、

417
00:17:06,720 --> 00:17:09,839
環境のドット ステップ部分で

418
00:17:09,839 --> 00:17:11,880
アクションを取得する場合です。 環境はどのように

419
00:17:11,880 --> 00:17:13,740
機能するのでしょうか。

420
00:17:13,740 --> 00:17:16,859
このフォルダー内に、

421
00:17:16,859 --> 00:17:18,839
素晴らしい環境であるファイルがあります。

422
00:17:18,839 --> 00:17:23,280
ええと SI Dot py です。これは基本的に

423
00:17:23,280 --> 00:17:25,319
環境クラスなので、

424
00:17:25,319 --> 00:17:27,299
この環境が実際にどのように

425
00:17:27,299 --> 00:17:29,340
実装されるかについては心配する必要はありません。心配するのは唯一のことです。

426
00:17:29,340 --> 00:17:31,380
about は、

427
00:17:31,380 --> 00:17:32,340


428
00:17:32,340 --> 00:17:34,919


429
00:17:34,919 --> 00:17:38,760
環境ドット ステップである、使用するこの関数です。この

430
00:17:38,760 --> 00:17:41,520
関数は、環境ドット ステップにアクションを実行し、

431
00:17:41,520 --> 00:17:43,919


432
00:17:43,919 --> 00:17:45,840
環境の現在の状態に応じて、エージェントからの

433
00:17:45,840 --> 00:17:48,900
このアクションを考慮して、最も可能性の高い次の状態を計算します。

434
00:17:48,900 --> 00:17:51,360
これがアイデアであり、

435
00:17:51,360 --> 00:17:53,880


436
00:17:53,880 --> 00:17:57,960


437
00:17:57,960 --> 00:18:00,179
目標状態でない場合は無視できる負の値の報酬も計算され、

438
00:18:00,179 --> 00:18:02,220
目標状態である場合は

439
00:18:02,220 --> 00:18:04,320
10 の報酬が与えられます。これが

440
00:18:04,320 --> 00:18:06,900
環境の設計方法であり、

441
00:18:06,900 --> 00:18:08,700
更新されます。 現在の状態を新しい

442
00:18:08,700 --> 00:18:10,500
状態に変換し、基本的に返されるものは

443
00:18:10,500 --> 00:18:13,080


444
00:18:13,080 --> 00:18:14,220
アクションに応じて新しい状態になります。

445
00:18:14,220 --> 00:18:16,080
そのアクションの報酬や、

446
00:18:16,080 --> 00:18:17,940
エピソードの終了かどうかなどです。

447
00:18:17,940 --> 00:18:20,700
この実装は

448
00:18:20,700 --> 00:18:22,500
標準の openai 環境

449
00:18:22,500 --> 00:18:24,660
実装であり、これは は、

450
00:18:24,660 --> 00:18:26,520
environment.step関数が正しいので、

451
00:18:26,520 --> 00:18:28,440
このグリッドで、

452
00:18:28,440 --> 00:18:31,320
たとえば、私が今この

453
00:18:31,320 --> 00:18:34,140
状態にいて、上にアクションを取ると、

454
00:18:34,140 --> 00:18:36,120


455
00:18:36,120 --> 00:18:38,460
北南東と西の4つの利用可能なアクションがあるので、

456
00:18:38,460 --> 00:18:41,100
北に行くと、環境ドットになります。 ステップでは、

457
00:18:41,100 --> 00:18:43,620
私がその州に関する州にいるかどうかを確認します。

458
00:18:43,620 --> 00:18:46,620
東または西に行く場合は、

459
00:18:46,620 --> 00:18:48,960
ここまたは南に滞在し、

460
00:18:48,960 --> 00:18:52,679
ここに滞在します。それがアイデアです。そう、

461
00:18:52,679 --> 00:18:54,780
エピソードの長さの制限は

462
00:18:54,780 --> 00:18:57,960
8 です。 つまり、

463
00:18:57,960 --> 00:19:00,179


464
00:19:00,179 --> 00:19:01,140


465
00:19:01,140 --> 00:19:03,179


466
00:19:03,179 --> 00:19:05,039


467
00:19:05,039 --> 00:19:06,840
混乱を避けるために、すべてのエピソードの長さを 8 に制限しています。これは、混乱を避けるために、このゴールド状態に到達するのに理想的な長さです。その

468
00:19:06,840 --> 00:19:09,179
ため、この環境では 8 回のアクションの後、

469
00:19:09,179 --> 00:19:11,059
環境は終了します。

470
00:19:11,059 --> 00:19:13,740
このルールに到達する必要がある場合は、このルールに到達する必要があります。

471
00:19:13,740 --> 00:19:16,380
最適な時点での状態です。これが、

472
00:19:16,380 --> 00:19:18,480
環境がどのように

473
00:19:18,480 --> 00:19:23,100
実装されるかというアイデアです。わかりました。それが明確であることを願っています。

474
00:19:23,100 --> 00:19:25,799


475
00:19:25,799 --> 00:19:27,780
この環境には、

476
00:19:27,780 --> 00:19:29,220


477
00:19:29,220 --> 00:19:32,100
レンダリングなどの便利な機能がたくさんあります。

478
00:19:32,100 --> 00:19:33,660
この環境では、以前の優先設定マトリックスをレンダリングする環境です。

479
00:19:33,660 --> 00:19:34,860


480
00:19:34,860 --> 00:19:36,679
優先順位の高い友人、この環境では、

481
00:19:36,679 --> 00:19:39,720
あなたの以前の好みがどのように絵で示されるかは、

482
00:19:39,720 --> 00:19:41,940


483
00:19:41,940 --> 00:19:44,039
下のノートブックに表示されます。

484
00:19:44,039 --> 00:19:46,440
それでは、今度は

485
00:19:46,440 --> 00:19:48,120
洗練された推論エージェントの生成モデルを定義します。

486
00:19:48,120 --> 00:19:50,340


487
00:19:50,340 --> 00:19:51,179


488
00:19:51,179 --> 00:19:54,020
その前に、の

489
00:19:54,720 --> 00:19:56,580
構造を定義しましょう。

490
00:19:56,580 --> 00:19:58,200
エージェントに念頭に置いてもらいたい生成モデルは、

491
00:19:58,200 --> 00:19:59,940


492
00:19:59,940 --> 00:20:01,919
この特定の

493
00:20:01,919 --> 00:20:05,120
環境に合わせて調整されているため、この

494
00:20:05,120 --> 00:20:08,580
特定のグリッド ワールド タスクには 25 の

495
00:20:08,580 --> 00:20:10,559
有効な状態があり、

496
00:20:10,559 --> 00:20:12,480
この状態から始まり、

497
00:20:12,480 --> 00:20:16,320
このパス内のこの黒い状態はすべて有効な

498
00:20:16,320 --> 00:20:18,960
状態になります 有効な州が 25 あり、

499
00:20:18,960 --> 00:20:20,700


500
00:20:20,700 --> 00:20:23,580
エージェントが北南東と西に 4 つの利用可能なアクションがある

501
00:20:23,580 --> 00:20:25,799
ため、これは生成モデルの一部であり、

502
00:20:25,799 --> 00:20:30,120


503
00:20:30,120 --> 00:20:32,700
グリッドの現実とも一致していますが、これは

504
00:20:32,700 --> 00:20:34,620
エージェントがどのような状態にあるかに関するものです。 その考えは正しけれ

505
00:20:34,620 --> 00:20:38,160
ば、その観察は単なる

506
00:20:38,160 --> 00:20:41,460
状態空間です。エージェントはそうです。

507
00:20:41,460 --> 00:20:43,200
問題は完全に観察可能であるため、

508
00:20:43,200 --> 00:20:46,020
そこに曖昧さはありません。その後、

509
00:20:46,020 --> 00:20:49,620
基本的に外国の状態の数を定義します。

510
00:20:49,620 --> 00:20:51,918


511
00:20:54,980 --> 00:20:58,080
基本的には

512
00:20:58,080 --> 00:21:00,840
状態空間のリストである状態の数です。

513
00:21:00,840 --> 00:21:03,660


514
00:21:03,660 --> 00:21:05,340
ここには熱と状態のアクターが 1 つしかないため、因子の数は 1 になります。

515
00:21:05,340 --> 00:21:07,740
次に、コントロールの数は

516
00:21:07,740 --> 00:21:10,260
4 になります。これは利用可能な

517
00:21:10,260 --> 00:21:13,440
アクションとそのような観察スペース用です。

518
00:21:13,440 --> 00:21:15,179
これが生成モデルの構造です。

519
00:21:15,179 --> 00:21:18,299


520
00:21:18,299 --> 00:21:21,840
pomdb 内のパラメーターの構造を見てください。

521
00:21:21,840 --> 00:21:24,780
最初の関数は、多くの場合

522
00:21:24,780 --> 00:21:27,120


523
00:21:27,120 --> 00:21:31,380
大文字の A で示される尤度関数

524
00:21:31,380 --> 00:21:33,240
です。ここでは、

525
00:21:33,240 --> 00:21:35,340
観測モダリティの数と

526
00:21:35,340 --> 00:21:37,799
状態モダリティの数の関数です。

527
00:21:37,799 --> 00:21:41,340
このセルを実行します はい、

528
00:21:41,340 --> 00:21:43,140


529
00:21:43,140 --> 00:21:45,600
すべてが機能することを確認するために親セルを実行

530
00:21:45,600 --> 00:21:48,900
する必要があるので、ダーティ環境を実行します うーん、

531
00:21:48,900 --> 00:21:50,280
生成モデルの構造です

532
00:21:50,280 --> 00:21:53,280
ここに、構造 25 25 を持つ大文字の A マトリックスがあります。

533
00:21:53,280 --> 00:21:56,400
これは、

534
00:21:56,400 --> 00:21:58,799
25 の州があることを意味し、 調査は 25 件あり、

535
00:21:58,799 --> 00:22:01,860
完全に観測可能であるため、

536
00:22:01,860 --> 00:22:04,020


537
00:22:04,020 --> 00:22:07,200
サイズ 25 の恒等行列として初期化しています。

538
00:22:07,200 --> 00:22:10,500
これが、

539
00:22:10,500 --> 00:22:13,260
この特定のグリッド タスク用に初期化している尤度行列です。2

540
00:22:13,260 --> 00:22:16,559
番目の要素は

541
00:22:16,559 --> 00:22:18,900
遷移行列です。そのため、

542
00:22:18,900 --> 00:22:21,240
注意してください。 既存のすべての

543
00:22:21,240 --> 00:22:24,299
時間 DB 機能を使用して

544
00:22:24,299 --> 00:22:25,679
ランダムな行列を定義し、

545
00:22:25,679 --> 00:22:28,919


546
00:22:28,919 --> 00:22:32,460
その上で恒等行列を使用しています。はい、

547
00:22:32,460 --> 00:22:35,400
ここでは何も新しいことはしていません。既存の

548
00:22:35,400 --> 00:22:38,220
時間 DB 機能です。その後、私ができることは次

549
00:22:38,220 --> 00:22:41,580
のとおりです 遷移マトリックスとも呼ばれる B マトリックスを定義します。

550
00:22:41,580 --> 00:22:43,500
これにより、

551
00:22:43,500 --> 00:22:45,960
遷移マトリックスは、

552
00:22:45,960 --> 00:22:48,000


553
00:22:48,000 --> 00:22:49,799
特定の状態から開始して

554
00:22:49,799 --> 00:22:52,440
アクションを実行した場合に将来どこに到達するかなどの遷移をエンコードします。これは、状態の

555
00:22:52,440 --> 00:22:55,320
数に依存するというアイデアです。

556
00:22:55,320 --> 00:22:56,640
状態は、隠れた状態の

557
00:22:56,640 --> 00:22:59,640
モダリティとコントロールの数であるため、

558
00:22:59,640 --> 00:23:02,159
状態アクション状態の構造を持ち、

559
00:23:02,159 --> 00:23:04,320


560
00:23:04,320 --> 00:23:05,640
特定の状態からアクションを実行した場合に

561
00:23:05,640 --> 00:23:08,340
最終的に到達するので、それは将来の状態でもあります。

562
00:23:08,340 --> 00:23:09,780


563
00:23:09,780 --> 00:23:12,980
これを真の環境状態として初期化する

564
00:23:12,980 --> 00:23:15,480
ので、これは

565
00:23:15,480 --> 00:23:17,039
私が構築した環境の一部となり、

566
00:23:17,039 --> 00:23:19,380
b マトリックスが得られます。

567
00:23:19,380 --> 00:23:21,179


568
00:23:21,179 --> 00:23:24,740
この B マトリックスの構造を見てみる価値はあるかもしれません。

569
00:23:25,380 --> 00:23:29,340
それで、ここには 25 があります。  25 4 つまり、

570
00:23:29,340 --> 00:23:32,820


571
00:23:32,820 --> 00:23:34,500
特定の状態からアクションを実行すると、

572
00:23:34,500 --> 00:23:38,220
最終的には最終的に到達することになり、設計によりこの特定のグリッドの真の遷移ダイナミクスが得られるため、

573
00:23:38,220 --> 00:23:40,140


574
00:23:40,140 --> 00:23:42,840
get Ruby と呼ばれる関数があり

575
00:23:42,840 --> 00:23:46,020
、次の結果が得られます。 私たちは、

576
00:23:46,020 --> 00:23:47,700
エージェントが

577
00:23:47,700 --> 00:23:51,000
問題なく使用できるシステムの真の B なので、理想的には

578
00:23:51,000 --> 00:23:52,919
エージェントにこれを学習してもらいたいと考えていますが、

579
00:23:52,919 --> 00:23:55,620
このデモの目的では、

580
00:23:55,620 --> 00:23:57,900
エージェントがすでに構造を知っていて

581
00:23:57,900 --> 00:24:00,960
、その後に以前のフットプリントが来ることを前提としています。

582
00:24:00,960 --> 00:24:03,840
えー、ここで興味深いのは、

583
00:24:03,840 --> 00:24:05,039


584
00:24:05,039 --> 00:24:08,280


585
00:24:08,280 --> 00:24:10,200
目標の状態にどれだけ近づいているかという意味で定義されているので、もしあなたがゴールドの状態にいる場合、

586
00:24:10,200 --> 00:24:12,720
それが

587
00:24:12,720 --> 00:24:15,539
最も求められている状態であることは明らかです。あなたが最も好むのはどのような状態ですか。

588
00:24:15,539 --> 00:24:18,840
また、どのように隣接する状態を好みますか?

589
00:24:18,840 --> 00:24:20,220
状態は正しいので、それは

590
00:24:20,220 --> 00:24:23,220
距離の平方根

591
00:24:23,220 --> 00:24:25,200
、または基本的に

592
00:24:25,200 --> 00:24:27,960
その特定の目標状態からの距離に依存する

593
00:24:27,960 --> 00:24:30,860
ため、

594
00:24:30,860 --> 00:24:34,679
この特定のグリッドタスクと同じサイズの8×8のグリッドを定義し

595
00:24:34,679 --> 00:24:39,419
、

596
00:24:39,419 --> 00:24:43,440
一種の追加メソッドがあります これは

597
00:24:43,440 --> 00:24:45,059
すべての状態に対して優先される値であり、

598
00:24:45,059 --> 00:24:48,240
特定の C マトリックスをレンダリングすると、

599
00:24:48,240 --> 00:24:49,919


600
00:24:49,919 --> 00:24:53,039
このゴールド状態が

601
00:24:53,039 --> 00:24:55,140
より優先され、周囲の

602
00:24:55,140 --> 00:24:57,780
状態があまり準備されていないなどの同じ構造がわかります。

603
00:24:57,780 --> 00:25:00,539
これで、C マトリックスが得られます。 これも

604
00:25:00,539 --> 00:25:03,419
古典的な時間の DP 方法で定義され、

605
00:25:03,419 --> 00:25:06,840
その c 行列を前のセルで評価した C 行列として初期化します。これは、

606
00:25:06,840 --> 00:25:09,299


607
00:25:09,299 --> 00:25:11,940
この特定の C 行列の小さな C です。

608
00:25:11,940 --> 00:25:13,740


609
00:25:13,740 --> 00:25:16,799
最後に、生成モデルについては、

610
00:25:16,799 --> 00:25:19,140
以前の大文字の D が得られます。

611
00:25:19,140 --> 00:25:21,000
そのために、

612
00:25:21,000 --> 00:25:23,640
均一なオブジェクト配列を使用しています。

613
00:25:23,640 --> 00:25:26,039
つまり、どこから

614
00:25:26,039 --> 00:25:29,700
開始するかという事前情報がないので、保留中のセルを実行します。そのため、

615
00:25:29,700 --> 00:25:32,120


616
00:25:32,700 --> 00:25:35,100
ここで D 行列は、隠れた状態

617
00:25:35,100 --> 00:25:37,140
全体に均一に分布しています。

618
00:25:37,140 --> 00:25:38,460
どこからシミュレーションを始めればよいのかわかりません。

619
00:25:38,460 --> 00:25:41,460
これが

620
00:25:41,460 --> 00:25:43,679
生成モデルの基本構造です。

621
00:25:43,679 --> 00:25:46,799
次に、環境と同様に個別に議論したいエージェント クラスがあります。

622
00:25:46,799 --> 00:25:48,500


623
00:25:48,500 --> 00:25:51,659


624
00:25:51,659 --> 00:25:54,600
これらの環境パラメーターを考慮すると、どうなるでしょうか。

625
00:25:54,600 --> 00:25:57,419
動作するエージェントクラスなので、

626
00:25:57,419 --> 00:25:59,880
このフォルダー構造内のエージェントクラスはどこですか

627
00:25:59,880 --> 00:26:01,260


628
00:26:01,260 --> 00:26:05,100
えー、pmdpモジュールフォルダー内に

629
00:26:05,100 --> 00:26:07,940
エージェントSIドットp yがあります。

630
00:26:07,940 --> 00:26:12,179
これも基本的にクラスであり

631
00:26:12,179 --> 00:26:14,419
、環境クラスに似ています。

632
00:26:14,419 --> 00:26:17,880
ここにもステップ関数があります。

633
00:26:17,880 --> 00:26:21,900


634
00:26:21,900 --> 00:26:25,500
関数への観測値と、オプションの環境を学習するかどうかのフラグも取得します。その

635
00:26:25,500 --> 00:26:28,020


636
00:26:28,020 --> 00:26:30,840
ため、これを無効にすると、

637
00:26:30,840 --> 00:26:33,419
生成モデルは学習されません。有効にすると、生成モデル

638
00:26:33,419 --> 00:26:35,400


639
00:26:35,400 --> 00:26:37,500
のパラメーターが更新されます。 生成モデルであり、

640
00:26:37,500 --> 00:26:39,240
基本的に行うことは、

641
00:26:39,240 --> 00:26:42,299
この時点で実行されるアクションを返し、

642
00:26:42,299 --> 00:26:44,880
環境は

643
00:26:44,880 --> 00:26:47,400
基本的にそのアクションを正しく使用できるため、

644
00:26:47,400 --> 00:26:49,080
このファイルにはエージェント クラスがあり、これについては後ほど

645
00:26:49,080 --> 00:26:51,960
詳しく説明します。

646
00:26:51,960 --> 00:26:54,960
基本的にそのエージェント

647
00:26:54,960 --> 00:26:57,740
クラスをこのセルにインポートして

648
00:26:57,740 --> 00:27:00,539
から、The Originals of State の入学論文

649
00:27:00,539 --> 00:27:03,000
からこの動作結果を再現してみます。

650
00:27:03,000 --> 00:27:05,820


651
00:27:05,820 --> 00:27:09,659
その

652
00:27:09,659 --> 00:27:12,480
ため、この

653
00:27:12,480 --> 00:27:14,760
事前優先構造を考慮すると、

654
00:27:14,760 --> 00:27:16,919
この事前パフォーマンスに局所的最大値が存在すると予想されます。

655
00:27:16,919 --> 00:27:18,539
構造なので、この

656
00:27:18,539 --> 00:27:21,419
特定の点から始めると、十分に深く計画しないと、

657
00:27:21,419 --> 00:27:24,419
最終的には、非常に好ましい観察が存在し

658
00:27:24,419 --> 00:27:26,640
ないこれらの局所的最大値の

659
00:27:26,640 --> 00:27:28,919


660
00:27:28,919 --> 00:27:31,200
1 つに行き着くでしょう。

661
00:27:31,200 --> 00:27:34,080
この特定の州にいます。

662
00:27:34,080 --> 00:27:36,539
あなたが見るのはこのローカルマキシマであり

663
00:27:36,539 --> 00:27:38,340
、そこに行って座ることになります。なぜなら、

664
00:27:38,340 --> 00:27:39,779
隣接する州はあまり

665
00:27:39,779 --> 00:27:42,059
優先されておらず、より

666
00:27:42,059 --> 00:27:43,980
優先されているこの州には世界または壁の構造のためにアクセスできないためです。

667
00:27:43,980 --> 00:27:47,279


668
00:27:47,279 --> 00:27:49,320
ターンをして、

669
00:27:49,320 --> 00:27:51,840
あまり優先されていない州を通過する場合、エージェントがそれを実行できるようにするために綿密な計画が必要です。

670
00:27:51,840 --> 00:27:54,059
エージェントは、

671
00:27:54,059 --> 00:27:56,220


672
00:27:56,220 --> 00:27:57,779


673
00:27:57,779 --> 00:28:00,360


674
00:28:00,360 --> 00:28:02,880
この非常に価値のある

675
00:28:02,880 --> 00:28:06,080
観測が到着することを確認するために、時間の 4 ステップ先をシミュレートできる必要があります。 そのようなアクションを実行する

676
00:28:06,080 --> 00:28:08,700
ので、それが

677
00:28:08,700 --> 00:28:09,720


678
00:28:09,720 --> 00:28:13,919
この特定のデモで確認しようとしている点です。つまり、

679
00:28:13,919 --> 00:28:17,220
計画の深さが低い場合、基本的に

680
00:28:17,220 --> 00:28:19,559
ローカルマキシマの1つにスタックしますが、

681
00:28:19,559 --> 00:28:21,179
十分な計画の深さがある場合は

682
00:28:21,179 --> 00:28:23,520
ゴールド状態に移動します。 それが

683
00:28:23,520 --> 00:28:25,919
私たちが正しく理解しようとしているものであり、

684
00:28:25,919 --> 00:28:28,440
さまざまなプランニング ホライズンがあり、

685
00:28:28,440 --> 00:28:31,440
基本的に行っていることは、

686
00:28:31,440 --> 00:28:34,440
エージェントに生成モデルを与えることです。このモデルでは、

687
00:28:34,440 --> 00:28:37,020
行列

688
00:28:37,020 --> 00:28:39,960
B マトリックス C マトリックス V マトリックスを定義します。その後、

689
00:28:39,960 --> 00:28:42,480
大文字 N のプランニング ホライズンが得られます。

690
00:28:42,480 --> 00:28:44,940
ここでは計画の深さを反復している

691
00:28:44,940 --> 00:28:48,000
ので、ループの n は 1、3、4 になります。

692
00:28:48,000 --> 00:28:50,580
すると、アクションの精度があり、

693
00:28:50,580 --> 00:28:53,100
アクティブな影響の文献ではアルファで示されることが多く、

694
00:28:53,100 --> 00:28:55,320


695
00:28:55,320 --> 00:28:58,080
どのアクションを実行するかを決定するため、非常に

696
00:28:58,080 --> 00:29:01,200
正確なアクションの行列になります。 これは、

697
00:29:01,200 --> 00:29:03,620


698
00:29:03,620 --> 00:29:07,080
期待される自由エネルギーが最も低く、アクセントが低い

699
00:29:07,080 --> 00:29:08,400
アクションに固執することを意味します。精度は、

700
00:29:08,400 --> 00:29:10,320


701
00:29:10,320 --> 00:29:12,480
他のアクションも考慮する一種の確率的なものです。その後、

702
00:29:12,480 --> 00:29:14,159
計画精度が得られます。これは、後で

703
00:29:14,159 --> 00:29:16,620
説明する計画機能の一部です。

704
00:29:16,620 --> 00:29:18,120
文献ではガンマとして示されている

705
00:29:18,120 --> 00:29:20,159
ので、

706
00:29:20,159 --> 00:29:21,960


707
00:29:21,960 --> 00:29:24,600
高度な推論には非常に重要な検索しきい値もあります。これは、研究

708
00:29:24,600 --> 00:29:26,880
で見たように、高度な推論は、

709
00:29:26,880 --> 00:29:28,559


710
00:29:28,559 --> 00:29:32,399


711
00:29:32,399 --> 00:29:34,740
多くの計算が必要になる可能性があるという意味で悪いものですが、

712
00:29:34,740 --> 00:29:36,480
しきい値を定義する必要があります。

713
00:29:36,480 --> 00:29:39,179
それを機能させるために多くの可能性を無視するということ

714
00:29:39,179 --> 00:29:41,159
です。それは私たちも

715
00:29:41,159 --> 00:29:44,340
議論するという考えです。それでは、

716
00:29:44,340 --> 00:29:47,820
エージェント クラスに行く前にプレビューだけしてください。

717
00:29:47,820 --> 00:29:51,480
私たちがやろうとしていることは、

718
00:29:51,480 --> 00:29:55,200
エージェント ドット ステップと呼ぶループの中にあります。

719
00:29:55,200 --> 00:29:57,240
と環境のドット ステップが連続して行われる

720
00:29:57,240 --> 00:30:00,179
ため、エージェントは観察を確認します。エージェントはアクションを

721
00:30:00,179 --> 00:30:01,559
実行します。

722
00:30:01,559 --> 00:30:03,960
そのアクションが環境に入ります。

723
00:30:03,960 --> 00:30:06,419
環境は新しい

724
00:30:06,419 --> 00:30:08,940
観察を返します。このループは継続し、

725
00:30:08,940 --> 00:30:11,600
時間の経過とともにこのループがどのように進化するかを確認したいと考えています。

726
00:30:11,600 --> 00:30:14,820
目的のある行動、

727
00:30:14,820 --> 00:30:18,419
そしてエージェントがそれができるかどうか、

728
00:30:18,419 --> 00:30:20,720
結果を明らかにする前に、

729
00:30:20,720 --> 00:30:24,480
エージェント クラスについて議論しましょう。観察が与えられた

730
00:30:24,480 --> 00:30:27,360
ときにアクションを与えるために、

731
00:30:27,360 --> 00:30:30,179
エージェントは

732
00:30:30,179 --> 00:30:33,120
適切な計画などを持っている必要があります。

733
00:30:33,120 --> 00:30:35,700
エージェント 洗練された

734
00:30:35,700 --> 00:30:38,340
推論エージェント

735
00:30:38,340 --> 00:30:40,799
ええと、実際には

736
00:30:40,799 --> 00:30:43,320
いくつかの機能に既存の Prime DB エージェントを使用しています。その

737
00:30:43,320 --> 00:30:46,320
ため、Pym DP には、

738
00:30:46,320 --> 00:30:50,580


739
00:30:50,580 --> 00:30:52,200


740
00:30:52,200 --> 00:30:55,200
知覚と学習のための非常によく書かれた関数がすでにあります。したがって、置き換えたい唯一のことは、

741
00:30:55,200 --> 00:30:57,600
エージェントは

742
00:30:57,600 --> 00:30:59,640
計画を立てており、エージェントが

743
00:30:59,640 --> 00:31:03,360
ポリシーに関してどのように意思決定を行っているかを適切に判断しているため、

744
00:31:03,360 --> 00:31:05,600


745
00:31:05,779 --> 00:31:09,419
ここではその親エージェント クラスを使用しているため、

746
00:31:09,419 --> 00:31:11,640


747
00:31:11,640 --> 00:31:14,340
dp.agent から、今議論している

748
00:31:14,340 --> 00:31:15,620


749
00:31:15,620 --> 00:31:19,500
SI エージェントの隣にあるエージェント クラスをインポートします。

750
00:31:19,500 --> 00:31:21,960


751
00:31:21,960 --> 00:31:23,279


752
00:31:23,279 --> 00:31:25,919
基本的に、

753
00:31:25,919 --> 00:31:28,679


754
00:31:28,679 --> 00:31:30,480
このクラスが機能するようにメインプログラムから生成モデル構造を取り込んでいます。

755
00:31:30,480 --> 00:31:33,299
これは a b c と d であり、私が述べたすべての

756
00:31:33,299 --> 00:31:35,460
精度としきい値パラメーター

757
00:31:35,460 --> 00:31:36,480


758
00:31:36,480 --> 00:31:39,140
です。それから、メインプログラムで述べた

759
00:31:39,140 --> 00:31:41,880
前の会議を正規化するようなものです。

760
00:31:41,880 --> 00:31:45,240


761
00:31:45,240 --> 00:31:50,220
C の

762
00:31:50,220 --> 00:31:52,620
構造が数値でどのように定義されているかを見ると、

763
00:31:52,620 --> 00:31:55,320
事前の優先順位が

764
00:31:55,320 --> 00:31:56,940
解釈されることがよくあります。または、

765
00:31:56,940 --> 00:31:58,679


766
00:31:58,679 --> 00:32:01,020
計算が正しく機能するためには確率分布である必要があるため、

767
00:32:01,020 --> 00:32:02,580


768
00:32:02,580 --> 00:32:05,460


769
00:32:05,460 --> 00:32:06,779
むしろ確率分布として正規化します。

770
00:32:06,779 --> 00:32:09,059
ええと、合計が 1 にならない数値がある

771
00:32:09,059 --> 00:32:11,340
よりも、それが起こっています。

772
00:32:11,340 --> 00:32:13,620
ここでは、ソフトマックスを使用してそれを実行しています。次に、私たちが行っていることは、

773
00:32:13,620 --> 00:32:15,600


774
00:32:15,600 --> 00:32:16,860


775
00:32:16,860 --> 00:32:20,159
既存の時間 DB エージェントをこれらの

776
00:32:20,159 --> 00:32:23,220
生成モデル パラメーターと私たちがしているもので初期化していることです。 やろうと

777
00:32:23,220 --> 00:32:27,240
しているのは、

778
00:32:27,240 --> 00:32:28,860
指定された計画期間

779
00:32:28,860 --> 00:32:32,039
と指定された UM しきい値の計画関数を 3

780
00:32:32,039 --> 00:32:35,399
秒間記述することです。わかりました。

781
00:32:35,399 --> 00:32:37,740
このエージェント クラスには 3 つの関数があります。1

782
00:32:37,740 --> 00:32:39,720
つは計画用のヘルパー関数で、

783
00:32:39,720 --> 00:32:42,240
これについてはこれから説明します。次に

784
00:32:42,240 --> 00:32:45,120
計画関数自体があります。 これは

785
00:32:45,120 --> 00:32:48,179
リサーチを使用して計画を実行します。

786
00:32:48,179 --> 00:32:50,220
そして、それは再帰的リサーチであるため、

787
00:32:50,220 --> 00:32:52,260


788
00:32:52,260 --> 00:32:54,980
その再帰的評価を実装する追加関数が必要になります。

789
00:32:54,980 --> 00:32:58,559


790
00:32:58,559 --> 00:33:00,799
この関数を

791
00:33:00,799 --> 00:33:04,200
関数自​​体の中で前方検索と呼ばれるため、

792
00:33:04,200 --> 00:33:05,700
この関数を呼び出します。 この関数の内部では、

793
00:33:05,700 --> 00:33:07,740


794
00:33:07,740 --> 00:33:09,240
次のステップの期待される自由エネルギーを計算するためのもので、

795
00:33:09,240 --> 00:33:11,279


796
00:33:11,279 --> 00:33:13,740
計画の地平線が完成するまで次のステップで再度この関数が呼び出されます。これが再帰

797
00:33:13,740 --> 00:33:16,940
ループのアイデアであり

798
00:33:16,940 --> 00:33:20,460
、最終的に

799
00:33:20,460 --> 00:33:23,460
すべてのアクションの期待される自由エネルギーを返します。 えー、所与の

800
00:33:23,460 --> 00:33:25,679
観測値が与えられたら、

801
00:33:25,679 --> 00:33:28,080
ステップ関数を実装するだけです。ここでは、発表が

802
00:33:28,080 --> 00:33:29,640
あった場合に何をするかを順番に記述します。それでは

803
00:33:29,640 --> 00:33:32,460


804
00:33:32,460 --> 00:33:37,519
デモに戻りますが、

805
00:33:38,279 --> 00:33:43,500


806
00:33:43,500 --> 00:33:46,799
観測値を取得して

807
00:33:46,799 --> 00:33:49,860
アクションを与えるという最初のアイデアがあります。 エージェントのドットステップ

808
00:33:49,860 --> 00:33:52,260
関数を使って、何が起こるかを想像してください。

809
00:33:52,260 --> 00:33:56,039
それで、それが時間 t が 0 に等しい場合、または

810
00:33:56,039 --> 00:33:59,460
実験の開始時であれば、

811
00:33:59,460 --> 00:34:01,019
最初に理想的に行うべきことは、その観察を

812
00:34:01,019 --> 00:34:03,779
使用してその状態にあるので、

813
00:34:03,779 --> 00:34:06,600
私たちはどうなるのかを想像してください。 これは

814
00:34:06,600 --> 00:34:09,899
観察であり、入口にモジュールを使用すると、状態に関する信念である

815
00:34:09,899 --> 00:34:12,899


816
00:34:12,899 --> 00:34:16,619
信念 Qs を思いつきます。

817
00:34:16,619 --> 00:34:19,560
それで、自己ドット Qs は

818
00:34:19,560 --> 00:34:23,159
エージェント内部の信念であり、エージェントが

819
00:34:23,159 --> 00:34:25,500
どこにあるかについての信念を持ったら、

820
00:34:25,500 --> 00:34:28,379
現時点では、プラン ドット リサーチを実装できます。

821
00:34:28,379 --> 00:34:31,080
これは、

822
00:34:31,080 --> 00:34:33,839
隠れ状態のこの特定の信念を

823
00:34:33,839 --> 00:34:36,359
今すぐ計画することです。計画が完了すると、

824
00:34:36,359 --> 00:34:39,239


825
00:34:39,239 --> 00:34:42,239
IMDb のサンプル アクション関数を使用して決定を下し、基本的に

826
00:34:42,239 --> 00:34:45,540
それを返します。そのアクションを返します。

827
00:34:45,540 --> 00:34:48,000
それと他のタイムステップごとに、

828
00:34:48,000 --> 00:34:50,580
シーケンスは同じままですが、

829
00:34:50,580 --> 00:34:52,139


830
00:34:52,139 --> 00:34:55,080
ホライズンクラスで学習を有効にすると、構造についても学習します。

831
00:34:55,080 --> 00:34:56,639


832
00:34:56,639 --> 00:35:01,260
これはステップ関数ですが、

833
00:35:01,260 --> 00:35:04,859
計画を行うために、それは一種

834
00:35:04,859 --> 00:35:06,599
の再編成になります。

835
00:35:06,599 --> 00:35:08,880
任意の数の熱と

836
00:35:08,880 --> 00:35:10,680
状態のモダリティ、および任意の数の

837
00:35:10,680 --> 00:35:12,240
観察モダリティの生成モデル構造です。そこで、

838
00:35:12,240 --> 00:35:16,320
融解がどのように機能するかを議論するために、

839
00:35:16,320 --> 00:35:17,760


840
00:35:17,760 --> 00:35:20,640


841
00:35:20,640 --> 00:35:22,920
その計画を実行するために評価される新しい A 行列と B 行列について話したいと思います。

842
00:35:22,920 --> 00:35:24,720


843
00:35:24,720 --> 00:35:27,780


844
00:35:27,780 --> 00:35:31,380
元の

845
00:35:31,380 --> 00:35:31,980


846
00:35:31,980 --> 00:35:34,440
隠しステート ファクターに戻りましょう。ここでは、

847
00:35:34,440 --> 00:35:36,780
隠しステート ファクターが 1 つしかありません。

848
00:35:36,780 --> 00:35:39,599
つまり、d0 が正しく、B1 は

849
00:35:39,599 --> 00:35:43,200
存在しません。なぜなら、

850
00:35:43,200 --> 00:35:45,660
隠れステート ファクターが 1 つしかないからです。ただし、

851
00:35:45,660 --> 00:35:47,880
2 つの隠しステート アクターがあると想像してください。

852
00:35:47,880 --> 00:35:50,880
同じサイズかもしれませんが、

853
00:35:50,880 --> 00:35:53,460
ここでは場所や、おそらく

854
00:35:53,460 --> 00:35:56,880
エージェントの心の中にある他のものになる可能性があります。また、

855
00:35:56,880 --> 00:35:57,660


856
00:35:57,660 --> 00:36:00,780


857
00:36:00,780 --> 00:36:05,180
これら 2 つの隠れた状態要素も同様に制御できる必要があるため、

858
00:36:05,220 --> 00:36:06,300


859
00:36:06,300 --> 00:36:08,700
すべての熱と状態要素を制御できる必要があります

860
00:36:08,700 --> 00:36:10,920
。

861
00:36:10,920 --> 00:36:13,859
能動推論の

862
00:36:13,859 --> 00:36:17,040
アイデアには精通していますが、おそらく観測

863
00:36:17,040 --> 00:36:18,540
空間も

864
00:36:18,540 --> 00:36:20,640
これら 2 つの放射率係数を直接観測している

865
00:36:20,640 --> 00:36:21,900


866
00:36:21,900 --> 00:36:24,420
ので、これは

867
00:36:24,420 --> 00:36:26,040
複数の隠れ状態

868
00:36:26,040 --> 00:36:29,579
と複数の観測モダリティを備えた新しい生成モデル構造であり、

869
00:36:29,579 --> 00:36:32,040


870
00:36:32,040 --> 00:36:33,660
パラメーターの次元が

871
00:36:33,660 --> 00:36:37,500
変化していることがすぐにわかります。  25 の隠れ状態の 25 倍から得られる 25 の観測値があり

872
00:36:37,500 --> 00:36:39,300


873
00:36:39,300 --> 00:36:43,320
、

874
00:36:43,320 --> 00:36:44,520
最初の観測モダリティの構造を見ると

875
00:36:44,520 --> 00:36:47,220
同じですが、

876
00:36:47,220 --> 00:36:49,920
私たちが必要として

877
00:36:49,920 --> 00:36:54,240
いるのは、2 つの隠れ状態ではなく

878
00:36:54,240 --> 00:36:55,920
1 つだけの隠れ状態を含む 25 になる新しい行列です。 状態間では、

879
00:36:55,920 --> 00:36:58,320


880
00:36:58,320 --> 00:37:01,440
生成モデルを再編成しただけですが、

881
00:37:01,440 --> 00:37:03,660
計算は本質的に同じままです。つまり、

882
00:37:03,660 --> 00:37:04,380


883
00:37:04,380 --> 00:37:06,900


884
00:37:06,900 --> 00:37:09,180
このヘルパー関数がやろうとしていることです。これにより、

885
00:37:09,180 --> 00:37:11,940


886
00:37:11,940 --> 00:37:13,800
複数の隠れ状態モダリティがある場合に作業が簡単になります。

887
00:37:13,800 --> 00:37:15,720


888
00:37:15,720 --> 00:37:18,180


889
00:37:18,180 --> 00:37:19,859
つまり、複数の隠れ状態モダリティがある場合

890
00:37:19,859 --> 00:37:21,060


891
00:37:21,060 --> 00:37:23,280


892
00:37:23,280 --> 00:37:25,320


893
00:37:25,320 --> 00:37:27,720


894
00:37:27,720 --> 00:37:29,760
各モダリティで書かれたステートの数を掛けた合計ステート数を計算します。つまり、

895
00:37:29,760 --> 00:37:32,280
1 つのモダリティに 25 の隠れステートがあり

896
00:37:32,280 --> 00:37:33,960
、もう 1 つのモダリティに 25 の隠れステートがある場合、

897
00:37:33,960 --> 00:37:37,380
合計 625 になることになります。

898
00:37:37,380 --> 00:37:40,079
スケールの数があり、

899
00:37:40,079 --> 00:37:43,020
各モダリティにそれぞれ 4 つのアクションがある場合、

900
00:37:43,020 --> 00:37:45,660
合計 16 のアクションがあります。これは、

901
00:37:45,660 --> 00:37:47,700


902
00:37:47,700 --> 00:37:51,119
モダリティ内のそれぞれの 4 つのアクションの組み合わせに他なりません。つまり、次の場合、

903
00:37:51,119 --> 00:37:53,220
4 の 4 の 16 アクションがあることになります。

904
00:37:53,220 --> 00:37:55,560
2 つのモダリティがあり、

905
00:37:55,560 --> 00:37:57,599
基本的には

906
00:37:57,599 --> 00:38:00,140


907
00:38:00,140 --> 00:38:03,300
同じ

908
00:38:03,300 --> 00:38:05,640
モデル パラメーターであるが、

909
00:38:05,640 --> 00:38:07,380
異なる次元構造を持つ生成モデルを構築することになります。これにより、

910
00:38:07,380 --> 00:38:09,240


911
00:38:09,240 --> 00:38:10,260
期待値の計算が容易になり、

912
00:38:10,260 --> 00:38:14,640
新しい a と新しい B

913
00:38:14,640 --> 00:38:17,520
と新しい信念が得られます。 これは

914
00:38:17,520 --> 00:38:20,880
テンソル積にほかならないので、既存のパラメータ

915
00:38:20,880 --> 00:38:23,460
と信念なので、それは新しい

916
00:38:23,460 --> 00:38:27,359
大きな行列にすぎず、他には何もありません、大丈夫です、それは

917
00:38:27,359 --> 00:38:29,820
転送ではありません、変更ではありません、それは

918
00:38:29,820 --> 00:38:32,579
単なる構造の変換です、そして

919
00:38:32,579 --> 00:38:36,420
これに b と Q が与えられると、

920
00:38:36,420 --> 00:38:38,520
何が起こっているかを予測します

921
00:38:38,520 --> 00:38:41,520
将来的に起こることと、彼らに期待される支払い

922
00:38:41,520 --> 00:38:43,680
エネルギーを評価するため、

923
00:38:43,680 --> 00:38:46,440
計画を行うために、それが

924
00:38:46,440 --> 00:38:48,060
2 番目の関数になります。

925
00:38:48,060 --> 00:38:50,760
まず、最初の関数を呼び出して、

926
00:38:50,760 --> 00:38:52,800
融解を行い、

927
00:38:52,800 --> 00:38:55,380
生成モデルをセットアップします。

928
00:38:55,380 --> 00:38:59,040
計算に適した次元 cc では、

929
00:38:59,040 --> 00:39:01,500
すべてのアクションに対する期待される自由エネルギーそのものが得られ、

930
00:39:01,500 --> 00:39:02,579


931
00:39:02,579 --> 00:39:07,040


932
00:39:07,040 --> 00:39:09,300


933
00:39:09,300 --> 00:39:11,579
これらのアクションに対するこの期待される自由エネルギーに依存する確率が得られます。では、なぜ観察ではなくアクションだけなのでしょうか。

934
00:39:11,579 --> 00:39:13,680


935
00:39:13,680 --> 00:39:16,619


936
00:39:16,619 --> 00:39:18,960
アクションの予想される自由エネルギーを評価するため

937
00:39:18,960 --> 00:39:22,140
です えー、所与の観察結果に対して、

938
00:39:22,140 --> 00:39:23,460


939
00:39:23,460 --> 00:39:26,280
えー、スライドに戻って

940
00:39:26,280 --> 00:39:29,240
、えー、

941
00:39:29,240 --> 00:39:31,920
物事を簡単にするために絵で説明しましょう。

942
00:39:31,920 --> 00:39:33,960
ここにはグリッドがあり、

943
00:39:33,960 --> 00:39:36,119
より高いフットプリントと

944
00:39:36,119 --> 00:39:38,640
実装しようとしているものがあります つまり、時間 T で何らかの観測を観測した場合、その観測を踏まえて

945
00:39:38,640 --> 00:39:41,700


946
00:39:41,700 --> 00:39:44,460
自分の行動の結果を考慮することになります。なぜなら、

947
00:39:44,460 --> 00:39:47,640


948
00:39:47,640 --> 00:39:49,980


949
00:39:49,980 --> 00:39:51,599
生成モデルには、

950
00:39:51,599 --> 00:39:53,700


951
00:39:53,700 --> 00:39:57,000
この状態が与えられた場合にそれを伝える遷移ダイナミクスがあるため、何が起こるかを予測できるからです。 私は最終的に正しい方向に進むこの行動を取る

952
00:39:57,000 --> 00:39:58,380


953
00:39:58,380 --> 00:40:00,359
ので、基本的には将来何が起こるかを予測しており、

954
00:40:00,359 --> 00:40:03,180
あなたは

955
00:40:03,180 --> 00:40:05,760
今、

956
00:40:05,760 --> 00:40:09,839
アーセナルで利用可能な行動の結果を検討しています。

957
00:40:09,839 --> 00:40:12,540
そして、行動を起こせば、次のことが可能になります。

958
00:40:12,540 --> 00:40:14,280


959
00:40:14,280 --> 00:40:16,440
新しい観測値として次のタイム ステップで何が起こるかを予測します。

960
00:40:16,440 --> 00:40:18,960
そうすると、

961
00:40:18,960 --> 00:40:20,760


962
00:40:20,760 --> 00:40:23,460
この観測値が最も可能性が高く

963
00:40:23,460 --> 00:40:25,320
、他の観測値はあまり

964
00:40:25,320 --> 00:40:27,839
可能性が高くないことがわかる確率分布が得られます。その場合、あなたが行うことは、

965
00:40:27,839 --> 00:40:30,359
あなたが行うことです。 これもまた、

966
00:40:30,359 --> 00:40:32,220


967
00:40:32,220 --> 00:40:34,740
その特定の観察に基づいて自分の行動を行った場合の結果を検討します。そして、これは

968
00:40:34,740 --> 00:40:37,440
計画の深さの中で正しく行われます。つまり、

969
00:40:37,440 --> 00:40:39,780


970
00:40:39,780 --> 00:40:42,480
ジムに行きたいと考えることができ、その後、

971
00:40:42,480 --> 00:40:44,460
すべての結果を考慮することになります。

972
00:40:44,460 --> 00:40:46,740
私が靴を履けば起こるでしょう、私が

973
00:40:46,740 --> 00:40:49,800
靴を履かなかったら、ああ、私が車に乗ったら、

974
00:40:49,800 --> 00:40:52,140
私が車に乗らなかったら、あなたは分かったでしょう、

975
00:40:52,140 --> 00:40:54,300
私は靴を履かなければなりません、そして

976
00:40:54,300 --> 00:40:56,700
あなたは私がその結果を考えるでしょう。

977
00:40:56,700 --> 00:40:59,520
私は今ジムに行く準備ができています、そして私が

978
00:40:59,520 --> 00:41:01,680
ジムに行くと

979
00:41:01,680 --> 00:41:03,660
結局私はジムにいるということになります、それは

980
00:41:03,660 --> 00:41:05,760
あなたが今いる場所の結果を考慮して、好きな

981
00:41:05,760 --> 00:41:08,760
だけ行ってもいいというような考えです、

982
00:41:08,760 --> 00:41:10,740
あなたは予測できますよね つまり、

983
00:41:10,740 --> 00:41:12,420
チェスのゲームでは、あなたは特定の状態にいるかもしれません、あなたは

984
00:41:12,420 --> 00:41:14,220
自分の結果を考慮します、あなたは

985
00:41:14,220 --> 00:41:16,440
未来が見えます、あなたは

986
00:41:16,440 --> 00:41:18,480
その未来からの結果を考慮します、

987
00:41:18,480 --> 00:41:21,660
そしてあなたは好きなだけ深く行くことができます、

988
00:41:21,660 --> 00:41:23,099


989
00:41:23,099 --> 00:41:23,700


990
00:41:23,700 --> 00:41:25,920


991
00:41:25,920 --> 00:41:27,839
ええと、あなたの計算能力に応じて、それがあなたです。

992
00:41:27,839 --> 00:41:31,740


993
00:41:31,740 --> 00:41:36,500
結果を考慮しているこのエージェント クラスに実装しようとしています

994
00:41:36,780 --> 00:41:38,880


995
00:41:38,880 --> 00:41:40,200


996
00:41:40,200 --> 00:41:42,240


997
00:41:42,240 --> 00:41:44,460


998
00:41:44,460 --> 00:41:46,859


999
00:41:46,859 --> 00:41:49,260


1000
00:41:49,260 --> 00:41:51,420


1001
00:41:51,420 --> 00:41:53,579


1002
00:41:53,579 --> 00:41:55,560


1003
00:41:55,560 --> 00:41:58,440
結果を考慮していると述べましたが、

1004
00:41:58,440 --> 00:42:00,000
前方検索では基本的に

1005
00:42:00,000 --> 00:42:04,020
すべてのアクションに対して行っているので、149行目に

1006
00:42:04,020 --> 00:42:06,119
すべてのアクションを対象とするループがあり、

1007
00:42:06,119 --> 00:42:07,140


1008
00:42:07,140 --> 00:42:08,760
その後、

1009
00:42:08,760 --> 00:42:11,640
すべてのアクションの事後結果または結果を検討します。

1010
00:42:11,640 --> 00:42:14,400


1011
00:42:14,400 --> 00:42:16,619
その結果を評価するために遷移確率を使用

1012
00:42:16,619 --> 00:42:17,880


1013
00:42:17,880 --> 00:42:19,260
します。その後、

1014
00:42:19,260 --> 00:42:21,000
私の以前の

1015
00:42:21,000 --> 00:42:23,520
好みが観測に関して定義されているため、観測を予測します。観測を

1016
00:42:23,520 --> 00:42:25,980
予測してから、

1017
00:42:25,980 --> 00:42:28,260


1018
00:42:28,260 --> 00:42:29,720


1019
00:42:29,720 --> 00:42:33,960
リスクと曖昧さの合計である期待される自由エネルギーを評価します。

1020
00:42:33,960 --> 00:42:37,320
大丈夫だと思います これは理にかなっています。ここでは

1021
00:42:37,320 --> 00:42:39,540


1022
00:42:39,540 --> 00:42:41,040


1023
00:42:41,040 --> 00:42:43,320


1024
00:42:43,320 --> 00:42:45,180
事後または事後の将来の結果である結果を考慮し

1025
00:42:45,180 --> 00:42:47,280
、基本的にその事後がどれだけ優れているかを

1026
00:42:47,280 --> 00:42:49,800


1027
00:42:49,800 --> 00:42:52,140
予想範囲に応じて評価しており、それが

1028
00:42:52,140 --> 00:42:53,880
その特定の事故で予想される自由エネルギーになります

1029
00:42:53,880 --> 00:42:56,160
。 すべてのアクションに対してこれを実行します。わかりました。

1030
00:42:56,160 --> 00:42:57,359


1031
00:42:57,359 --> 00:43:01,260
なぜこれが強力なのかという

1032
00:43:01,260 --> 00:43:03,540
と、好きなだけ深く進むことができるからです。

1033
00:43:03,540 --> 00:43:07,020
次のステップでは、この戦利品に移動して、

1034
00:43:07,020 --> 00:43:07,980


1035
00:43:07,980 --> 00:43:11,819
私が自分の深い計画や深さを超えているかどうかを確認します。

1036
00:43:11,819 --> 00:43:14,520
計画を立てる

1037
00:43:14,520 --> 00:43:16,380
と、基本的に同じことを行っていますが、

1038
00:43:16,380 --> 00:43:18,780


1039
00:43:18,780 --> 00:43:20,520


1040
00:43:20,520 --> 00:43:22,500
その事後関数のアクションの結果が何かを考慮して、

1041
00:43:22,500 --> 00:43:23,339
ここで

1042
00:43:23,339 --> 00:43:24,900
もう一度

1043
00:43:24,900 --> 00:43:28,020
親関数を呼び出していることを考慮して、

1044
00:43:28,020 --> 00:43:30,599
同じ関数を前方検索して

1045
00:43:30,599 --> 00:43:33,180
それらの組み合わせの結果を検討します。

1046
00:43:33,180 --> 00:43:34,980
それは基本的に戻ってきて、

1047
00:43:34,980 --> 00:43:37,380
予想される自由エネルギーに加算されるため、

1048
00:43:37,380 --> 00:43:40,140
このシーケンスで何が起こるかというと、

1049
00:43:40,140 --> 00:43:43,319
将来の結果の一部またはすべてを検討し、

1050
00:43:43,319 --> 00:43:46,579
その後、すべての値が

1051
00:43:46,579 --> 00:43:48,720


1052
00:43:48,720 --> 00:43:51,420
ツリーに滴り落ち、

1053
00:43:51,420 --> 00:43:53,400
予想される自由エネルギーの合計がわかります。 どの

1054
00:43:53,400 --> 00:43:55,140
アクションが良いのか、どのアクションが悪いのか、

1055
00:43:55,140 --> 00:43:56,940
それを

1056
00:43:56,940 --> 00:43:58,980
取り入れて、好みの

1057
00:43:58,980 --> 00:44:00,240
観察結果を確認することができます。

1058
00:44:00,240 --> 00:44:02,520


1059
00:44:02,520 --> 00:44:05,819


1060
00:44:05,819 --> 00:44:09,180


1061
00:44:09,180 --> 00:44:11,819
それが研究を実施するというアイデアです。また、ここでのこのしきい値の重要性についても話します。

1062
00:44:11,819 --> 00:44:13,980
アルゴリズムは可能であるため、この

1063
00:44:13,980 --> 00:44:16,140
しきい値がないと、このアルゴリズムは

1064
00:44:16,140 --> 00:44:19,200
機能しません。なぜそうなるのかについては明示的に説明します。

1065
00:44:19,200 --> 00:44:21,960


1066
00:44:21,960 --> 00:44:23,819
その後、現在の状態を考慮して

1067
00:44:23,819 --> 00:44:26,460
すべての利用可能なアクションの予想される自由エネルギーを評価すると、

1068
00:44:26,460 --> 00:44:28,800
基本的に

1069
00:44:28,800 --> 00:44:30,420


1070
00:44:30,420 --> 00:44:32,420
アクション分布と呼ばれるものを計算できます。

1071
00:44:32,420 --> 00:44:36,240
これは、私の行動の可能性がどの程度であるか、

1072
00:44:36,240 --> 00:44:37,800


1073
00:44:37,800 --> 00:44:40,740
または私の行動をどのように取るべきかということです。つまり、この行動の

1074
00:44:40,740 --> 00:44:43,560
精度パラメータであるアルファもあります。そのため、アルファが

1075
00:44:43,560 --> 00:44:46,740
非常に高い場合、基本的には

1076
00:44:46,740 --> 00:44:48,839
非常に偏った分布となり、

1077
00:44:48,839 --> 00:44:50,099


1078
00:44:50,099 --> 00:44:52,920
期待値を最小限に抑えるアクションを常に選択することになります。 自由エネルギー アルファが

1079
00:44:52,920 --> 00:44:55,800
本当に低い場合、それは

1080
00:44:55,800 --> 00:44:56,700
より

1081
00:44:56,700 --> 00:44:59,400
まばらな、または分散した分布になるでしょう。

1082
00:44:59,400 --> 00:45:00,599
そして、このアクション分布を使用して

1083
00:45:00,599 --> 00:45:02,339


1084
00:45:02,339 --> 00:45:07,200
アクションをサンプリングすることができ、アジア

1085
00:45:07,200 --> 00:45:09,720
環境のループで

1086
00:45:09,720 --> 00:45:12,180
そのアクション分布の計画と計算を完了したところです

1087
00:45:12,180 --> 00:45:14,460
次に、そのアクション分布を使用して、

1088
00:45:14,460 --> 00:45:16,980


1089
00:45:16,980 --> 00:45:19,440
ポリシー空間からアクションをサンプリングできます。

1090
00:45:19,440 --> 00:45:21,060
この生成モデルのポリシー空間を見てみましょう。

1091
00:45:21,060 --> 00:45:23,040


1092
00:45:23,040 --> 00:45:25,619
そこで、

1093
00:45:25,619 --> 00:45:27,480
1 つの隠れ状態因子を持つ元の生成モデルに戻り、

1094
00:45:27,480 --> 00:45:28,760


1095
00:45:28,760 --> 00:45:30,660


1096
00:45:30,660 --> 00:45:33,720
計画を立てて

1097
00:45:33,720 --> 00:45:35,599
、おそらく

1098
00:45:35,599 --> 00:45:38,819
このエージェントを初期化しましょう。

1099
00:45:38,819 --> 00:45:41,400


1100
00:45:41,400 --> 00:45:44,460
実行値ではなくポリシー空間を確認するためにこのエージェントを初期化したいだけなので、

1101
00:45:44,460 --> 00:45:47,000


1102
00:45:49,800 --> 00:45:52,440
このエージェントをたとえば計画の深さ 1 で初期化します。

1103
00:45:52,440 --> 00:45:56,099


1104
00:45:56,099 --> 00:45:59,300
エージェントのドット

1105
00:46:04,079 --> 00:46:05,520
ポリシーを見ると、

1106
00:46:05,520 --> 00:46:07,920
基本的に利用可能なアクションが 4 つあると言えます。

1107
00:46:07,920 --> 00:46:10,800


1108
00:46:10,800 --> 00:46:13,560
West で、アクションの分布がある場合は、

1109
00:46:13,560 --> 00:46:15,780


1110
00:46:15,780 --> 00:46:18,060
そのアクションが実行される確率がどのくらいかが表示されるので、

1111
00:46:18,060 --> 00:46:19,260


1112
00:46:19,260 --> 00:46:22,040
エージェントを

1113
00:46:23,339 --> 00:46:27,420
Pi に見てみると、わかりました。計画を立てていないため、これは定義されていませんが、計画を

1114
00:46:27,420 --> 00:46:30,540


1115
00:46:30,540 --> 00:46:32,160
立てることはできます。

1116
00:46:32,160 --> 00:46:34,578


1117
00:46:38,700 --> 00:46:41,460
はい、定義されていますので、調査を行って計画を実装しました。これで

1118
00:46:41,460 --> 00:46:43,079
アクションの

1119
00:46:43,079 --> 00:46:45,119
分布が得られました。この特定の

1120
00:46:45,119 --> 00:46:47,339
シナリオでは、3 番目の

1121
00:46:47,339 --> 00:46:48,900
アクションを最も多く実行します。

1122
00:46:48,900 --> 00:46:52,200
これは 0.99 です。基本的に、

1123
00:46:52,200 --> 00:46:54,300


1124
00:46:54,300 --> 00:46:56,099
この特定のケースでは南北と東の確率です

1125
00:46:56,099 --> 00:46:58,400
。

1126
00:46:58,400 --> 00:47:01,800
マトリックスに少し慣れてもらいたかっただけですが、

1127
00:47:01,800 --> 00:47:03,359
これから

1128
00:47:03,359 --> 00:47:05,760
エージェント環境のループの動作を見ていきます。

1129
00:47:05,760 --> 00:47:07,500


1130
00:47:07,500 --> 00:47:09,000


1131
00:47:09,000 --> 00:47:12,359


1132
00:47:12,359 --> 00:47:15,180
サンプル アクション関数からアクションをサンプリングして、

1133
00:47:15,180 --> 00:47:17,099


1134
00:47:17,099 --> 00:47:19,560
標準の Pym DP 方法を使用した学習を実装できます。 ここで

1135
00:47:19,560 --> 00:47:21,720
トランジションのダイナミクスと同等の

1136
00:47:21,720 --> 00:47:23,880
ダイナミクスを、私が見たもの

1137
00:47:23,880 --> 00:47:26,099
や私の信念などに応じて更新します。つまり、

1138
00:47:26,099 --> 00:47:31,280
意思決定の部分に重点を置いているので、

1139
00:47:38,220 --> 00:47:40,980
アクションをサンプリングすると、その

1140
00:47:40,980 --> 00:47:43,520
アクションは基本的に環境に戻ります。

1141
00:47:43,520 --> 00:47:46,940
それでは今すぐ

1142
00:47:46,940 --> 00:47:49,800
これを計画の深さ 1 で実装し

1143
00:47:49,800 --> 00:47:53,099
、エージェントがどのように動作するかを見てみましょう。

1144
00:47:53,099 --> 00:47:55,920
ここで計画の深さが 1 の場合、

1145
00:47:55,920 --> 00:47:57,960
エージェントは

1146
00:47:57,960 --> 00:47:59,760
1 回の Step Ahead の結果のみを考慮し、

1147
00:47:59,760 --> 00:48:01,920


1148
00:48:01,920 --> 00:48:05,040
計画を実行するための当面の将来だけを確認していることを意味します。 そうですね、

1149
00:48:05,040 --> 00:48:08,040
計画の深さを 1 に設定しています。

1150
00:48:08,040 --> 00:48:09,900


1151
00:48:09,900 --> 00:48:11,700
エージェントが

1152
00:48:11,700 --> 00:48:14,099
最初の開始状態から開始する環境をリセットし、

1153
00:48:14,099 --> 00:48:16,260


1154
00:48:16,260 --> 00:48:18,900
ループ内で

1155
00:48:18,900 --> 00:48:20,960


1156
00:48:22,079 --> 00:48:24,359
観察を取得し、

1157
00:48:24,359 --> 00:48:27,300
そのアクションを実行し、アクションを返します。

1158
00:48:27,300 --> 00:48:29,060
アクションの確率を見て

1159
00:48:29,060 --> 00:48:31,920
、そのアクションを

1160
00:48:31,920 --> 00:48:33,119
環境に戻して

1161
00:48:33,119 --> 00:48:35,040
観察を戻します。このループは

1162
00:48:35,040 --> 00:48:37,740
エピソードが終了するまで続きます。税金の結果を見る

1163
00:48:37,740 --> 00:48:39,780
ためだけにエピソードの長さを 8 に設定しました。

1164
00:48:39,780 --> 00:48:42,900


1165
00:48:42,900 --> 00:48:46,920
このループを実行すると、これらのマトリックスは

1166
00:48:46,920 --> 00:48:48,780


1167
00:48:48,780 --> 00:48:51,900
各アクションが実行される可能性のアクション分布に他なりません。

1168
00:48:51,900 --> 00:48:54,960
これが最後のテキストでエージェントが最終的に到達する場所です。それでは、

1169
00:48:54,960 --> 00:48:58,020


1170
00:48:58,020 --> 00:49:00,900
これを表示する環境またはレンダリングも有効にしてみましょう。

1171
00:49:00,900 --> 00:49:03,839


1172
00:49:03,839 --> 00:49:06,000
各タイムステップでエージェントがどこにいるのかというと、

1173
00:49:06,000 --> 00:49:08,880
最初はエージェントはこの場所にいて、

1174
00:49:08,880 --> 00:49:11,400


1175
00:49:11,400 --> 00:49:14,400
南東と西ではなくここでのアクション分布があるので、

1176
00:49:14,400 --> 00:49:16,440
エージェントは

1177
00:49:16,440 --> 00:49:19,260
北に行く必要があることを知っています。なぜなら、

1178
00:49:19,260 --> 00:49:21,720
事前の優先設定を見ると、

1179
00:49:21,720 --> 00:49:23,940
ええと、この状態はこの状態よりも好ましいですよね。その

1180
00:49:23,940 --> 00:49:25,800
ため、エージェントは

1181
00:49:25,800 --> 00:49:27,720
予想される自由エネルギーを正常に計算し、

1182
00:49:27,720 --> 00:49:30,540


1183
00:49:30,540 --> 00:49:33,480
この状態に留まるのではなく

1184
00:49:33,480 --> 00:49:35,220
この状態に進むべきだと推測しました。利用可能な

1185
00:49:35,220 --> 00:49:36,780
遷移の生成モデルがあるので、

1186
00:49:36,780 --> 00:49:39,060
私は次のように推測できます。

1187
00:49:39,060 --> 00:49:41,640
州に行くには北にアクションをとるべきです。

1188
00:49:41,640 --> 00:49:42,540


1189
00:49:42,540 --> 00:49:45,540
それでそれは良いことです。エージェントは北に行きます。

1190
00:49:45,540 --> 00:49:47,880
この特定の州では、

1191
00:49:47,880 --> 00:49:49,920
エージェントは北南東に行くべきだと推測します。その

1192
00:49:49,920 --> 00:49:52,800
ため、東にアクションをとり

1193
00:49:52,800 --> 00:49:53,819


1194
00:49:53,819 --> 00:49:56,460
、こことに行きます。 この

1195
00:49:56,460 --> 00:49:59,520
時点で、えー、

1196
00:49:59,520 --> 00:50:01,200
アクションの分布が

1197
00:50:01,200 --> 00:50:04,260
北と東で同じ確率であることに注目していただきたいのですが、なぜそうなるのかというと、

1198
00:50:04,260 --> 00:50:06,599
エージェントは直近の未来しか見ていないため、

1199
00:50:06,599 --> 00:50:08,640


1200
00:50:08,640 --> 00:50:09,839


1201
00:50:09,839 --> 00:50:12,599
エージェントが今ここにいる以前の優先順位に戻りましょう。

1202
00:50:12,599 --> 00:50:15,420


1203
00:50:15,420 --> 00:50:18,240
ここですか、はい、今ここに

1204
00:50:18,240 --> 00:50:20,700
この特定の状態があり、

1205
00:50:20,700 --> 00:50:22,260
エージェントが

1206
00:50:22,260 --> 00:50:25,020
1 つのアクションだけの即時的な結果を考慮している場合、

1207
00:50:25,020 --> 00:50:27,900
これら 2 つの状態は次のステップで同様に適切で

1208
00:50:27,900 --> 00:50:30,599
あるため、次の

1209
00:50:30,599 --> 00:50:33,240
場合にはこれら 2 つの状態の間に区別はありません。

1210
00:50:33,240 --> 00:50:34,680
それは目先の未来だけを見ている

1211
00:50:34,680 --> 00:50:37,260
ので、それは期待される

1212
00:50:37,260 --> 00:50:39,660
自由エネルギーが私が

1213
00:50:39,660 --> 00:50:41,460
北か東に行くべきだという結論に達することを意味します

1214
00:50:41,460 --> 00:50:43,800
1回だけを見ているのかどうかは問題ではありません 一

1215
00:50:43,800 --> 00:50:47,760
歩先を見てください、わかりました、それはアイデアであり

1216
00:50:47,760 --> 00:50:53,040
、確率の外です それはここへ行きます

1217
00:50:53,040 --> 00:50:56,640
東への行動をとり、この州から

1218
00:50:56,640 --> 00:50:57,420


1219
00:50:57,420 --> 00:50:59,220
推論するときに

1220
00:50:59,220 --> 00:51:01,740
この州の方が優れていると推論し、

1221
00:51:01,740 --> 00:51:03,780
基本的に最終的にはこの

1222
00:51:03,780 --> 00:51:06,960
ローカルなマキシマ州に行き着くのです。このローカルなマキシマ州は、

1223
00:51:06,960 --> 00:51:10,740


1224
00:51:10,740 --> 00:51:12,599
近隣の州の準備が整っていない特定の州です。

1225
00:51:12,599 --> 00:51:14,940
ここは壁であり、

1226
00:51:14,940 --> 00:51:16,980


1227
00:51:16,980 --> 00:51:19,440
構造上エージェントが禁止されているため、そこに行くことはできません。したがって、エージェントは基本的に

1228
00:51:19,440 --> 00:51:21,839
永遠にそこに留まり、

1229
00:51:21,839 --> 00:51:25,619
優先順位の高いローカル Maxima のみが表示されます

1230
00:51:25,619 --> 00:51:27,300
。より

1231
00:51:27,300 --> 00:51:30,960


1232
00:51:30,960 --> 00:51:33,839
高度な計画がある場合に何が起こるかを見てみましょう 深さなので、

1233
00:51:33,839 --> 00:51:37,800
計画の深さ 3

1234
00:51:37,800 --> 00:51:39,480
um に行く場合、

1235
00:51:39,480 --> 00:51:42,240
エージェントは実際には

1236
00:51:42,240 --> 00:51:45,599
最後のタイム ステップでゴールド ステートに到達していますが、まだ

1237
00:51:45,599 --> 00:51:46,980
3 番目のタイム ポイントでは

1238
00:51:46,980 --> 00:51:49,859


1239
00:51:49,859 --> 00:51:53,520
2 つの確率的アクションもピアニストもあったため、

1240
00:51:53,520 --> 00:51:56,700
この特定のステートからここに移動することを意味します。

1241
00:51:56,700 --> 00:51:59,880
北にアクションをとったが、

1242
00:51:59,880 --> 00:52:01,980
同じように東にアクションをとって

1243
00:52:01,980 --> 00:52:04,200
この局所最大値に到達することはできないので、

1244
00:52:04,200 --> 00:52:06,780
もう一度実行しましょう。おそらく最終的にはこの局所最大値に到達するでしょう。

1245
00:52:06,780 --> 00:52:10,260


1246
00:52:10,260 --> 00:52:12,300
計画の深さは 4 で

1247
00:52:12,300 --> 00:52:15,119
十分です。 これは

1248
00:52:15,119 --> 00:52:18,900
この特定のグリッドに必要です

1249
00:52:18,900 --> 00:52:21,599
えー、エージェントは何をすべきか完全

1250
00:52:21,599 --> 00:52:24,540
に確信しています、つまりどの時点でも何をすべきか完全に確信しています えー、北に進み、東に進み、北に進み、東に

1251
00:52:24,540 --> 00:52:28,140


1252
00:52:28,140 --> 00:52:31,559
進み、そして

1253
00:52:31,559 --> 00:52:34,500
南に進み、この特定の状態に到達する必要があることを したがって、

1254
00:52:34,500 --> 00:52:36,119
タイム ステップ

1255
00:52:36,119 --> 00:52:39,300
うーん、または計画の深さ n が 4 に等しい場合にのみ、

1256
00:52:39,300 --> 00:52:41,819
このグリッドを正常にナビゲートできます。これが、皆さんが

1257
00:52:41,819 --> 00:52:44,599


1258
00:52:44,599 --> 00:52:47,339


1259
00:52:47,339 --> 00:52:50,160
理解していただければ幸いな実装で

1260
00:52:50,160 --> 00:52:51,059
あるというアイデアです。

1261
00:52:51,059 --> 00:52:53,400
アクションの精度というアイデアもあります。

1262
00:52:53,400 --> 00:52:55,319
ここでは、高いアクションの

1263
00:52:55,319 --> 00:52:58,319
精度を示します。 なぜそれが

1264
00:52:58,319 --> 00:53:01,319
確率に基づいた行動をとるのか もし

1265
00:53:01,319 --> 00:53:03,180
それが低い行動であれば、精度が

1266
00:53:03,180 --> 00:53:05,460
1のように、

1267
00:53:05,460 --> 00:53:09,780


1268
00:53:09,780 --> 00:53:12,540
それなら良い行動の可能性がより高くなりますが、それはここで幸運によってそれが実行されるという意味ではありません、

1269
00:53:12,540 --> 00:53:16,800
それは

1270
00:53:16,800 --> 00:53:19,079
正しい行動をとっているのです 状態に到達しますが、

1271
00:53:19,079 --> 00:53:21,000
ここでは確率が最も高くなりますが、

1272
00:53:21,000 --> 00:53:23,700


1273
00:53:23,700 --> 00:53:27,059


1274
00:53:27,059 --> 00:53:29,520
このアクション プロセスを制御すると、より多くの試行回数で探索動作のような動作も表示されるため、エージェントがこの特定の目標に到達することを

1275
00:53:29,520 --> 00:53:31,859
確認するために高い値に設定しました。

1276
00:53:31,859 --> 00:53:33,780


1277
00:53:33,780 --> 00:53:36,180
問題はありますが、

1278
00:53:36,180 --> 00:53:38,760
プレイする価値はあり、重要です、わかりました、

1279
00:53:38,760 --> 00:53:40,500


1280
00:53:40,500 --> 00:53:42,180


1281
00:53:42,180 --> 00:53:42,720


1282
00:53:42,720 --> 00:53:45,480
ええと、この問題の

1283
00:53:45,480 --> 00:53:47,760
1 3 と 4 のようなさまざまな計画深さの場合、

1284
00:53:47,760 --> 00:53:49,980
これは、

1285
00:53:49,980 --> 00:53:52,740
より低い計画深さで予期される動作で

1286
00:53:52,740 --> 00:53:54,660
あり、エージェントは

1287
00:53:54,660 --> 00:53:58,140
ローカル Maximus で終了します。

1288
00:53:58,140 --> 00:54:00,420
または、 期待される自由エネルギーの局所的最小値

1289
00:54:00,420 --> 00:54:03,420
またはフライド ブループリントの局所的最大値ですが、

1290
00:54:03,420 --> 00:54:05,280
十分な計画があれば、ナビゲートして

1291
00:54:05,280 --> 00:54:08,099
目標に到達できる

1292
00:54:08,099 --> 00:54:12,180
ため、このチュートリアルの最後のポイントに進みます。

1293
00:54:12,180 --> 00:54:14,160


1294
00:54:14,160 --> 00:54:15,420


1295
00:54:15,420 --> 00:54:19,880


1296
00:54:19,880 --> 00:54:22,640


1297
00:54:22,640 --> 00:54:26,400
洗練された推論を評価する際にしきい値を設定することがなぜ重要なのかということです。

1298
00:54:26,400 --> 00:54:29,339
閾値とは、

1299
00:54:29,339 --> 00:54:31,859
将来の可能性を 2 つの

1300
00:54:31,859 --> 00:54:34,200
レベルで無視できるということです。この研究では、

1301
00:54:34,200 --> 00:54:36,900
可能性の低いアクションや可能性の低い

1302
00:54:36,900 --> 00:54:39,300
観察は無視できますが、

1303
00:54:39,300 --> 00:54:41,300


1304
00:54:41,300 --> 00:54:44,220
すべてのアクションと観察の結果を考慮する場合、

1305
00:54:44,220 --> 00:54:46,020
考慮する必要があることを意味します。

1306
00:54:46,020 --> 00:54:48,240
まず最初に 4 つの結果がある場合、

1307
00:54:48,240 --> 00:54:50,040


1308
00:54:50,040 --> 00:54:52,559
次のタイム ステップでアクションの状態を 4 倍考慮する必要があり、

1309
00:54:52,559 --> 00:54:55,140
そのすべてに

1310
00:54:55,140 --> 00:54:56,760
アクションの数が乗算され、

1311
00:54:56,760 --> 00:54:59,579
この研究は爆発するまで手に負えなくなり

1312
00:54:59,579 --> 00:55:02,400
、研究よりもさらに悪いことになります。

1313
00:55:02,400 --> 00:55:04,079
古典的な能動推論ポリシーの

1314
00:55:04,079 --> 00:55:07,140
空間問題ですが、

1315
00:55:07,140 --> 00:55:10,260
たとえ小さな値のしきい値を定義することによって、えー、可能

1316
00:55:10,260 --> 00:55:12,000
性を無視します。では、

1317
00:55:12,000 --> 00:55:15,420
それは前方検索とアルゴリズムのどこに実装されていますか。えー、

1318
00:55:15,420 --> 00:55:18,540


1319
00:55:18,540 --> 00:55:21,900
アクションを考慮しています。えー、

1320
00:55:21,900 --> 00:55:23,760


1321
00:55:23,760 --> 00:55:26,339
ここでは特定のしきい値より大きいアクションの確率のみを使用します。

1322
00:55:26,339 --> 00:55:29,280
1 x 16 として定義しています。

1323
00:55:29,280 --> 00:55:33,119
親論文でも 1 x 16 です。

1324
00:55:33,119 --> 00:55:36,240
えー、アクションの確率は

1325
00:55:36,240 --> 00:55:39,839
問題ないので、0 の場合は、将来

1326
00:55:39,839 --> 00:55:42,180
のすべての結果を考慮することを意味し、

1327
00:55:42,180 --> 00:55:46,200
対話可能であるため、

1328
00:55:46,200 --> 00:55:48,540
アクションは無視できます。 可能性が低く、

1329
00:55:48,540 --> 00:55:52,440


1330
00:55:52,440 --> 00:55:56,040
可能

1331
00:55:56,040 --> 00:55:57,780
性が低い状態を無視するか、この特定のしきい値よりも高い確率を持つ状態のみを考慮することで、

1332
00:55:57,780 --> 00:56:00,240


1333
00:56:00,240 --> 00:56:02,099
計算の複雑さが大幅に軽減され、

1334
00:56:02,099 --> 00:56:03,720


1335
00:56:03,720 --> 00:56:06,119
おそらく

1336
00:56:06,119 --> 00:56:09,540
将来のツリーに含まれる組み合わせのみを考慮することになります。

1337
00:56:09,540 --> 00:56:12,900
計画の視野をさらに深くしてください。

1338
00:56:12,900 --> 00:56:16,020
これは重要なポイントです。

1339
00:56:16,020 --> 00:56:17,400


1340
00:56:17,400 --> 00:56:18,359


1341
00:56:18,359 --> 00:56:21,619


1342
00:56:21,619 --> 00:56:24,980
検索しきい値が 0 の場合の、より深い計画にかかる時間を比較すると、

1343
00:56:24,980 --> 00:56:28,619
検索しきい値が 0 0 ということは、

1344
00:56:28,619 --> 00:56:30,780
すべての

1345
00:56:30,780 --> 00:56:33,300
結果を考慮し、

1346
00:56:33,300 --> 00:56:35,880
より深い計画を立てることを意味します。 計画を立てれば、

1347
00:56:35,880 --> 00:56:38,640
時間がかかるほど時間がかかります。

1348
00:56:38,640 --> 00:56:42,480
最初の未来または

1349
00:56:42,480 --> 00:56:44,579
当面の未来だけを考慮する場合は 0.01 秒かかり

1350
00:56:44,579 --> 00:56:45,900


1351
00:56:45,900 --> 00:56:48,720
、将来の 3 つの可能性を考慮する場合は

1352
00:56:48,720 --> 00:56:50,880
3 秒かかり、

1353
00:56:50,880 --> 00:56:53,099
4 つの可能性を検討する場合は 300 秒

1354
00:56:53,099 --> 00:56:54,960
かかります。 計算時間は指数

1355
00:56:54,960 --> 00:56:59,579
関数的に増加しますが、

1356
00:56:59,579 --> 00:57:02,819
非常に小さいしきい値検索しきい値がある場合、

1357
00:57:02,819 --> 00:57:08,280


1358
00:57:08,280 --> 00:57:11,940


1359
00:57:11,940 --> 00:57:15,420
現実世界では実装に意味のある計算時間になります。つまり、ここで n が

1360
00:57:15,420 --> 00:57:17,880
4 の場合、つまり未来への 4 つの時間ステップにすぎません。

1361
00:57:17,880 --> 00:57:20,640
0.1 秒かかりますが、それでも問題ありません。

1362
00:57:20,640 --> 00:57:22,440


1363
00:57:22,440 --> 00:57:25,440
この複雑さでもシミュレーションはできますが、

1364
00:57:25,440 --> 00:57:28,079
これが

1365
00:57:28,079 --> 00:57:29,400


1366
00:57:29,400 --> 00:57:31,020
どのようなものか、ええと実際に依存する計算の複雑さがどれほど少ないかについて話す方法はありません。えっと、

1367
00:57:31,020 --> 00:57:34,020


1368
00:57:34,020 --> 00:57:35,700
以前の設定と

1369
00:57:35,700 --> 00:57:37,980
実行中の環境の性質に依存しますが、この検索は

1370
00:57:37,980 --> 00:57:40,619
しきい値は実際に実際に機能し

1371
00:57:40,619 --> 00:57:43,140
、

1372
00:57:43,140 --> 00:57:46,559
n が 4 の場合のシミュレーションではわずか 0.3 秒しかかからなかったことがわかりましたが、

1373
00:57:46,559 --> 00:57:50,040


1374
00:57:50,040 --> 00:57:53,220
検索しきい値をゼロに設定すると、

1375
00:57:53,220 --> 00:57:55,559


1376
00:57:55,559 --> 00:57:58,880
フルステップの計画を実行するのにすでに 300 秒かかります。 そして、

1377
00:57:58,880 --> 00:58:01,800
計画の深さを 5 に設定すると、

1378
00:58:01,800 --> 00:58:04,200
基本的には永遠に実行されます。多分もう一度実行します。私は

1379
00:58:04,200 --> 00:58:06,960
公民を行うことができないので、それが

1380
00:58:06,960 --> 00:58:10,619
検索しきい値のアイデアです。ええと、

1381
00:58:10,619 --> 00:58:13,440
実際にはそれだけです。

1382
00:58:13,440 --> 00:58:16,260
ええと、

1383
00:58:16,260 --> 00:58:18,300
エージェント クラス、

1384
00:58:18,300 --> 00:58:20,520
環境クラス、および 特定の

1385
00:58:20,520 --> 00:58:24,420
デモです、ええ、聞いている人がいたら質問するのに良い時間かもしれません、

1386
00:58:24,420 --> 00:58:27,180


1387
00:58:27,180 --> 00:58:29,760
そして、人々が

1388
00:58:29,760 --> 00:58:33,359
このコードをいじって、

1389
00:58:33,359 --> 00:58:35,819
チュートリアルを見て、

1390
00:58:35,819 --> 00:58:38,280
これを実装し、

1391
00:58:38,280 --> 00:58:40,260
このような生成モデルを構築できることを願っています。この特定の

1392
00:58:40,260 --> 00:58:41,640
例は、その

1393
00:58:41,640 --> 00:58:43,920
方法です。 このグリッドタスクの生成モデルを構築して

1394
00:58:43,920 --> 00:58:45,359


1395
00:58:45,359 --> 00:58:47,640
、エージェントがどのように

1396
00:58:47,640 --> 00:58:51,839
意味のあるアクションを実行できるかを確認しますか。ここでは、

1397
00:58:51,839 --> 00:58:54,299
環境の真の構造を

1398
00:58:54,299 --> 00:58:57,000
B マトリックスやマトリックスなどで与えましたが、

1399
00:58:57,000 --> 00:59:00,299


1400
00:59:00,299 --> 00:59:03,480
学習を試してみることもできます。 これは、

1401
00:59:03,480 --> 00:59:04,740


1402
00:59:04,740 --> 00:59:09,380
エージェントのドット ステップを定義するときに、

1403
00:59:09,380 --> 00:59:14,420
学習が true に等しいことを示すフラグを追加できるという意味で、情報

1404
00:59:14,420 --> 00:59:18,059
のない a b などから開始すると、

1405
00:59:18,059 --> 00:59:20,520


1406
00:59:20,520 --> 00:59:22,380
エージェントがその環境をどのように学習しているかをここで確認できます。

1407
00:59:22,380 --> 00:59:24,420
最初の B マトリックス、

1408
00:59:24,420 --> 00:59:26,099


1409
00:59:26,099 --> 00:59:28,559
たとえば 10 回の試行後に B マトリックスを見て、

1410
00:59:28,559 --> 00:59:31,140
ここで学習がどのように行われているかを確認できます。

1411
00:59:31,140 --> 00:59:33,059
エージェントは

1412
00:59:33,059 --> 00:59:35,760
構造を知っており、あまり学習しないため問題ありませんが、

1413
00:59:35,760 --> 00:59:37,260


1414
00:59:37,260 --> 00:59:39,660
未知の構造から始まる場合は問題ありません。 それから、

1415
00:59:39,660 --> 00:59:42,180
実装すべき学習の範囲もあり、それは

1416
00:59:42,180 --> 00:59:44,640
すでに実装されています。なぜなら、AとBの学習に

1417
00:59:44,640 --> 00:59:47,700
既存の時間DP機能を使用しているからです。それは

1418
00:59:47,700 --> 00:59:50,520


1419
00:59:50,520 --> 00:59:51,960
すでにステップ関数の一部であるため、

1420
00:59:51,960 --> 00:59:52,980


1421
00:59:52,980 --> 00:59:54,780


1422
00:59:54,780 --> 00:59:57,000
ステップ関数が明確であることを願っています、

1423
00:59:57,000 --> 00:59:58,500
ええと、これが唯一のものです

1424
00:59:58,500 --> 00:59:59,819


1425
00:59:59,819 --> 01:00:02,040
洗練された推論を実装しようとしているのかどうかを知る必要があり、

1426
01:00:02,040 --> 01:00:03,839
行列を調べて調べたい場合は行列の名前だけを知る必要があります。

1427
01:00:03,839 --> 01:00:07,380


1428
01:00:07,380 --> 01:00:10,880
セッションが役に立ったことを願っています。

1429
01:00:10,880 --> 01:00:13,460
私の協力者と

1430
01:00:13,460 --> 01:00:16,140
5mdp を管理しているコーナーと

1431
01:00:16,140 --> 01:00:18,540
Brandon に感謝します。 私も参加していた主要な DP Fellowship を運営している人で、

1432
01:00:18,540 --> 01:00:21,720
そこで私は

1433
01:00:21,720 --> 01:00:23,579


1434
01:00:23,579 --> 01:00:26,599
IMDb でのソース チケット推論の実装に取り​​組みました。これは

1435
01:00:26,599 --> 01:00:30,299
すぐに元の Pi mdp モジュールの一部となる予定です。

1436
01:00:30,299 --> 01:00:32,760
人々がこのモジュールを使用して関連推論の実験をシミュレートできることを願っています。

1437
01:00:32,760 --> 01:00:34,500


1438
01:00:34,500 --> 01:00:37,680
これは基本的にそうなります。

1439
01:00:37,680 --> 01:00:39,420


1440
01:00:39,420 --> 01:00:41,579
コードに関する質問や説明について話し合う良い時期かもしれません。

1441
01:00:41,579 --> 01:00:43,559
あるいは、休憩を取るのに良い時期かもしれません。

1442
01:00:43,559 --> 01:00:46,280
はい、

1443
01:00:47,880 --> 01:00:50,640
ありがとうございます、素晴らしかったです。

1444
01:00:50,640 --> 01:00:52,799
いくつかの異なる質問があるので、次の質問を

1445
01:00:52,799 --> 01:00:55,500
いくつか読みます。

1446
01:00:55,500 --> 01:00:58,380
ライブチャットなので、まず

1447
01:00:58,380 --> 01:01:00,660
ライブチャットに行き、それから

1448
01:01:00,660 --> 01:01:02,579
それらを質問し、それから他の

1449
01:01:02,579 --> 01:01:04,980
質問をします。それでデイブは

1450
01:01:04,980 --> 01:01:06,960


1451
01:01:06,960 --> 01:01:09,839
再帰脳のニューラル実装についてどう思いますか尋ねます。

1452
01:01:09,839 --> 01:01:11,579
コンピュータハードウェア

1453
01:01:11,579 --> 01:01:13,559
スタイルの再帰はより深く実装されていないようです 高度に

1454
01:01:13,559 --> 01:01:15,660


1455
01:01:15,660 --> 01:01:18,299
過学習されたタスクを除けば、ストックの深さは 1 つであり、時間

1456
01:01:18,299 --> 01:01:20,220


1457
01:01:20,220 --> 01:01:22,619


1458
01:01:22,619 --> 01:01:24,780
的に前方を探索する適度に深い状態空間を探索する目的で再帰について尋ねることに限定できます。

1459
01:01:24,780 --> 01:01:27,119
では、この本当に美しくエレガントで、計算効率の高い完全な深さの研究をどのように調和させるかをどうすればよいでしょうか。

1460
01:01:27,119 --> 01:01:30,359


1461
01:01:30,359 --> 01:01:32,579


1462
01:01:32,579 --> 01:01:36,839


1463
01:01:36,839 --> 01:01:41,099
マルチスケール計画の生物学的基礎を使って、

1464
01:01:41,099 --> 01:01:42,540
そうですね、

1465
01:01:42,540 --> 01:01:43,260


1466
01:01:43,260 --> 01:01:45,660
私はニューラル計算の専門家ではありませんが、

1467
01:01:45,660 --> 01:01:48,420
それに対する答えは、

1468
01:01:48,420 --> 01:01:49,559


1469
01:01:49,559 --> 01:01:50,460


1470
01:01:50,460 --> 01:01:52,319
基本的には一度に 1 つの競技だけをやっているわけで、

1471
01:01:52,319 --> 01:01:55,619


1472
01:01:55,619 --> 01:01:58,140
必要なものは だけです。

1473
01:01:58,140 --> 01:02:01,740
あなたの信念を保存し、それらの信念を使用して

1474
01:02:01,740 --> 01:02:03,540
同じ計算を再度実行するためのメモリが必要です。つまり、

1475
01:02:03,540 --> 01:02:06,059


1476
01:02:06,059 --> 01:02:08,940
ニューラルについて話しているのではありません。つまり、

1477
01:02:08,940 --> 01:02:11,160
このハードコアな再帰的実装を意味します。

1478
01:02:11,160 --> 01:02:13,380


1479
01:02:13,380 --> 01:02:15,780
一度にローカル計算のみを行っており、

1480
01:02:15,780 --> 01:02:17,700
その構造のためです。 生成モデル

1481
01:02:17,700 --> 01:02:21,660
と私たち、そして私たちには記憶があるから、

1482
01:02:21,660 --> 01:02:23,819
ええと、これはできるのです

1483
01:02:23,819 --> 01:02:27,599
が、個々のニューロンがそれを行うことができないとしても、なぜ脳がそれをできないのかわかりません

1484
01:02:27,599 --> 01:02:29,520


1485
01:02:29,520 --> 01:02:32,099
主要な脳には記憶があります

1486
01:02:32,099 --> 01:02:34,319
脳が持っている 記憶を保存する能力

1487
01:02:34,319 --> 01:02:36,420
と夢を見る能力

1488
01:02:36,420 --> 01:02:39,240
シミュレーションする能力 ああ、それは行動の結果を知っていて

1489
01:02:39,240 --> 01:02:41,819
、あなたはこれを毎日行っており、

1490
01:02:41,819 --> 01:02:43,500
そこで

1491
01:02:43,500 --> 01:02:46,140
将来を計画し、何を

1492
01:02:46,140 --> 01:02:48,960
正しく行うかを決定します、つまり単一のニューロンレベルで

1493
01:02:48,960 --> 01:02:50,460
私は

1494
01:02:50,460 --> 01:02:52,559
その質問にどう答えるかよくわからないけど、

1495
01:02:52,559 --> 01:02:54,359
なぜ脳が生物としてそれができないのかよくわからない、クール、

1496
01:02:54,359 --> 01:02:57,859


1497
01:02:58,740 --> 01:03:00,839


1498
01:03:00,839 --> 01:03:03,480
うーん、コードは大丈夫だけど、いくつか

1499
01:03:03,480 --> 01:03:05,700
質問があると思うんだけど、迷路に戻ってもいいかな？

1500
01:03:05,700 --> 01:03:08,058


1501
01:03:10,740 --> 01:03:13,020
もちろん、他の誰かが

1502
01:03:13,020 --> 01:03:16,920
ライブチャットで質問がある場合は、そのまま質問してください、ええと、

1503
01:03:16,920 --> 01:03:17,640


1504
01:03:17,640 --> 01:03:21,839
迷路では、ええと、

1505
01:03:21,839 --> 01:03:24,900
可能な動きはどのように行われますか、それはどのように

1506
01:03:24,900 --> 01:03:28,200
反映されますか、どの段階で

1507
01:03:28,200 --> 01:03:31,380
更新されますか、たとえば、

1508
01:03:31,380 --> 01:03:33,480
最初にできることがわかっていることは何ですか 上に行くだけで、

1509
01:03:33,480 --> 01:03:36,000
その後は右か下に行くことしかできません。それは、

1510
01:03:36,000 --> 01:03:38,160


1511
01:03:38,160 --> 01:03:40,680


1512
01:03:40,680 --> 01:03:43,260
アフォーダンスのリレーショナルな側面のようなもので何ができるのか、

1513
01:03:43,260 --> 01:03:45,059


1514
01:03:45,059 --> 01:03:47,760
そしてそれが実行されたときにディープツリー検索でどのように評価されるのかの更新に反映されていますか？

1515
01:03:47,760 --> 01:03:49,680


1516
01:03:49,680 --> 01:03:53,819


1517
01:03:53,819 --> 01:03:56,460
将来何が起こる可能性があるのか​​、あるいは起こり得ないのかを知る必要がありますか

1518
01:03:56,460 --> 01:03:58,640


1519
01:03:59,819 --> 01:04:01,140
えっと、私が質問を正しく理解していれば、

1520
01:04:01,140 --> 01:04:02,339


1521
01:04:02,339 --> 01:04:03,000


1522
01:04:03,000 --> 01:04:05,099
インポートがあります

1523
01:04:05,099 --> 01:04:06,420
生成

1524
01:04:06,420 --> 01:04:08,880
プロセスと生成モデルの間には重要な違いがあります、

1525
01:04:08,880 --> 01:04:11,579
つまり、この素晴らしい世界では、

1526
01:04:11,579 --> 01:04:15,119
えー、どれが 生成プロセスです

1527
01:04:15,119 --> 01:04:17,160
ええと、

1528
01:04:17,160 --> 01:04:19,619
この遷移があるところではすべて手動で実装しました

1529
01:04:19,619 --> 01:04:21,540
ダイナミクス

1530
01:04:21,540 --> 01:04:22,680
ええと、

1531
01:04:22,680 --> 01:04:25,380


1532
01:04:25,380 --> 01:04:27,660
状態からアクションを実行すると何が起こるかをすでに知っているので、動作方法を知っている環境のようなものです ええと、

1533
01:04:27,660 --> 01:04:30,599


1534
01:04:30,599 --> 01:04:32,700
それは現実のようなものです

1535
01:04:32,700 --> 01:04:34,380
アクションの結果があり、それは

1536
01:04:34,380 --> 01:04:37,619
すでにそこにありますが、この情報は

1537
01:04:37,619 --> 01:04:40,680
エージェントが生成モデルの一部として利用できます。

1538
01:04:40,680 --> 01:04:43,440


1539
01:04:43,440 --> 01:04:45,240
生成モデルでは基本的に、

1540
01:04:45,240 --> 01:04:48,119


1541
01:04:48,119 --> 01:04:51,119
与えられたまたは学習された遷移ダイナミクスを使用して、何が起こるかをシミュレートします。

1542
01:04:51,119 --> 01:04:54,299
未来は大丈夫です、

1543
01:04:54,299 --> 01:04:56,460
その遷移ができたら ダイナミクス うーん、

1544
01:04:56,460 --> 01:04:58,200
ごめんなさい、

1545
01:04:58,200 --> 01:05:00,359


1546
01:05:00,359 --> 01:05:02,700
その研究に行ったら、

1547
01:05:02,700 --> 01:05:05,160
本質的にやっていることは、

1548
01:05:05,160 --> 01:05:08,640
特定の状態とアクション遺伝子を与えられた後の事後評価なので、

1549
01:05:08,640 --> 01:05:11,700
私の生成

1550
01:05:11,700 --> 01:05:14,520
モデルから、次のことがわかります。 この状態から開始して、

1551
01:05:14,520 --> 01:05:16,799
このアクションを実行すると、

1552
01:05:16,799 --> 01:05:19,680
このポストエリアに移動し、すべての結果を考慮します。

1553
01:05:19,680 --> 01:05:22,319


1554
01:05:22,319 --> 01:05:24,540
生成モデルでは、

1555
01:05:24,540 --> 01:05:27,119
東に行ってもそこには行かない可能性が低い場合など、

1556
01:05:27,119 --> 01:05:29,220
基本的には

1557
01:05:29,220 --> 01:05:31,920
自動的に実行されます。 期待される自由エネルギーに反映されている

1558
01:05:31,920 --> 01:05:33,780


1559
01:05:33,780 --> 01:05:34,319


1560
01:05:34,319 --> 01:05:37,140
ので、これで質問の答えになると思います。

1561
01:05:37,140 --> 01:05:39,980
それでは、

1562
01:05:40,020 --> 01:05:42,000
アクションの精度を高く設定し、

1563
01:05:42,000 --> 01:05:42,960


1564
01:05:42,960 --> 01:05:44,400


1565
01:05:44,400 --> 01:05:48,000


1566
01:05:48,000 --> 01:05:50,599
環境も有効にすると、

1567
01:05:50,960 --> 01:05:53,579
最初はこの特定の状態になり、

1568
01:05:53,579 --> 01:05:56,700


1569
01:05:56,700 --> 01:05:58,559
期待される自由エネルギーに関して私たちはどのようになりますか? 私がやっているのは、

1570
01:05:58,559 --> 01:06:00,960
生成モデルを使用して、

1571
01:06:00,960 --> 01:06:03,599
4 つのアクションをとった場合に何が起こるかを予測していることです。

1572
01:06:03,599 --> 01:06:06,180
私の予測では、

1573
01:06:06,180 --> 01:06:08,460
北を取ればここに行き、他の

1574
01:06:08,460 --> 01:06:10,740
すべてのアクションをとったらここに留まります。

1575
01:06:10,740 --> 01:06:12,839
優先順位は北の方が

1576
01:06:12,839 --> 01:06:15,480
優先です。私が選択すべきアクションだけではないと推測できるので、それが

1577
01:06:15,480 --> 01:06:16,680


1578
01:06:16,680 --> 01:06:19,619


1579
01:06:19,619 --> 01:06:20,640
アイデアです。

1580
01:06:20,640 --> 01:06:22,920
ここではグリッド構造がエージェントに与えられており

1581
01:06:22,920 --> 01:06:24,240
、少し

1582
01:06:24,240 --> 01:06:26,039
混乱するかもしれませんが、エージェントはスクリプトの構造を学習することもでき

1583
01:06:26,039 --> 01:06:27,780
、 これが

1584
01:06:27,780 --> 01:06:30,059
機能する場合は、エージェントとしてグリッド構造を理解したら、

1585
01:06:30,059 --> 01:06:32,339
将来をシミュレートして

1586
01:06:32,339 --> 01:06:34,920
アクションの結果を正しく検討できる

1587
01:06:34,920 --> 01:06:36,000


1588
01:06:36,000 --> 01:06:39,000
ため、それが起こっていることになり、その状態になったら、

1589
01:06:39,000 --> 01:06:40,319


1590
01:06:40,319 --> 01:06:42,780
4 つのアクションすべての結果を検討して推測します

1591
01:06:42,780 --> 01:06:44,640
わかった、

1592
01:06:44,640 --> 01:06:46,380
東に行くほうがいいよ、そうすることで

1593
01:06:46,380 --> 01:06:48,480
私はこの状態になれるから

1594
01:06:48,480 --> 01:06:50,460


1595
01:06:50,460 --> 01:06:52,319


1596
01:06:52,319 --> 01:06:54,059


1597
01:06:54,059 --> 01:06:55,619


1598
01:06:55,619 --> 01:06:58,559


1599
01:06:58,559 --> 01:07:00,240
現実は

1600
01:07:00,240 --> 01:07:03,660
あなたが何を与えるかによって決まります。

1601
01:07:03,660 --> 01:07:05,579


1602
01:07:05,579 --> 01:07:08,099
それで、

1603
01:07:08,099 --> 01:07:10,740


1604
01:07:10,740 --> 01:07:13,380


1605
01:07:13,380 --> 01:07:15,059


1606
01:07:15,059 --> 01:07:16,920
生成モデリングを実行したい新しい状況を作成しようとしている場合、

1607
01:07:16,920 --> 01:07:20,400
既存の

1608
01:07:20,400 --> 01:07:23,280
作業中の Pi mdp ノートブックから開始して

1609
01:07:23,280 --> 01:07:26,220
状態空間の変更を開始する傾向がありますか、それとも描画しますか それを

1610
01:07:26,220 --> 01:07:28,380
キャンバスに書き出してください。

1611
01:07:28,380 --> 01:07:30,000


1612
01:07:30,000 --> 01:07:32,819
ここに示されているものを複製する以外に、誰かにどのように勧めますか。正確には

1613
01:07:32,819 --> 01:07:34,079


1614
01:07:34,079 --> 01:07:37,079
単なる迷路ではないものに興味があるとしましょう。どうすればよいかを

1615
01:07:37,079 --> 01:07:42,660
理解するには

1616
01:07:42,660 --> 01:07:44,880
どうすればよいですか。

1617
01:07:44,880 --> 01:07:46,140
はい、

1618
01:07:46,140 --> 01:07:49,260
良い質問です。 たとえば

1619
01:07:49,260 --> 01:07:52,859
新しい環境をシミュレートしようとしている場合は、

1620
01:07:52,859 --> 01:07:55,680


1621
01:07:55,680 --> 01:07:57,720


1622
01:07:57,720 --> 01:07:59,280
エージェントの生成モデルを定義するという重労働をする必要があります。

1623
01:07:59,280 --> 01:08:01,260


1624
01:08:01,260 --> 01:08:02,819
エージェントが学習できるさまざまな部分の生成モデルを定義することもできます

1625
01:08:02,819 --> 01:08:05,039
が、

1626
01:08:05,039 --> 01:08:06,980
その構造を定義する必要があります。 構造がそこにあるはずで、その

1627
01:08:06,980 --> 01:08:10,140
構造を使用するだけでエージェントは

1628
01:08:10,140 --> 01:08:13,260
生成モデルを学習できるので、ここ

1629
01:08:13,260 --> 01:08:15,780
で、このコードのセルを利用して、

1630
01:08:15,780 --> 01:08:17,880


1631
01:08:17,880 --> 01:08:19,080
グリッドの構造を定義する方法を理解できます。

1632
01:08:19,080 --> 01:08:21,719
それでは、エージェントの構造を定義します。 これを

1633
01:08:21,719 --> 01:08:24,060
利用するには、

1634
01:08:24,060 --> 01:08:26,460
有効な状態が 25 個あり

1635
01:08:26,460 --> 01:08:29,339
、使用可能なアクションが 4 つあり、

1636
01:08:29,339 --> 01:08:31,920
これが時間 DB の状態空間を定義する標準的な方法であり

1637
01:08:31,920 --> 01:08:33,000


1638
01:08:33,000 --> 01:08:36,540
、エージェントの

1639
01:08:36,540 --> 01:08:40,020
中央パラメータ a b c および d も定義する必要があります。

1640
01:08:40,020 --> 01:08:42,779
刺激なので、ここでは

1641
01:08:42,779 --> 01:08:43,859


1642
01:08:43,859 --> 01:08:46,380
状態空間と

1643
01:08:46,380 --> 01:08:49,560
観察空間を使用して を定義していますが、

1644
01:08:49,560 --> 01:08:52,439
それを与えるか、それが恒等行列であることを伝えるこのステップは、

1645
01:08:52,439 --> 01:08:55,198


1646
01:08:55,198 --> 01:08:58,259
モデリングにおける私の意思決定の選択です シミュレーションではこれを行う必要はありません。

1647
01:08:58,259 --> 01:09:01,620
エージェントは

1648
01:09:01,620 --> 01:09:04,920
ランダムな行列から学習するか、

1649
01:09:04,920 --> 01:09:06,420
ランダムな画像行列から開始するとき、

1650
01:09:06,420 --> 01:09:07,198


1651
01:09:07,198 --> 01:09:10,679
この B 行列についても同様にこの

1652
01:09:10,679 --> 01:09:12,060
構造が

1653
01:09:12,060 --> 01:09:15,540
定義されており、

1654
01:09:15,540 --> 01:09:17,040
ランダムな B 行列を与えることができるこのような関数があります

1655
01:09:17,040 --> 01:09:19,080
が、これはモデリングの選択です。

1656
01:09:19,080 --> 01:09:21,600
グリッド構造を与えるか与えたくない場合は、

1657
01:09:21,600 --> 01:09:22,979


1658
01:09:22,979 --> 01:09:25,259
ランダムな B マトリックスから開始して、

1659
01:09:25,259 --> 01:09:27,420
エージェントに学習させ、

1660
01:09:27,420 --> 01:09:29,759
その学習したビームを確認します。

1661
01:09:29,759 --> 01:09:31,799
デモの目的のためだけに、

1662
01:09:31,799 --> 01:09:33,660
有効にする最大の構造を与えました。 アクションを実行するためのものです

1663
01:09:33,660 --> 01:09:36,540


1664
01:09:36,540 --> 01:09:38,880
が、これは必須ではないため、このノートブックは何をすべきかがわかるという意味では便利ですが、

1665
01:09:38,880 --> 01:09:40,679


1666
01:09:40,679 --> 01:09:42,299


1667
01:09:42,299 --> 01:09:46,198
必須ではない可能性のある手順を試してみる必要があるのは間違いありません。そのため、

1668
01:09:46,198 --> 01:09:49,140
この状態を優先的に指定すると、次のようになります。

1669
01:09:49,140 --> 01:09:51,299
最大値である場合、

1670
01:09:51,299 --> 01:09:53,520
エージェントがそこに正しく行こうとする動作がわかります。

1671
01:09:53,520 --> 01:09:55,320


1672
01:09:55,320 --> 01:09:58,860
したがって、この事前設定は、

1673
01:09:58,860 --> 01:10:00,660
これが目標状態であることと組み合わせて定義されていますが、

1674
01:10:00,660 --> 01:10:03,060
これはコールド状態ではない可能性があり、

1675
01:10:03,060 --> 01:10:05,040
別のタスクで事前

1676
01:10:05,040 --> 01:10:06,780
設定が意味するものは次のとおりです。 環境に応じて異なります、

1677
01:10:06,780 --> 01:10:08,760


1678
01:10:08,760 --> 01:10:11,100
ええと、それもそこにあり、

1679
01:10:11,100 --> 01:10:13,199
以前のものなので、一度実行する必要がある生成モデルを定義すると、

1680
01:10:13,199 --> 01:10:15,900


1681
01:10:15,900 --> 01:10:18,840
そこから実行することはできません。その後、すべてが

1682
01:10:18,840 --> 01:10:21,540
自動化されます。エージェントは、

1683
01:10:21,540 --> 01:10:22,260


1684
01:10:22,260 --> 01:10:26,699
エージェントドットを使用するだけで済みます。 ステップは、

1685
01:10:26,699 --> 01:10:28,860


1686
01:10:28,860 --> 01:10:31,080
エージェントがアクションの実行方法を知っている環境からの観察を与えてから、

1687
01:10:31,080 --> 01:10:33,600


1688
01:10:33,600 --> 01:10:36,000
エージェント内で起こるすべてのことを実際に心配する必要はありません、

1689
01:10:36,000 --> 01:10:37,500
ええと、

1690
01:10:37,500 --> 01:10:39,900
この構造は、あなた

1691
01:10:39,900 --> 01:10:42,420
の特定のタスクに役立つと確信しています

1692
01:10:42,420 --> 01:10:47,300


1693
01:10:47,460 --> 01:10:49,760


1694
01:10:51,540 --> 01:10:54,659
うーん、とても興味深いですね。

1695
01:10:54,659 --> 01:10:57,900
それをどのように対比させたいか、または、

1696
01:10:57,900 --> 01:10:59,580


1697
01:10:59,580 --> 01:11:01,560


1698
01:11:01,560 --> 01:11:03,780
誰かが迷路で

1699
01:11:03,780 --> 01:11:06,360
別の種類の深い政策

1700
01:11:06,360 --> 01:11:09,360
エージェントを使用する場合のように、これが能動的な推論の外でどのように追求されるかについて、類似点や相違点を指摘していただけますか? 例

1701
01:11:09,360 --> 01:11:11,340
ええと、プロセスのどの部分が

1702
01:11:11,340 --> 01:11:12,600
馴染みのあるもの

1703
01:11:12,600 --> 01:11:15,480
で、どの部分が予想外の多大な

1704
01:11:15,480 --> 01:11:17,340
作業になるか、または

1705
01:11:17,340 --> 01:11:18,780
多大な作業だった部分をスキップすることになります。そうでなけれ

1706
01:11:18,780 --> 01:11:20,040


1707
01:11:20,040 --> 01:11:21,780


1708
01:11:21,780 --> 01:11:24,360
ば、ええと、一般的な構造は

1709
01:11:24,360 --> 01:11:26,640
何かを行う人にとって非常によく知られています

1710
01:11:26,640 --> 01:11:30,780
強化学習ではこれと同じように、

1711
01:11:30,780 --> 01:11:33,179
エージェント ドット ステップ

1712
01:11:33,179 --> 01:11:35,699
と環境ドット ステップという考えです。これは

1713
01:11:35,699 --> 01:11:38,340


1714
01:11:38,340 --> 01:11:41,280
環境を記述する標準的なオープン AI ジムの方法であり、

1715
01:11:41,280 --> 01:11:43,800
エージェントを記述する標準的なオープン AI 方法です。

1716
01:11:43,800 --> 01:11:46,380
キュー学習がある場合は問題ありません。 えー、

1717
01:11:46,380 --> 01:11:48,780
エージェントが同じことをしてナビゲートしようとしている場合、

1718
01:11:48,780 --> 01:11:51,480


1719
01:11:51,480 --> 01:11:54,600
Q マトリックスを定義する必要があるのは重労働であり、そこでは

1720
01:11:54,600 --> 01:11:58,320
単なる状態アクションのマッピングであり、

1721
01:11:58,320 --> 01:12:00,719
アクティブ推論とは対照的に、

1722
01:12:00,719 --> 01:12:02,280


1723
01:12:02,280 --> 01:12:04,440
必要な生成モデルを考え出す必要があります。 能動

1724
01:12:04,440 --> 01:12:06,360
推論では、生成モデルが

1725
01:12:06,360 --> 01:12:08,520
中心的なものであることがわかります。生成モデルがなければ、

1726
01:12:08,520 --> 01:12:10,760


1727
01:12:10,760 --> 01:12:13,739
能動的な影響における目的のある行動の意味がありません。

1728
01:12:13,739 --> 01:12:17,460
したがって、強化学習のような分野から来た人にとって唯一の馴染みのない部分は、

1729
01:12:17,460 --> 01:12:20,159


1730
01:12:20,159 --> 01:12:21,780


1731
01:12:21,780 --> 01:12:23,760
生成モデルの構造ですが、

1732
01:12:23,760 --> 01:12:25,320


1733
01:12:25,320 --> 01:12:29,100
それが支配的な形式の DP 構造であることに慣れる以外に方法はありませんが、

1734
01:12:29,100 --> 01:12:31,020
深く

1735
01:12:31,020 --> 01:12:33,659
アクティブな推論を行う場合、これはすべて

1736
01:12:33,659 --> 01:12:36,300
ニューラルネットワークになり、パーム DPS も

1737
01:12:36,300 --> 01:12:38,400
アクティブではありません

1738
01:12:38,400 --> 01:12:40,800
うーん、物事は正しく表示されます、それは産業

1739
01:12:40,800 --> 01:12:43,380
工学のことです、それで、ポン DPS は、コンピューター サイエンスのバックグラウンドを持つ

1740
01:12:43,380 --> 01:12:45,000
人々にとってもよく知られているはずです。

1741
01:12:45,000 --> 01:12:46,020


1742
01:12:46,020 --> 01:12:49,739


1743
01:12:49,739 --> 01:12:52,140
エージェント内で実際に起こっていることは、

1744
01:12:52,140 --> 01:12:54,179


1745
01:12:54,179 --> 01:12:55,980
自由エネルギーと変分が期待される能動推論の部分であるという考えだけです。

1746
01:12:55,980 --> 01:12:57,960
フリーエネルギー、

1747
01:12:57,960 --> 01:13:00,540
それについて知りたければ、エージェントに行って、

1748
01:13:00,540 --> 01:13:03,060
それがどのように機能するのかを確認する必要があります。

1749
01:13:03,060 --> 01:13:04,620
マトリックスを数値的に見て、何が

1750
01:13:04,620 --> 01:13:07,440
起こっているのかを確認してください。しかし、私はあなたが始めたいレベルにはいませ

1751
01:13:07,440 --> 01:13:09,239
ん。

1752
01:13:09,239 --> 01:13:12,120
何か問題があれば見てください。これはすべて、

1753
01:13:12,120 --> 01:13:14,179
えーっと

1754
01:13:15,440 --> 01:13:18,600
、openai のジム環境です。エージェント

1755
01:13:18,600 --> 01:13:21,199
環境です。ループです。これは

1756
01:13:21,199 --> 01:13:23,219
コンピューター サイエンスで非常に深く議論されています。クールではありません。

1757
01:13:23,219 --> 01:13:26,239


1758
01:13:27,300 --> 01:13:30,300


1759
01:13:30,780 --> 01:13:34,219
えーっと、他にどのような

1760
01:13:34,219 --> 01:13:37,140
モチーフや認知現象に興奮していますか。

1761
01:13:37,140 --> 01:13:40,260
あるいは、円周率の mdp 開発の軌跡はどのように見えますか?

1762
01:13:40,260 --> 01:13:44,219


1763
01:13:44,219 --> 01:13:46,260
洗練された推論が

1764
01:13:46,260 --> 01:13:47,520
引き込まれた後も続ける

1765
01:13:47,520 --> 01:13:49,140


1766
01:13:49,140 --> 01:13:50,040


1767
01:13:50,040 --> 01:13:51,780
ええと、Pym DP にはオリジナルの

1768
01:13:51,780 --> 01:13:53,960
機能と、

1769
01:13:53,960 --> 01:13:56,280


1770
01:13:56,280 --> 01:13:58,980


1771
01:13:58,980 --> 01:14:00,960
ポリシー空間などを備えた一般的なアクティブ推論エージェントを実装またはシミュレートする機能があり、

1772
01:14:00,960 --> 01:14:03,860
コミュニティの多くの人々がそれを可能にしました

1773
01:14:03,860 --> 01:14:08,219


1774
01:14:08,219 --> 01:14:08,760


1775
01:14:08,760 --> 01:14:10,760


1776
01:14:10,760 --> 01:14:13,500
複雑なコーディングなどに精通していない人ではありません

1777
01:14:13,500 --> 01:14:17,219
心理学をやっている人 精神医学などすべてが

1778
01:14:17,219 --> 01:14:19,199
正しいので、

1779
01:14:19,199 --> 01:14:22,560
思いついて試してみたい人は誰でも mdp による能動推論の実装が

1780
01:14:22,560 --> 01:14:26,280
可能になり、私はそれを期待しています

1781
01:14:26,280 --> 01:14:28,500
このモジュールを使用すると、

1782
01:14:28,500 --> 01:14:30,620
試してみたい人が

1783
01:14:30,620 --> 01:14:32,820
特定のドメインで友人の実験に参加できるようになります。

1784
01:14:32,820 --> 01:14:35,820
時間をかけて

1785
01:14:35,820 --> 01:14:37,560


1786
01:14:37,560 --> 01:14:40,800
Prime DP の仕組みに慣れれば、あとは

1787
01:14:40,800 --> 01:14:43,920


1788
01:14:43,920 --> 01:14:46,800
最小限の機能で Jupiter ノートブックを書くだけです。 これをシミュレートする

1789
01:14:46,800 --> 01:14:49,980
ために適切にコードを作成してください。ドメイン内に特定のタスクがある場合は、

1790
01:14:49,980 --> 01:14:53,100


1791
01:14:53,100 --> 01:14:55,920
初心者がそれをコーディングしてみることに問題はないと思います。

1792
01:14:55,920 --> 01:14:58,199
人々が

1793
01:14:58,199 --> 01:15:01,080
このモジュールをさまざまな実験に使用しているのを見るのがとても楽しみです

1794
01:15:01,080 --> 01:15:03,480
人々が

1795
01:15:03,480 --> 01:15:05,699
pi mdp を使い始めて洗練された

1796
01:15:05,699 --> 01:15:08,659
推論が普及し始めたのと同じように、それが能動推論を行う方法であるということが今では

1797
01:15:08,659 --> 01:15:12,840
広く話題になっています。

1798
01:15:12,840 --> 01:15:15,719


1799
01:15:15,719 --> 01:15:17,820
私は、

1800
01:15:17,820 --> 01:15:20,340
さまざまな分野の人々がこのモジュールを使い始めて、その成果を

1801
01:15:20,340 --> 01:15:22,320
見てほしいと心から願っています。 実験

1802
01:15:22,320 --> 01:15:24,480
とフィードを楽しみにしています

1803
01:15:24,480 --> 01:15:27,540
はい、IMDb が 2 年前に行ったことと同じことです。

1804
01:15:27,540 --> 01:15:29,460
このモジュールがスープ状態

1805
01:15:29,460 --> 01:15:32,580
でアクティブな入力をモデル化しようとしている人々に役立つことを願っています。

1806
01:15:32,580 --> 01:15:34,940


1807
01:15:34,980 --> 01:15:39,179


1808
01:15:39,179 --> 01:15:41,520
それで、オープン AI ジムと標準化された形式について言及しました。 どのような

1809
01:15:41,520 --> 01:15:45,420
ベンチマークを使用していますか、またはあなたは何ですか、

1810
01:15:45,420 --> 01:15:47,640
どのような種類のテストスイートを

1811
01:15:47,640 --> 01:15:49,140
比較していますか、そして

1812
01:15:49,140 --> 01:15:51,900


1813
01:15:51,900 --> 01:15:54,960


1814
01:15:54,960 --> 01:15:58,739


1815
01:15:58,739 --> 01:16:00,239
他の

1816
01:16:00,239 --> 01:16:03,540
手法では実現できない方法で本当に上回っている、または優れている生成モデルを作成したことを

1817
01:16:03,540 --> 01:16:05,880
どのようにして本当に知ることができますか？

1818
01:16:05,880 --> 01:16:10,140
えー、オープン AI ジムの Web サイトに行ってみます

1819
01:16:10,140 --> 01:16:12,179
えー、そこにはいくつかの実験があります えー、

1820
01:16:12,179 --> 01:16:13,739
古典的な償還学習の

1821
01:16:13,739 --> 01:16:15,120
例があります えー、

1822
01:16:15,120 --> 01:16:16,980


1823
01:16:16,980 --> 01:16:19,679
今この画面に表示されている月着陸船のようなもので、アクティブな

1824
01:16:19,679 --> 01:16:22,320
推論が可能です インセプションは、タスクに合わせて

1825
01:16:22,320 --> 01:16:24,960
スケールするという問題に直面してきました。

1826
01:16:24,960 --> 01:16:27,600
それ

1827
01:16:27,600 --> 01:16:29,340
自体がアクティブな

1828
01:16:29,340 --> 01:16:30,360
推論、

1829
01:16:30,360 --> 01:16:32,040
アクティブな入力のスケーリングの研究分野であり、それが

1830
01:16:32,040 --> 01:16:34,260
ディープアクティブ推論が

1831
01:16:34,260 --> 01:16:35,820


1832
01:16:35,820 --> 01:16:38,100
このようなタスクの処理を引き継いだ理由の 1 つであるため、

1833
01:16:38,100 --> 01:16:39,659


1834
01:16:39,659 --> 01:16:42,239
洗練された

1835
01:16:42,239 --> 01:16:43,920
推論では処理できない可能性のあるベンチマークが現在でも存在します。

1836
01:16:43,920 --> 01:16:46,020
状態空間と個人的には、それが

1837
01:16:46,020 --> 01:16:48,480
私の博士課程での研究です。私は実際、高度な推論

1838
01:16:48,480 --> 01:16:49,860


1839
01:16:49,860 --> 01:16:52,620
における計算の最適化を検討しています。

1840
01:16:52,620 --> 01:16:54,600


1841
01:16:54,600 --> 01:16:57,239


1842
01:16:57,239 --> 01:16:59,699
そのような 2 つの環境をスケールアップできるアルゴリズムを検討しています。しかし、始めるには、

1843
01:16:59,699 --> 01:17:02,280


1844
01:17:02,280 --> 01:17:04,199
コードを書いてそれが機能するかどうかを確認する必要があります。 ある

1845
01:17:04,199 --> 01:17:07,679
環境についてそれが

1846
01:17:07,679 --> 01:17:09,659
機能していないかどうかを確認し、

1847
01:17:09,659 --> 01:17:12,659
それをスケールアップするためのメソッド ワードを確認する必要がある、というように、

1848
01:17:12,659 --> 01:17:14,699


1849
01:17:14,699 --> 01:17:16,860
洗練されたベンチマークと

1850
01:17:16,860 --> 01:17:19,080
他の RL アルゴリズムと同じくらい優れたプリンセスについて話しているのであれば、

1851
01:17:19,080 --> 01:17:21,840
この状態空間では、小規模な環境では

1852
01:17:21,840 --> 01:17:23,460
どのゲート入口が

1853
01:17:23,460 --> 01:17:26,580
機能するかという問題は非常に良いですが、

1854
01:17:26,580 --> 01:17:29,100
このような高次元の問題の場合は、

1855
01:17:29,100 --> 01:17:31,020


1856
01:17:31,020 --> 01:17:33,239
先ほど示した古典的な実装は機能しない可能性がありますが、

1857
01:17:33,239 --> 01:17:36,120
まともな実験には十分ですが、

1858
01:17:36,120 --> 01:17:38,040
スケールアップしたい場合はまだ

1859
01:17:38,040 --> 01:17:40,199
オープンです。 新しい研究分野であり、

1860
01:17:40,199 --> 01:17:43,040
あなたの研究が次の新しい

1861
01:17:43,040 --> 01:17:46,020
重要な論文になるかもしれないので、その点に関して私に言えるのはこれだけです。

1862
01:17:46,020 --> 01:17:49,520


1863
01:17:49,940 --> 01:17:52,260


1864
01:17:52,260 --> 01:17:53,580


1865
01:17:53,580 --> 01:17:54,840


1866
01:17:54,840 --> 01:17:57,960
計算リソースなど、どのような手段を探していると思いますか、

1867
01:17:57,960 --> 01:18:00,000
あるいはそれを可能にする手段は何ですか

1868
01:18:00,000 --> 01:18:04,020
このような異なるメソッドを並べるのはセンスが

1869
01:18:04,020 --> 01:18:09,120
あり、オープン AI ジムは

1870
01:18:09,120 --> 01:18:12,600
さまざまなアルゴリズムを比較するために設計されているので、

1871
01:18:12,600 --> 01:18:15,900
オープン想像してみてください、定義上、

1872
01:18:15,900 --> 01:18:18,179
多くの環境のコレクションであるため、私の

1873
01:18:18,179 --> 01:18:19,620
デモではグリッド環境について話していましたが、

1874
01:18:19,620 --> 01:18:22,440
オープン iigm は単なる

1875
01:18:22,440 --> 01:18:24,719
多くの環境のコレクションで、

1876
01:18:24,719 --> 01:18:26,460


1877
01:18:26,460 --> 01:18:29,360


1878
01:18:29,360 --> 01:18:31,980
environment.step 関数を使用してそれらの環境と対話できるようになります。

1879
01:18:31,980 --> 01:18:32,699


1880
01:18:32,699 --> 01:18:34,500
ええと、ここには

1881
01:18:34,500 --> 01:18:36,719


1882
01:18:36,719 --> 01:18:39,060
月着陸船と対話できるenvironment.step 関数があり、

1883
01:18:39,060 --> 01:18:42,120
その特定のタスクには、ええと判断できるマトリックスがあります。

1884
01:18:42,120 --> 01:18:44,040


1885
01:18:44,040 --> 01:18:46,500
アルゴリズムがどの程度良いか悪いか、

1886
01:18:46,500 --> 01:18:50,100
この月着陸船の問題では、

1887
01:18:50,100 --> 01:18:52,080


1888
01:18:52,080 --> 01:18:54,659


1889
01:18:54,659 --> 01:18:57,900
燃料を最小限に抑えるなどして、どのように最適にローバーをこれら 2 つの旗の間に着陸させることができるか、これらの

1890
01:18:57,900 --> 01:19:01,920
行列は非常にタスクに特化したものであり、

1891
01:19:01,920 --> 01:19:03,780
それが取るべき 1 つの方向です。

1892
01:19:03,780 --> 01:19:07,679
ええと、マトリックスで RL アルゴリズムと競合してみてください。

1893
01:19:07,679 --> 01:19:10,739
でも、

1894
01:19:10,739 --> 01:19:12,960
適切な可能性、または

1895
01:19:12,960 --> 01:19:16,080
高度な推論における潜在的な IC、

1896
01:19:16,080 --> 01:19:19,020
インテリジェントな動作をモデリングします。RL では、

1897
01:19:19,020 --> 01:19:21,300
これを機能させるために物事を成し遂げることに重点が置かれていますが

1898
01:19:21,300 --> 01:19:23,340
、

1899
01:19:23,340 --> 01:19:25,679
特に D 並列学習と深層学習では説明がつきません。

1900
01:19:25,679 --> 01:19:27,719
しかし、能動推論では、

1901
01:19:27,719 --> 01:19:29,159
スケールアップすることができれば

1902
01:19:29,159 --> 01:19:31,620
説明可能であり、

1903
01:19:31,620 --> 01:19:33,719


1904
01:19:33,719 --> 01:19:36,540
時間の経過とともにどのようにインテリジェンスが現れるかを理解できるようになります。RL と

1905
01:19:36,540 --> 01:19:39,300


1906
01:19:39,300 --> 01:19:41,340
競争するよりもその方が興味深いと思います。なぜなら、

1907
01:19:41,340 --> 01:19:44,219
物事を成し遂げることに焦点を当てているのであれば、 おそらく

1908
01:19:44,219 --> 01:19:46,320
エンジニアリングが正しい方法であり、

1909
01:19:46,320 --> 01:19:49,460
有効な保険ではありません えーっと、

1910
01:19:50,699 --> 01:19:55,219
その他のコメントや考えは

1911
01:20:02,159 --> 01:20:04,199
ありますか オスマン、他にコメントや

1912
01:20:04,199 --> 01:20:05,340
考えは

1913
01:20:05,340 --> 01:20:09,300


1914
01:20:09,300 --> 01:20:10,980
ありますか いいえ、私はかなり満足しています

1915
01:20:10,980 --> 01:20:13,020


1916
01:20:13,020 --> 01:20:14,400
あなたのレベルは

1917
01:20:14,400 --> 01:20:16,380
そうですが、これを使い始めてコードを書く人が少なくとも 1 人いるのに役立つことを願っています。

1918
01:20:16,380 --> 01:20:19,080


1919
01:20:19,080 --> 01:20:21,179


1920
01:20:21,179 --> 01:20:23,520
時間を割いていただきありがとうございます。素晴らしい

1921
01:20:23,520 --> 01:20:25,440
機会をありがとうございます。

1922
01:20:25,440 --> 01:20:28,080
次回まで参加していただきありがとうございます。またお会いしましょう。

1923
01:20:28,080 --> 01:20:29,159


1924
01:20:29,159 --> 01:20:32,780
ありがとうございました さようなら、また

1925
01:20:37,860 --> 01:20:40,639


1926
01:20:45,060 --> 01:20:48,320


1927
01:20:48,780 --> 01:20:52,219
会えるまで韓国へご挨拶

