
00:06 _Daniel:_
[[start:6010][end:6570]] Greetings.

00:06 _Bert:_
[[start:6650][end:10954]] All right, well, our next session. Hey, Bert.
[[start:11002][end:11898]] Greetings.
[[start:12074][end:12414]] Great.
[[start:12452][end:13102]] Hey, how you doing?

00:13 [[start:13156][end:13790]] Good, good.

00:13 _Dmitry:_
[[start:13860][end:14718]] Very well.

00:14 _Daniel:_
[[start:14884][end:20106]] Our next session is with Bert DeVries, Dmitri Bagaev, and Bart Van Erp.
[[start:20218][end:25246]] It's going to be called towards User Friendly Design of Synthetic Active inference agents.
[[start:25428][end:31910]] And I know a lot of people are super excited to see this really practical and cutting edge work.

00:31 [[start:31980][end:35560]] So to you, Bert, and just let us know how we can support.

00:36 _Bert:_
[[start:36570][end:37720]] Okay, great.
[[start:38650][end:39926]] Is my audio good?

00:40 _Daniel:_
[[start:40028][end:41434]] Yep, sounds good.

00:41 _Bert:_
[[start:41632][end:44300]] Okay, then I'm going to share my screen.

00:46 [[start:46430][end:48042]] I hope I picked the right one.
[[start:48096][end:50826]] I don't work with zoom quite often.
[[start:51008][end:51866]] Looks good.
[[start:51968][end:52522]] Looks good.
[[start:52576][end:52854]] Yeah.

00:52 [[start:52912][end:53502]] All right.
[[start:53636][end:54320]] Super.
[[start:55250][end:59514]] Well, thanks a lot, Daniel, for hosting this symposium.
[[start:59562][end:60986]] I've been watching some talks.
[[start:61018][end:62094]] It's really amazing.

01:02 [[start:62292][end:66830]] And we feel privileged to get a chance to present ourselves.
[[start:66990][end:73410]] So we are also, just like a few others before us, interested in developing a toolbox for active inference.
[[start:73830][end:81574]] And so this picture, or she kind of shows what we're about or what we are interested in.
[[start:81692][end:88898]] So here's a lady on the left hand side, and I'm going to try to get a laser pointer.
[[start:88994][end:95194]] And she has this idea about a rewarding behavior for a vacuum cleaning robot, right?

01:35 [[start:95232][end:98438]] So she's writing down she has a textual expression.
[[start:98614][end:105902]] Move around the apartment, apply suction until the floor is clean, do not touch objects, and when done, return to the dog.

01:45 [[start:105956][end:107422]] So that's not so hard.
[[start:107476][end:114880]] I'm going to rate that with one star out of three stars in terms of difficulty level to specify that.
[[start:115670][end:118722]] But that's not enough to program this robot, right?

01:58 [[start:118776][end:129650]] Because what she really needs to do now is to specify a generative model and there's effectors and actuators, right.
[[start:129720][end:134582]] The robot has to move around, apply suction until the floor is clean.
[[start:134636][end:136870]] So there are sensors, probably a camera.
[[start:137370][end:138866]] Do not touch objects.
[[start:138898][end:141102]] Or maybe there has to be object recognition.

02:21 [[start:141266][end:146666]] This is a really difficult task to come up with this generative model here.
[[start:146768][end:156830]] And on top of that, she has to specify this kind of rewarding behavior in terms now of probability distributions of this generative model.
[[start:156900][end:158494]] So very difficult.
[[start:158612][end:174930]] I'm going to rate that with two stars because the next thing she has to do for this model is to specify the inference procedure to do actually active inference and free energy minimization in real time for this complex model.

02:55 [[start:175000][end:177442]] And really that's almost impossible, right?

02:57 [[start:177496][end:187078]] Only a few specialists can really write a procedure for variational free energy minimization in some very difficult model.
[[start:187244][end:193426]] So what we are about what we've been working on is to try to automate the inference task.
[[start:193458][end:195302]] So get rid of the three stars.
[[start:195446][end:202554]] And yes, she will still have to specify her model, but in the long term, we try to get away from that.
[[start:202592][end:205786]] So in the long term, we hope we will get a toolbox.

03:25 [[start:205818][end:229490]] And now we're talking 510 years, right, where a textual description would be enough to specify some initial model with an initial prior and everything else is just automated inference, learning of states, parameters, structural adaptation of the model, even maybe based on her feedback updating the prior.
[[start:229650][end:238306]] So that's long term for now, we would be very happy if we could just automate the inference task.

03:58 [[start:238498][end:244218]] So why is it so difficult to specify inference for an active inference agent?
[[start:244304][end:249500]] Well, we have so many competing KPIs, right?
[[start:250110][end:261390]] We want to do this for large model scopes, not just for ABCD models, but maybe there's also continuous variables and hierarchical models, right?

04:21 [[start:261460][end:263450]] It must be very user friendly.
[[start:263610][end:268740]] We really don't want her to worry about robustness of her code.
[[start:269350][end:278874]] We don't want her to worry about whether two variables have conjugate relationships adaptivity.
[[start:278942][end:282006]] We want to update states, parameters, maybe even the model.
[[start:282108][end:298134]] The model structure has to be low power because these ancients often run on edge devices, so they run on their battery powered has to be in real time because you can't learn how to ride a bike if there's no real time reasoning.

04:58 [[start:298262][end:302586]] And on top of that, you actually want to minimize variational frequency, right?

05:02 [[start:302608][end:307930]] You want to do it at least as good or at least in a neighborhood of if you would do a manual derivation.
[[start:308010][end:311694]] And some of these decidorata bite each other, right?
[[start:311732][end:320962]] If you want to minimize variational free energy, but you have to do it in real time and on low power that kind of bites each other, right?
[[start:321016][end:328966]] So these are difficult KPIs that they're all important.

05:29 [[start:329068][end:334440]] You can't just take one out because then the whole system wouldn't work.
[[start:335130][end:350358]] So when you read papers on active inference, you often also read and now we implement variation of minimization and that can be done by message passing on a graph.
[[start:350454][end:356670]] And I want to clarify first why it has to be done by message passing on the graph.
[[start:357010][end:361294]] I do that by giving a very short answer and then do an example.
[[start:361412][end:373474]] The short answer is that Bayesian inference involves computing very large sum of products, like what you see here on the left hand side.

06:13 [[start:373592][end:380274]] Here's a product AC, ADBC, and then we sum them AC plus ad and so forth.
[[start:380322][end:381846]] This is a sum of products.
[[start:382028][end:391160]] Now, we know by the Distributive law that this here on the left hand side can also be computed as on the right hand side.
[[start:391610][end:395766]] If I multiply this out, I get a times C plus a times D and so forth.
[[start:395878][end:400714]] This is a product of sums and they're exactly the same thing.

06:40 [[start:400912][end:410026]] The only difference is that to compute the left hand side takes four additions sorry, four multiplications and three additions.
[[start:410138][end:415270]] To compute the right hand side takes two additions and only one multiplication.
[[start:415450][end:420994]] So on the right hand side is much cheaper to compute than the left hand side.
[[start:421192][end:438434]] Normally when we write down marginalization and Beijing inference, we write things down as in the left hand side what message passing does on the graph, it will automatically convert that into much cheaper to evaluate product of sums.

07:18 [[start:438562][end:441420]] And I'll give an example of that.

07:23 [[start:443470][end:450650]] So here is an example model F of seven variables x one, x two through x seven.
[[start:450800][end:457642]] And this model happens to be factorized FA of x one, FB, x two and so forth.
[[start:457786][end:462186]] Now, we can draw this factorization as a graph.
[[start:462378][end:471086]] And what we do, and this is called a Farney style factor graph, what we do is for each factor FA, we allocate a node.
[[start:471118][end:474526]] So FB gets a node and FC gets a node.

07:54 [[start:474718][end:479170]] And we associate the variables in our system with the edge.
[[start:479330][end:485158]] And an edge is connected to a node if that variable is an argument of that function.
[[start:485244][end:491142]] So FC is a function of x one, x two, x three.
[[start:491276][end:499530]] And that means that FC connects to the edges x one, x two, x three, and FD is only a function of x four.

08:19 [[start:499600][end:503510]] So FD only connects to the edge x four.

08:23 [[start:503680][end:514400]] So what you can see in this graph is this graph is nothing but a visualization of the factorization assumptions that we have for this model.
[[start:515350][end:530440]] Now, if I'm interested in a big marginalization task and I integrate out over all variables but x three, so x one, x two, x four and so forth through x seven, I'm interested in this.
[[start:531290][end:551834]] Then taking advantage of this factorization, I can rewrite basically this sum of product into a product of sums as below here, what you will see here below this computes exactly the same thing.
[[start:551872][end:554670]] But I've made use of this distributive law.
[[start:554820][end:560766]] For instance, FC contains no x four, no x five.

09:20 [[start:560868][end:564270]] So I moved it over the summation sign to the left.
[[start:564420][end:569858]] And FB also doesn't contain x four, x five, x six, seven.
[[start:569944][end:572100]] So I moved it all the way to the left.
[[start:572550][end:587462]] And when you do that, you are left here with an expression where I only sum over two variables and here I have to sum over six variables and here over two, and here over two.
[[start:587596][end:602778]] So you can imagine if each variable, let's say x one, x two, if each variable has ten interesting values that you need to sum over, then I have here the original marginalization problem.

10:02 [[start:602864][end:613902]] I have ten to the power six, so a million terms, and here in red I have 100 terms and here I have 100 and here I have 100.
[[start:613956][end:618418]] So here I have 300 terms and here I have 1 million terms.
[[start:618584][end:629014]] So it's an enormous reduction in computational complexity when we make use of this distributive law.

10:29 [[start:629132][end:638722]] Now, it turns out that if you write this out, you can associate these intermediate factors with messages on the graph.
[[start:638786][end:641862]] It's just an interpretation, a visual interpretation.

10:42 [[start:642006][end:656894]] It's as if FC receives a message from FA and FB receive or FC receives a message from FB and computes an outgoing message MU x three.
[[start:657012][end:658686]] And the same thing for Fe.
[[start:658788][end:669138]] So Fe receives a message from its neighboring factors, FD and FF and computes an outgoing message, x three.
[[start:669304][end:683880]] So what you see here is that the entire marginalization process can be represented as basically computing a few messages on a graph and multiplying some of these messages with each other.
[[start:684650][end:690478]] And that's how you can do Bayesian inference and also how you can do variational free energy minimization.

11:30 [[start:690674][end:706410]] So this works in factorized models, but I would say even stronger if your model is not factorized and you have a lot of variables, there is just no way you can do proper inference.
[[start:706490][end:714042]] So any serious model is factorized, like the brain is almost sparse, is almost empty.
[[start:714106][end:720574]] We have, what is it, about 10 billion neurons, and each neuron connects to a few thousand other neurons.
[[start:720622][end:726366]] So if I would draw the graph, that graph is almost empty, it is hugely sparse.
[[start:726478][end:731590]] And so there is no other way to do inference in the brain than by message passing.

12:12 [[start:732170][end:737000]] So that's why message passing, just because it's more effective than anything else.
[[start:738650][end:742822]] Now then the issue is which message do you compute?
[[start:742886][end:744810]] How do you compute messages?
[[start:745550][end:748874]] Because there are different ways of doing it right.
[[start:748912][end:761774]] And we also read in active inference papers, you can do this by variational message passing, or expectation maximization, or belief propagation and variational LaPlace and all these terms.

12:41 [[start:761972][end:768830]] It turns out that there is an umbrella framework for all these methods passing frameworks.
[[start:768910][end:774686]] And that umbrella framework is called Constraint better free energy minimization.
[[start:774878][end:781430]] And I will try to illustrate it by this slide.
[[start:781850][end:784050]] So here I have this graph.
[[start:784130][end:796426]] This is just an example graph where my generative model is basically factorized in FA, FB, FC, FD and Fe.

13:16 [[start:796608][end:798362]] And I've also written that here.
[[start:798416][end:800940]] So this now is the variational free energy.
[[start:801710][end:805422]] Now, I haven't made any assumption on Q of X.
[[start:805476][end:808894]] So Q of X is still Q of x one, x two, x three.
[[start:808932][end:814910]] It's just a joint overall variables and it doesn't have any factorization assumption.

13:35 [[start:815910][end:825602]] It makes sense to also assume that the posterior kind of follows the factorization assumption of the prior, namely of the generative model.

13:45 [[start:825736][end:842854]] So if we make that assumption and that means we're going to make the assumption that QX is also now a product of QAS of X of A, where QAS of X of A stands for beliefs over nodes.
[[start:842902][end:854986]] What I mean by that is that Q of B is a posterior belief over this node, meaning it's a posterior belief over the edges that connect to this node.
[[start:855098][end:873890]] Just like FB is a function of x one, x two, x four, that's if you will, the prior or the generative model, then Q of B, the variational posterior for this node will also depend on x one, x two, x four, and on no other factors.
[[start:874470][end:886498]] If you just do that, then you will count some of the variables double because x one is part of the belief over FA, but also part of the belief over FB.

14:46 [[start:886674][end:892806]] So we just have to discount that by dividing by beliefs over edges.
[[start:892998][end:908910]] That means that I make now an assumption that my posterior beliefs is divided into local beliefs over notes and local beliefs over edges over variables.
[[start:909570][end:911994]] This will make things a lot simpler.
[[start:912042][end:926450]] In fact, if my graph is a tree and I did the tree here, and I would do message passing on that tree and I could suppose I could do that perfectly, everything is linear gaussian, then I get perfect Bayesian inference.
[[start:927030][end:928514]] There is no approximation.

15:28 [[start:928562][end:930386]] So this is a good assumption.
[[start:930578][end:946010]] Sometimes it's still very hard to compute a message because even the single messages that come out of these nodes, they're still integrals or summations, and in particular the integrals may be a problem.
[[start:946080][end:948266]] We may not have an analytical answer.

15:48 [[start:948448][end:953814]] So what we sometimes do is add additional assumptions.
[[start:953942][end:965270]] We'll say, well, the posterior belief over FD, I can't compute it in general, but I'm going to just assume now that it's a gaussian that makes it easier.

16:05 [[start:965450][end:988360]] Or we can make an extra factorization assumption and say the posterior belief over FB, which is really a belief over the joint x one, x two, x four is going to be broken into independent belief over x one and belief over x two and x four.

16:30 [[start:990810][end:996686]] These additional assumptions, if I impose them as well, this is what I recall.
[[start:996738][end:1004222]] Now, if I all substituted here in Q of x, I get what's called a constrained beth free energy.
[[start:1004356][end:1007386]] This is the same Beth as in the Oppenheimer movie.
[[start:1007418][end:1010560]] This is Hans Bethe, where it's named after.

16:53 [[start:1013730][end:1033238]] We have a graph now that is highly factorized and we have local beliefs over notes and over and they're indicated with red and we have additional constraints in green.
[[start:1033324][end:1037346]] They could be Gaussians or mean field constraints or other constraints.
[[start:1037458][end:1041814]] And now we will assume constraints that make it possible to compute all the messages.
[[start:1041862][end:1045750]] And now we can just automate this by making different assumptions.
[[start:1045830][end:1054106]] We can turn this into expectation maximization or belief propagation or hybrid forms thereof.

17:34 [[start:1054138][end:1058526]] We can turn it into any relevant message passing algorithm that you've heard of.
[[start:1058628][end:1064160]] So this is a very nice umbrella framework that basically encompasses everything.
[[start:1066070][end:1075940]] We've written a pretty large paper on this in the Entropy Journal where you can read all the math on how this works.

17:57 [[start:1077430][end:1084674]] So we've talked about why message passing, namely because it's the most effective way of doing inference.
[[start:1084722][end:1096726]] And we've talked about which messages to compute, namely we turn our variational free energy into something called a constraint, better free energy and then we can compute messages.

18:16 [[start:1096838][end:1102102]] The only thing that's left is, well, when do we pass these messages?
[[start:1102246][end:1103946]] What is the sequence of messages?
[[start:1103978][end:1105520]] Which one comes first?
[[start:1105890][end:1110400]] And this is where we see a lot of papers, right?
[[start:1111730][end:1114586]] You have to write control flow, what's called control flow.

18:34 [[start:1114618][end:1118734]] You have to say, okay, here is my algorithm for active inference.
[[start:1118782][end:1120370]] First I specify a model.
[[start:1120520][end:1133910]] Then let's do inference for every time step, collect a new observation, update the state, update the desired future, and so forth, compute expected free energy, select the policy, et cetera.
[[start:1135610][end:1137510]] This kind of program.

18:57 [[start:1137660][end:1142598]] The problem with active inferences is that there is nested for loops in here.

19:02 [[start:1142684][end:1145894]] Here's a for loop, and here's another for loop.
[[start:1145942][end:1152486]] And for each of these policies, I'm going to have to go into the future, so I'm going to have another time loop.
[[start:1152518][end:1155178]] So it is for loops, in for loops, in for loops.
[[start:1155274][end:1160186]] This will completely explode in terms of computational complexity.
[[start:1160378][end:1167742]] So as a result, some very clever people have written very clever algorithms of doing this much faster.

19:27 [[start:1167806][end:1176770]] Sophisticated inference, branching time active inference, dynamic programming EFE are recent proposals for doing this very clever.
[[start:1177190][end:1186150]] In the end, all of these proposals come down to a particular just a message passing schedule.
[[start:1187530][end:1193866]] Once we commit to message passing on the graph as our inference procedure, it's the only thing that's going on.
[[start:1194048][end:1202966]] And all of this sophisticated inference and branching time active inference, all it does is it schedules the messages.

20:02 [[start:1202998][end:1206270]] It says first this message, then this message, then this message.

20:06 [[start:1206420][end:1210714]] I don't mean that as a slight to these algorithms.
[[start:1210762][end:1211530]] They're very clever.
[[start:1211610][end:1219390]] And as we've seen in the presentation by Aswin Paul, you get huge improvements if you go from regular inference to sophisticated inference.
[[start:1219550][end:1228600]] But it's good to realize that these algorithms just specify in a graph which message comes after which message.
[[start:1229850][end:1238690]] So here's an example of a graph and a message sequence.

20:38 [[start:1238770][end:1248586]] Here's message one, then message two, and message three goes up, and then we go from FC to FF, and here's message five, and then we go to Fe.
[[start:1248688][end:1255790]] And this could correspond this sequence to dynamic time programming EFE or sophisticated inference.
[[start:1256530][end:1268802]] There are a couple of problems with this approach, which basically with having the user to specify a clever algorithm, first of all, you have to be a specialist to do it right.

21:08 [[start:1268856][end:1270660]] Only these are very clever people.
[[start:1271030][end:1282470]] That means that if we let it leave it to say to an engineer in a company, well, it's a high probability he's not going to get it right.

21:22 [[start:1282540][end:1283990]] That's very unfortunate.
[[start:1284570][end:1292902]] But there is another issue, and that is that in a sense, it's a global variable in the message passing schedule.
[[start:1292966][end:1299430]] All nodes are visited, because if a node would not be visited, then we shouldn't have it in the graph.
[[start:1299510][end:1305754]] And that means if one node crashes, basically the message passing schedule is invalid.
[[start:1305802][end:1307520]] I have to reset my system.

21:48 [[start:1308290][end:1320690]] And if you fly a drone, if it's deployed and it's out in the field and a node crashes, a transistor burns out, and I have to totally reset now my system, I have to compute a new message passing schedule.
[[start:1321510][end:1325378]] Then you're not doing inference and your drone flies into the wall.
[[start:1325544][end:1327578]] So this is not robust.
[[start:1327774][end:1334866]] And it also for the same reason we may actually want to take out a node.

22:15 [[start:1335058][end:1340350]] We may want to prune a node, we want to do structural adaptation.

22:20 [[start:1340530][end:1348182]] And we can't do structural adaptation because we have to reset the system, recompute a message passing schedule.
[[start:1348326][end:1358378]] So this procedural style where an engineer specifies which message comes after this message has some disadvantages.
[[start:1358474][end:1359962]] It's not very robust.
[[start:1360106][end:1365190]] And if you want to do it very clever, you have to be really a specialist.
[[start:1365370][end:1371330]] So a better system is what we call reactive message passing.

22:51 [[start:1371910][end:1379830]] And it's very related to what was in the first session called the actor model.
[[start:1379980][end:1383686]] Keith Duggar had a nice presentation on the actor model.
[[start:1383868][end:1390366]] So what we will do is we will say we will not have a global message passing schedule.
[[start:1390498][end:1394374]] The engineer will not specify anything anymore.
[[start:1394502][end:1402234]] The inference code that an engineer will have to write is just say, react to any free energy minimization opportunity.

23:22 [[start:1402432][end:1404894]] In other words, there is no inference code.
[[start:1404932][end:1406510]] It's completely automated.
[[start:1407010][end:1415414]] And we will replace this global message passing schedule by local triggering inside the node.
[[start:1415482][end:1422340]] So each node is now just an autonomous system that's interested in minimizing its free energy.
[[start:1422950][end:1425966]] It can do so by sending out messages.

23:46 [[start:1426158][end:1428482]] And when will it do so?
[[start:1428536][end:1440602]] Well, it receives messages, and then when it looks at these messages and it feels like, oh, there is an opportunity for me to minimize free energy by or expected free energy energy by sending out a message.
[[start:1440656][end:1452780]] Then we'll send out a message and each node will do so by itself asynchronously so you get parallel distributed processing, or concurrent processing, as Keith called it.
[[start:1453490][end:1463710]] In principle, you could play this game on many computers at the same time, and so you get tremendous advantages.

24:25 [[start:1465510][end:1468114]] First of all, you don't have to write difficult code.

24:28 [[start:1468232][end:1475780]] Second of all, you can do multithreading or you can run it on multiple computers at the same time.
[[start:1477510][end:1491258]] And there's also robustness advantages because if a node crashes, then there's nothing that stops the system from just finding another path, right?
[[start:1491344][end:1497722]] If this node crashes, this path from here's message three, this path now doesn't work.
[[start:1497776][end:1502570]] So I cannot send anything to Fe anymore from X.
[[start:1502720][end:1504782]] Well, then I just sent a new message here.

25:04 [[start:1504836][end:1505630]] Why not?
[[start:1505780][end:1515302]] It's like when water falls down a mountain and it zigzags its way down into the value and you halfway put up an obstruction.
[[start:1515386][end:1520126]] It just finds another path, not the preferred path.
[[start:1520318][end:1526722]] This has to find, well, the second best path, because the first path has been obstructed, right?

25:26 [[start:1526776][end:1529954]] And that's what's going to happen in this system as well, right?

25:29 [[start:1529992][end:1531700]] That's just how nature works.
[[start:1532150][end:1537074]] It tries to find the best path, the easiest path, and if that's not available, then we do the second best path.
[[start:1537122][end:1540638]] And that's also what you can do with reactive message passing.
[[start:1540754][end:1542406]] So you can prune nodes.
[[start:1542438][end:1548118]] You can do structural adaptation, and it's far more robust.

25:48 [[start:1548294][end:1556014]] And you can also do chance encounters with other drones, right?
[[start:1556132][end:1563262]] Drones that get close can start communicating with each other, and when they fire away, they stop communicating with each other.
[[start:1563316][end:1578920]] And this is no problem, because you can basically change who change nodes can change on the fly, who they communicate to and who they want to listen to.
[[start:1580890][end:1589490]] That's the way nature works, and also how it works when we do reactive programming and reactive message passing.

26:29 [[start:1589650][end:1598620]] So, in summary, we're interested in automating inference, in active inference agents, right?

26:39 [[start:1599150][end:1604522]] Because it's an operation that's basically only for experts.
[[start:1604586][end:1619762]] And this active inference technology is not going to be successful unless we get more people, let's say, democracies it, and we get competent engineers being able to develop good agents, right?
[[start:1619816][end:1625154]] You shouldn't have to be a top specialist in the world to develop an active inference agent.
[[start:1625352][end:1633218]] Now, in order to automate inference, you must do message passing, and I've talked about that for efficiency.
[[start:1633394][end:1636280]] I've also talked about which messages to pass.

27:16 [[start:1636970][end:1645734]] Not necessarily do you have to follow this framework, but constrained better Free energy framework is very convenient.
[[start:1645782][end:1657546]] It's an umbrella framework that basically goes over all the interesting other message passing computations.

27:37 [[start:1657738][end:1664270]] When message passing, reactive message passing, it's fully automated, so you don't have to write any code anymore.
[[start:1664690][end:1669226]] In principle, you can do parallel distributed processing.
[[start:1669258][end:1670850]] It's robust structural changes.

27:50 [[start:1670920][end:1672782]] You can learn new inference pathways.
[[start:1672846][end:1675860]] So lots of advantages here.
[[start:1676230][end:1679140]] Now, how do we do it?
[[start:1679750][end:1685190]] I like to introduce a toolbox that we've been working on called ARX infer.
[[start:1685770][end:1689794]] And we do that with my lab here at the university.

28:09 [[start:1689842][end:1693434]] I'm here in Eindhoven in the south of the Netherlands, and we have a lab.
[[start:1693552][end:1695082]] The lab is called BIS lab.
[[start:1695136][end:1704126]] Here are postdocs and assistant professors and PhD students, and we've been working on this for many years.
[[start:1704308][end:1713390]] And some of these, like Albert and Ismail and Tyce, have written dissertations.
[[start:1714210][end:1718270]] And our best work, we have consolidated that in a toolbox.

28:39 [[start:1719010][end:1721286]] And the toolbox is called Arcs infer.
[[start:1721338][end:1725198]] And if you want to have a look, you can go to the website, arcsinfer.
[[start:1725294][end:1726050]] ML.
[[start:1726470][end:1733042]] And Arctinfur works in the way that I've just discussed.
[[start:1733106][end:1734562]] It does message passing.

28:54 [[start:1734626][end:1737638]] It tries to minimize constraint, better free energy.
[[start:1737804][end:1742950]] That means it can come up with all kinds of message passing algorithms.
[[start:1744590][end:1752634]] It will do it in a reactive way, and it will try to do it in real time and low power and all the KPIs that we're talking about.
[[start:1752672][end:1759386]] Now, it's, of course, not done, but it's functional and like to show some demos.
[[start:1759418][end:1768610]] And I will leave it to Dimitri and Bart, who are two advanced PhD students in my lab to show the demos.

29:30 [[start:1770710][end:1774370]] So I'm going to stop sharing.

29:37 _Daniel:_
[[start:1777350][end:1778100]] Awesome.
[[start:1778490][end:1779394]] Thank you, Bert.
[[start:1779442][end:1780150]] Great talk.

29:40 _Bert:_
[[start:1780220][end:1780840]] Sure.

29:42 _Dmitry:_
[[start:1782490][end:1783558]] Can you hear?

29:43 _Bert:_
[[start:1783724][end:1784102]] Yeah.
[[start:1784156][end:1784760]] Yeah.

29:45 _Dmitry:_
[[start:1785290][end:1785750]] Okay.
[[start:1785820][end:1788038]] I will try to share my screen.

29:48 _Bert:_
[[start:1788204][end:1788920]] Okay.

29:50 _Dmitry:_
[[start:1790010][end:1791820]] So you should see it now.

29:52 _Daniel:_
[[start:1792430][end:1793420]] Looks good.

29:53 _Dmitry:_
[[start:1793950][end:1797846]] Okay, so, yeah, hello to everyone, I'm Dmitry
[[start:1797878][end:1814266]] Bagaev. So I'm a PhD student in Bioslab in Einhoven University of Technology, and yes, I have a small presentation about actual software developments in so over the past few years, we have significantly improved our tools.
[[start:1814378][end:1823790]] And basically my entire PhD was dedicated to implement this idea, which Beard was talking about, like implementing the variation of reactive message passing.

30:23 [[start:1823870][end:1830630]] And in this presentation, I just want to show you what you can actually do using this theory under the hood.
[[start:1831930][end:1837794]] Okay, so basically, in order to automate active inference, we need to automate Bayesian inference.
[[start:1837842][end:1846054]] And we have already a lot of solutions for that, such as Pyro NumPy, which is funded by Google, Info.
[[start:1846102][end:1850460]] Net is funded by Microsoft, turing is in July, PIMC, and many, many.
[[start:1851470][end:1857886]] And basically these solutions are really good and they're really good at prototyping as well.

30:57 [[start:1857988][end:1864474]] But our goal is eventually to be able to deploy these kind of systems, not just prototype.
[[start:1864602][end:1869810]] And we are really focusing on these particular properties for this automated Bayesian inference.
[[start:1870230][end:1874846]] So it must be low power, adaptive, real time scalable.
[[start:1874958][end:1881810]] It also must be user friendly at the end and must support a large scope of models if we want it to be useful.
[[start:1883750][end:1893058]] In Bioslab, we want to build such a software with such nice properties and it's always about trade offs, right?

31:33 [[start:1893084][end:1903340]] So we do something better in one particular domain and maybe other software libraries, they might be better in a different domain, but we are really focusing on this particular property.
[[start:1904430][end:1907754]] And so, yes, I will reiterate a little bit Bert's presentation.
[[start:1907802][end:1909102]] So how do we achieve this?
[[start:1909156][end:1926210]] So imagine we have an environment and we have an agent, and the agent takes some actions and the agent basically what he needs is to come up with some sort of good enough probabilistic model of its environment in order to do patient inference.

32:06 [[start:1926870][end:1936520]] And in our framework, we encode the model as a factor graph, which not only models the observations, but also actions and desired future.

32:17 [[start:1937930][end:1949126]] And this approach allows us to decompose these complex relationships between variables and hidden states into some kind of structure and local blocks.
[[start:1949318][end:1952490]] And it's not a black box anymore.
[[start:1953250][end:1958138]] And the model itself may have some sort of background motivation interpretation.
[[start:1958234][end:1970802]] It may encode your prior knowledge about some particular physical system and the locality of these blocks basically allows you to scale to millions of variables and hidden states.
[[start:1970936][end:1978450]] It allows you to pre optimize it maybe, or maybe use some sort of different approximation strategies in different places.

32:58 [[start:1978970][end:1983094]] So it allows a lot of very nice properties as well.
[[start:1983292][end:1988978]] And we use reactive message passing to run actual variational Bayesian inference.

33:09 [[start:1989154][end:1995020]] It uses reactive programming under the hood to minimize the approximation to the variational free energy.
[[start:1995470][end:2000540]] And yes, as Bert also mentioned, it's very much related to actor model.
[[start:2002510][end:2005118]] And basically in Ariks and fur.

33:25 [[start:2005204][end:2016080]] You can think of different nodes as actors themselves and they have basically one single purpose is to send a variational message that minimizes free energy.
[[start:2016610][end:2022366]] This is a very short and very high level description, but it is essentially what is happening under lipid.
[[start:2022478][end:2034246]] So we are not treating different agents which interact with each other as actors, but we also treat the actual components of the underlying model as actors themselves.
[[start:2034428][end:2036866]] It's like a very hierarchical structure.
[[start:2036978][end:2042250]] So this is the main central idea of this inference.

34:03 [[start:2043790][end:2049500]] So here for example, first example, we can do an inference in a dynamical system.

34:10 [[start:2050110][end:2054430]] This example, which is quite old already, I think it's like two years ago.
[[start:2054580][end:2065866]] So we track a position of the object given some noisy measurements which are indicated by green dots, the actual real signal, we cannot observe it, but we just can plot.
[[start:2065898][end:2072318]] It is shown as blue and the inferred signal is shown as red and the data set is infinite.
[[start:2072414][end:2076980]] The inference end just reacts on it and does not assume any particular data size.

34:37 [[start:2077430][end:2080020]] Simply reacts in your observation as soon as possible.
[[start:2080810][end:2084760]] Yeah, I'm actually not sure how smoothly Zoom shares my screen.
[[start:2085370][end:2092220]] Maybe you can see it's a bit lagging in the animations, I'm not sure because maybe zoom does not share it on a full frame rate.
[[start:2093070][end:2098982]] And also on the right hand side you can see how we define models in our framework.
[[start:2099046][end:2101050]] We use Julia as a programming language.

35:02 [[start:2102910][end:2108206]] Basically, this is everything that you need to define this particular model and run inference on a data set.
[[start:2108388][end:2114250]] And actually I literally spent more days to plot it instead of inference.

35:14 [[start:2114330][end:2121650]] So inference was an easiest part for me, plotting was way much harder to relate to user friendliness.
[[start:2123030][end:2128354]] And we actually have plans to improve our model specification language, make it even easier.
[[start:2128402][end:2138870]] So now for technical reasons, we have some auxiliary statements in the model specification language, but we are working to improve that and make it even easier.

35:41 [[start:2141130][end:2149094]] This is another example which is similar to the previous one, that uses much more complex and linear dynamical system of the double pendulum.
[[start:2149222][end:2157470]] And the system is chaotic and we can observe only a small part of it with a lot of noise, also indicated as a green dots.
[[start:2158290][end:2172020]] And nevertheless, given good enough model, you can infer the other hidden states with pretty much high precision and the code needed for that is also relatively short.

36:15 [[start:2175510][end:2182390]] We also have examples with active inference agents that interact with their environment.
[[start:2183050][end:2191338]] So the left up shows mountain car problem, very famous problem.
[[start:2191504][end:2201820]] The left bottom side shows an active inference agent which tries to control the inverted pendulum from falling in the windy conditions it reacts in wind.
[[start:2202510][end:2208218]] We also have a demo of an agent that controls a pendulum in an ever changing environment.
[[start:2208394][end:2215342]] So on the right side you see a pendulum with an engine and engine has limited power and.

36:55 [[start:2215396][end:2220450]] The agent itself needs to reach the goal and the goal is indicated as a red circle.

37:02 [[start:2222470][end:2227326]] Basically, in this demo we can change the environment in real time and see how the agent reacts.
[[start:2227438][end:2237474]] So we can change the mass of the pebble among its length or the amount of noise in the measurements, or we can change the goal, we can change maximum engine power, et cetera.

37:17 [[start:2237602][end:2246410]] So the agent will still try to infer the best possible course of actions in order to reach its goal and it just never stops reacting.
[[start:2248110][end:2256254]] It's also actually possible to restrict engine power such that it will not longer possible to reach the goal, right?
[[start:2256292][end:2258080]] But the agent will still try.

37:40 [[start:2260050][end:2280550]] We have other cool demos with smart navigation and collision avoidance which are still under active research and the code for them is not available publicly it will be soon available, but for example in this example we can define a set of agents with their boundaries and a set of their destinations.
[[start:2280890][end:2284710]] And we can see how they try to resolve their routes altogether.

38:07 [[start:2287050][end:2290558]] And we can have some static obstacles in the map.
[[start:2290674][end:2300570]] We can see how agents can find their most optimal path in order to reach their goals and avoid any possible collision.

38:21 [[start:2301630][end:2308382]] And it's also not necessary to have static obstacles, the obstacles themselves may move.
[[start:2308516][end:2317614]] So on this demo we have hundreds of agents that navigate through a map of obstacles that move from bottom to top to the circles or obstacles.
[[start:2317742][end:2325730]] And agents are depicted as small dots and they need to go from left to right, basically avoid any sort of collision.

38:47 [[start:2327670][end:2341898]] And as I also mentioned, we want to perform efficient and real time inference, but we also to do it like low power, low performance on low performance devices such as Raspberry, Pi or Coolpy as an example.
[[start:2342064][end:2348630]] And we have some results of successfully running the Bayesian audio source separation, for example, on coolpy.
[[start:2348790][end:2356910]] So it is actually possible we try to run active inference agents also on Coolpy.
[[start:2357410][end:2374786]] So as the aforementioned inverted pendulum, and as I mentioned, we also need to have a large model scope and basically RICS infer has not been designed to solve any of the aforementioned problems.

39:34 [[start:2374888][end:2383590]] Specifically, we have a large set of different examples in our repository, different models, different data, different inference constraints.

39:44 [[start:2384250][end:2393506]] We have examples for linear regression, hidden Markov model altogether, grace model hierarchy models, misheard models, Gaussian process and so, right?
[[start:2393548][end:2395930]] So this approach is very versatile.
[[start:2396670][end:2416642]] And for example, if you compare it with sort of a conventional software libraries where you let's say have a library that solves a common filter, might be a very great library, maybe super fast, have top performance works great and very reliable, super good.
[[start:2416696][end:2422034]] But then you are constrained by this particular model common filtering, right?
[[start:2422072][end:2424020]] And you can't really change it much.

40:24 [[start:2424630][end:2437042]] In Ericsson Fur we are free to define our own models which we can pretty much easily define a model that essentially would act equivalently to common filtering equation.

40:37 [[start:2437186][end:2447500]] And so basically in the demo that I showed before about object tracking, it was essentially a common filter but was written in a probabilistic model.
[[start:2449470][end:2453282]] So yeah, that was my small addition to Bear's presentation.
[[start:2453446][end:2459550]] So our software is free MIT license and it's open source available on GitHub.
[[start:2460530][end:2466062]] Yeah, and we would be happy thanks to be able to present where we would be happy to answer.

41:06 [[start:2466196][end:2468080]] Any, thanks.

41:14 _Daniel:_
[[start:2474760][end:2475508]] Awesome.
[[start:2475674][end:2478100]] All right, I'll just ask a quick question.
[[start:2478170][end:2491000]] In the chat Marco asks sorry if I missed it are the collision avoidance demos real time adapting to other agents behavior or is it a collectively pre computed path?

41:33 _Dmitry:_
[[start:2493020][end:2500412]] So basically they are not super real time, they're kind of fast to compute this path, like maybe 5 seconds or so.
[[start:2500546][end:2503292]] But we are basically working to make it real time.
[[start:2503346][end:2509228]] So we know what is the problem, we know where to improve and we will make it real time.
[[start:2509314][end:2511090]] Yes, almost.

41:53 _Daniel:_
[[start:2513220][end:2514224]] Next question.
[[start:2514342][end:2517404]] Do you have some comparative data with other methods?
[[start:2517452][end:2528736]] And just more generally, what kinds of benchmarks or when you're talking with industry in different settings, what are people looking for that killer app of active inference?
[[start:2528768][end:2532200]] Or what are they looking for their key measures?

42:14 _Dmitry:_
[[start:2534140][end:2547500]] So I personally have a big paper about comparison with sampling based methods like HMC and also in my PhD thesis, there will be a comparison with nuts, also other sampling based methods.

42:28 [[start:2548240][end:2555790]] So, long story short, sampling based methods cannot really run this kind of sophisticated inference in real time.
[[start:2556240][end:2557852]] They're very time consuming.
[[start:2557916][end:2562992]] They do not really scale well to large problems which is really needed for active inference agents.
[[start:2563046][end:2570870]] Because if you have a large environment, very complicated, you will have a lot of unknown variables in your model.

42:53 [[start:2573480][end:2580230]] There is a paper that compares and basically we show that our approach scales much, much better.
[[start:2580540][end:2593770]] So I personally run on just a regular MacBook laptop, I run the model with 2 million unknown variables and it was quite fast.

43:14 [[start:2594620][end:2609090]] With sampling based methods you may find yourself in a model with like 100 variables and then you wait like 2 hours or something and then it turns out that your chain did not converge or something like that.

43:31 _Daniel:_
[[start:2611860][end:2612368]] Cool.
[[start:2612454][end:2619712]] Yeah, it's people commenting in the chat like how far message passing and factor graphs have come.
[[start:2619766][end:2626884]] And so to Bias Lab and to Bert at all, we definitely appreciate this exciting line of research.
[[start:2627002][end:2637896]] I mean, there's so much to learn there and sometimes looking at the equations, it can seem like it's like written in stone and just sort of the beginning and the end is, you know, variational free energy.
[[start:2638078][end:2643012]] But then in your presentations you're really showing like no, we are hands on.

44:03 [[start:2643166][end:2648824]] That's where we get the interpretability, the modularity, that's where it really is implemented.
[[start:2648952][end:2652072]] And it's like an information logistics challenge.
[[start:2652216][end:2655730]] It's not like an esoteric philosophy question at that point.

44:16 _Bert:_
[[start:2656740][end:2658400]] No, indeed.
[[start:2659620][end:2664144]] I should say it's taken us we are no geniuses, right.

44:24 [[start:2664182][end:2676356]] So our lab exists more than eight years, and you see all the people in the lab, it's taken us many years with lots of wrong directions to get this to work to where it's now.
[[start:2676458][end:2678560]] So it's a very long path.
[[start:2678720][end:2699096]] But at this moment, I'm pretty confident that at some point in the future and we don't want to say in three months or in one year, but we will be able to write a toolbox that will allow people to design a generative model and just press a button and forget about the inference.
[[start:2699128][end:2700984]] You don't have to worry about inference anymore.
[[start:2701032][end:2707170]] It will be fast and automated, and that will happen, and it will happen within a few years.

45:08 [[start:2708980][end:2711644]] And maybe somebody else will write an even better toolbox.
[[start:2711772][end:2719190]] But I'm pretty confident that even our toolbox will be able to do that.

45:20 [[start:2720680][end:2727012]] People talk about, why don't we have the success of deep learning and generative AI, right?
[[start:2727066][end:2737492]] Well, they have the success because of big data availability of big data, big computers and toolboxes TensorFlow and all the successes.
[[start:2737636][end:2742808]] We don't need big data because agents collect their own data in the field.

45:42 [[start:2742894][end:2750728]] We don't need big computers, active influence agents, they manage their power resources.
[[start:2750904][end:2760240]] But we need a really good toolbox because programming an active inference agent, programming the inference by hand is just not doable.
[[start:2760660][end:2765570]] So we need a really good toolbox that really automates this.
[[start:2766260][end:2770772]] We hope Arcs Infer will be one of the first toolboxes to do that.
[[start:2770826][end:2777430]] I am sure that other people will also be working on it, and better toolboxes will come about.

46:18 [[start:2778200][end:2783210]] But I think the optimistic message is that it will happen.

46:24 [[start:2784300][end:2796904]] And once we have a toolbox like that, then we can actually a large community can start building agents, and we can actually show deployable agents in the field that they work.
[[start:2796942][end:2801292]] And they work better than reinforcement learning agent or whatever is out there.
[[start:2801346][end:2801950]] Right.
[[start:2802560][end:2806850]] So I think that's a very positive and hopeful message.

46:48 _Daniel:_
[[start:2808020][end:2808992]] It's what we expect.
[[start:2809046][end:2810220]] It's what we prefer.

46:50 _Bert:_
[[start:2810380][end:2811090]] Yeah.

46:52 _Daniel:_
[[start:2812900][end:2815730]] Any last comments from either of you?

46:59 _Bert:_
[[start:2819240][end:2820084]] Comments from us?
[[start:2820122][end:2832120]] No, I'm just very happy to get the opportunity, and yeah, I want to everybody can download this toolbox.
[[start:2833340][end:2839240]] I think at this moment, you still should be a programmer to work with the toolbox.
[[start:2839580][end:2846940]] And I hope you're friendly, because it's not totally polished in the way that we want.
[[start:2847010][end:2848172]] But it's coming, right?

47:28 [[start:2848226][end:2848684]] It's coming.
[[start:2848722][end:2857484]] In the next years, there will be a good toolbox for almost everybody to use, but people that are interested, even people that are interested to work.
[[start:2857522][end:2870290]] Here at Biaslab, we have an open position for PhD students, so we're happy to receive emails from people that are interested to work with us.

47:52 _Dmitry:_
[[start:2872420][end:2872896]] Thank you.

47:52 _Daniel:_
[[start:2872918][end:2874720]] Dimitri, anything in closing?

47:56 _Dmitry:_
[[start:2876420][end:2877344]] No, just that.
[[start:2877382][end:2880248]] Thank you again for possibility to present.
[[start:2880374][end:2881850]] Super nice to be here.

48:02 _Daniel:_
[[start:2882860][end:2883368]] Cool.

48:03 _Dmitry:_
[[start:2883454][end:2883704]] Yeah.

48:03 _Daniel:_
[[start:2883742][end:2898890]] Well, later in the year, we will be discussing your two part recent work, and so we're going to be getting a lot into the details, and I hope that people in the institute and the ecosystem will be as excited as we all are.
[[start:2899420][end:2900410]] Thank you.

48:20 _Bert:_
[[start:2900860][end:2901480]] Thank you.

48:21 [[start:2901550][end:2901796]] Bye.
