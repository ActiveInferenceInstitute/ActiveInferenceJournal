1
00:00:00,359 --> 00:00:03,199
알았어

2
00:00:05,940 --> 00:00:08,820
인사 알았어 다음

3
00:00:08,820 --> 00:00:12,300
세션 안녕 안녕 버트 인사

4
00:00:12,300 --> 00:00:14,280
잘 지내요 잘 지내요 잘 지내요 음

5
00:00:14,280 --> 00:00:15,059


6
00:00:15,059 --> 00:00:17,220
다음 세션은 새 장치

7
00:00:17,220 --> 00:00:20,580
Dimitri bagayev와 Bart van Erp를 사용하는 것입니다

8
00:00:20,580 --> 00:00:22,740


9
00:00:22,740 --> 00:00:24,720
합성 능동 추론의 사용자 친화적인 디자인을 지향할 예정입니다

10
00:00:24,720 --> 00:00:27,480
상담원들과 저는 많은 사람들이 이

11
00:00:27,480 --> 00:00:30,119
정말

12
00:00:30,119 --> 00:00:32,759
실용적이고 첨단 기술이 작동하는 것을 보고 매우 기뻐한다는 것을 알고 있습니다. 그러니

13
00:00:32,759 --> 00:00:35,100
Bert에게 우리가 어떻게 지원할 수 있는지 알려주세요. 알겠습니다.

14
00:00:35,100 --> 00:00:36,600


15
00:00:36,600 --> 00:00:40,680
훌륭합니다. 제 오디오는 괜찮습니다. 네,

16
00:00:40,680 --> 00:00:44,040
좋은 것 같네요. 그러면 할게요.  내

17
00:00:44,040 --> 00:00:46,739
화면을 공유해 uh

18
00:00:46,739 --> 00:00:48,719
제대로 골랐으면 좋겠어 작동하지 않아

19
00:00:48,719 --> 00:00:52,079
Zoom이 꽤 자주 좋아

20
00:00:52,079 --> 00:00:55,140
보여 괜찮아 보이는데 응 알았어 슈퍼 음 음 이 행사를

21
00:00:55,140 --> 00:00:57,719


22
00:00:57,719 --> 00:01:00,239
주최해 준 Daniel에게 정말 고마워 uh 심포지엄

23
00:01:00,239 --> 00:01:02,100
강연 몇 편을 보고 있었어  정말 놀랍고

24
00:01:02,100 --> 00:01:05,400
어 우리는

25
00:01:05,400 --> 00:01:07,619
우리 자신을 소개할 기회를 얻게 된 것을 정말 특권으로 생각합니다. 그래서

26
00:01:07,619 --> 00:01:09,780
우리도

27
00:01:09,780 --> 00:01:11,640
이전에

28
00:01:11,640 --> 00:01:13,920
능동 추론을 위한 도구 상자를 개발하는 데 관심이 있는 몇몇 다른 사람들과 마찬가지로

29
00:01:13,920 --> 00:01:17,760
이 사진이나 이 사진은

30
00:01:17,760 --> 00:01:18,900
우리가

31
00:01:18,900 --> 00:01:20,820
음 무엇인지 보여줍니다.  우리가

32
00:01:20,820 --> 00:01:23,700
관심을 갖고 있는 것이 무엇인지 여기 왼쪽에 한 여성이 있는데

33
00:01:23,700 --> 00:01:26,100


34
00:01:26,100 --> 00:01:27,420
음 우리는

35
00:01:27,420 --> 00:01:30,119
레이저 포인터를 얻으려고 하는데 그 여성은 진공 청소 로봇의

36
00:01:30,119 --> 00:01:33,600
보람 있는 행동에 대한 아이디어를 갖고 있어서 글을

37
00:01:33,600 --> 00:01:36,000


38
00:01:36,000 --> 00:01:37,799
쓰고 있습니다.

39
00:01:37,799 --> 00:01:39,900


40
00:01:39,900 --> 00:01:42,420
바닥이 깨끗해질 때까지 흡입을 하세요.

41
00:01:42,420 --> 00:01:45,180
물건을 만지지 마세요. 그리고

42
00:01:45,180 --> 00:01:47,400
개에게 돌아오지 않도록 하세요. 별

43
00:01:47,400 --> 00:01:50,520


44
00:01:50,520 --> 00:01:52,259
3개 중 1개로 평가하겠습니다.

45
00:01:52,259 --> 00:01:55,560
그것을 지정하기 어려운 난이도 측면에서 볼 때

46
00:01:55,560 --> 00:01:58,320
그것은 이러한 로봇을 올바르게 프로그래밍하기에 충분하지 않습니다.

47
00:01:58,320 --> 00:02:00,000
왜냐하면 지금 그녀가 실제로

48
00:02:00,000 --> 00:02:02,939
해야 할 일은

49
00:02:02,939 --> 00:02:06,299
생성 모델을 지정하는 것이고 어 로봇이 움직여야 하는

50
00:02:06,299 --> 00:02:09,479
작동기와 작동기가 있다는 것을 알고 있기 때문입니다.

51
00:02:09,479 --> 00:02:12,420


52
00:02:12,420 --> 00:02:15,360
바닥이 깨끗해질 때까지 흡입을 적용하여

53
00:02:15,360 --> 00:02:18,480
센서가 카메라가 물체에 닿지 ​​않을 수 있도록 하므로

54
00:02:18,480 --> 00:02:20,459
물체

55
00:02:20,459 --> 00:02:23,099
인식이 있어야 할 수도 있습니다. 여기서

56
00:02:23,099 --> 00:02:25,680
이 생성 모델을 생각해내는 것은 정말 어려운 작업이며 무엇

57
00:02:25,680 --> 00:02:28,680
보다도

58
00:02:28,680 --> 00:02:31,860
그녀가 이런 종류를 지정해야 합니다.

59
00:02:31,860 --> 00:02:34,140


60
00:02:34,140 --> 00:02:36,300
이

61
00:02:36,300 --> 00:02:39,120
생성 모델의 확률 분포 측면에서 보상 행동에 대한 설명은 매우 어렵습니다.

62
00:02:39,120 --> 00:02:40,560
별 두 개로 평가하겠습니다.

63
00:02:40,560 --> 00:02:42,720


64
00:02:42,720 --> 00:02:45,060
이 모델에 대해 그녀가 해야 할 다음 일은

65
00:02:45,060 --> 00:02:47,220


66
00:02:47,220 --> 00:02:49,800
실제로 능동적인

67
00:02:49,800 --> 00:02:52,379
추론과 자유 계약을 수행하기 위한 추론 절차를 지정하는 것이기 때문입니다.  실시간 최소화

68
00:02:52,379 --> 00:02:53,400


69
00:02:53,400 --> 00:02:56,459
또는 이 복잡한 모델은 실제로

70
00:02:56,459 --> 00:02:59,540
거의 불가능합니다. 소수의

71
00:02:59,540 --> 00:03:02,940
전문가만이 매우 어려운 모델에서 변형 자유 에너지 최소화에 대한 절차를 실제로 작성할 수 있으므로

72
00:03:02,940 --> 00:03:04,319


73
00:03:04,319 --> 00:03:06,540


74
00:03:06,540 --> 00:03:09,780
우리가

75
00:03:09,780 --> 00:03:12,599
작업하고 있는 작업은 다음과 같습니다.  추론 작업을 자동화하여

76
00:03:12,599 --> 00:03:14,580


77
00:03:14,580 --> 00:03:17,459
별 3개를 제거하고 예, 그녀는 여전히

78
00:03:17,459 --> 00:03:20,159
모델을 지정해야 하지만

79
00:03:20,159 --> 00:03:23,220
장기적으로 우리는 그것에서 벗어나려고 노력하므로

80
00:03:23,220 --> 00:03:25,500
장기적으로 도구 상자를 얻을 수 있기를 바랍니다.

81
00:03:25,500 --> 00:03:27,720
이제 우리는  50년 동안 이야기하면

82
00:03:27,720 --> 00:03:31,440
텍스트 설명으로

83
00:03:31,440 --> 00:03:33,780


84
00:03:33,780 --> 00:03:36,959
초기 사전 설정을 사용하여 일부 초기 모델을 지정하기에 충분하고 그

85
00:03:36,959 --> 00:03:39,060
밖의 모든 것은

86
00:03:39,060 --> 00:03:42,120
상태 매개변수에 대한 자동 추론 학습일 뿐이며

87
00:03:42,120 --> 00:03:44,280
모델의 구조적 적응은

88
00:03:44,280 --> 00:03:48,360


89
00:03:48,360 --> 00:03:52,440
사전을 업데이트하는 피드백을 기반으로 할 수도 있습니다.  장기적으로 어

90
00:03:52,440 --> 00:03:55,140
지금은 추론 어 작업을 자동화할 수 있다면 매우 기쁠 것입니다. 음

91
00:03:55,140 --> 00:04:00,060


92
00:04:00,060 --> 00:04:02,459


93
00:04:02,459 --> 00:04:04,560
활성 추론 에이전트에 대한 추론을 지정하는 것이 왜 그렇게 어려운가요?

94
00:04:04,560 --> 00:04:07,819
경쟁하는 kpi가 너무 많아서

95
00:04:07,819 --> 00:04:11,519
어 우리가 하고 싶은 일  이것은

96
00:04:11,519 --> 00:04:15,180
ABCD

97
00:04:15,180 --> 00:04:17,720
모델뿐만 아니라 연속

98
00:04:17,720 --> 00:04:19,738
변수와

99
00:04:19,738 --> 00:04:22,440
생물학적 모델도 있을 수 있는 대형 모델 범위에 대한 것입니다.

100
00:04:22,440 --> 00:04:24,960
사용자 친화적이어야 합니다. 그녀가

101
00:04:24,960 --> 00:04:29,220
코드의 견고성에 대해 걱정하는 것을 원하지 않습니다.

102
00:04:29,220 --> 00:04:30,960
음 우리는 그녀가 다음과 같은 것에 대해 걱정하지 않기를 바랍니다.

103
00:04:30,960 --> 00:04:32,880


104
00:04:32,880 --> 00:04:36,180
음 두 변수는 코인지 좋은

105
00:04:36,180 --> 00:04:38,220
관계를 가지고 있습니다. 맞습니다

106
00:04:38,220 --> 00:04:40,320
음 적응성 상태 매개변수를 업데이트하고 싶습니다.

107
00:04:40,320 --> 00:04:42,540
아마도 모델일 수도 있습니다.

108
00:04:42,540 --> 00:04:45,060
모델 구조는 저전력이어야 합니다.

109
00:04:45,060 --> 00:04:48,180
왜냐하면 이 엔젤은 종종 엣지 장치에서 실행되기

110
00:04:48,180 --> 00:04:50,759
때문에

111
00:04:50,759 --> 00:04:53,340
배터리 전원으로 실행되어야 하기 때문입니다.

112
00:04:53,340 --> 00:04:55,979
왜냐하면 실시간 추론이 없으면 자전거 타는 법을 배울 수 없고

113
00:04:55,979 --> 00:04:58,139


114
00:04:58,139 --> 00:05:01,259
게다가 실제로

115
00:05:01,259 --> 00:05:03,000
현실의 변화를 최소화하고 싶기 때문입니다.

116
00:05:03,000 --> 00:05:04,740


117
00:05:04,740 --> 00:05:06,780


118
00:05:06,780 --> 00:05:09,720
수동 파생을 수행하고 이들 중 일부가

119
00:05:09,720 --> 00:05:11,880
오히려 서로를 물고 있다면 맞습니까? 어

120
00:05:11,880 --> 00:05:14,520
당신은

121
00:05:14,520 --> 00:05:16,740
변형 자유 에너지를 최소화하고 싶지만

122
00:05:16,740 --> 00:05:19,259
실시간으로 저전력으로 수행해야 합니다. 그래

123
00:05:19,259 --> 00:05:21,479
그런 종류가 서로 물립니다. 맞죠?  그래서

124
00:05:21,479 --> 00:05:23,340
이것은

125
00:05:23,340 --> 00:05:27,600
우리가 원하는 어려운 KPI입니다. 예

126
00:05:27,600 --> 00:05:30,000
우리는 모두 중요합니다.

127
00:05:30,000 --> 00:05:31,380
하나만 빼낼 수는 없습니다. 음

128
00:05:31,380 --> 00:05:33,180
그러면 전체 시스템이

129
00:05:33,180 --> 00:05:35,520
작동하지 않을 것이기 때문입니다. 음

130
00:05:35,520 --> 00:05:37,320
그래서

131
00:05:37,320 --> 00:05:40,860
음 능동 추론에 관한 논문을 읽을 때

132
00:05:40,860 --> 00:05:44,039
자주 읽고  이제 우리는

133
00:05:44,039 --> 00:05:46,259
변형 다양성 최소화를 구현

134
00:05:46,259 --> 00:05:49,380
하고 이는 그래프에 메시지를 전달하여 수행할 수 있습니다.

135
00:05:49,380 --> 00:05:53,639
먼저 그래프에

136
00:05:53,639 --> 00:05:56,039
메시지를 전달하여 수행해야 하는 이유를 명확히 하고 싶습니다.

137
00:05:56,039 --> 00:05:57,539


138
00:05:57,539 --> 00:05:58,919
음 매우 짧은

139
00:05:58,919 --> 00:06:00,120
답변으로

140
00:06:00,120 --> 00:06:02,960
수행하겠습니다.  짧은 대답의 예는

141
00:06:02,960 --> 00:06:08,759
베이지안 추론이 음 여기 왼쪽에 보이는 것과 같이

142
00:06:08,759 --> 00:06:11,340
매우 큰 곱의 합을 계산하는 것과 관련이 있다는 것입니다.

143
00:06:11,340 --> 00:06:13,199


144
00:06:13,199 --> 00:06:16,160
여기에는 AC

145
00:06:16,160 --> 00:06:19,800
adbc 곱이 있고 AC + 80으로 보내면

146
00:06:19,800 --> 00:06:21,840
이것이 곱의 합입니다.

147
00:06:21,840 --> 00:06:26,039
이제 우리는 분배 법칙에 의해

148
00:06:26,039 --> 00:06:28,380
여기 왼쪽에 있는 것이

149
00:06:28,380 --> 00:06:31,860
오른쪽에도 계산될 수 있다는 것을 알고 있습니다.

150
00:06:31,860 --> 00:06:34,259
이것을 곱하면 곱하기 C 더하기

151
00:06:34,259 --> 00:06:36,900
곱하기 D를 얻게 됩니다. 등등 이것은 합계의 곱입니다.

152
00:06:36,900 --> 00:06:39,000


153
00:06:39,000 --> 00:06:41,819
정확히 똑같습니다. 유일한

154
00:06:41,819 --> 00:06:44,400
차이점은 왼쪽을 계산하려면

155
00:06:44,400 --> 00:06:47,160
4개의 덧셈이 필요하다는 것입니다. 죄송합니다.

156
00:06:47,160 --> 00:06:49,979
4개의 곱셈과 3개의 덧셈이 필요합니다.

157
00:06:49,979 --> 00:06:52,919
오른쪽을 계산하려면 2개의

158
00:06:52,919 --> 00:06:54,300
덧셈과 1개의

159
00:06:54,300 --> 00:06:57,600
덧셈만 필요하므로 오른쪽이

160
00:06:57,600 --> 00:07:00,240
계산하는 것이 훨씬 저렴합니다.  일반적으로 왼쪽에는

161
00:07:00,240 --> 00:07:03,259


162
00:07:03,259 --> 00:07:05,819
소외와 아시아 추론을 기록할 때

163
00:07:05,819 --> 00:07:08,639


164
00:07:08,639 --> 00:07:11,460


165
00:07:11,460 --> 00:07:13,500
그래프에서 메시지 전달이 수행되는 왼쪽과 같이 자동으로

166
00:07:13,500 --> 00:07:16,919
훨씬 더 깊은 값으로 변환하여

167
00:07:16,919 --> 00:07:20,099
합계의 곱을 평가합니다.

168
00:07:20,099 --> 00:07:22,259


169
00:07:22,259 --> 00:07:23,460
음, 음,

170
00:07:23,460 --> 00:07:27,900
여기에 예가 있습니다.

171
00:07:27,900 --> 00:07:31,319
7개의 변수 X1 X2부터 X7까지의 모델 F이고

172
00:07:31,319 --> 00:07:34,319
이 모델은 X1 fbx2의 F A를 인수분해하는 식입니다.

173
00:07:34,319 --> 00:07:39,300
이제 우리는

174
00:07:39,300 --> 00:07:42,479
이 인수분해를 그래프로 그릴 수 있습니다.

175
00:07:42,479 --> 00:07:44,699
우리는 이것을

176
00:07:44,699 --> 00:07:46,919
Forney 스타일 요인 그래프라고 합니다. 우리가 하는 일은

177
00:07:46,919 --> 00:07:51,300
각 요인 FA에 대해 노드를 할당하여

178
00:07:51,300 --> 00:07:54,780
FB가 노트를 얻고 FC가 노트를 얻고

179
00:07:54,780 --> 00:07:58,020


180
00:07:58,020 --> 00:08:00,720
시스템의 변수를 가장자리와 연결하고 가장자리가

181
00:08:00,720 --> 00:08:03,780
연결되는 것입니다.  해당 변수가

182
00:08:03,780 --> 00:08:07,440
해당 함수의 인수이므로 FC는

183
00:08:07,440 --> 00:08:12,060
X1 X2 X 3의 F의 함수이고 이는

184
00:08:12,060 --> 00:08:14,880
FC가 가장자리 X1 X2 X3에 연결되고

185
00:08:14,880 --> 00:08:20,039
FD는 X4의 함수일 뿐이므로

186
00:08:20,039 --> 00:08:24,419
D가 다음에만 연결되는 경우 노드입니다.  edge X4 그래서

187
00:08:24,419 --> 00:08:26,580
이 그래프에서 볼 수 있는 것은 이

188
00:08:26,580 --> 00:08:28,500
그래프가

189
00:08:28,500 --> 00:08:31,399


190
00:08:31,399 --> 00:08:35,339
이 모델에 대해 우리가 가지고 있는 인수분해 가정의 시각화일 뿐이라는 것입니다.

191
00:08:35,339 --> 00:08:37,860
만약 제가 큰 소외화에 관심이 있다면

192
00:08:37,860 --> 00:08:41,820


193
00:08:41,820 --> 00:08:47,220
X3을 제외한 모든 변수에 대해 작업을 통합하므로 X1 X2입니다.  X4

194
00:08:47,220 --> 00:08:49,680
등에서 X7까지 저는 이것에 관심이 있습니다.

195
00:08:49,680 --> 00:08:51,540


196
00:08:51,540 --> 00:08:52,860
음 그러면

197
00:08:52,860 --> 00:08:55,800
이

198
00:08:55,800 --> 00:08:58,560
인수분해를 이용하여 이 합을

199
00:08:58,560 --> 00:09:03,620
기본적으로 이 곱의 합을 아래와

200
00:09:03,620 --> 00:09:09,060
같이 합의 곱으로 다시 쓸 수 있습니다. 여기 아래에서 볼 수 있는 것은

201
00:09:09,060 --> 00:09:10,980


202
00:09:10,980 --> 00:09:13,080
정확히 다음을 계산합니다.  같은 일이지만 나는

203
00:09:13,080 --> 00:09:16,519
이 분배 법칙을 사용했습니다. 예를 들어

204
00:09:16,519 --> 00:09:22,080
FC에는 X4와 X5가 없으므로

205
00:09:22,080 --> 00:09:25,080
합산 기호 위로 왼쪽으로 이동했고

206
00:09:25,080 --> 00:09:30,660
FB에도 X4 X5 x67이 포함되어 있지 않으므로

207
00:09:30,660 --> 00:09:32,760
끝까지 이동했습니다.  왼쪽

208
00:09:32,760 --> 00:09:35,700
으로 그렇게 하면 여기에

209
00:09:35,700 --> 00:09:38,279


210
00:09:38,279 --> 00:09:42,480
2개의 변수 중 일부만 더해져야 하는 표현식이 남게 됩니다.

211
00:09:42,480 --> 00:09:44,519
여기서는

212
00:09:44,519 --> 00:09:46,860
6개의 변수를 합산해야 하고 여기서는 2개, 여기에서는

213
00:09:46,860 --> 00:09:49,920
2개를 합산해야 하므로 각

214
00:09:49,920 --> 00:09:53,760
변수가 그렇게 되는지 상상할 수 있습니다. X1  X2 각

215
00:09:53,760 --> 00:09:56,399
변수에 합산해야 할 10개의 흥미로운 값이 있는 경우

216
00:09:56,399 --> 00:09:57,959


217
00:09:57,959 --> 00:10:00,180
여기에

218
00:10:00,180 --> 00:10:03,360
원래의 주변화 문제가 있습니다.

219
00:10:03,360 --> 00:10:06,240
10의 6승이 있으므로 백만 개의

220
00:10:06,240 --> 00:10:08,940
용어가 있고 여기

221
00:10:08,940 --> 00:10:12,000
빨간색으로 100개의 용어가 있고 여기에

222
00:10:12,000 --> 00:10:14,940
100개가 있고 여기에 있습니다.  100 여기에는

223
00:10:14,940 --> 00:10:18,060
300개의 용어가 있고 여기에는 100만 개의 용어가 있으므로

224
00:10:18,060 --> 00:10:20,820


225
00:10:20,820 --> 00:10:23,240


226
00:10:23,240 --> 00:10:24,920


227
00:10:24,920 --> 00:10:28,620
이 분배 법칙을 사용하면 계산 복잡성이 엄청나게 줄어듭니다.

228
00:10:28,620 --> 00:10:31,860
이제

229
00:10:31,860 --> 00:10:36,000
이것을 작성하면 이러한

230
00:10:36,000 --> 00:10:38,459
중간 요소를 다음과 연결할 수 있다는 것이 밝혀졌습니다.  그래프의 메시지는

231
00:10:38,459 --> 00:10:40,620


232
00:10:40,620 --> 00:10:43,860
단지 해석일 뿐입니다.

233
00:10:43,860 --> 00:10:45,720
FC가

234
00:10:45,720 --> 00:10:49,140
fa에서 메시지를 받고 FB가

235
00:10:49,140 --> 00:10:51,839
수신하거나 FC가

236
00:10:51,839 --> 00:10:55,260
FB에서 X로부터 메시지를 받고 나가는

237
00:10:55,260 --> 00:10:58,740
메시지 mu X3을 계산하고 Fe에 대해서도 같은 내용을 계산하므로

238
00:10:58,740 --> 00:11:01,680
Fe가 메시지를 받는 것과 같습니다.

239
00:11:01,680 --> 00:11:04,920
이웃 요인 FD 및 FF에서 나가는

240
00:11:04,920 --> 00:11:07,640
메시지

241
00:11:07,640 --> 00:11:12,660
또는 X3을 계산하므로 여기서 볼 수 있는 것은

242
00:11:12,660 --> 00:11:15,660
전체 소외 프로세스가

243
00:11:15,660 --> 00:11:18,899
기본적으로 그래프에서 몇 개의 메시지를 계산

244
00:11:18,899 --> 00:11:20,820


245
00:11:20,820 --> 00:11:22,860
하고 이러한 메시지 중 일부를

246
00:11:22,860 --> 00:11:25,500
서로 곱하는 것으로 나타낼 수 있다는 것입니다.  이것이 추론

247
00:11:25,500 --> 00:11:27,540
에서 기본을 수행할 수 있는 방법이자

248
00:11:27,540 --> 00:11:29,399
변형 자유 에너지 최소화를 수행할 수 있는 방법이므로 음 인수

249
00:11:29,399 --> 00:11:33,959


250
00:11:33,959 --> 00:11:38,220
분해된 모델에서 작동하지만

251
00:11:38,220 --> 00:11:40,140
모델이 인수분해되지 않고 변수가 많으면 더 강력하다고 말하고 싶습니다.

252
00:11:40,140 --> 00:11:42,180


253
00:11:42,180 --> 00:11:45,300


254
00:11:45,300 --> 00:11:48,240
적절한 추론을 할 수 있는 방법은 어떤 심각한

255
00:11:48,240 --> 00:11:51,000
모델이라도 뇌가

256
00:11:51,000 --> 00:11:54,779
거의 희박하고 거의 비어 있는 것처럼 인수분해할 수 있다는 것입니다.

257
00:11:54,779 --> 00:11:58,019
약 100억 개의 뉴런이 있고

258
00:11:58,019 --> 00:11:59,940
각 뉴런은 수천 개의 다른 뉴런에 연결되어 있으므로

259
00:11:59,940 --> 00:12:02,519


260
00:12:02,519 --> 00:12:04,800
그래프를 그리면  거의 비어 있고

261
00:12:04,800 --> 00:12:08,700
매우 드물기 때문에 메시지를 전달하는 것

262
00:12:08,700 --> 00:12:10,620
외에 뇌에서 추론을 수행할 수 있는 다른 방법이 없습니다.

263
00:12:10,620 --> 00:12:12,540


264
00:12:12,540 --> 00:12:14,519
음 그래서 메시지 전달이

265
00:12:14,519 --> 00:12:16,200


266
00:12:16,200 --> 00:12:18,500
다른 것보다 더 효과적이기 때문에

267
00:12:18,500 --> 00:12:22,440
문제는 어떤 메시지를

268
00:12:22,440 --> 00:12:25,920
어떻게 계산하는지입니다.  당신은 메시지를 계산합니다.

269
00:12:25,920 --> 00:12:28,320


270
00:12:28,320 --> 00:12:30,360
올바르게 수행하는 방법에는 여러 가지가 있고 우리는

271
00:12:30,360 --> 00:12:32,160
활성 추론 논문에서도 읽었기 때문입니다.

272
00:12:32,160 --> 00:12:34,339
변형 메시지 전달이나

273
00:12:34,339 --> 00:12:37,440
기대 최대화 또는 믿음

274
00:12:37,440 --> 00:12:39,240
전파 및

275
00:12:39,240 --> 00:12:42,360
변형 LaPlace를 통해 이를 수행할 수 있으며 이러한 모든 용어는

276
00:12:42,360 --> 00:12:46,260
우산이 있다는 것이 밝혀졌습니다.  프레임워크를

277
00:12:46,260 --> 00:12:48,300
전달하는 이러한 모든 방법에 대한

278
00:12:48,300 --> 00:12:50,700
프레임워크이며 그 우산 프레임워크는

279
00:12:50,700 --> 00:12:53,220
제약 조건 더 나은

280
00:12:53,220 --> 00:12:56,459
자유 에너지 최소화라고 하며 저는

281
00:12:56,459 --> 00:12:57,920


282
00:12:57,920 --> 00:13:02,040
이 슬라이드를 통해 이를 설명하려고 노력합니다.

283
00:13:02,040 --> 00:13:05,160
그래서 여기에 이 ​​그래프가 있습니다. 이것은

284
00:13:05,160 --> 00:13:06,980


285
00:13:06,980 --> 00:13:11,839
제 생성 모델이 다음과 같은 예시 그래프일 뿐입니다.  기본적으로

286
00:13:11,839 --> 00:13:17,399
dnfe의 F A FB FC를 인수분해하고

287
00:13:17,399 --> 00:13:19,560
여기에도 썼습니다. 이제 이것은

288
00:13:19,560 --> 00:13:21,779
자유 에너지의 변화입니다.

289
00:13:21,779 --> 00:13:25,260
이제 X의 Q에 대해 어떤 가정도 하지 않았

290
00:13:25,260 --> 00:13:29,399
으므로 X의 Q는 여전히 X1의 Q입니다. X2 X3은

291
00:13:29,399 --> 00:13:32,820
단지  공동 전체 변수이며

292
00:13:32,820 --> 00:13:34,079
인수분해 가정이 없습니다.

293
00:13:34,079 --> 00:13:36,120


294
00:13:36,120 --> 00:13:39,240
음,

295
00:13:39,240 --> 00:13:41,940
사후 종류가 사전

296
00:13:41,940 --> 00:13:43,920
인수화 가정,

297
00:13:43,920 --> 00:13:47,339
즉 생성 모델을 따른다고 가정하는 것도 의미가 있습니다. 따라서

298
00:13:47,339 --> 00:13:49,260
해당 가정을 하면

299
00:13:49,260 --> 00:13:51,959
다음과 같이 됩니다.

300
00:13:51,959 --> 00:13:55,320
Q X는 이제

301
00:13:55,320 --> 00:13:57,180


302
00:13:57,180 --> 00:14:01,620
a의 qas of X의 곱이라고 가정합니다. 여기서 a의 X의 qas는 노트에 대한

303
00:14:01,620 --> 00:14:04,320
믿음을 나타냅니다. 즉,

304
00:14:04,320 --> 00:14:08,220
B의 Q는 a라는 것이

305
00:14:08,220 --> 00:14:10,760
이 노드에 대한 사후 믿음이라는 것입니다. 즉, 사후 믿음입니다.

306
00:14:10,760 --> 00:14:13,800


307
00:14:13,800 --> 00:14:17,700
FB와 마찬가지로 이러한 노드에 연결되는 가장자리에 대한 믿음은

308
00:14:17,700 --> 00:14:20,760
X1 X2 X 4의 함수입니다.

309
00:14:20,760 --> 00:14:23,220
즉, 이전 또는

310
00:14:23,220 --> 00:14:26,279
생성 모델을 사용하면 B의 Q도 이

311
00:14:26,279 --> 00:14:28,500
노드의 변형 사후

312
00:14:28,500 --> 00:14:32,839
도 X1 X2 X4에 따라 달라지며 아니요에 따라 달라집니다.  다른

313
00:14:32,839 --> 00:14:36,660
요인들 그렇게 하면

314
00:14:36,660 --> 00:14:39,720
일부 변수를 두 배로 계산하게 됩니다.

315
00:14:39,720 --> 00:14:43,380
왜냐하면 X1은 F A에 대한 믿음의 일부일

316
00:14:43,380 --> 00:14:47,399
뿐만 아니라 FB에 대한 믿음의 일부이기 때문입니다. 따라서

317
00:14:47,399 --> 00:14:49,860
우리는 가장자리에 대한 믿음으로 나누어 이를 할인해야 합니다.

318
00:14:49,860 --> 00:14:53,760
즉,

319
00:14:53,760 --> 00:14:57,240
이제

320
00:14:57,240 --> 00:15:01,680
내 사후 믿음이 메모에

321
00:15:01,680 --> 00:15:05,639
대한 지역적 신념

322
00:15:05,639 --> 00:15:08,100
과 변수에 대한 가장자리에 대한 지역적 신념으로 나뉘어져 있다고 가정합니다.

323
00:15:08,100 --> 00:15:09,540


324
00:15:09,540 --> 00:15:12,779
이는

325
00:15:12,779 --> 00:15:16,860
내 그래프가 트리이고

326
00:15:16,860 --> 00:15:19,560
여기 트리이고 메시지를 보내면 실제로 상황이 훨씬 간단해질 것입니다.  그 트리를 전달하면

327
00:15:19,560 --> 00:15:21,600


328
00:15:21,600 --> 00:15:23,579
완벽하게 모든 것이 선형

329
00:15:23,579 --> 00:15:25,800
가우스라고 할 수 있다고 가정할 수 있습니다. 그런 다음 완벽한 베이지안 추론을 얻습니다.

330
00:15:25,800 --> 00:15:28,980
근사치가 없으므로

331
00:15:28,980 --> 00:15:32,100
이것은 좋은 가정입니다. 때로는

332
00:15:32,100 --> 00:15:33,959
메시지를 계산하기가 매우 어렵습니다.

333
00:15:33,959 --> 00:15:35,279


334
00:15:35,279 --> 00:15:38,660


335
00:15:38,660 --> 00:15:41,040
이러한 노드에서 나오는 메시지는 여전히

336
00:15:41,040 --> 00:15:44,100
적분 또는 합산,

337
00:15:44,100 --> 00:15:46,019
특히 적분이 문제일 수 있습니다.

338
00:15:46,019 --> 00:15:47,760
우리는 분석적인 답을 얻지 못할 수도 있습니다.

339
00:15:47,760 --> 00:15:51,480
그래서 우리가 때때로 하는 일은 음,

340
00:15:51,480 --> 00:15:53,100


341
00:15:53,100 --> 00:15:56,279


342
00:15:56,279 --> 00:15:59,519
FD에 대한 사후 믿음을 잘 말할 수 있는 가정을 추가하는 것입니다.  일반적으로 계산하지는 않지만

343
00:15:59,519 --> 00:16:01,139


344
00:16:01,139 --> 00:16:03,420
이제는

345
00:16:03,420 --> 00:16:06,300
더 쉽게 만드는 가우스라고 가정하겠습니다. 또는

346
00:16:06,300 --> 00:16:08,399
추가 인수분해 가정을 하고

347
00:16:08,399 --> 00:16:09,959


348
00:16:09,959 --> 00:16:13,260


349
00:16:13,260 --> 00:16:16,320
실제로 조인트

350
00:16:16,320 --> 00:16:20,420
X1 X2 X4에 대한 믿음인 FB에 대한 사후 믿음이 진행된다고 말할 수 있습니다.

351
00:16:20,420 --> 00:16:25,380
어 음 X1에 대한 독립적인 믿음과

352
00:16:25,380 --> 00:16:26,940


353
00:16:26,940 --> 00:16:29,880
음 X2 및 X4에 대한 믿음에서

354
00:16:29,880 --> 00:16:30,740
음

355
00:16:30,740 --> 00:16:34,920
이러한 추가 가정으로 분해되는 것은 내가

356
00:16:34,920 --> 00:16:36,839
그것들을 부과한다면 이것이 내가

357
00:16:36,839 --> 00:16:39,899
지금 부를 것입니다. 만약 내가 여기

358
00:16:39,899 --> 00:16:42,540
X의 Q에서 모두 대체한다면 나는 얻습니다.

359
00:16:42,540 --> 00:16:45,180
제한된 베타 프리 에너지라고 불리는 것은 이것은

360
00:16:45,180 --> 00:16:47,459
오펜하이머 영화에서와 같은 죽음입니다.

361
00:16:47,459 --> 00:16:50,339
이것은 Hans 베타의 이름을 딴 것입니다.

362
00:16:50,339 --> 00:16:51,899


363
00:16:51,899 --> 00:16:53,820
음 그래서

364
00:16:53,820 --> 00:16:56,360
우리는 이제

365
00:16:56,360 --> 00:17:00,839
그것이 고도로 인수분해된 그래프를 갖게 되었고 우리는

366
00:17:00,839 --> 00:17:02,480


367
00:17:02,480 --> 00:17:07,079


368
00:17:07,079 --> 00:17:09,660
음표에 대한 지역적 신념을 가지고 있습니다.  가장자리는 빨간색으로 표시되고

369
00:17:09,660 --> 00:17:11,819


370
00:17:11,819 --> 00:17:14,040
녹색에는 추가 제약 조건이 있습니다.

371
00:17:14,040 --> 00:17:16,559
가우스나 평균 필드 제약 조건 또는

372
00:17:16,559 --> 00:17:19,859
기타 제약 조건이 있을 수 있습니다. 이제

373
00:17:19,859 --> 00:17:21,059


374
00:17:21,059 --> 00:17:22,679
모든 메시지를 계산할 수 있는 제약 조건을 가정하고 이제

375
00:17:22,679 --> 00:17:24,959
다음과 같이 자동화할 수 있습니다.  다른

376
00:17:24,959 --> 00:17:27,179
가정을 하면 이를

377
00:17:27,179 --> 00:17:30,059
기대 최대화 또는 믿음

378
00:17:30,059 --> 00:17:32,280
전파로 바꿀 수 있습니다. 또는

379
00:17:32,280 --> 00:17:32,820
음

380
00:17:32,820 --> 00:17:35,280
하이브리드 형식은 꺼져 있습니다. 우리는 이를 여러분이 들어본

381
00:17:35,280 --> 00:17:37,620
관련 메시지 전달 알고리즘으로 바꿀 수 있습니다.

382
00:17:37,620 --> 00:17:40,020
따라서 이것은

383
00:17:40,020 --> 00:17:42,960
기본적으로 모든 것을 포괄하는 매우 훌륭한 우산 프레임워크입니다.

384
00:17:42,960 --> 00:17:46,320


385
00:17:46,320 --> 00:17:49,260
우리는

386
00:17:49,260 --> 00:17:51,059


387
00:17:51,059 --> 00:17:53,700


388
00:17:53,700 --> 00:17:57,200
이것이 어떻게 작동하는지에 대한 모든 수학을 읽을 수 있는 엔트로피 저널에 이 음에 대해 꽤 큰 논문을 작성했습니다.

389
00:17:57,200 --> 00:18:00,240
그래서 우리는 메시지

390
00:18:00,240 --> 00:18:02,700
전달이

391
00:18:02,700 --> 00:18:05,160
추론을 수행하는 가장 효과적인 방법이기 때문에 왜 메시지 전달인지에 대해 이야기했습니다.

392
00:18:05,160 --> 00:18:06,900
우리는 어떤 메시지를 계산해야 하는지에 대해 이야기했습니다.

393
00:18:06,900 --> 00:18:08,760
즉,

394
00:18:08,760 --> 00:18:10,679


395
00:18:10,679 --> 00:18:12,900
변형 자유 에너지를

396
00:18:12,900 --> 00:18:14,760
제한된 더 나은 자유 에너지라고 하는 것으로 변환한

397
00:18:14,760 --> 00:18:17,400
다음 메시지를 계산할 수 있습니다.

398
00:18:17,400 --> 00:18:20,940
남은 유일한 것은

399
00:18:20,940 --> 00:18:23,100
이러한 메시지를 올바른

400
00:18:23,100 --> 00:18:25,080
메시지 순서로 전달하는 것입니다.  어느 것이 먼저 나오는지,

401
00:18:25,080 --> 00:18:25,980


402
00:18:25,980 --> 00:18:27,360


403
00:18:27,360 --> 00:18:29,760
음 여기가 우리가 많은 논문을 보는 곳입니다.

404
00:18:29,760 --> 00:18:30,840


405
00:18:30,840 --> 00:18:31,559
음

406
00:18:31,559 --> 00:18:34,020
당신은 올바른 제어 흐름을 가지고 있습니다.

407
00:18:34,020 --> 00:18:36,419
좋은 제어 흐름이 무엇인지 말해야 합니다.

408
00:18:36,419 --> 00:18:38,520
여기 활성 추론을 위한 내 알고리즘이 있습니다.

409
00:18:38,520 --> 00:18:41,100
먼저 모델을 지정한 다음

410
00:18:41,100 --> 00:18:43,320
모든 항목에 대해 추론을 해보겠습니다.  시간 단계

411
00:18:43,320 --> 00:18:45,780
새로운 관찰 수집 업데이트

412
00:18:45,780 --> 00:18:48,960
상태 업데이트 원하는 미래

413
00:18:48,960 --> 00:18:51,720
권리 등 예상되는 자유

414
00:18:51,720 --> 00:18:55,140
에너지 계산 정책 선택 기타

415
00:18:55,140 --> 00:18:58,799
이런 종류의 프로그램

416
00:18:58,799 --> 00:19:01,200
능동 추론의 문제는

417
00:19:01,200 --> 00:19:03,600
여기에 for 루프가 중첩되어 있다는 것입니다. 여기에 for

418
00:19:03,600 --> 00:19:06,600
루프가 있고 여기에는  또 다른 for 루프와

419
00:19:06,600 --> 00:19:09,179
이러한 각 정책에 대해

420
00:19:09,179 --> 00:19:11,580
어 미래로 가야 하므로

421
00:19:11,580 --> 00:19:13,380
또 다른 시간 루프를 가질 예정이므로

422
00:19:13,380 --> 00:19:15,780
4개의 루프에 for 루프가 있습니다. for 루프에 이것은

423
00:19:15,780 --> 00:19:17,700


424
00:19:17,700 --> 00:19:19,140
계산 측면에서 완전히 폭발할 것입니다.

425
00:19:19,140 --> 00:19:23,520
결과적으로 일부 매우

426
00:19:23,520 --> 00:19:25,980
영리한 사람들은

427
00:19:25,980 --> 00:19:27,900
훨씬 더 빠른

428
00:19:27,900 --> 00:19:30,960
정교한 추론 분기 시간

429
00:19:30,960 --> 00:19:33,179
활성 영향 동적 프로그래밍을 수행하는 매우 영리한 알고리즘을 작성했습니다. 이 작업을

430
00:19:33,179 --> 00:19:36,299
수행하기 위한 우리의 최근 제안은 매우

431
00:19:36,299 --> 00:19:37,320
영리합니다.

432
00:19:37,320 --> 00:19:41,460
결국 이 모든 제안은

433
00:19:41,460 --> 00:19:44,660
특정 특정 항목으로 귀결됩니다.  메시지

434
00:19:44,660 --> 00:19:47,160
전달 일정

435
00:19:47,160 --> 00:19:50,039
음 일단 추론 절차로 그래프에 메시지 전달을 약속하면 이것이

436
00:19:50,039 --> 00:19:51,900


437
00:19:51,900 --> 00:19:54,780
진행되는 유일한 일이고

438
00:19:54,780 --> 00:19:56,520
이 모든 것

439
00:19:56,520 --> 00:19:59,160
또는 정교한 추론과

440
00:19:59,160 --> 00:20:02,160
시간 활성 추론을 허용하는 것은

441
00:20:02,160 --> 00:20:04,140


442
00:20:04,140 --> 00:20:06,000
이 메시지가 처음으로 말하는 메시지를 예약하는 것뿐입니다.  그런 다음 이 메시지 다음 이

443
00:20:06,000 --> 00:20:09,960
메시지는 이러한 알고리즘에 대한 슬라이드로서 매우 영리하다는 의미는 아니며 Asvine Paul의

444
00:20:09,960 --> 00:20:12,120


445
00:20:12,120 --> 00:20:14,039
프레젠테이션에서 본 것처럼 일반 추론에서 정교한 추론으로 전환하면

446
00:20:14,039 --> 00:20:16,260
큰 개선을 얻을 수 있다는 의미는 아닙니다.

447
00:20:16,260 --> 00:20:17,820


448
00:20:17,820 --> 00:20:20,700


449
00:20:20,700 --> 00:20:22,799


450
00:20:22,799 --> 00:20:25,919
이 알고리즘은 그래프에서

451
00:20:25,919 --> 00:20:28,080
어떤 메시지가 그 뒤에 오는지 지정한다는 것을 알아두면 좋습니다.

452
00:20:28,080 --> 00:20:29,880


453
00:20:29,880 --> 00:20:32,220
음, 여기 예가 있습니다.

454
00:20:32,220 --> 00:20:35,100
여기에 그래프와 메시지의 예가 있습니다.

455
00:20:35,100 --> 00:20:37,200


456
00:20:37,200 --> 00:20:38,039


457
00:20:38,039 --> 00:20:40,500
순서는 여기에 메시지 1이 있고,

458
00:20:40,500 --> 00:20:43,200
메시지 H2와 메시지 3이 올라가고, 그 다음부터 시작됩니다.

459
00:20:43,200 --> 00:20:46,559
FC에서 f f로, 여기서는

460
00:20:46,559 --> 00:20:49,260
5와 일치하고 Fe로 이동합니다.

461
00:20:49,260 --> 00:20:51,559
이는

462
00:20:51,559 --> 00:20:54,299
동적 시간 프로그래밍 efe 또는

463
00:20:54,299 --> 00:20:56,820
정교한 추론에 대한 시퀀스에 해당할 수 있습니다. 음

464
00:20:56,820 --> 00:20:58,799


465
00:20:58,799 --> 00:21:00,840
이 접근 방식에는 기본적으로

466
00:21:00,840 --> 00:21:04,440
사용자가 지정하도록 하는 데 몇 가지 문제가 있습니다.

467
00:21:04,440 --> 00:21:06,419
영리한 알고리즘 우선

468
00:21:06,419 --> 00:21:08,340


469
00:21:08,340 --> 00:21:10,559
제대로 하려면 전문가가 되어야 합니다. 이 사람들은 매우 영리한 사람들이기 때문에

470
00:21:10,559 --> 00:21:14,580
음, 그냥

471
00:21:14,580 --> 00:21:17,160
놔두면 음,

472
00:21:17,160 --> 00:21:18,900
회사의 엔지니어에게

473
00:21:18,900 --> 00:21:21,059
괜찮다고 해보자. 확률이 더 높다는 뜻입니다.

474
00:21:21,059 --> 00:21:22,620
제대로 처리되지 않을 거라는 점은

475
00:21:22,620 --> 00:21:24,960
매우 안타깝지만 음

476
00:21:24,960 --> 00:21:27,900
또 다른 문제가 있는데 그것은

477
00:21:27,900 --> 00:21:29,940
어떤 의미에서는 전역

478
00:21:29,940 --> 00:21:31,440
변수입니다.

479
00:21:31,440 --> 00:21:33,419
음 메시지 전달 일정의 모든

480
00:21:33,419 --> 00:21:36,059
노드는 방문됩니다. 왜냐하면 노드가

481
00:21:36,059 --> 00:21:38,700
방문되지 않으면 우리는 '

482
00:21:38,700 --> 00:21:40,860
그래프에 표시되지 않으며 이는

483
00:21:40,860 --> 00:21:44,159
하나의 노드가 충돌하면 기본적으로 메시지

484
00:21:44,159 --> 00:21:46,559
전달 일정이 유효하지 않다는 것을 의미합니다. 시스템을 재설정해야 하며

485
00:21:46,559 --> 00:21:48,480


486
00:21:48,480 --> 00:21:50,580
드론이 배치되어

487
00:21:50,580 --> 00:21:53,039
현장에 있고 노드가

488
00:21:53,039 --> 00:21:56,520
충돌하면 트랜지스터가 타서 날아갑니다.

489
00:21:56,520 --> 00:21:58,320
이제 시스템을 완전히 재설정해야 합니다.

490
00:21:58,320 --> 00:22:00,179
새 메시지 전달 일정을 계산해야 합니다.

491
00:22:00,179 --> 00:22:01,559


492
00:22:01,559 --> 00:22:03,179
그러면 추론을 수행하지 않고

493
00:22:03,179 --> 00:22:05,100
드론이 벽으로 날아간다는 것을 알 수 있습니다.

494
00:22:05,100 --> 00:22:09,120
따라서 이것은 견고하지 않으며

495
00:22:09,120 --> 00:22:12,059
우리가 사용하는 것과 동일한 이유입니다.

496
00:22:12,059 --> 00:22:14,940
실제로 노드를 제거하고 싶을 수도 있습니다.

497
00:22:14,940 --> 00:22:17,280
많이 정리하고 싶을

498
00:22:17,280 --> 00:22:20,100
수도 있습니다. 구조적 적응을 원

499
00:22:20,100 --> 00:22:21,780
하지만

500
00:22:21,780 --> 00:22:23,700


501
00:22:23,700 --> 00:22:26,039
시스템을 재설정해야 하기 때문에 구조적 적응을 수행할 수 없습니다.

502
00:22:26,039 --> 00:22:29,039
메시지 전달 일정을 다시 계산하여

503
00:22:29,039 --> 00:22:32,340
이 절차적 스타일이  엔지니어

504
00:22:32,340 --> 00:22:35,640
앱은 이 메시지 뒤에 어떤 메시지가 오는지 순전히 지정하는데

505
00:22:35,640 --> 00:22:37,559
몇 가지

506
00:22:37,559 --> 00:22:40,799
단점이 있습니다. 그다지 강력하지도 않고

507
00:22:40,799 --> 00:22:42,600
어, 아주 영리하게 하고 싶다면

508
00:22:42,600 --> 00:22:46,980
정말 전문가가 되어야 하므로

509
00:22:46,980 --> 00:22:50,280
더 나은 시스템은 우리가 반응형

510
00:22:50,280 --> 00:22:52,080
메시지 전달이라고 부르는 것입니다.

511
00:22:52,080 --> 00:22:56,700


512
00:22:56,700 --> 00:22:59,580
첫 번째 세션에서 있었던 일과 관련하여 어 배우

513
00:22:59,580 --> 00:23:01,919
모델이라고 불리는 Keith Duggar는

514
00:23:01,919 --> 00:23:04,020
배우 모델에 대해 멋진 프리젠테이션을 했기

515
00:23:04,020 --> 00:23:07,679
때문에 우리가 할 일은

516
00:23:07,679 --> 00:23:09,960
글로벌 메시지 통과 일정이 없을 것이라고 말할 것입니다.

517
00:23:09,960 --> 00:23:12,480
엔지니어는

518
00:23:12,480 --> 00:23:15,480
더 이상 공백을 지정하지 않을 것입니다.

519
00:23:15,480 --> 00:23:17,640
엔지니어가 작성해야 하는 추론 코드는

520
00:23:17,640 --> 00:23:21,000
자유 에너지 최소화 기회에 반응한다고 말하는 것입니다.

521
00:23:21,000 --> 00:23:23,460
즉,

522
00:23:23,460 --> 00:23:25,440


523
00:23:25,440 --> 00:23:27,059
완전히 자동화된 추론 코드가 없으며

524
00:23:27,059 --> 00:23:28,559


525
00:23:28,559 --> 00:23:31,620
음 우리는 이 글로벌 메시지

526
00:23:31,620 --> 00:23:34,559
전달 일정을 노트 내부의 로컬 트리거링으로 대체하므로

527
00:23:34,559 --> 00:23:37,679
각 노드가  이제

528
00:23:37,679 --> 00:23:40,320


529
00:23:40,320 --> 00:23:42,440
자유 에너지를 최소화하는 데 관심이 있는 자율 자율 시스템일 뿐입니다

530
00:23:42,440 --> 00:23:45,980
어 메시지를 보내면 그렇게 할 수

531
00:23:45,980 --> 00:23:50,100
있고 언제 메시지를 잘 받을 수 있을까요?

532
00:23:50,100 --> 00:23:52,500
제 말은 이 메시지를 볼 때 느끼는 것과

533
00:23:52,500 --> 00:23:54,120
아, 그런 느낌이 든다는 것입니다.

534
00:23:54,120 --> 00:23:55,799


535
00:23:55,799 --> 00:23:57,360
자유 에너지를 최소화할 수 있는 기회

536
00:23:57,360 --> 00:24:00,299


537
00:24:00,299 --> 00:24:02,039
메시지를 전송하여 무료 입장을 구매하거나 예상한 다음 메시지를 전송

538
00:24:02,039 --> 00:24:05,460
하고 각 노드가

539
00:24:05,460 --> 00:24:08,159
비동기식으로 이를 수행하므로 원칙적으로 Keys에서 부르는

540
00:24:08,159 --> 00:24:10,320
병렬 분산 처리 또는

541
00:24:10,320 --> 00:24:13,559
동시 처리를 얻을 수 있습니다.

542
00:24:13,559 --> 00:24:16,440


543
00:24:16,440 --> 00:24:20,280
동시에 여러 대의 컴퓨터에서 이 게임을 플레이할 수

544
00:24:20,280 --> 00:24:25,280
있고 어 엄청난 이점을 얻을 수 있습니다.

545
00:24:25,280 --> 00:24:27,480
우선 어려운 코드를 작성할 필요가 없습니다. 둘째,

546
00:24:27,480 --> 00:24:30,240


547
00:24:30,240 --> 00:24:33,840
멀티스레딩을 할 수 있거나 실행할 수 있습니다.

548
00:24:33,840 --> 00:24:35,400
동시에 여러 대의 컴퓨터를 사용할 수 있고

549
00:24:35,400 --> 00:24:36,480


550
00:24:36,480 --> 00:24:40,980
견고성도 있습니다

551
00:24:40,980 --> 00:24:42,659
음 음 어

552
00:24:42,659 --> 00:24:45,419
장점은 메모가

553
00:24:45,419 --> 00:24:49,140
충돌하면

554
00:24:49,140 --> 00:24:50,580
시스템이 다른

555
00:24:50,580 --> 00:24:53,880
경로를 찾는 것을 막는 것이 없기 때문입니다. 이 노드가 이

556
00:24:53,880 --> 00:24:56,760
경로와 충돌하면 여기의 메시지 3은

557
00:24:56,760 --> 00:24:59,220
지금은 그렇지 않습니다.  작동이 안 되서

558
00:24:59,220 --> 00:25:02,520
더 이상 Fe에게 아무것도 보낼 수 없어요 X에서는 어 안 돼요

559
00:25:02,520 --> 00:25:04,919
그럼 방금 여기에 새 메시지를 보냈어요

560
00:25:04,919 --> 00:25:08,340
물이

561
00:25:08,340 --> 00:25:11,340
산 아래로 떨어져서 지그재그로

562
00:25:11,340 --> 00:25:13,679
값을 따라 내려가는 것과 같은 경우는 어떨까요?

563
00:25:13,679 --> 00:25:16,080
장애물 위로

564
00:25:16,080 --> 00:25:18,120
다른 경로를 찾는 것입니다.

565
00:25:18,120 --> 00:25:21,840
음 선호하는 경로는 아닙니다. 이것은

566
00:25:21,840 --> 00:25:24,360
두 번째 경로를 두 번째로 좋은

567
00:25:24,360 --> 00:25:26,039
경로로 찾아야 합니다. 왜냐하면 첫 번째 경로가 막혔기 때문입니다. 그렇죠.

568
00:25:26,039 --> 00:25:27,960


569
00:25:27,960 --> 00:25:29,700
이 시스템에서도 그런 일이 일어날 것입니다.

570
00:25:29,700 --> 00:25:32,279
그렇죠. 자연이 그렇죠.  작동합니다.

571
00:25:32,279 --> 00:25:34,200
가장 쉬운 경로를 찾으려고 노력

572
00:25:34,200 --> 00:25:35,580
하고 그것이 가능하지 않으면

573
00:25:35,580 --> 00:25:37,559
우리는 두 번째 최선의 패스를 수행합니다.

574
00:25:37,559 --> 00:25:39,360
이는 또한

575
00:25:39,360 --> 00:25:41,820
반응형 메시지 전달로 수행할 수 있는 작업이므로

576
00:25:41,820 --> 00:25:43,980
구조적 적응을 수행할 수 있다는 메모를 증명할 수 있습니다.

577
00:25:43,980 --> 00:25:45,720


578
00:25:45,720 --> 00:25:49,440
음 그리고 훨씬 더 강력합니다.  그리고 당신은

579
00:25:49,440 --> 00:25:53,100
또한 얻을 수 있습니다 어 음

580
00:25:53,100 --> 00:25:55,980
다른 드론과의 우연한 만남 오른쪽 가까이 다가가는

581
00:25:55,980 --> 00:25:58,080
드론은

582
00:25:58,080 --> 00:26:00,900
서로 통신을 시작할 수 있고

583
00:26:00,900 --> 00:26:02,760
멀리 떨어져 있으면 서로 통신을 중단하며

584
00:26:02,760 --> 00:26:04,860


585
00:26:04,860 --> 00:26:09,240
기본적으로 누가 변경했는지 변경할 수 있기 때문에 이것은 문제가되지 않습니다

586
00:26:09,240 --> 00:26:11,640


587
00:26:11,640 --> 00:26:13,279
음

588
00:26:13,279 --> 00:26:16,080
노드는

589
00:26:16,080 --> 00:26:18,240
통신 대상과

590
00:26:18,240 --> 00:26:22,020
듣고 싶은 대상을 즉시 변경할 수 있습니다. 이것이 바로

591
00:26:22,020 --> 00:26:24,840
데이터가 작동하는 방식이며

592
00:26:24,840 --> 00:26:26,700


593
00:26:26,700 --> 00:26:29,820
메시지 전달을 통해 반응형 프로그래밍 영역을 수행할 때 작동하는 방식이므로

594
00:26:29,820 --> 00:26:32,760
요약하자면 다음과 같습니다.

595
00:26:32,760 --> 00:26:35,100


596
00:26:35,100 --> 00:26:38,900
음 능동적 영향력 에이전트에서 추론을 자동화하는

597
00:26:38,900 --> 00:26:42,419
것은

598
00:26:42,419 --> 00:26:46,260
기본적으로 전문가만을 위한 작업이고 이

599
00:26:46,260 --> 00:26:48,779
능동적 추론 기술은

600
00:26:48,779 --> 00:26:51,240
더 많은 사람을 확보하지 않으면 성공하지 못할 것이기 때문입니다. 어

601
00:26:51,240 --> 00:26:54,360
민주화하고

602
00:26:54,360 --> 00:26:58,080
유능한 엔지니어를 확보하여

603
00:26:58,080 --> 00:27:00,600
좋은 에이전트를 올바르게 개발할 수 있습니다.  추론을 자동화하려면 이제 활성 추론 에이전트를 개발하기 위해

604
00:27:00,600 --> 00:27:02,640
세계 최고의 전문가가 될 필요는 없습니다.

605
00:27:02,640 --> 00:27:04,679


606
00:27:04,679 --> 00:27:08,880


607
00:27:08,880 --> 00:27:11,400
메시지 전달을 수행해야 하며

608
00:27:11,400 --> 00:27:12,600


609
00:27:12,600 --> 00:27:15,179
효율성을 위해 그것에 대해 이야기했습니다. 어떤

610
00:27:15,179 --> 00:27:17,039
메시지를 전달

611
00:27:17,039 --> 00:27:19,620
하지 말아야 하는지에 대해서도 이야기했습니다.  반드시

612
00:27:19,620 --> 00:27:22,919
이 프레임워크를 따라야 하지만 제한된 더 나은

613
00:27:22,919 --> 00:27:25,919
자유 에너지 프레임워크는 매우 편리합니다.

614
00:27:25,919 --> 00:27:27,480


615
00:27:27,480 --> 00:27:29,340
기본적으로

616
00:27:29,340 --> 00:27:30,179
음

617
00:27:30,179 --> 00:27:34,340


618
00:27:34,340 --> 00:27:38,760
Nas가 반응성을 전달할 때 계산을 전달하는 모든 흥미로운 다른 메시지를 검토하는 우산 프레임워크입니다.

619
00:27:38,760 --> 00:27:40,559


620
00:27:40,559 --> 00:27:42,720
완전히 자동화되어 있으므로 필요하지 않습니다.

621
00:27:42,720 --> 00:27:44,880


622
00:27:44,880 --> 00:27:48,000
원칙적으로는 더 이상 코드를 작성할 수 있게 되었습니다. 병렬 분산 처리를 수행할 수 있습니다.

623
00:27:48,000 --> 00:27:49,740


624
00:27:49,740 --> 00:27:51,539
구조적 변경에 강력합니다.

625
00:27:51,539 --> 00:27:53,880
새로운 추론을 배울 수 있습니다. 경로에는

626
00:27:53,880 --> 00:27:56,340
많은 이점이 있습니다.

627
00:27:56,340 --> 00:27:57,659
이제

628
00:27:57,659 --> 00:28:00,120
어떻게 해야 할까요?

629
00:28:00,120 --> 00:28:02,520
음, 도구 상자를 소개하고 싶습니다.

630
00:28:02,520 --> 00:28:05,820
우리는 어 RX infer라는 작업을 해왔고

631
00:28:05,820 --> 00:28:09,539
여기 대학의 내 연구실에서 작업하고 있습니다.

632
00:28:09,539 --> 00:28:11,520
저는 여기 네덜란드 남부의 아인트호벤에 있고

633
00:28:11,520 --> 00:28:13,260
우리

634
00:28:13,260 --> 00:28:17,059
연구실은 bislab이라고 합니다. 여기

635
00:28:17,059 --> 00:28:21,059
박사후 연구원과 보조 교수들이 있고  박사 과정

636
00:28:21,059 --> 00:28:23,220
학생들과 우리는 수년 동안 이 작업을 해왔고

637
00:28:23,220 --> 00:28:27,419
이들 중 일부는

638
00:28:27,419 --> 00:28:28,080


639
00:28:28,080 --> 00:28:31,440
Albert와 Ismail과 감사합니다. 음

640
00:28:31,440 --> 00:28:33,980
논문을 작성했고

641
00:28:33,980 --> 00:28:36,960
우리가 가진 최고의 작업을

642
00:28:36,960 --> 00:28:39,059
도구 상자

643
00:28:39,059 --> 00:28:41,700
와 도구 상자에 RX 추론이라고 통합했으며 다음과

644
00:28:41,700 --> 00:28:43,740
같이 할 수 있습니다.

645
00:28:43,740 --> 00:28:46,980
웹 사이트 archiver.ml에 가서 요청하면 됩니다.

646
00:28:46,980 --> 00:28:50,779


647
00:28:50,779 --> 00:28:53,159
어 제가 방금 논의한 방식으로 작동합니다.

648
00:28:53,159 --> 00:28:55,679
메시지 전달은

649
00:28:55,679 --> 00:28:57,539
더 나은 자유 에너지 제한을 최소화하려고 시도합니다.

650
00:28:57,539 --> 00:29:00,299
즉, 가능하다는 뜻입니다.  온갖

651
00:29:00,299 --> 00:29:04,020
종류의 메시지 전달 알고리즘을 생각해 보세요.

652
00:29:04,020 --> 00:29:07,860
음 그것은 반응적인 방식으로 할 것이고

653
00:29:07,860 --> 00:29:10,440
그들은 실시간으로 저전력으로 그것을 시도할 것입니다.

654
00:29:10,440 --> 00:29:12,419
그리고 우리가

655
00:29:12,419 --> 00:29:13,919
지금 이야기하고 있는 모든 kpi는

656
00:29:13,919 --> 00:29:18,299
물론 완료되지 않았습니다.  음, 기능적이며

657
00:29:18,299 --> 00:29:20,899
몇 가지 데모를 보여드리고 싶습니다.

658
00:29:20,899 --> 00:29:24,059


659
00:29:24,059 --> 00:29:27,779
제 연구실의 고급 PC 학생인 Dimitri와 Bart에게 데모를 보여주도록 맡기겠습니다.

660
00:29:27,779 --> 00:29:30,320


661
00:29:30,899 --> 00:29:33,720


662
00:29:33,720 --> 00:29:36,440


663
00:29:37,500 --> 00:29:42,360
멋진 공유는 그만하겠습니다. 감사합니다. 좋은 이야기입니다. 어, 제 말

664
00:29:42,360 --> 00:29:45,480
들리나요?  응

665
00:29:45,480 --> 00:29:50,279
알았어 내 화면을 공유해 볼게 알았

666
00:29:50,279 --> 00:29:52,559
으니 이제

667
00:29:52,559 --> 00:29:54,000
괜찮아 보이겠지 알았어 그래

668
00:29:54,000 --> 00:29:57,600
안녕 어 모두에게 어 난

669
00:29:57,600 --> 00:30:00,059
어 디미트리 가방이야 그래서 나는

670
00:30:00,059 --> 00:30:01,740
바이오슬랩 박사과정 학생이고 공과대학 출신이야

671
00:30:01,740 --> 00:30:04,320
어, 네,

672
00:30:04,320 --> 00:30:06,659
실제 소프트웨어

673
00:30:06,659 --> 00:30:09,240
개발과 편견 연구소에 대한 작은 프레젠테이션이 있습니다. 네,

674
00:30:09,240 --> 00:30:12,240
지난 몇 년 동안 우리는

675
00:30:12,240 --> 00:30:15,000
도구를 크게 개선했으며

676
00:30:15,000 --> 00:30:17,460
기본적으로 내 박사 학위 전체는

677
00:30:17,460 --> 00:30:19,919
Bert가 이야기했던 이 아이디어를 구현하는 데 전념했습니다.

678
00:30:19,919 --> 00:30:22,380


679
00:30:22,380 --> 00:30:23,940
변형 반응 메시지 구현이 가능하며

680
00:30:23,940 --> 00:30:25,679
이 프레젠테이션에서는 이 이론을 내부적으로 사용하여

681
00:30:25,679 --> 00:30:28,559
실제로 무엇을 할 수 있는지 보여주고 싶습니다.

682
00:30:28,559 --> 00:30:31,799


683
00:30:31,799 --> 00:30:35,279
기본적으로

684
00:30:35,279 --> 00:30:36,659
활성 추론을 자동화하려면

685
00:30:36,659 --> 00:30:38,760
베이지안 영향을 자동화해야 하며, 어,

686
00:30:38,760 --> 00:30:40,860
우리는  Google 인터넷에서 자금을 지원하는

687
00:30:40,860 --> 00:30:44,520
Stan pyro numpyre는

688
00:30:44,520 --> 00:30:46,740


689
00:30:46,740 --> 00:30:49,200
7월에 Microsoft Turing에서 자금을 지원하고

690
00:30:49,200 --> 00:30:52,820
IMC에는 많은 솔루션이 있습니다. 기본적으로

691
00:30:52,820 --> 00:30:54,960
이러한 솔루션은 정말 정말 훌륭하므로

692
00:30:54,960 --> 00:30:56,880
uh 그리고 정말 훌륭합니다.

693
00:30:56,880 --> 00:31:00,000
프로토타입 제작 역시 우리의 목표는 궁극적으로

694
00:31:00,000 --> 00:31:02,460


695
00:31:02,460 --> 00:31:05,279
프로토타입뿐만 아니라 이런 종류의 시스템을 배포할 수 있는 것입니다. 그리고

696
00:31:05,279 --> 00:31:06,720
우리는 이

697
00:31:06,720 --> 00:31:08,760
궁극적인 침입 추론을 위해 이 특정 속성에 실제로 초점을 맞추고 있습니다.

698
00:31:08,760 --> 00:31:12,299
따라서

699
00:31:12,299 --> 00:31:15,539
저전력 적응형 실시간 확장 가능해야 하며

700
00:31:15,539 --> 00:31:17,340
사용자도 가능해야 합니다.  결국에는 친절

701
00:31:17,340 --> 00:31:19,559
하고 유용하길 원한다면 넓은 범위의 모델을 지원해야 하므로

702
00:31:19,559 --> 00:31:22,760


703
00:31:22,760 --> 00:31:26,399
바이어스 연구소에서는 어 이렇게

704
00:31:26,399 --> 00:31:30,559
멋진 속성을 갖춘 소프트웨어를 만들고 싶습니다.

705
00:31:30,559 --> 00:31:33,480
그리고 그것은 항상 Traders에 관한 것이기 때문에

706
00:31:33,480 --> 00:31:35,100
우리는 하나에서 더 나은 일을 합니다.  특정

707
00:31:35,100 --> 00:31:37,140
도메인이나 다른 소프트웨어

708
00:31:37,140 --> 00:31:39,480
라이브러리는 다른 도메인에서 더 나을 수도 있습니다.

709
00:31:39,480 --> 00:31:41,520
하지만 우리는 실제로

710
00:31:41,520 --> 00:31:44,159
이 특정 속성에 초점을 맞추고 있습니다.

711
00:31:44,159 --> 00:31:47,039
어, 그렇습니다. 최고의 프레젠테이션을 조금 반복하겠습니다.

712
00:31:47,039 --> 00:31:48,779


713
00:31:48,779 --> 00:31:50,760
그러면 이를 어떻게 달성할 수 있을까요?

714
00:31:50,760 --> 00:31:53,520
환경에 에이전트가 있고

715
00:31:53,520 --> 00:31:55,020
에이전트는 몇 가지 작업을 수행할 수

716
00:31:55,020 --> 00:31:57,720
있으며 에이전트에게 기본적으로

717
00:31:57,720 --> 00:32:00,480
필요한 것은

718
00:32:00,480 --> 00:32:02,580


719
00:32:02,580 --> 00:32:03,779


720
00:32:03,779 --> 00:32:06,600
환자 추론을 수행하기 위해 환경에 대한 일종의 충분히 좋은 확률 모델을 생각해내는 것입니다.

721
00:32:06,600 --> 00:32:09,360
그리고 우리 프레임워크에서 인코딩합니다

722
00:32:09,360 --> 00:32:11,520


723
00:32:11,520 --> 00:32:15,000
관찰뿐만 아니라 행동

724
00:32:15,000 --> 00:32:17,539
과 원하는 미래도 모델링하는 요인 그래프로서의 모델

725
00:32:17,539 --> 00:32:20,820
어 그리고 이 접근법을 사용하면

726
00:32:20,820 --> 00:32:23,279


727
00:32:23,279 --> 00:32:26,460
변수와 숨겨진 상태 사이의 복잡한 관계를

728
00:32:26,460 --> 00:32:28,919
일종의 구조와 로컬 블록으로 분해할 수 있습니다

729
00:32:28,919 --> 00:32:31,440
어 그리고 그것은 블록이 아닙니다

730
00:32:31,440 --> 00:32:34,679
더 이상 블랙박스가 아니므로 어 그리고 모델 자체에는

731
00:32:34,679 --> 00:32:36,120
일종의 배경 동기 해석이 있을 수 있습니다.

732
00:32:36,120 --> 00:32:39,419


733
00:32:39,419 --> 00:32:41,340
특정 물리적 시스템에 대한 사전 지식을 인코딩할 수 있습니다.

734
00:32:41,340 --> 00:32:43,200


735
00:32:43,200 --> 00:32:46,559
어 그리고 이러한 블록의 위치를 ​​통해

736
00:32:46,559 --> 00:32:49,080
기본적으로

737
00:32:49,080 --> 00:32:50,880
수백만 개의 변수와 숨겨진 상태로 확장할 수 있습니다.

738
00:32:50,880 --> 00:32:53,399
이를 통해 미리 최적화할 수 있거나

739
00:32:53,399 --> 00:32:55,520


740
00:32:55,520 --> 00:32:57,659
다양한 장소에서 일종의 다른 근사 전략을 사용할 수 있습니다.

741
00:32:57,659 --> 00:33:01,440
어 그래서 아주 좋은 속성도 많이 허용하며

742
00:33:01,440 --> 00:33:03,600


743
00:33:03,600 --> 00:33:06,480
반응성 메시지 전달을 사용하여

744
00:33:06,480 --> 00:33:08,159
어 실제 변형 버전 추론을 실행합니다.

745
00:33:08,159 --> 00:33:11,279
반응형을 사용합니다.  에너지 변화에 대한

746
00:33:11,279 --> 00:33:13,140
근사치를 최소화하기 위해 내부적으로 프로그래밍

747
00:33:13,140 --> 00:33:14,700


748
00:33:14,700 --> 00:33:17,820
하고 berdos가 언급했듯이

749
00:33:17,820 --> 00:33:22,399
그것은 액터 모델과 매우 관련이

750
00:33:22,399 --> 00:33:26,039
있으며 기본적으로 간접 전송은

751
00:33:26,039 --> 00:33:28,380
다른 노드를 액터 자체로 생각할 수 있습니다.

752
00:33:28,380 --> 00:33:29,760


753
00:33:29,760 --> 00:33:32,460
어 그래서 기본적으로 하나의 단일

754
00:33:32,460 --> 00:33:34,620
목적을 가지고 있습니다.  에너지를 최소화하는 변형 메시지를 보내는 것

755
00:33:34,620 --> 00:33:36,539


756
00:33:36,539 --> 00:33:38,760
어 이것은 매우 짧고 매우 높은

757
00:33:38,760 --> 00:33:40,799
수준의 설명이지만 본질적으로

758
00:33:40,799 --> 00:33:44,519
일어나고 있는 일이므로 서로

759
00:33:44,519 --> 00:33:47,580
상호 작용하는 다양한 에이전트를

760
00:33:47,580 --> 00:33:49,980
행위자로 취급하지 않고

761
00:33:49,980 --> 00:33:52,260
실제 구성 요소도 취급합니다.

762
00:33:52,260 --> 00:33:54,779
행위자로서의 기본 모델은

763
00:33:54,779 --> 00:33:57,000
매우 계층적 구조와 같으

764
00:33:57,000 --> 00:34:01,260
므로 이것이 이 추론의 주요 중심 아이디어입니다.

765
00:34:01,260 --> 00:34:03,600


766
00:34:03,600 --> 00:34:06,840
어, 예를 들어 첫 번째 예는

767
00:34:06,840 --> 00:34:08,879
동적 시스템에서 추론을 수행할 수

768
00:34:08,879 --> 00:34:11,760
있으며 이 예는

769
00:34:11,760 --> 00:34:13,619
이미 꽤 오래된 것 같습니다.  2년

770
00:34:13,619 --> 00:34:16,679
전과 같기 때문에 녹색 점으로 표시되는 노이즈 측정값을 고려하여 물체의 위치를 ​​추적합니다.

771
00:34:16,679 --> 00:34:18,359


772
00:34:18,359 --> 00:34:22,379


773
00:34:22,379 --> 00:34:24,899
실제 실제 신호는 관찰할 수 없지만

774
00:34:24,899 --> 00:34:27,540
플롯할 수 있습니다. uh 에스트론은

775
00:34:27,540 --> 00:34:30,000
파란색이고 반전 신호는 빨간색으로 표시됩니다.

776
00:34:30,000 --> 00:34:32,699
그리고 데이터 세트는 추론이 무한하며

777
00:34:32,699 --> 00:34:34,739
그것에 반응하고

778
00:34:34,739 --> 00:34:37,159
특정 데이터 크기를 가정하지 않습니다.

779
00:34:37,159 --> 00:34:39,359
단순히 관찰에 가능한 한 빨리 반응합니다.

780
00:34:39,359 --> 00:34:40,619


781
00:34:40,619 --> 00:34:42,719
어 예 실제로

782
00:34:42,719 --> 00:34:46,080
Zoom이 내 화면을 얼마나 원활하게 공유하는지 잘 모르겠습니다. 어 어쩌면

783
00:34:46,080 --> 00:34:48,239
보시다시피  애니메이션이 약간 지연됩니다.

784
00:34:48,239 --> 00:34:49,980


785
00:34:49,980 --> 00:34:51,899
Zoom이 전체 프레임 속도로 공유하지 않을 수도 있기 때문에 잘 모르겠습니다.

786
00:34:51,899 --> 00:34:53,280


787
00:34:53,280 --> 00:34:55,260
음 그리고 오른쪽

788
00:34:55,260 --> 00:34:58,500
에서도 모델을 정의하는 방법을 볼 수 있습니다. uh 우리

789
00:34:58,500 --> 00:35:00,240
프레임워크에서는 보석을 프로그래밍 언어로 사용합니다.

790
00:35:00,240 --> 00:35:01,880


791
00:35:01,880 --> 00:35:04,619
기본적으로 이것은

792
00:35:04,619 --> 00:35:06,180
이 특정 모델을 정의

793
00:35:06,180 --> 00:35:09,240
하고 데이터 세트에 대해 추론을 실행하는 데 필요한 모든 것입니다.

794
00:35:09,240 --> 00:35:11,820
실제로 저는

795
00:35:11,820 --> 00:35:14,760
프랑스에서 대신 그래프를 그리는 데 더 많은 시간을 소비하고 싶습니다. 그래서

796
00:35:14,760 --> 00:35:17,280
추론은 접근하기가 훨씬 쉬운 부분이었습니다.

797
00:35:17,280 --> 00:35:19,680
더 어려운 것은

798
00:35:19,680 --> 00:35:22,520
사용자 친화성과 관련이 있기

799
00:35:22,520 --> 00:35:25,560
때문에 실제로

800
00:35:25,560 --> 00:35:28,020
모델 사양 언어를 개선하여

801
00:35:28,020 --> 00:35:30,119
더욱 쉽게 만들 계획이 있습니다. 이제 기술적인 이유로

802
00:35:30,119 --> 00:35:32,760
몇 가지 보조 설명과

803
00:35:32,760 --> 00:35:34,859
모델 사양 언어가 있지만

804
00:35:34,859 --> 00:35:38,339
이를 개선하고 더욱 쉽게 만들기 위해 노력하고 있습니다.

805
00:35:38,339 --> 00:35:39,960


806
00:35:39,960 --> 00:35:41,280


807
00:35:41,280 --> 00:35:43,619


808
00:35:43,619 --> 00:35:45,960
이전 예제와 유사하지만 이중 진자의 훨씬 더

809
00:35:45,960 --> 00:35:48,119
복잡하고 선형적인 동적 시스템을 사용하는 또 다른 예는

810
00:35:48,119 --> 00:35:50,520
시스템이

811
00:35:50,520 --> 00:35:53,760
혼란스럽고 이 작은

812
00:35:53,760 --> 00:35:56,460
부분에서도 많은 노이즈가

813
00:35:56,460 --> 00:35:58,020
녹색 점으로 표시되는 것을 관찰할 수 있습니다.

814
00:35:58,020 --> 00:36:00,800
어 그럼에도 불구하고

815
00:36:00,800 --> 00:36:04,260
충분히 좋은 모델이 주어진다면 어 당신은

816
00:36:04,260 --> 00:36:06,839
거의 높은 정밀도로 다른 숨겨진 상태를 추론할 수

817
00:36:06,839 --> 00:36:10,320
있고 그에 필요한 코드도

818
00:36:10,320 --> 00:36:15,380
상대적으로 짧습니다. 그리고 어

819
00:36:15,480 --> 00:36:19,200


820
00:36:19,200 --> 00:36:21,359


821
00:36:21,359 --> 00:36:22,800
환경과 상호 작용하는 활성 추론 에이전트에 대한 예도 있습니다

822
00:36:22,800 --> 00:36:25,380
어 그래서 왼쪽은 어

823
00:36:25,380 --> 00:36:29,460
왼쪽 위는 어 예 산

824
00:36:29,460 --> 00:36:32,220
곡선 문제 매우 유명한 문제

825
00:36:32,220 --> 00:36:34,200
왼쪽 하단은

826
00:36:34,200 --> 00:36:36,599


827
00:36:36,599 --> 00:36:39,300


828
00:36:39,300 --> 00:36:42,780
바람이 부는 조건, 선로 및 바람에서 역진자가 떨어지는 것을 제어하려고 시도하는 활성 추론 에이전트를 보여줍니다.

829
00:36:42,780 --> 00:36:44,760
또한 진자를 제어하는 ​​에이전트의 데모도 있습니다.

830
00:36:44,760 --> 00:36:47,520
끊임없이 변화하는

831
00:36:47,520 --> 00:36:50,640
환경이므로 오른쪽에는

832
00:36:50,640 --> 00:36:52,560
엔진이 있는 진자가 있고

833
00:36:52,560 --> 00:36:54,900
엔진에는 제한된 전력이 있으며

834
00:36:54,900 --> 00:36:57,780
에이전트 자체는 목표에 도달해야 하며

835
00:36:57,780 --> 00:36:59,940
목표는 빨간색 원으로 표시되므로

836
00:36:59,940 --> 00:37:02,240


837
00:37:02,240 --> 00:37:04,740
기본적으로 이 데모에서는

838
00:37:04,740 --> 00:37:06,599
실시간으로 환경을 변경하고

839
00:37:06,599 --> 00:37:08,760
에이전트가 어떻게 반응하는지 확인할 수 있으므로

840
00:37:08,760 --> 00:37:11,099


841
00:37:11,099 --> 00:37:13,980
측정 시 소음의 양에 따라 속어로 진자의 질량을 변경할 수 있습니다. 또는

842
00:37:13,980 --> 00:37:15,780
목표를 변경할 수 있습니다.

843
00:37:15,780 --> 00:37:18,300
최대 엔진 출력 등을 변경할 수 있습니다.

844
00:37:18,300 --> 00:37:20,700


845
00:37:20,700 --> 00:37:23,220


846
00:37:23,220 --> 00:37:25,800
목표를 달성하기 위해 가능한 최선의 행동 과정을 추론하려고 시도하며 반응을 결코 멈추지 않습니다.

847
00:37:25,800 --> 00:37:28,079


848
00:37:28,079 --> 00:37:30,440
음

849
00:37:30,440 --> 00:37:33,960


850
00:37:33,960 --> 00:37:36,180
더 이상 목표에 올바르게 도달할 수 없도록 고대의 힘을 제한하는 것도 실제로 가능

851
00:37:36,180 --> 00:37:39,320
하지만 에이전트는  그래도 시도해 보세요.

852
00:37:39,320 --> 00:37:42,960
스마트 내비게이션 및 충돌 방지 기능을 갖춘 다른 멋진 데모가 있습니다.

853
00:37:42,960 --> 00:37:46,380


854
00:37:46,380 --> 00:37:48,119
아직 연구 중이고

855
00:37:48,119 --> 00:37:50,160
이에 대한 코드는 공개적으로 제공되지 않습니다.

856
00:37:50,160 --> 00:37:52,260
곧 제공될 예정이지만

857
00:37:52,260 --> 00:37:55,380
예를 들어 이 예에서는 에이전트 세트를 정의할 수 있습니다.

858
00:37:55,380 --> 00:37:57,240


859
00:37:57,240 --> 00:37:59,460
경계와

860
00:37:59,460 --> 00:38:02,640
목적지 세트를 통해 그들이 루트를 해결하려고 어떻게 노력하는지 볼 수 있습니다.

861
00:38:02,640 --> 00:38:06,540


862
00:38:06,540 --> 00:38:07,200
음,

863
00:38:07,200 --> 00:38:10,079


864
00:38:10,079 --> 00:38:13,020
맵에 정적 장애물이 있을 수 있습니다. 에이전트가 목표에 도달하기 위해 가장 최적의 경로를 찾을 수 있는 방법을 볼 수 있습니다.

865
00:38:13,020 --> 00:38:15,839


866
00:38:15,839 --> 00:38:18,839


867
00:38:18,839 --> 00:38:21,320
가능한 충돌을 피하고

868
00:38:21,320 --> 00:38:23,940


869
00:38:23,940 --> 00:38:27,119
정적 장애물도 필요하지 않습니다. 어 장애물

870
00:38:27,119 --> 00:38:30,000
자체가 움직일 수 있으므로 이 데모에는

871
00:38:30,000 --> 00:38:32,820


872
00:38:32,820 --> 00:38:35,099


873
00:38:35,099 --> 00:38:37,140
아래에서 위로 원 또는

874
00:38:37,140 --> 00:38:40,260
장애물로 이동하는 장애물 지도를 탐색하는 수백 개의 에이전트가 있으며 에이전트가 표시됩니다.

875
00:38:40,260 --> 00:38:42,900
작은 점으로서 왼쪽에서 오른쪽으로 이동해야 합니다.

876
00:38:42,900 --> 00:38:45,240
기본적으로 모든 종류의 오염을 피해야 합니다.

877
00:38:45,240 --> 00:38:47,220


878
00:38:47,220 --> 00:38:50,820
어 그리고 제가 또한 언급했듯이 우리는

879
00:38:50,820 --> 00:38:52,740
효율적이고 실시간 추론을 수행하고 싶지만

880
00:38:52,740 --> 00:38:55,260


881
00:38:55,260 --> 00:38:57,900
저전력, 저성능, 저

882
00:38:57,900 --> 00:39:00,180
성능 장치에서도 수행합니다.  예를 들어 Raspberry Pi

883
00:39:00,180 --> 00:39:03,300
또는 Coolpy를 사용하고 예를 들어 Cool Pi에서

884
00:39:03,300 --> 00:39:05,820


885
00:39:05,820 --> 00:39:07,500
베이지안 오디오 소스 분리를 ​​성공적으로 실행한 결과가 있으므로

886
00:39:07,500 --> 00:39:10,079
실제로

887
00:39:10,079 --> 00:39:13,440
활성화할 수도 있습니다. Coolpy

888
00:39:13,440 --> 00:39:16,260
에서도 활성 추론 에이전트를 실행하려고 합니다.

889
00:39:16,260 --> 00:39:20,040
앞서 언급한

890
00:39:20,040 --> 00:39:21,440
역진자

891
00:39:21,440 --> 00:39:23,160
및

892
00:39:23,160 --> 00:39:25,079
제가 언급한 것처럼

893
00:39:25,079 --> 00:39:29,220
우리는 또한 큰 모델 범위를 가져야 하며

894
00:39:29,220 --> 00:39:31,980
기본적으로 RX 추론은

895
00:39:31,980 --> 00:39:33,960


896
00:39:33,960 --> 00:39:36,599
앞서 언급한 문제를 해결하도록 설계되지 않았습니다. 특히

897
00:39:36,599 --> 00:39:38,520


898
00:39:38,520 --> 00:39:40,980
저장소에 다양한 예제 세트가 있습니다. 다양한

899
00:39:40,980 --> 00:39:42,300
모델 다양한 데이터 다양한

900
00:39:42,300 --> 00:39:44,040
영향 제약

901
00:39:44,040 --> 00:39:46,380
어 선형

902
00:39:46,380 --> 00:39:48,060
회귀 숨겨진 마르코프 모델 자동

903
00:39:48,060 --> 00:39:50,640
회귀 모델 계층 모델 혼합

904
00:39:50,640 --> 00:39:53,520
모델 가우스 프로세스 등에 대한 예가 있습니다. 따라서

905
00:39:53,520 --> 00:39:56,760
이 접근 방식은 매우 다양합니다.

906
00:39:56,760 --> 00:40:00,060
예를 들어

907
00:40:00,060 --> 00:40:02,880
음, 이를

908
00:40:02,880 --> 00:40:05,220
기존 소프트웨어 라이브러리와 비교해 보면

909
00:40:05,220 --> 00:40:07,200


910
00:40:07,200 --> 00:40:09,060
공통 필터를 해결하는 라이브러리가 매우 훌륭할 수 있다고 가정해 보겠습니다.

911
00:40:09,060 --> 00:40:11,579
라이브러리가 아마도 초고속일 수 있습니다. 최고의

912
00:40:11,579 --> 00:40:13,920
성능이 훌륭하고 매우 안정적으로 작동합니다

913
00:40:13,920 --> 00:40:15,119


914
00:40:15,119 --> 00:40:17,820
어 정말 훌륭하지만

915
00:40:17,820 --> 00:40:20,460
이 특정 모델의

916
00:40:20,460 --> 00:40:22,859
공통 필터링 권리로 인해 제한을 받고 실제로 변경할 수 없습니다.

917
00:40:22,859 --> 00:40:25,400


918
00:40:25,400 --> 00:40:29,240
우리는 우리 자신의 모델을 자유롭게 정의할 수 있습니다.

919
00:40:29,240 --> 00:40:31,800
어 우리는 매우 쉽게

920
00:40:31,800 --> 00:40:33,720


921
00:40:33,720 --> 00:40:36,599
공통 필터링 방정식과 동등하게 작동하는 모델을 정의할 수 있습니다.

922
00:40:36,599 --> 00:40:38,700
따라서 기본적으로

923
00:40:38,700 --> 00:40:40,500
객체 추적에 대해 이전에 보여드린 데모에서는

924
00:40:40,500 --> 00:40:42,839
기본적으로 공통 필터였습니다.

925
00:40:42,839 --> 00:40:43,980


926
00:40:43,980 --> 00:40:47,160
확률 모델로 작성되었습니다

927
00:40:47,160 --> 00:40:49,140


928
00:40:49,140 --> 00:40:52,200
어 그래 그게

929
00:40:52,200 --> 00:40:55,079
이 프리젠테이션에 제가 추가한 작은 내용이므로 우리 소프트웨어는

930
00:40:55,079 --> 00:40:57,960
무료입니다. MIT 라이선스이고

931
00:40:57,960 --> 00:41:00,240
GitHub에서 사용할 수 있는 오픈 소스입니다

932
00:41:00,240 --> 00:41:03,540
어 예 그리고

933
00:41:03,540 --> 00:41:05,400
우리가 발표할 수 있는 곳에서 발표할 수 있어서 기쁠 것 같습니다.

934
00:41:05,400 --> 00:41:09,920
어떤 질문이라도 기꺼이 답변해 드릴게요 감사합니다

935
00:41:12,180 --> 00:41:14,960
멋지네요 좋아요

936
00:41:15,000 --> 00:41:17,700


937
00:41:17,700 --> 00:41:19,980
채팅에서 간단히 질문하겠습니다

938
00:41:19,980 --> 00:41:22,619
Marco가

939
00:41:22,619 --> 00:41:24,900
놓쳤다면 죄송하다고 묻습니다 충돌

940
00:41:24,900 --> 00:41:27,540
방지 데모는 다른 에이전트에 실시간으로 적응하는 것입니다

941
00:41:27,540 --> 00:41:29,220
행동 아니면

942
00:41:29,220 --> 00:41:32,720
집합적으로 사전 계산된 것인가요?  경로

943
00:41:33,240 --> 00:41:35,880
음 기본적으로 그들은 어 슈퍼 실시간이 아닙니다.

944
00:41:35,880 --> 00:41:38,099


945
00:41:38,099 --> 00:41:39,839
이 경로를 계산하는 것은 다소 빠르지만 5초 정도는 될 것입니다.

946
00:41:39,839 --> 00:41:42,599
하지만 우리는 기본적으로

947
00:41:42,599 --> 00:41:44,820
이를 실시간으로 만들기 위해 노력하고 있으므로 개선해야 할 부분이 무엇인지 알고 있습니다.

948
00:41:44,820 --> 00:41:47,460


949
00:41:47,460 --> 00:41:50,339
그리고 우리는 기분을 나쁘게 만들 것입니다 예

950
00:41:50,339 --> 00:41:53,400
거의

951
00:41:53,400 --> 00:41:55,440
다음 질문과 같습니다.

952
00:41:55,440 --> 00:41:57,960
다른 방법과의 비교 데이터가 있습니까? 그리고

953
00:41:57,960 --> 00:42:00,000
더 일반적으로 어떤 종류의

954
00:42:00,000 --> 00:42:02,520
벤치마크가 있는지 또는

955
00:42:02,520 --> 00:42:04,619
다른 환경에서 업계와 이야기할 때

956
00:42:04,619 --> 00:42:07,800
사람들은 그 킬러를 찾는 것을 좋아합니까?

957
00:42:07,800 --> 00:42:09,599
능동 추론 앱 또는 그들이

958
00:42:09,599 --> 00:42:13,920
주요 측정값을 찾고 있는 것이 무엇입니까

959
00:42:13,920 --> 00:42:16,260
uh 그래서 저는 개인적으로 HMC와 같은

960
00:42:16,260 --> 00:42:19,200
샘플링 기반 방법과의 비교에 대한 큰 논문을 가지고 있으며

961
00:42:19,200 --> 00:42:23,220
또한 제 박사 과정에서도 이

962
00:42:23,220 --> 00:42:25,079
결과가

963
00:42:25,079 --> 00:42:29,280
다른 샘플링 기반 방법은 아니더라도 비교가 될 것입니다 uh  너무

964
00:42:29,280 --> 00:42:31,680
긴 이야기의 짧은 샘플링 기반 방법은

965
00:42:31,680 --> 00:42:33,900
실제로 실행할 수 없습니다. uh 이런 종류의

966
00:42:33,900 --> 00:42:36,119
정교한 추론을 실시간으로

967
00:42:36,119 --> 00:42:38,640
실행할 수 없습니다 uh 시간이 많이 걸립니다. 실제로

968
00:42:38,640 --> 00:42:40,740
큰 문제에 맞게 확장되지는 않습니다.

969
00:42:40,740 --> 00:42:42,420
이는 활성 영향에 실제로 필요한데

970
00:42:42,420 --> 00:42:44,400


971
00:42:44,400 --> 00:42:46,560
대규모 환경이 있는 경우  매우 복잡할 것입니다.

972
00:42:46,560 --> 00:42:49,619


973
00:42:49,619 --> 00:42:53,940
모델에 알 수 없는 변수가 많이 있을 것입니다. 어, 그렇죠,

974
00:42:53,940 --> 00:42:56,520
비교하는 논문이 있는데

975
00:42:56,520 --> 00:42:58,380
기본적으로 우리의 접근 방식이

976
00:42:58,380 --> 00:43:01,859
훨씬 더 잘 확장된다는 것을 보여줍니다. 그래서 저는 개인적으로

977
00:43:01,859 --> 00:43:05,180
일반 MacBook 노트북에서 실행합니다.

978
00:43:05,180 --> 00:43:08,660
200만 개의 어 알 수 없는 변수와 함께 모델을 실행했는데

979
00:43:08,660 --> 00:43:12,060


980
00:43:12,060 --> 00:43:15,240
꽤 빨랐고

981
00:43:15,240 --> 00:43:17,760
샘플링 기반 방법의 경우

982
00:43:17,760 --> 00:43:19,980
100개 정도의 변수가 있는 모델에서 자신을 발견할 수 있으며

983
00:43:19,980 --> 00:43:21,780
2시간 정도 기다렸다가 결과가

984
00:43:21,780 --> 00:43:24,300
바뀔 수도 있습니다.

985
00:43:24,300 --> 00:43:28,020
체인이 수렴되지 않았다는 점에서 어

986
00:43:28,020 --> 00:43:30,980
또는 그와 비슷한

987
00:43:31,980 --> 00:43:34,560
멋진 예 음 사람들이

988
00:43:34,560 --> 00:43:37,500
채팅에서 메시지 전달

989
00:43:37,500 --> 00:43:41,040
및 요인 그래프가 얼마나 멀리 왔는지에 대해 언급하고

990
00:43:41,040 --> 00:43:43,380
바이어스 연구실과 Bert에 대해 우리는

991
00:43:43,380 --> 00:43:44,520


992
00:43:44,520 --> 00:43:46,680
이 흥미로운 라인에 확실히 감사드립니다.

993
00:43:46,680 --> 00:43:48,420
연구 내 말은 거기에서 배울 것이 너무 많고

994
00:43:48,420 --> 00:43:50,400
때로는 방정식을 보면

995
00:43:50,400 --> 00:43:52,440


996
00:43:52,440 --> 00:43:54,720
돌에 쓰여진 것처럼 보일 수 있고 일종의

997
00:43:54,720 --> 00:43:56,400
시작과 끝이

998
00:43:56,400 --> 00:43:59,099
자유 에너지 변형을 알고 있다는 것입니다. 그러나 프레젠테이션에서는

999
00:43:59,099 --> 00:44:00,720
실제로 다음과 같은 것을 보여줍니다.

1000
00:44:00,720 --> 00:44:04,020
아니요, 우리는 실습입니다.

1001
00:44:04,020 --> 00:44:06,180
해석 가능성을 얻는 곳입니다.

1002
00:44:06,180 --> 00:44:08,700
실제로 구현되는 모듈성이며

1003
00:44:08,700 --> 00:44:11,400
정보 물류 과제와 같습니다.

1004
00:44:11,400 --> 00:44:13,800


1005
00:44:13,800 --> 00:44:16,980
그 시점에서는 난해한 철학 질문과 같지 않습니다.

1006
00:44:16,980 --> 00:44:19,800
아니요 아니요, 내 말은,

1007
00:44:19,800 --> 00:44:22,859
어라고 말해야 한다는 뜻입니다.  내 말은

1008
00:44:22,859 --> 00:44:25,619
우리는 천재가 아니기 때문에 우리 연구실은

1009
00:44:25,619 --> 00:44:28,200
8년 이상 존재했고

1010
00:44:28,200 --> 00:44:30,119
연구실에 있는 모든 사람들을 보면

1011
00:44:30,119 --> 00:44:33,060


1012
00:44:33,060 --> 00:44:35,700
이것이 지금의 위치로 작동하도록 하는 데 많은 잘못된 방향으로 수년이 걸렸습니다.

1013
00:44:35,700 --> 00:44:38,359
그래서 아주 먼 길이

1014
00:44:38,359 --> 00:44:42,060
지만 지금 이 순간 나는

1015
00:44:42,060 --> 00:44:44,640
미래의 어느 시점이 올 것이라고 확신하고 있고

1016
00:44:44,640 --> 00:44:47,339
어

1017
00:44:47,339 --> 00:44:48,839
3개월이나 1년 안에는 말하고 싶지 않지만

1018
00:44:48,839 --> 00:44:52,440


1019
00:44:52,440 --> 00:44:54,780
사람들이

1020
00:44:54,780 --> 00:44:56,700
생성 모델을 디자인하고 버튼만 누르면

1021
00:44:56,700 --> 00:44:59,040


1022
00:44:59,040 --> 00:45:00,420
영향을 잊어버릴 수 있는 도구 상자를 작성할 수 있을 것입니다. 더 이상 유아에 대해 걱정할 필요가 없습니다.

1023
00:45:00,420 --> 00:45:02,400
그것은 빠르고 자동화될 것이며 그렇게 될 것입니다.

1024
00:45:02,400 --> 00:45:05,520


1025
00:45:05,520 --> 00:45:07,400
몇 년 안에 그런 일이 일어나면

1026
00:45:07,400 --> 00:45:10,500
어, 어쩌면 다른 사람이

1027
00:45:10,500 --> 00:45:12,839
더 나은 도구 상자를 작성할 수도 있지만

1028
00:45:12,839 --> 00:45:14,960
우리 도구 상자도

1029
00:45:14,960 --> 00:45:18,300
그렇게 할 수 있을 것이라고 확신합니다. 그래서 음

1030
00:45:18,300 --> 00:45:21,240
그리고 제 생각엔 사람들이

1031
00:45:21,240 --> 00:45:24,780
어에 대해 이야기하는 걸 아시겠지만, 왜 그러지 않는 걸까요?

1032
00:45:24,780 --> 00:45:26,280


1033
00:45:26,280 --> 00:45:29,280


1034
00:45:29,280 --> 00:45:32,099


1035
00:45:32,099 --> 00:45:34,640
빅 데이터 빅 컴퓨터와 도구 상자

1036
00:45:34,640 --> 00:45:38,280
텐서플로우의 빅 데이터 가용성과 모든 성공으로 인해 딥 러닝과 생성 AI가 성공한다면 우리는 딥 러닝과 생성 AI의 성공을 거둘 수

1037
00:45:38,280 --> 00:45:40,740
없습니다. 에이전트가 자체 데이터를 수집하기 때문에 빅 데이터가 필요하지 않습니다.

1038
00:45:40,740 --> 00:45:42,839
또는

1039
00:45:42,839 --> 00:45:45,119
필터에는 대형 컴퓨터 활성 관심 에이전트가 필요하지 않습니다.

1040
00:45:45,119 --> 00:45:47,700


1041
00:45:47,700 --> 00:45:49,920
그들이 전력 자원을 관리한다는 것을 알고

1042
00:45:49,920 --> 00:45:51,119


1043
00:45:51,119 --> 00:45:53,099
있지만

1044
00:45:53,099 --> 00:45:54,980


1045
00:45:54,980 --> 00:45:57,300
프로그래밍 및 활성 추론 에이전트를

1046
00:45:57,300 --> 00:45:59,280
직접 프로그래밍하는 것은

1047
00:45:59,280 --> 00:46:00,599
불가능하므로

1048
00:46:00,599 --> 00:46:04,140
정말 좋은 도구 상자가 필요합니다.

1049
00:46:04,140 --> 00:46:06,300
이것을 실제로 자동화하는 도구 상자

1050
00:46:06,300 --> 00:46:08,160
우리는 어

1051
00:46:08,160 --> 00:46:10,140
우리의 예가 수행할 처음 두 상자 중 하나가 되기를 바랍니다.

1052
00:46:10,140 --> 00:46:13,140
나는 다른

1053
00:46:13,140 --> 00:46:15,720
사람들도 어 그것에 대해 작업하고

1054
00:46:15,720 --> 00:46:18,480
더 나은 도구 상자가 나올 것이라고 확신합니다. 음

1055
00:46:18,480 --> 00:46:20,839
하지만 낙관적인

1056
00:46:20,839 --> 00:46:24,300
메시지는 다음과 같습니다.  그것이 바로 일어날 것이라고 어

1057
00:46:24,300 --> 00:46:26,760
그리고 일단 그런 도구 상자가 있으면

1058
00:46:26,760 --> 00:46:28,859
실제로 대규모 커뮤니티가

1059
00:46:28,859 --> 00:46:31,260
에이전트 구축을 시작할 수 있고 우리는

1060
00:46:31,260 --> 00:46:32,579
실제로

1061
00:46:32,579 --> 00:46:33,960


1062
00:46:33,960 --> 00:46:36,180
현장에 배포 가능한 에이전트가 제대로

1063
00:46:36,180 --> 00:46:38,339
작동하고 강화 부동 에이전트보다 더 잘 작동한다는 것을 보여줄 수 있습니다

1064
00:46:38,339 --> 00:46:40,260
아니면

1065
00:46:40,260 --> 00:46:42,780
거기에 있는 것이 무엇이든

1066
00:46:42,780 --> 00:46:44,940
음 그래서 그건 매우

1067
00:46:44,940 --> 00:46:48,240
긍정적이고 희망적인 메시지인 것 같아요

1068
00:46:48,240 --> 00:46:50,160
그것은 우리가 기대하는 것입니다 그것이 우리가 선호하는 것입니다

1069
00:46:50,160 --> 00:46:52,980
예 예 예

1070
00:46:52,980 --> 00:46:57,560
두 분 중 마지막 댓글은

1071
00:46:59,280 --> 00:47:01,260
음 우리의 댓글에서 아니요 아니요 우리는 단지

1072
00:47:01,260 --> 00:47:03,839
저는 단지 매우  기회를 얻게 되어 기쁘고

1073
00:47:03,839 --> 00:47:07,020
어 예 저는 그러고 싶습니다 어 그럼 예 음

1074
00:47:07,020 --> 00:47:09,420


1075
00:47:09,420 --> 00:47:13,440
모두가 이 도구 상자를 다운로드할 수 있습니다.

1076
00:47:13,440 --> 00:47:15,960
음 지금 이 순간에도 도구 상자를 사용하려면 여전히 프로그래머여야 한다고 생각합니다.

1077
00:47:15,960 --> 00:47:18,599


1078
00:47:18,599 --> 00:47:19,680


1079
00:47:19,680 --> 00:47:22,500
친하게 지냈으면 좋겠습니다.

1080
00:47:22,500 --> 00:47:25,800
어

1081
00:47:25,800 --> 00:47:27,960
우리가 원하는 방식으로 완벽하게 다듬어지지는 않았지만 바로 올 것입니다.

1082
00:47:27,960 --> 00:47:30,119
내년에 올 것입니다.

1083
00:47:30,119 --> 00:47:31,800
거의 모든 사람이 사용할 수 있는 좋은 도구 상자가 있을 것이지만

1084
00:47:31,800 --> 00:47:34,260


1085
00:47:34,260 --> 00:47:35,640
관심 있는 사람들

1086
00:47:35,640 --> 00:47:37,680
심지어 여기에서 슬래브를 구입하는 데 관심이 있는 사람들도 있습니다.

1087
00:47:37,680 --> 00:47:39,480


1088
00:47:39,480 --> 00:47:43,500
어 박사 과정 학생을 위한 공석이 있어서 어 음

1089
00:47:43,500 --> 00:47:47,099
우리는 우리와 함께 일하고 싶어하는

1090
00:47:47,099 --> 00:47:48,900
관심 있는 사람들로부터 이메일을 받게 되어 기쁩니다.

1091
00:47:48,900 --> 00:47:52,040


1092
00:47:52,619 --> 00:47:56,599
감사합니다 디미트리 마무리에 필요한 모든 것

1093
00:47:56,640 --> 00:47:59,400
아니요 단지 그것만으로도 감사합니다 네 아주 좋은 발표 가능성에 대해 다시 한 번 감사드립니다

1094
00:47:59,400 --> 00:48:01,560


1095
00:48:01,560 --> 00:48:03,000


1096
00:48:03,000 --> 00:48:05,460
네, 올해 말에 우리는

1097
00:48:05,460 --> 00:48:08,940
귀하의 두 부분으로 구성된 최근 작업에 대해 논의할 예정이므로

1098
00:48:08,940 --> 00:48:11,400


1099
00:48:11,400 --> 00:48:14,579
세부 사항에 대해 많은 정보를 얻을 것입니다.

1100
00:48:14,579 --> 00:48:16,260
생태계에 있는 The Institute의 사람들이 다음

1101
00:48:16,260 --> 00:48:19,319
과 같이 흥분할 수 있기를 바랍니다.  우리 모두 너무

1102
00:48:19,319 --> 00:48:24,319
고마워요 알았어 고마워요 안녕 안녕 알았어 알았어

1103
00:48:32,940 --> 00:48:35,720


1104
00:48:37,260 --> 00:48:40,040


1105
00:48:43,200 --> 00:48:46,079
다음 시간 동안

1106
00:48:46,079 --> 00:48:48,680
우리는

