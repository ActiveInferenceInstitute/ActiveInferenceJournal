1
00:00:00,359 --> 00:00:03,199
分かった、

2
00:00:05,940 --> 00:00:08,820
挨拶、分かった、次の

3
00:00:08,820 --> 00:00:12,300
セッション、やあ、バート、ご挨拶、

4
00:00:12,300 --> 00:00:14,280
調子はどうですか、とても順調です、

5
00:00:14,280 --> 00:00:15,059


6
00:00:15,059 --> 00:00:17,220
えー、次のセッションはバードデバイスのディミトリ・

7
00:00:17,220 --> 00:00:20,580
バガエフとバート・ファン・エルプとのセッションです。

8
00:00:20,580 --> 00:00:22,740


9
00:00:22,740 --> 00:00:24,720
合成アクティブ推論のユーザーフレンドリーな設計に向けて呼び出されます。

10
00:00:24,720 --> 00:00:27,480
エージェントも私も、多くの人が

11
00:00:27,480 --> 00:00:30,119
この本当に実用的で最先端の作品を見てとても興奮していることを知っ

12
00:00:30,119 --> 00:00:32,759


13
00:00:32,759 --> 00:00:35,100
ています。それではバートさん、私たちがどのようにサポートできるか教えてください。わかりました、

14
00:00:35,100 --> 00:00:36,600


15
00:00:36,600 --> 00:00:40,680
素晴らしいです、そうですね、私のオーディオは良好です、はい、

16
00:00:40,680 --> 00:00:44,040
いい音です、それでは私が行きます 画面を共有してください、ああ、

17
00:00:44,040 --> 00:00:46,739


18
00:00:46,739 --> 00:00:48,719
正しいものを選んだといいのですが、

19
00:00:48,719 --> 00:00:52,079
うまくいきません、Zoom です、よく見えます、よく見えます、

20
00:00:52,079 --> 00:00:55,140


21
00:00:55,140 --> 00:00:57,719
はい、わかりました、スーパー えー、このシンポジウムを主催してくれたダニエルにとても感謝しています。

22
00:00:57,719 --> 00:01:00,239


23
00:01:00,239 --> 00:01:02,100
いくつかの講演を見てきました。 本当に素晴らしいです。

24
00:01:02,100 --> 00:01:05,400
そして、私たちは

25
00:01:05,400 --> 00:01:07,619
自分自身を発表する機会を得ることができて光栄に思っています。

26
00:01:07,619 --> 00:01:09,780
私たちも他の数人と同じように、

27
00:01:09,780 --> 00:01:11,640


28
00:01:11,640 --> 00:01:13,920
能動的推論のためのツールボックスの開発に興味を持っています。

29
00:01:13,920 --> 00:01:17,760
この写真は、

30
00:01:17,760 --> 00:01:18,900
私たちが

31
00:01:18,900 --> 00:01:20,820
何であるかを示しています。 私たちは何について、あるいは何に

32
00:01:20,820 --> 00:01:23,700
興味を持っているので、左側に女性がいます。

33
00:01:23,700 --> 00:01:26,100


34
00:01:26,100 --> 00:01:27,420


35
00:01:27,420 --> 00:01:30,119
レーザーポインターを手に入れようとしています。彼女は掃除ロボット

36
00:01:30,119 --> 00:01:33,600
にとってやりがいのある行動についてアイデアを持っているので、こう

37
00:01:33,600 --> 00:01:36,000


38
00:01:36,000 --> 00:01:37,799
書いています。 彼女はテキスト

39
00:01:37,799 --> 00:01:39,900
表現を持っていますが、アパートの中を動き回ります。

40
00:01:39,900 --> 00:01:42,420
床がきれいになるまで吸引を適用します。

41
00:01:42,420 --> 00:01:45,180
物に触れないでください。また、

42
00:01:45,180 --> 00:01:47,400
犬の元に戻らないようにしてください。そうするのはそれほど

43
00:01:47,400 --> 00:01:50,520
難しいことではありません。3 つ星中 1 つ星と評価します。

44
00:01:50,520 --> 00:01:52,259


45
00:01:52,259 --> 00:01:55,560
それを指定するのは難しい難易度です

46
00:01:55,560 --> 00:01:58,320
が、これらのロボットを正しくプログラムするにはそれだけでは十分ではありません。なぜなら

47
00:01:58,320 --> 00:02:00,000
彼女が今本当にしなければならないのは

48
00:02:00,000 --> 00:02:02,939


49
00:02:02,939 --> 00:02:06,299
生成モデルを指定することです。そして、ロボットが動き回る必要がある適切なエフェクターとアクチュエーターがあることは知っているからです。

50
00:02:06,299 --> 00:02:09,479


51
00:02:09,479 --> 00:02:12,420


52
00:02:12,420 --> 00:02:15,360
床がきれいになるまで吸引を適用します。そのため、

53
00:02:15,360 --> 00:02:18,480
センサーがおそらくカメラが

54
00:02:18,480 --> 00:02:20,459
物体に触れないようにします。そのため、おそらく物体

55
00:02:20,459 --> 00:02:23,099
認識が必要です。ここでこの生成モデルを考え出すのは非常に困難な

56
00:02:23,099 --> 00:02:25,680
作業であり、

57
00:02:25,680 --> 00:02:28,680
その上、

58
00:02:28,680 --> 00:02:31,860
この種類を指定する必要があります。

59
00:02:31,860 --> 00:02:34,140


60
00:02:34,140 --> 00:02:36,300
この

61
00:02:36,300 --> 00:02:39,120
生成モデルの確率分布に関しては、報酬を与える行動が非常に難しいので、

62
00:02:39,120 --> 00:02:40,560
星 2 つと評価します。

63
00:02:40,560 --> 00:02:42,720
なぜなら、

64
00:02:42,720 --> 00:02:45,060
彼女がこのモデルに対して次にしなければならないことは、

65
00:02:45,060 --> 00:02:47,220


66
00:02:47,220 --> 00:02:49,800
実際にアクティブな

67
00:02:49,800 --> 00:02:52,379
推論とフリーランスを行うための推論手順を指定することだからです。 リアルタイムでの最小化

68
00:02:52,379 --> 00:02:53,400


69
00:02:53,400 --> 00:02:56,459
やこの複雑なモデルは、実際には

70
00:02:56,459 --> 00:02:59,540
ほとんど不可能です。非常に難しいモデルで変分自由エネルギー最小化の

71
00:02:59,540 --> 00:03:02,940
手順を実際に書ける専門家は数人だけです。その

72
00:03:02,940 --> 00:03:04,319


73
00:03:04,319 --> 00:03:06,540


74
00:03:06,540 --> 00:03:09,780
ため、私たちが

75
00:03:09,780 --> 00:03:12,599
取り組んできたことについては、 推論タスクを自動化する

76
00:03:12,599 --> 00:03:14,580
ので、

77
00:03:14,580 --> 00:03:17,459
3 つの星を削除します。はい、彼女は

78
00:03:17,459 --> 00:03:20,159
モデルを指定する必要がありますが、長期

79
00:03:20,159 --> 00:03:23,220
的にはそこから逃れようとしているので、

80
00:03:23,220 --> 00:03:25,500
長期的にはツールボックスを入手できることを願っています。

81
00:03:25,500 --> 00:03:27,720
5 10

82
00:03:27,720 --> 00:03:31,440
年前に話したところ、

83
00:03:31,440 --> 00:03:33,780


84
00:03:33,780 --> 00:03:36,959
初期事前確率で初期モデルを指定するにはテキストの説明で十分で、それ

85
00:03:36,959 --> 00:03:39,060
以外は単に状態

86
00:03:39,060 --> 00:03:42,120
パラメータの自動推論学習であり、

87
00:03:42,120 --> 00:03:44,280


88
00:03:44,280 --> 00:03:48,360
おそらく彼女のフィードバックに基づいてモデルを構造的に適応させて、えー、事前確率を更新するということです。

89
00:03:48,360 --> 00:03:52,440
長期的には、

90
00:03:52,440 --> 00:03:55,140
今のところ、

91
00:03:55,140 --> 00:04:00,060
推論のタスクを自動化できれば非常にうれしいのですが、

92
00:04:00,060 --> 00:04:02,459


93
00:04:02,459 --> 00:04:04,560
アクティブな推論エージェントの推論を指定するのはなぜそれほど難しいのですか、

94
00:04:04,560 --> 00:04:07,819
競合する

95
00:04:07,819 --> 00:04:11,519
KPI が非常に多くあります。 これは

96
00:04:11,519 --> 00:04:15,180
大規模なモデルのスコープです。ABCD モデルだけでなく、

97
00:04:15,180 --> 00:04:17,720
連続

98
00:04:17,720 --> 00:04:19,738
変数や

99
00:04:19,738 --> 00:04:22,440
生物学的モデルも含まれる可能性があります。

100
00:04:22,440 --> 00:04:24,960
非常にユーザー フレンドリーである必要があります。

101
00:04:24,960 --> 00:04:29,220
コードの堅牢性について

102
00:04:29,220 --> 00:04:30,960
彼女に心配してほしくないのです。ええと、私たちは彼女に、

103
00:04:30,960 --> 00:04:32,880


104
00:04:32,880 --> 00:04:36,180
ええと、2 つの変数には良好な関係があります。

105
00:04:36,180 --> 00:04:38,220


106
00:04:38,220 --> 00:04:40,320
ええと、適応性を更新したいのです

107
00:04:40,320 --> 00:04:42,540
が、状態パラメータもおそらくモデルです。

108
00:04:42,540 --> 00:04:45,060


109
00:04:45,060 --> 00:04:48,180
これらのエンジェルはエッジ デバイスで実行されることが多いため、モデル構造は低電力でなければなりません。

110
00:04:48,180 --> 00:04:50,759


111
00:04:50,759 --> 00:04:53,340
バッテリー駆動で実行する必要があるからです。 リアルタイム

112
00:04:53,340 --> 00:04:55,979
というのは、

113
00:04:55,979 --> 00:04:58,139
リアルタイムの推論がなければ自転車の乗り方を学べないからで、

114
00:04:58,139 --> 00:05:01,259
それに加えて実際には

115
00:05:01,259 --> 00:05:03,000
現実の変化を最小限に抑えたいので、

116
00:05:03,000 --> 00:05:04,740
少なくとも同じくらいか、

117
00:05:04,740 --> 00:05:06,780
少なくともその近辺で自転車の乗り方を学びたいのです。

118
00:05:06,780 --> 00:05:09,720
手動導出を行う場合、これらの一部は

119
00:05:09,720 --> 00:05:11,880
かなり噛み合います。

120
00:05:11,880 --> 00:05:14,520


121
00:05:14,520 --> 00:05:16,740
変分自由エネルギーを最小限に抑えたいが、

122
00:05:16,740 --> 00:05:19,259
リアルタイムで低電力で実行する必要がある場合、

123
00:05:19,259 --> 00:05:21,479
そのようなものは噛み合います。

124
00:05:21,479 --> 00:05:23,340
これらは

125
00:05:23,340 --> 00:05:27,600
難しい KPI であり、私たちがそうしたいのですが、

126
00:05:27,600 --> 00:05:30,000
それらはすべて重要です、

127
00:05:30,000 --> 00:05:31,380
1 つだけ取り出すことはできません、そうすれ

128
00:05:31,380 --> 00:05:33,180
ばシステム全体が

129
00:05:33,180 --> 00:05:35,520
機能しなくなるからです、

130
00:05:35,520 --> 00:05:37,320


131
00:05:37,320 --> 00:05:40,860
ええと、能動推論に関する論文を読むときは、

132
00:05:40,860 --> 00:05:44,039
よく次のようなことも読みます。 今、

133
00:05:44,039 --> 00:05:46,259
バリエーションの最小化を実装します。

134
00:05:46,259 --> 00:05:49,380
これはグラフ上のメッセージ パッシングによって実行できます。

135
00:05:49,380 --> 00:05:53,639
最初に、

136
00:05:53,639 --> 00:05:56,039
なぜグラフ上のメッセージ パッシングによって実行する必要があるのか​​を明確にしたいと思います。

137
00:05:56,039 --> 00:05:57,539


138
00:05:57,539 --> 00:05:58,919
えー、非常に短い答えを与えることでそれを実行し

139
00:05:58,919 --> 00:06:00,120


140
00:06:00,120 --> 00:06:02,960
ます。 例 短い答えは、

141
00:06:02,960 --> 00:06:08,759
ベイズ推論には、左側に表示されているような

142
00:06:08,759 --> 00:06:11,340
非常に大きな積の合計を計算することが含まれます。

143
00:06:11,340 --> 00:06:13,199


144
00:06:13,199 --> 00:06:16,160
ここに積 AC

145
00:06:16,160 --> 00:06:19,800
adbc があり、それから AC プラス 80 などで送信します。

146
00:06:19,800 --> 00:06:21,840
これは積の和です。

147
00:06:21,840 --> 00:06:26,039
これで、分配法則によって、

148
00:06:26,039 --> 00:06:28,380
左側のこれも

149
00:06:28,380 --> 00:06:31,860
右側のように計算できることがわかりました。

150
00:06:31,860 --> 00:06:34,259
これを掛けると、C の倍と

151
00:06:34,259 --> 00:06:36,900
D の倍などが得られ、これは合計の積です。

152
00:06:36,900 --> 00:06:39,000


153
00:06:39,000 --> 00:06:41,819
まったく同じことですが、唯一の

154
00:06:41,819 --> 00:06:44,400
違いは、左側を計算するには

155
00:06:44,400 --> 00:06:47,160
4 つの加算が必要です、申し訳ありませんが、

156
00:06:47,160 --> 00:06:49,979
4 つの乗算と 3 つの加算が必要です。

157
00:06:49,979 --> 00:06:52,919
右側を計算するには、2 つの

158
00:06:52,919 --> 00:06:54,300
加算と 1 つの

159
00:06:54,300 --> 00:06:57,600
乗算が必要なので、右側の

160
00:06:57,600 --> 00:07:00,240
計算ははるかに安価です。 通常、左側に

161
00:07:00,240 --> 00:07:03,259


162
00:07:03,259 --> 00:07:05,819
疎外とアジアの推論を書き出すとき、

163
00:07:05,819 --> 00:07:08,639


164
00:07:08,639 --> 00:07:11,460
左側にあるように、メッセージパッシングが

165
00:07:11,460 --> 00:07:13,500
グラフ上で行うことを書きます。これは、

166
00:07:13,500 --> 00:07:16,919


167
00:07:16,919 --> 00:07:20,099
合計とIの積を評価するために、それをさらに深く自動的に変換します。 その例を示します。

168
00:07:20,099 --> 00:07:22,259


169
00:07:22,259 --> 00:07:23,460
えー、

170
00:07:23,460 --> 00:07:27,900
これが例です。

171
00:07:27,900 --> 00:07:31,319
7 つの変数 X1 X2 から X7 のモデル F です。

172
00:07:31,319 --> 00:07:34,319
このモデルは

173
00:07:34,319 --> 00:07:39,300
たまたま因数分解されます。 X1 fbx2 の F A などです。

174
00:07:39,300 --> 00:07:42,479
この因数分解をグラフとして描くことができます。

175
00:07:42,479 --> 00:07:44,699
これは

176
00:07:44,699 --> 00:07:46,919
フォーニースタイルの因子グラフと呼ばれます。私たちが行うことは、

177
00:07:46,919 --> 00:07:51,300
各因子 F A に対してノードを割り当てること

178
00:07:51,300 --> 00:07:54,780
で、FB がノートを取得し、FC がノートを取得し

179
00:07:54,780 --> 00:07:58,020
、システム内の変数を

180
00:07:58,020 --> 00:08:00,720
エッジに関連付け、エッジが

181
00:08:00,720 --> 00:08:03,780
接続されます。 その変数が

182
00:08:03,780 --> 00:08:07,440
その関数の引数である場合、FC は

183
00:08:07,440 --> 00:08:12,060
X1 X2 X3 の F の関数です。

184
00:08:12,060 --> 00:08:14,880
つまり、FC はエッジ X1 X2 X3 に接続され

185
00:08:14,880 --> 00:08:20,039
、FD は X4 のみの関数である

186
00:08:20,039 --> 00:08:24,419
ため、D が エッジ X4 なので、

187
00:08:24,419 --> 00:08:26,580
このグラフでわかることは、この

188
00:08:26,580 --> 00:08:28,500
グラフは、

189
00:08:28,500 --> 00:08:31,399


190
00:08:31,399 --> 00:08:35,339
このモデルに対して現在持っている因数分解の仮定を視覚化したものにほかなりません。

191
00:08:35,339 --> 00:08:37,860
大きな

192
00:08:37,860 --> 00:08:41,820
限界化に興味がある場合、タスクは

193
00:08:41,820 --> 00:08:47,220
X3 を除くすべての変数を統合するため、X1 X2 になります。  X4

194
00:08:47,220 --> 00:08:49,680
など X7 まで 私は

195
00:08:49,680 --> 00:08:51,540
これに興味があります。

196
00:08:51,540 --> 00:08:52,860
それでは、

197
00:08:52,860 --> 00:08:55,800
この

198
00:08:55,800 --> 00:08:58,560
因数分解を利用して、この合計を以下のように合計の積に書き換えることができます。

199
00:08:58,560 --> 00:09:03,620


200
00:09:03,620 --> 00:09:09,060


201
00:09:09,060 --> 00:09:10,980
以下に表示される内容は、

202
00:09:10,980 --> 00:09:13,080
正確に計算されます。 同じことですが、

203
00:09:13,080 --> 00:09:16,519
この分配法則を利用しました。たとえば、

204
00:09:16,519 --> 00:09:22,080
FC には X4 も X5 も含まれていないので、

205
00:09:22,080 --> 00:09:25,080
左側の合計記号の上に移動し、

206
00:09:25,080 --> 00:09:30,660
FB にも X4 X5 x67 が含まれていないので、

207
00:09:30,660 --> 00:09:32,760
それを

208
00:09:32,760 --> 00:09:35,700
これを実行すると、ここでは

209
00:09:35,700 --> 00:09:38,279


210
00:09:38,279 --> 00:09:42,480
2 つの 2 つの変数の一部だけを計算した式が残りますが、

211
00:09:42,480 --> 00:09:44,519
ここでは

212
00:09:44,519 --> 00:09:46,860
6 つの変数、ここでは 2 つ、ここでは

213
00:09:46,860 --> 00:09:49,920
2 つ以上の変数を合計する必要があるので、各変数がそうであるかどうかを想像できます

214
00:09:49,920 --> 00:09:53,760
X1  X2 各

215
00:09:53,760 --> 00:09:56,399
変数に合計する必要がある興味深い値が 10 個ある場合、

216
00:09:56,399 --> 00:09:57,959


217
00:09:57,959 --> 00:10:00,180
ここに

218
00:10:00,180 --> 00:10:03,360
元の周辺化問題があります。10 の

219
00:10:03,360 --> 00:10:06,240
6 乗なので 100 万個の項があり、ここでは

220
00:10:06,240 --> 00:10:08,940


221
00:10:08,940 --> 00:10:12,000
赤で示しています。100 個の項があり、ここでは

222
00:10:12,000 --> 00:10:14,940
100 があり、ここでは次のようになります。  100 ということは、ここには

223
00:10:14,940 --> 00:10:18,060
300 項があり、ここには 100 万項があるということで、

224
00:10:18,060 --> 00:10:20,820


225
00:10:20,820 --> 00:10:23,240


226
00:10:23,240 --> 00:10:24,920


227
00:10:24,920 --> 00:10:28,620
この分配

228
00:10:28,620 --> 00:10:31,860
法則を利用すると、計算の複雑さが大幅に軽減されます。これを書き出すと、

229
00:10:31,860 --> 00:10:36,000
これらの

230
00:10:36,000 --> 00:10:38,459
中間因子を次の要素に関連付けることができることがわかります。 グラフ上のメッセージ

231
00:10:38,459 --> 00:10:40,620
これは単なる解釈です

232
00:10:40,620 --> 00:10:43,860
視覚的な解釈です

233
00:10:43,860 --> 00:10:45,720
FCが

234
00:10:45,720 --> 00:10:49,140
FAからメッセージを受信し、FBが

235
00:10:49,140 --> 00:10:51,839
受信するか、FCが

236
00:10:51,839 --> 00:10:55,260
FBからXからのメッセージを受信して​​送信

237
00:10:55,260 --> 00:10:58,740
メッセージmu X3を計算します。Feについても同様で、

238
00:10:58,740 --> 00:11:01,680
Feがメッセージを受信します

239
00:11:01,680 --> 00:11:04,920
隣接する因子 FD と FF から

240
00:11:04,920 --> 00:11:07,640
出力メッセージ

241
00:11:07,640 --> 00:11:12,660
または X3 を計算するため、ここでわかることは、

242
00:11:12,660 --> 00:11:15,660
疎外プロセス全体が

243
00:11:15,660 --> 00:11:18,899
基本的にグラフ上でいくつかのメッセージを計算し

244
00:11:18,899 --> 00:11:20,820


245
00:11:20,820 --> 00:11:22,860
、これらのメッセージの一部を

246
00:11:22,860 --> 00:11:25,500
相互に乗算することによって表すことができるということです。 これが

247
00:11:25,500 --> 00:11:27,540
ベース推論を行う方法であり、

248
00:11:27,540 --> 00:11:29,399
変分自由

249
00:11:29,399 --> 00:11:33,959
エネルギー最小化を行う方法です。したがって、これは因数分解されたモデルで機能しますが、

250
00:11:33,959 --> 00:11:38,220


251
00:11:38,220 --> 00:11:40,140
モデルが因数分解されておらず、変数がたくさんある場合はさらに強力になると思います。

252
00:11:40,140 --> 00:11:42,180


253
00:11:42,180 --> 00:11:45,300


254
00:11:45,300 --> 00:11:48,240
適切な推論を行う方法で、本格的な

255
00:11:48,240 --> 00:11:51,000
モデルは脳がほとんどまばらであるかのように因数分解されます。脳はほとんど

256
00:11:51,000 --> 00:11:54,779
空です。

257
00:11:54,779 --> 00:11:58,019
約 100 億のニューロンがあり、

258
00:11:58,019 --> 00:11:59,940
各ニューロンは他の数千のニューロンに接続しています。

259
00:11:59,940 --> 00:12:02,519


260
00:12:02,519 --> 00:12:04,800
グラフを描くとしたら、そのグラフ ほとんど空です

261
00:12:04,800 --> 00:12:08,700
非常にスパースなので、

262
00:12:08,700 --> 00:12:10,620
脳内で推論を行うには

263
00:12:10,620 --> 00:12:12,540


264
00:12:12,540 --> 00:12:14,519
メッセージ パッシング以外に方法はありません ええと、だからメッセージ パッシングが他の何

265
00:12:14,519 --> 00:12:16,200
よりも効果的であるという理由だけで、

266
00:12:16,200 --> 00:12:18,500


267
00:12:18,500 --> 00:12:22,440
問題はどのメッセージを

268
00:12:22,440 --> 00:12:25,920
どのように計算するかです メッセージを計算するのは、

269
00:12:25,920 --> 00:12:28,320


270
00:12:28,320 --> 00:12:30,360
それを正しく行うさまざまな方法があり、

271
00:12:30,360 --> 00:12:32,160


272
00:12:32,160 --> 00:12:34,339
変分メッセージパッシング、

273
00:12:34,339 --> 00:12:37,440
期待値の最大化、信念

274
00:12:37,440 --> 00:12:39,240
伝播、

275
00:12:39,240 --> 00:12:42,360
変分ラプラスによってこれを行うことができるという能動的推論の論文も読んだためです。これらすべての項には

276
00:12:42,360 --> 00:12:46,260
傘があることがわかります。 フレーム

277
00:12:46,260 --> 00:12:48,300
ワークを渡すこれらすべてのメソッドの

278
00:12:48,300 --> 00:12:50,700
フレームワークであり、その包括的なフレームワークは

279
00:12:50,700 --> 00:12:53,220
制約の改善された

280
00:12:53,220 --> 00:12:56,459
自由エネルギー最小化と呼ばれます。そして、

281
00:12:56,459 --> 00:12:57,920


282
00:12:57,920 --> 00:13:02,040
このスライドでそれを説明しようとします。

283
00:13:02,040 --> 00:13:05,160
それで、ここにこのグラフがあります。これは

284
00:13:05,160 --> 00:13:06,980


285
00:13:06,980 --> 00:13:11,839
私の生成モデルが 基本的に

286
00:13:11,839 --> 00:13:17,399
dnfe の F A FB FC を因数分解します。

287
00:13:17,399 --> 00:13:19,560
ここでも書きましたが、これは

288
00:13:19,560 --> 00:13:21,779
自由エネルギーの変化です。X

289
00:13:21,779 --> 00:13:25,260


290
00:13:25,260 --> 00:13:29,399
の Q については何の仮定も行っていないので、X の Q は依然として X1 X2 X3 の Q です。

291
00:13:29,399 --> 00:13:32,820
全体的な変数を結合しており、

292
00:13:32,820 --> 00:13:34,079
因数分解の仮定はありません。

293
00:13:34,079 --> 00:13:36,120


294
00:13:36,120 --> 00:13:39,240
えー、

295
00:13:39,240 --> 00:13:41,940
事後的な種類の

296
00:13:41,940 --> 00:13:43,920
因数分解の仮定、

297
00:13:43,920 --> 00:13:47,339
つまり生成モデルの事前の

298
00:13:47,339 --> 00:13:49,260
仮定に従うと仮定することも理にかなっています。そのため、その仮定を置く

299
00:13:49,260 --> 00:13:51,959
と、つまり次のようになります。

300
00:13:51,959 --> 00:13:55,320
Q X も a の X の qas の積であると仮定します。ここで、a の

301
00:13:55,320 --> 00:13:57,180


302
00:13:57,180 --> 00:14:01,620
X の qas は

303
00:14:01,620 --> 00:14:04,320
音符に対する信念を表します。つまり、

304
00:14:04,320 --> 00:14:08,220
B の Q は a であるということは、

305
00:14:08,220 --> 00:14:10,760
このノードに対する事後信念であり、それが

306
00:14:10,760 --> 00:14:13,800
事後であることを意味します

307
00:14:13,800 --> 00:14:17,700
FB が X1 X2 X 4 の関数であるのと同じように、これらのノードに接続するエッジに対する信念は、

308
00:14:17,700 --> 00:14:20,760


309
00:14:20,760 --> 00:14:23,220
事前

310
00:14:23,220 --> 00:14:26,279
モデルまたは生成モデルの場合、

311
00:14:26,279 --> 00:14:28,500
このノードの変分事後 Q of B

312
00:14:28,500 --> 00:14:32,839
も X1 X2 X4 に依存します。 他の

313
00:14:32,839 --> 00:14:36,660
要因 これを行うと、

314
00:14:36,660 --> 00:14:39,720
一部の変数が 2 倍にカウントされることになります。X1 は

315
00:14:39,720 --> 00:14:43,380
F A に対する信念の一部であるだけ

316
00:14:43,380 --> 00:14:47,399
でなく、FB に対する信念の一部でもあるため、

317
00:14:47,399 --> 00:14:49,860


318
00:14:49,860 --> 00:14:53,760
エッジに対する信念で割ることでそれを割り引く必要があります

319
00:14:53,760 --> 00:14:57,240
。つまり、 ここで、

320
00:14:57,240 --> 00:15:01,680
私が事後的に信じていることは、メモ

321
00:15:01,680 --> 00:15:05,639
に対するローカルな信念

322
00:15:05,639 --> 00:15:08,100
と、変数に対するエッジに対するローカルな信念に分けられるという仮定を立てます。

323
00:15:08,100 --> 00:15:09,540


324
00:15:09,540 --> 00:15:12,779
これにより、

325
00:15:12,779 --> 00:15:16,860
実際、グラフがツリーであり、

326
00:15:16,860 --> 00:15:19,560
ここでもツリーである場合、物事がはるかに単純になります。

327
00:15:19,560 --> 00:15:21,600
そのツリーを渡すと、それを完璧に実行できると想定できます。

328
00:15:21,600 --> 00:15:23,579
すべてが線形

329
00:15:23,579 --> 00:15:25,800
ガウスです。その後、完璧なベイズ

330
00:15:25,800 --> 00:15:28,980
推論が得られます。近似がない

331
00:15:28,980 --> 00:15:32,100


332
00:15:32,100 --> 00:15:33,959


333
00:15:33,959 --> 00:15:35,279
ため、これは良い仮定です。場合によっては、メッセージを計算するのは依然として非常に困難です。

334
00:15:35,279 --> 00:15:38,660


335
00:15:38,660 --> 00:15:41,040
これらのノードから出てくるメッセージは、静止

336
00:15:41,040 --> 00:15:44,100
積分または合計、

337
00:15:44,100 --> 00:15:46,019
特に積分は

338
00:15:46,019 --> 00:15:47,760
分析的な答えがない可能性がある問題である可能性がある

339
00:15:47,760 --> 00:15:51,480
ため、私たちが時々行うことは、追加の仮定を追加することですが、

340
00:15:51,480 --> 00:15:53,100


341
00:15:53,100 --> 00:15:56,279
よく言えば、

342
00:15:56,279 --> 00:15:59,519
FD に対する事後信念です。

343
00:15:59,519 --> 00:16:01,139
一般的に計算することはできません

344
00:16:01,139 --> 00:16:03,420
が、

345
00:16:03,420 --> 00:16:06,300
ガウス関数を使用すると計算が簡単になると仮定します。または、

346
00:16:06,300 --> 00:16:08,399
追加の因数分解の仮定を行って、

347
00:16:08,399 --> 00:16:09,959


348
00:16:09,959 --> 00:16:13,260


349
00:16:13,260 --> 00:16:16,320
実際には結合

350
00:16:16,320 --> 00:16:20,420
X1 X2 X4 に対する信念である FB に対する事後信念が次のようになります。 ええと、

351
00:16:20,420 --> 00:16:25,380
X1 に関する独立した信念と、ええと

352
00:16:25,380 --> 00:16:26,940


353
00:16:26,940 --> 00:16:29,880
X2 と X4 に関する信念に分割されます。ええと、

354
00:16:29,880 --> 00:16:30,740


355
00:16:30,740 --> 00:16:34,920
これらの追加の仮定も

356
00:16:34,920 --> 00:16:36,839
同様に課す場合、これを今呼びます。

357
00:16:36,839 --> 00:16:39,899


358
00:16:39,899 --> 00:16:42,540


359
00:16:42,540 --> 00:16:45,180
拘束されたベータフリーエネルギーと呼ばれるもの これは

360
00:16:45,180 --> 00:16:47,459
オッペンハイマーの映画と同じ死です

361
00:16:47,459 --> 00:16:50,339
これはハンスベータにちなんで名付けられました

362
00:16:50,339 --> 00:16:51,899


363
00:16:51,899 --> 00:16:53,820


364
00:16:53,820 --> 00:16:56,360


365
00:16:56,360 --> 00:17:00,839
これで高度に因数分解されたグラフができました そして

366
00:17:00,839 --> 00:17:02,480


367
00:17:02,480 --> 00:17:07,079
音符や音についての局所的な信念があります

368
00:17:07,079 --> 00:17:09,660
エッジは赤で示されており、

369
00:17:09,660 --> 00:17:11,819


370
00:17:11,819 --> 00:17:14,040
緑色で追加の制約があります。

371
00:17:14,040 --> 00:17:16,559
ガウス制約、平均フィールド制約、

372
00:17:16,559 --> 00:17:19,859
その他の制約が考えられます。ここで、

373
00:17:19,859 --> 00:17:21,059


374
00:17:21,059 --> 00:17:22,679
すべてのメッセージの計算を可能にする制約を想定します。

375
00:17:22,679 --> 00:17:24,959
これを次のように自動化できます。 さまざまな仮定を立てて、

376
00:17:24,959 --> 00:17:27,179
これを

377
00:17:27,179 --> 00:17:30,059
期待値の最大化や信念の

378
00:17:30,059 --> 00:17:32,280
伝播に変えることも、

379
00:17:32,280 --> 00:17:32,820


380
00:17:32,820 --> 00:17:35,280
ハイブリッド形式をオフにすることもできます。これを聞いたことの

381
00:17:35,280 --> 00:17:37,620
ある関連するメッセージ受け渡しアルゴリズムに変えることもできます。

382
00:17:37,620 --> 00:17:40,020
つまり、これは

383
00:17:40,020 --> 00:17:42,960
基本的にすべてを網羅する非常に優れた包括的なフレームワークです。

384
00:17:42,960 --> 00:17:46,320


385
00:17:46,320 --> 00:17:49,260


386
00:17:49,260 --> 00:17:51,059
これについては、

387
00:17:51,059 --> 00:17:53,700
エントロピー ジャーナルにかなり大規模な論文を書きました。このジャーナルでは、

388
00:17:53,700 --> 00:17:57,200
これがどのように機能するかについてのすべての計算を読むことができます。そのため、なぜ

389
00:17:57,200 --> 00:18:00,240
メッセージ

390
00:18:00,240 --> 00:18:02,700
パッシングを行うのかについて説明しました。つまり、それが

391
00:18:02,700 --> 00:18:05,160
推論を行う最も効果的な方法であるからです。

392
00:18:05,160 --> 00:18:06,900
どのメッセージを計算するかについて話しました。

393
00:18:06,900 --> 00:18:08,760
つまり、

394
00:18:08,760 --> 00:18:10,679


395
00:18:10,679 --> 00:18:12,900
変分自由エネルギーを、

396
00:18:12,900 --> 00:18:14,760
制約付きのより良い自由エネルギーと呼ばれるものに変換します。

397
00:18:14,760 --> 00:18:17,400
その後、メッセージを計算できます。あとは、

398
00:18:17,400 --> 00:18:20,940


399
00:18:20,940 --> 00:18:23,100
メッセージをいつ渡すかです。

400
00:18:23,100 --> 00:18:25,080
メッセージのシーケンスは何ですか。 どちらが

401
00:18:25,080 --> 00:18:25,980
先で、

402
00:18:25,980 --> 00:18:27,360


403
00:18:27,360 --> 00:18:29,760
えー、ここは多くの論文が見られる場所です、

404
00:18:29,760 --> 00:18:30,840


405
00:18:30,840 --> 00:18:31,559


406
00:18:31,559 --> 00:18:34,020
正しい制御フローをお持ちですね、

407
00:18:34,020 --> 00:18:36,419
良い制御フローは何ですか、言わなければなりません、これが

408
00:18:36,419 --> 00:18:38,520
私の能動推論のアルゴリズムです。

409
00:18:38,520 --> 00:18:41,100
最初にモデルを指定してから、

410
00:18:41,100 --> 00:18:43,320
すべてのモデルについて推論を行いましょう タイムステップ

411
00:18:43,320 --> 00:18:45,780
新しい観測値を収集する

412
00:18:45,780 --> 00:18:48,960
状態を更新する 望ましい未来を更新する

413
00:18:48,960 --> 00:18:51,720
など 期待される自由

414
00:18:51,720 --> 00:18:55,140
エネルギーを計算する ポリシーを選択する

415
00:18:55,140 --> 00:18:58,799
この種のプログラムでは、

416
00:18:58,799 --> 00:19:01,200
能動的推論の問題は、

417
00:19:01,200 --> 00:19:03,600
ここに for ループが入れ子になっていることです。

418
00:19:03,600 --> 00:19:06,600
もう 1 つの for ループと

419
00:19:06,600 --> 00:19:09,179
これらのポリシーのそれぞれについて、

420
00:19:09,179 --> 00:19:11,580
未来に行かなければならないので、

421
00:19:11,580 --> 00:19:13,380
もう一度ループするつもりです。つまり、

422
00:19:13,380 --> 00:19:15,780
4 つのループで for ループになります。for ループでは、これは

423
00:19:15,780 --> 00:19:17,700


424
00:19:17,700 --> 00:19:19,140
計算量の点で完全に爆発します。

425
00:19:19,140 --> 00:19:23,520
複雑さがあるため、結果として、一部の非常に

426
00:19:23,520 --> 00:19:25,980
賢い人々が、これをはるかに高速に実行する非常に賢いアルゴリズムを作成しました。

427
00:19:25,980 --> 00:19:27,900
洗練された

428
00:19:27,900 --> 00:19:30,960
推論分岐時間

429
00:19:30,960 --> 00:19:33,179
アクティブな影響動的プログラミングですが、

430
00:19:33,179 --> 00:19:36,299
これを非常に賢く実行するための私たちの最近の提案は、

431
00:19:36,299 --> 00:19:37,320


432
00:19:37,320 --> 00:19:41,460
結局のところ、これらの提案はすべて、

433
00:19:41,460 --> 00:19:44,660
特定の単なる問題に帰着します。 メッセージ

434
00:19:44,660 --> 00:19:47,160
パッシング スケジュール

435
00:19:47,160 --> 00:19:50,039
ええと、推論手順としてグラフ上でメッセージ パッシングをコミットしたら、それが進行して

436
00:19:50,039 --> 00:19:51,900


437
00:19:51,900 --> 00:19:54,780
いるだけです。

438
00:19:54,780 --> 00:19:56,520
このすべてのこと、

439
00:19:56,520 --> 00:19:59,160
または高度な推論と

440
00:19:59,160 --> 00:20:02,160
時間アクティブ推論の付与は、

441
00:20:02,160 --> 00:20:04,140
最初にこのメッセージで言うメッセージをスケジュールするだけです。

442
00:20:04,140 --> 00:20:06,000
次にこのメッセージ 次にこの

443
00:20:06,000 --> 00:20:09,960
メッセージ 私は、

444
00:20:09,960 --> 00:20:12,120
これらのアルゴリズムが非常に賢いものであるという意味ではありません。asvine

445
00:20:12,120 --> 00:20:14,039


446
00:20:14,039 --> 00:20:16,260
Paul のプレゼンテーションで見たように、

447
00:20:16,260 --> 00:20:17,820
通常の推論から

448
00:20:17,820 --> 00:20:20,700
高度な推論に移行すると大幅な改善が得られます。

449
00:20:20,700 --> 00:20:22,799


450
00:20:22,799 --> 00:20:25,919
これらのアルゴリズムは、グラフ内で

451
00:20:25,919 --> 00:20:28,080
どのメッセージがどのメッセージの後に来るかを指定するだけであることを認識すると良いでしょう。えー、

452
00:20:28,080 --> 00:20:29,880


453
00:20:29,880 --> 00:20:32,220
これが例です。グラフとメッセージの例です。えー、シーケンスは次のとおりです。

454
00:20:32,220 --> 00:20:35,100


455
00:20:35,100 --> 00:20:37,200


456
00:20:37,200 --> 00:20:38,039


457
00:20:38,039 --> 00:20:40,500
メッセージ 1、次に

458
00:20:40,500 --> 00:20:43,200
メッセージ H2、メッセージ 3 が上がり、

459
00:20:43,200 --> 00:20:46,559
その後から始まります。  FC から f f で、ここでは

460
00:20:46,559 --> 00:20:49,260
5 に一致し、次に Fe に進みます。

461
00:20:49,260 --> 00:20:51,559
これは、

462
00:20:51,559 --> 00:20:54,299
動的時間プログラミング efe または

463
00:20:54,299 --> 00:20:56,820
高度な推論にシーケンスを対応させることができます。

464
00:20:56,820 --> 00:20:58,799


465
00:20:58,799 --> 00:21:00,840
このアプローチにはいくつかの問題がありますが、基本的にはユーザーが指定する必要があります。

466
00:21:00,840 --> 00:21:04,440


467
00:21:04,440 --> 00:21:06,419
賢いアルゴリズム まず第一に、それを

468
00:21:06,419 --> 00:21:08,340


469
00:21:08,340 --> 00:21:10,559
正しく行うには専門家でなければなりません ただ彼らは非常に賢い人々です つまりつまり、

470
00:21:10,559 --> 00:21:14,580


471
00:21:14,580 --> 00:21:17,160
それを任せておけば、ええと

472
00:21:17,160 --> 00:21:18,900
会社のエンジニアに言ってみましょう

473
00:21:18,900 --> 00:21:21,059
それは大丈夫です、その可能性が高いです うまくいかないのは

474
00:21:21,059 --> 00:21:22,620


475
00:21:22,620 --> 00:21:24,960
非常に残念です

476
00:21:24,960 --> 00:21:27,900
が、別の問題があります。それはある

477
00:21:27,900 --> 00:21:29,940
意味グローバル

478
00:21:29,940 --> 00:21:31,440
変数です。

479
00:21:31,440 --> 00:21:33,419
メッセージ パッシング スケジュールではすべての

480
00:21:33,419 --> 00:21:36,059
ノードが訪問されます。なぜなら、ノードが

481
00:21:36,059 --> 00:21:38,700
訪問されない場合は、訪問すべきではないからです。

482
00:21:38,700 --> 00:21:40,860
グラフにはそれがありません。つまり、

483
00:21:40,860 --> 00:21:44,159
1 つのノードがクラッシュすると、基本的にメッセージ

484
00:21:44,159 --> 00:21:46,559
パッシング スケジュールが無効になります。

485
00:21:46,559 --> 00:21:48,480
システムをリセットする必要があります。

486
00:21:48,480 --> 00:21:50,580
ドローンが展開されていて

487
00:21:50,580 --> 00:21:53,039
フィールドに飛ばされてノードが

488
00:21:53,039 --> 00:21:56,520
クラッシュすると、トランジスタが焼き切れてしまい、

489
00:21:56,520 --> 00:21:58,320
今、システムを完全にリセットしなければなりません

490
00:21:58,320 --> 00:22:00,179
新しいメッセージ受け渡しスケジュールを計算する必要があります

491
00:22:00,179 --> 00:22:01,559


492
00:22:01,559 --> 00:22:03,179
えー、それでは推論を行っていません、

493
00:22:03,179 --> 00:22:05,100
ドローンが壁に激突することはわかっています、

494
00:22:05,100 --> 00:22:09,120
これは堅牢ではありません、そして

495
00:22:09,120 --> 00:22:12,059
これとまったく同じ理由です

496
00:22:12,059 --> 00:22:14,940
実際にノードを削除したいかもしれない

497
00:22:14,940 --> 00:22:17,280
多くのプルーニングを

498
00:22:17,280 --> 00:22:20,100
したいかも

499
00:22:20,100 --> 00:22:21,780


500
00:22:21,780 --> 00:22:23,700
しれない 構造適応をしたいかもしれない

501
00:22:23,700 --> 00:22:26,039
が、システムをリセットして

502
00:22:26,039 --> 00:22:29,039
メッセージパッシングスケジュールを再計算する必要があるため構造適応はできない

503
00:22:29,039 --> 00:22:32,340
この手続き型スタイルでは、 エンジニア

504
00:22:32,340 --> 00:22:35,640
アプリは、このメッセージの後にどのメッセージが来るかを純粋に指定します。

505
00:22:35,640 --> 00:22:37,559
いくつかの

506
00:22:37,559 --> 00:22:40,799
欠点があります。あまり堅牢ではありません。

507
00:22:40,799 --> 00:22:42,600
非常に賢明に実行したい場合は、

508
00:22:42,600 --> 00:22:46,980
本当に専門家である必要があります。したがって、

509
00:22:46,980 --> 00:22:50,280
より良いシステムは、いわゆるリアクティブ

510
00:22:50,280 --> 00:22:52,080
メッセージ パッシングであり

511
00:22:52,080 --> 00:22:56,700
、非常に簡単です 最初のセッションの内容に関連して、

512
00:22:56,700 --> 00:22:59,580
えー、アクター モデルと呼ばれるものです。

513
00:22:59,580 --> 00:23:01,919
Keith Duggar が

514
00:23:01,919 --> 00:23:04,020
アクター モデルについて素晴らしいプレゼンテーションを行ったので、

515
00:23:04,020 --> 00:23:07,679
私たちが行うことは、

516
00:23:07,679 --> 00:23:09,960
グローバル メッセージ パッシング スケジュールを持たないと言うことです。

517
00:23:09,960 --> 00:23:12,480
エンジニアはこれ以上スペースを指定しません。

518
00:23:12,480 --> 00:23:15,480


519
00:23:15,480 --> 00:23:17,640
エンジニアが書かなければならない推論コードは、

520
00:23:17,640 --> 00:23:21,000
自由エネルギー最小化の機会に反応すると言うだけです。

521
00:23:21,000 --> 00:23:23,460
つまり、

522
00:23:23,460 --> 00:23:25,440
推論コードはありません。

523
00:23:25,440 --> 00:23:27,059
完全に自動化されており、

524
00:23:27,059 --> 00:23:28,559


525
00:23:28,559 --> 00:23:31,620
このグローバル メッセージ

526
00:23:31,620 --> 00:23:34,559
パッシング スケジュールを

527
00:23:34,559 --> 00:23:37,679
ノート内のローカル トリガーに置き換えます。 今は

528
00:23:37,679 --> 00:23:40,320


529
00:23:40,320 --> 00:23:42,440
自由エネルギーを最小限に抑えることに興味があるただの自律自律システムです えー、

530
00:23:42,440 --> 00:23:45,980
それはメッセージを送信することで実現できますが、

531
00:23:45,980 --> 00:23:50,100
いつになったらうまくいきますか メッセージを受信します つまり、

532
00:23:50,100 --> 00:23:52,500


533
00:23:52,500 --> 00:23:54,120
これらのメッセージを見ると、ああ、

534
00:23:54,120 --> 00:23:55,799
あるような気がします メッセージを送信することで、

535
00:23:55,799 --> 00:23:57,360
フリーエネルギーの購入を最小限に抑える

536
00:23:57,360 --> 00:24:00,299
か、無料のエントリを期待する機会が得られます。

537
00:24:00,299 --> 00:24:02,039
その後、メッセージが送信され

538
00:24:02,039 --> 00:24:05,460
、各ノードがそれを

539
00:24:05,460 --> 00:24:08,159
非同期で自動的に実行するため、原理的にはキーが呼んだように、

540
00:24:08,159 --> 00:24:10,320
並列分散処理または

541
00:24:10,320 --> 00:24:13,559
同時処理が得られます。

542
00:24:13,559 --> 00:24:16,440
このゲームは

543
00:24:16,440 --> 00:24:20,280
多数のコンピュータで同時にプレイできるので、非常

544
00:24:20,280 --> 00:24:25,280
に大きなメリットが得られます。

545
00:24:25,280 --> 00:24:27,480
まず第一に、

546
00:24:27,480 --> 00:24:30,240
難しいコードを書く必要がありません。次に、

547
00:24:30,240 --> 00:24:33,840
マルチスレッドが可能で、複数のコンピュータで実行できることです。

548
00:24:33,840 --> 00:24:35,400
複数のコンピュータを同時に使用できる

549
00:24:35,400 --> 00:24:36,480


550
00:24:36,480 --> 00:24:40,980
など、堅牢性もあります。

551
00:24:40,980 --> 00:24:42,659


552
00:24:42,659 --> 00:24:45,419
ノートが

553
00:24:45,419 --> 00:24:49,140
クラッシュした場合、

554
00:24:49,140 --> 00:24:50,580
システムが別の

555
00:24:50,580 --> 00:24:53,880
パスを見つけることを止めるものは何もないからです。このノードがこのパスをクラッシュした場合、

556
00:24:53,880 --> 00:24:56,760
このパスのメッセージ 3 から、

557
00:24:56,760 --> 00:24:59,220
現在はそうではありません。 動作しないので、

558
00:24:59,220 --> 00:25:02,520
もう Fe に何も送信できません。うーん、X からではありません。

559
00:25:02,520 --> 00:25:04,919
では、ここに新しいメッセージを送信しました。

560
00:25:04,919 --> 00:25:08,340
なぜなら、水が

561
00:25:08,340 --> 00:25:11,340
山から落ちてジグザグに

562
00:25:11,340 --> 00:25:13,679
値の中に落ちていくようなものです。

563
00:25:13,679 --> 00:25:16,080
障害物を乗り越えると、

564
00:25:16,080 --> 00:25:18,120
別のパスが見つかるだけです、

565
00:25:18,120 --> 00:25:21,840
ええと、優先パスではありません。

566
00:25:21,840 --> 00:25:24,360


567
00:25:24,360 --> 00:25:26,039


568
00:25:26,039 --> 00:25:27,960
これは、最初のパスが遮られているため、2 番目に最適なパスをうまく見つけなければなりません。それが

569
00:25:27,960 --> 00:25:29,700
このシステムでも起こることです。

570
00:25:29,700 --> 00:25:32,279
それが自然の仕組みです。 動作すると、

571
00:25:32,279 --> 00:25:34,200
最も簡単なパスで最適なパスを見つけようとします。

572
00:25:34,200 --> 00:25:35,580
それが利用できない場合は、

573
00:25:35,580 --> 00:25:37,559
2番目に最適なパスを実行します。

574
00:25:37,559 --> 00:25:39,360
それが

575
00:25:39,360 --> 00:25:41,820
リアクティブメッセージパッシングでも

576
00:25:41,820 --> 00:25:43,980
実行できるので、構造的な適応が可能であることを証明できます。ええと、

577
00:25:43,980 --> 00:25:45,720


578
00:25:45,720 --> 00:25:49,440
それははるかに堅牢です また、

579
00:25:49,440 --> 00:25:53,100


580
00:25:53,100 --> 00:25:55,980
他のドローンと偶然遭遇することもできます。

581
00:25:55,980 --> 00:25:58,080
ドローンが近づく

582
00:25:58,080 --> 00:26:00,900
と相互に通信を開始し、離れると

583
00:26:00,900 --> 00:26:02,760
通信を停止します。

584
00:26:02,760 --> 00:26:04,860


585
00:26:04,860 --> 00:26:09,240
基本的に変更した人を変更できるため、これは問題ありません。

586
00:26:09,240 --> 00:26:11,640


587
00:26:11,640 --> 00:26:13,279
um

588
00:26:13,279 --> 00:26:16,080
ノードは、通信する相手や聞きたい相手をその場で変更できます。

589
00:26:16,080 --> 00:26:18,240


590
00:26:18,240 --> 00:26:22,020
これが

591
00:26:22,020 --> 00:26:24,840
データの仕組みであり、メッセージ パッシングを使用したリアクティブな um プログラミング領域を実行するときにもどのように機能するかということです。要約すると、

592
00:26:24,840 --> 00:26:26,700


593
00:26:26,700 --> 00:26:29,820


594
00:26:29,820 --> 00:26:32,760
次のこと

595
00:26:32,760 --> 00:26:35,100
に興味があります。

596
00:26:35,100 --> 00:26:38,900
えー、アクティブな影響力エージェントの推論を自動化するのは正しいことです。

597
00:26:38,900 --> 00:26:42,419
これは

598
00:26:42,419 --> 00:26:46,260
基本的に専門家のみのための操作であり、この

599
00:26:46,260 --> 00:26:48,779
アクティブな推論テクノロジーは、

600
00:26:48,779 --> 00:26:51,240
より多くの人を集めない限り成功しません。

601
00:26:51,240 --> 00:26:54,360
民主化して、

602
00:26:54,360 --> 00:26:58,080


603
00:26:58,080 --> 00:27:00,600
適切なエージェントを開発できる有能なエンジニアを獲得しましょう。

604
00:27:00,600 --> 00:27:02,640


605
00:27:02,640 --> 00:27:04,679
アクティブな推論エージェントを開発するのに、世界のトップのスペシャリストである必要はありません。

606
00:27:04,679 --> 00:27:08,880


607
00:27:08,880 --> 00:27:11,400
推論を自動化するには、メッセージ パッシングを行う必要があります。

608
00:27:11,400 --> 00:27:12,600


609
00:27:12,600 --> 00:27:15,179
効率化のためにそれについては話しましたが、どの

610
00:27:15,179 --> 00:27:17,039
メッセージを渡さ

611
00:27:17,039 --> 00:27:19,620
ないのかについても話しました。 必然的に

612
00:27:19,620 --> 00:27:22,919
このフレームワークに従う必要がありますが、制約付きのより良い

613
00:27:22,919 --> 00:27:25,919
自由エネルギーフレームワークは非常に便利です。

614
00:27:25,919 --> 00:27:27,480
これは

615
00:27:27,480 --> 00:27:29,340
基本的に、Nas が受け渡しているときに計算を渡す

616
00:27:29,340 --> 00:27:30,179


617
00:27:30,179 --> 00:27:34,340
他のすべての興味深いメッセージを網羅する包括的なフレームワークです。

618
00:27:34,340 --> 00:27:38,760


619
00:27:38,760 --> 00:27:40,559
反応性が受け渡されている場合、

620
00:27:40,559 --> 00:27:42,720
完全に自動化されているため、

621
00:27:42,720 --> 00:27:44,880


622
00:27:44,880 --> 00:27:48,000
原理的にはもうコードを書くことはできません

623
00:27:48,000 --> 00:27:49,740
並列分散処理ができるようになりました

624
00:27:49,740 --> 00:27:51,539
構造の変更に対して堅牢です

625
00:27:51,539 --> 00:27:53,880
新しい推論経路を学ぶことができます

626
00:27:53,880 --> 00:27:56,340
ここには多くの利点があります

627
00:27:56,340 --> 00:27:57,659


628
00:27:57,659 --> 00:28:00,120
どのようにすればよいでしょう

629
00:28:00,120 --> 00:28:02,520
か えーっと ツールボックスを紹介したいと思います

630
00:28:02,520 --> 00:28:05,820
私たちは RX 推論と呼ばれる研究に取り組んでいます

631
00:28:05,820 --> 00:28:09,539
ここ大学の私の研究室でそれを行っています 私は

632
00:28:09,539 --> 00:28:11,520
ここオランダ南部のアイントホーフェンにいます

633
00:28:11,520 --> 00:28:13,260
私たちの研究

634
00:28:13,260 --> 00:28:17,059
室は bislab と呼ばれています ここには

635
00:28:17,059 --> 00:28:21,059
ポスドクと助教授がいます 博士課程の

636
00:28:21,059 --> 00:28:23,220
学生たちと私たちは長年これに取り組んできました。

637
00:28:23,220 --> 00:28:27,419


638
00:28:27,419 --> 00:28:28,080


639
00:28:28,080 --> 00:28:31,440
アルバートやイスマイルのような人たちもいます。感謝しています。博士

640
00:28:31,440 --> 00:28:33,980
論文を書き、私たちの

641
00:28:33,980 --> 00:28:36,960
最高の成果をあげました。

642
00:28:36,960 --> 00:28:39,059
それをツールボックスに統合しました。その

643
00:28:39,059 --> 00:28:41,700
ツールボックスは RX 推論と呼ばれ、次

644
00:28:41,700 --> 00:28:43,740
のようなことができます。 見てみたいなら、

645
00:28:43,740 --> 00:28:46,980
Web サイトの archiver.ml にアクセスしてください。

646
00:28:46,980 --> 00:28:50,779
ええと、その会議を求めています。ええと、

647
00:28:50,779 --> 00:28:53,159
先ほど説明した方法で機能します。

648
00:28:53,159 --> 00:28:55,679
メッセージ パッシングを実行します。

649
00:28:55,679 --> 00:28:57,539
より良い自由エネルギーの制約を最小限に抑えようとします。

650
00:28:57,539 --> 00:29:00,299
つまり、それが可能です。 あらゆる

651
00:29:00,299 --> 00:29:04,020
種類のメッセージパッシングアルゴリズムを考え出します、

652
00:29:04,020 --> 00:29:07,860
それはリアクティブな方法で実行され、

653
00:29:07,860 --> 00:29:10,440
リアルタイムで

654
00:29:10,440 --> 00:29:12,419
低電力で実行しようとします、そして今話しているすべてのkpisは

655
00:29:12,419 --> 00:29:13,919
もちろん

656
00:29:13,919 --> 00:29:18,299
完了していませんが、 ええと、それは機能しており、

657
00:29:18,299 --> 00:29:20,899
いくつかのデモを見せたいと思っています。デモを

658
00:29:20,899 --> 00:29:24,059


659
00:29:24,059 --> 00:29:27,779
見せるのは、私の研究室の上級 PC 学生であるディミトリとバートに任せます。

660
00:29:27,779 --> 00:29:30,320


661
00:29:30,899 --> 00:29:33,720
だから、素晴らしい話を共有するのはやめておきます、

662
00:29:33,720 --> 00:29:36,440


663
00:29:37,500 --> 00:29:42,360
ありがとう、素晴らしい話です、

664
00:29:42,360 --> 00:29:45,480
ええ、聞こえますか？

665
00:29:45,480 --> 00:29:50,279
ええ、わかりました、画面を共有してみます、わかりました、

666
00:29:50,279 --> 00:29:52,559
今は

667
00:29:52,559 --> 00:29:54,000
うまく表示されているのがわかります、それで、

668
00:29:54,000 --> 00:29:57,600
はい、こんにちは、皆さん、私は

669
00:29:57,600 --> 00:30:00,059
ええとディミトリバッグです、それで

670
00:30:00,059 --> 00:30:01,740
私はバイオスラップの博士課程の学生で、工科大学の出身です

671
00:30:01,740 --> 00:30:04,320
ええと、はい、

672
00:30:04,320 --> 00:30:06,659
実際のソフトウェア

673
00:30:06,659 --> 00:30:09,240
開発とバイアス ラボについての小さなプレゼンテーションがあります。そう、

674
00:30:09,240 --> 00:30:12,240
過去数年にわたって私たちは

675
00:30:12,240 --> 00:30:15,000
ツールを大幅に改善してきました。

676
00:30:15,000 --> 00:30:17,460
基本的に私の博士課程全体は、

677
00:30:17,460 --> 00:30:19,919
バートが話していたこのアイデアを実装することに専念しました。

678
00:30:19,919 --> 00:30:22,380


679
00:30:22,380 --> 00:30:23,940
変分反応型メッセージを実装することが可能です。

680
00:30:23,940 --> 00:30:25,679
このプレゼンテーションでは、

681
00:30:25,679 --> 00:30:28,559


682
00:30:28,559 --> 00:30:31,799
この理論を内部で使用して実際に何ができるかを示したいと思います。

683
00:30:31,799 --> 00:30:35,279
基本的に、能動推論を自動化するには、

684
00:30:35,279 --> 00:30:36,659


685
00:30:36,659 --> 00:30:38,760
ベイズの影響を自動化する必要があります。

686
00:30:38,760 --> 00:30:40,860
すでに

687
00:30:40,860 --> 00:30:44,520
そのためのソリューションはたくさんあります。Google が資金提供している Stan pyro numpyre です。

688
00:30:44,520 --> 00:30:46,740
インターネットは

689
00:30:46,740 --> 00:30:49,200
Microsoft が資金提供しています。チューリングは 7 月に

690
00:30:49,200 --> 00:30:52,820
IMC で開催されます。その他多くのソリューションがあります。基本的に、

691
00:30:52,820 --> 00:30:54,960
これらのソリューションは

692
00:30:54,960 --> 00:30:56,880
本当に優れています。

693
00:30:56,880 --> 00:31:00,000
プロトタイピングも私たちの目標は、

694
00:31:00,000 --> 00:31:02,460
最終的には

695
00:31:02,460 --> 00:31:05,279
プロトタイプだけでなくこの種のシステムを展開できるようにすることです。そして、

696
00:31:05,279 --> 00:31:06,720
私たちは

697
00:31:06,720 --> 00:31:08,760
この究極の侵入推論のためにこの特定のプロパティに重点を置いています。

698
00:31:08,760 --> 00:31:12,299
そのため、低消費

699
00:31:12,299 --> 00:31:15,539
電力で適応性があり、リアルタイムでスケーラブルである必要があります。

700
00:31:15,539 --> 00:31:17,340
また、ユーザーにも対応できる必要があります。 最終的にはフレンドリーであり、

701
00:31:17,340 --> 00:31:19,559


702
00:31:19,559 --> 00:31:22,760
便利にしたい場合は広範囲のモデルをサポートする必要があるので、

703
00:31:22,760 --> 00:31:26,399
バイアス ラボでは、この

704
00:31:26,399 --> 00:31:30,559
ような優れたプロパティを備えたソフトウェアを構築したいと考えています。それは

705
00:31:30,559 --> 00:31:33,480
常にトレーダーにとって正しいので、

706
00:31:33,480 --> 00:31:35,100
1 つのソフトウェアで何かより良いものを実現します。 特定の

707
00:31:35,100 --> 00:31:37,140
ドメインとおそらく他のソフトウェア

708
00:31:37,140 --> 00:31:39,480
ライブラリは、別のドメインの方が優れている可能性があります。

709
00:31:39,480 --> 00:31:41,520
しかし、私たちは実際に

710
00:31:41,520 --> 00:31:44,159
この特定のプロパティに焦点を

711
00:31:44,159 --> 00:31:47,039
当てています。ええと、それでは、はい、

712
00:31:47,039 --> 00:31:48,779
少し繰り返しますが、最高のプレゼンテーションをどのように

713
00:31:48,779 --> 00:31:50,760
達成するかというと、

714
00:31:50,760 --> 00:31:53,520
環境にはエージェントがいて、

715
00:31:53,520 --> 00:31:55,020


716
00:31:55,020 --> 00:31:57,720
エージェントにはいくつかのアクションを実行することが許可されています。エージェントが基本的に

717
00:31:57,720 --> 00:32:00,480
必要なのは、

718
00:32:00,480 --> 00:32:02,580


719
00:32:02,580 --> 00:32:03,779


720
00:32:03,779 --> 00:32:06,600
患者の推論を行うために環境の十分に優れた確率モデルを考え出すことです。フレーム

721
00:32:06,600 --> 00:32:09,360
ワークではエンコードします。

722
00:32:09,360 --> 00:32:11,520


723
00:32:11,520 --> 00:32:15,000
観察だけでなく行動

724
00:32:15,000 --> 00:32:17,539
や望ましい未来もモデル化するファクターグラフとしてのモデル

725
00:32:17,539 --> 00:32:20,820
このアプローチにより、

726
00:32:20,820 --> 00:32:23,279


727
00:32:23,279 --> 00:32:26,460
変数と隠れ状態の間の複雑な関係を

728
00:32:26,460 --> 00:32:28,919
ある種の構造とローカルブロックに分解することができます

729
00:32:28,919 --> 00:32:31,440
えー、これはブロックではありません それは

730
00:32:31,440 --> 00:32:34,679
もうブラックボックスではないので、モデル自体には

731
00:32:34,679 --> 00:32:36,120
ある種の背景

732
00:32:36,120 --> 00:32:39,419
動機の解釈がある可能性があり、特定の物理システムに関する事前知識をエンコードしている可能性があります。

733
00:32:39,419 --> 00:32:41,340


734
00:32:41,340 --> 00:32:43,200


735
00:32:43,200 --> 00:32:46,559
これらのブロックの局所性により、

736
00:32:46,559 --> 00:32:49,080
基本的に

737
00:32:49,080 --> 00:32:50,880
数百万の変数と隠れた状態にスケールすることができます

738
00:32:50,880 --> 00:32:53,399
それを事前に最適化することができます。

739
00:32:53,399 --> 00:32:55,520
または、

740
00:32:55,520 --> 00:32:57,659
さまざまな場所で何らかの異なる近似戦略のようなものを使用することもできます。つまり、

741
00:32:57,659 --> 00:33:01,440
多くの非常に

742
00:33:01,440 --> 00:33:03,600
優れたプロパティも可能であり、

743
00:33:03,600 --> 00:33:06,480


744
00:33:06,480 --> 00:33:08,159
実際の変分バージョン推論を実行するためにリアクティブ メッセージ パッシングを使用します。

745
00:33:08,159 --> 00:33:11,279
リアクティブを使用します。 エネルギーの変動の近似を最小限

746
00:33:11,279 --> 00:33:13,140
に抑えるために内部でプログラミングしています。そして、

747
00:33:13,140 --> 00:33:14,700


748
00:33:14,700 --> 00:33:17,820
berdos が述べたように、

749
00:33:17,820 --> 00:33:22,399
これはアクター モデルに非常に関連しており、

750
00:33:22,399 --> 00:33:26,039
基本的には間接的な転送です。

751
00:33:26,039 --> 00:33:28,380
さまざまなノードをアクターそのものとして考えることができます。

752
00:33:28,380 --> 00:33:29,760


753
00:33:29,760 --> 00:33:32,460
つまり、それらの目的は基本的に 1 つ

754
00:33:32,460 --> 00:33:34,620
です。 エネルギーを最小化する変分メッセージを送信する

755
00:33:34,620 --> 00:33:36,539


756
00:33:36,539 --> 00:33:38,760
これは非常に短く、非常に高

757
00:33:38,760 --> 00:33:40,799
レベルの説明ですが、本質的には

758
00:33:40,799 --> 00:33:44,519
起こっていることなので、相互に

759
00:33:44,519 --> 00:33:47,580
作用するさまざまなエージェントを

760
00:33:47,580 --> 00:33:49,980
アクターとして扱うのではなく、

761
00:33:49,980 --> 00:33:52,260
実際のコンポーネントも扱います。

762
00:33:52,260 --> 00:33:54,779
アクター自体としての基礎となるモデルは

763
00:33:54,779 --> 00:33:57,000
非常に階層構造のようなもので、

764
00:33:57,000 --> 00:34:01,260
これがこの推論の主要な中心的なアイデアです。

765
00:34:01,260 --> 00:34:03,600


766
00:34:03,600 --> 00:34:06,840
えー、たとえばここで最初の例として、

767
00:34:06,840 --> 00:34:08,879
動的システムで推論を行うことができます。

768
00:34:08,879 --> 00:34:11,760
この例は

769
00:34:11,760 --> 00:34:13,619
すでにかなり古いものだと思います 2年

770
00:34:13,619 --> 00:34:16,679
前のことなので、緑の点で示されるノイズの多い測定値を基に物体の位置を追跡します。

771
00:34:16,679 --> 00:34:18,359


772
00:34:18,359 --> 00:34:22,379


773
00:34:22,379 --> 00:34:24,899
実際の実際の信号は観測できませんが、

774
00:34:24,899 --> 00:34:27,540
プロットすることはできます。えー、エストロンは

775
00:34:27,540 --> 00:34:30,000
青、反転信号は赤で表示されます

776
00:34:30,000 --> 00:34:32,699
そして、データセットは無限の

777
00:34:32,699 --> 00:34:34,739
推論であり、それに反応するだけであり、

778
00:34:34,739 --> 00:34:37,159
特定のデータサイズを想定しません。

779
00:34:37,159 --> 00:34:39,359
観察にできるだけ早く反応するだけです。

780
00:34:39,359 --> 00:34:40,619


781
00:34:40,619 --> 00:34:42,719
ええと、

782
00:34:42,719 --> 00:34:46,080
Zoomが私の画面をどれほどスムーズに共有するかは実際にはわかりません、ええと、おそらく

783
00:34:46,080 --> 00:34:48,239
わかるでしょう。 アニメーションに少し遅れがあります。

784
00:34:48,239 --> 00:34:49,980
おそらく

785
00:34:49,980 --> 00:34:51,899
Zoom がフル フレーム レートで共有していないため、わかりません。

786
00:34:51,899 --> 00:34:53,280


787
00:34:53,280 --> 00:34:55,260
また、右側には

788
00:34:55,260 --> 00:34:58,500
モデルをどのように定義するかが表示されます。フレーム

789
00:34:58,500 --> 00:35:00,240
ワークではジュエリーをプログラミング言語として使用しています。

790
00:35:00,240 --> 00:35:01,880


791
00:35:01,880 --> 00:35:04,619
基本的にこれが、

792
00:35:04,619 --> 00:35:06,180
この特定のモデルを定義し、

793
00:35:06,180 --> 00:35:09,240
データセットで推論を実行するために必要なすべてです。

794
00:35:09,240 --> 00:35:11,820
実際、私はフランスにいるよりも、それをプロットするのにもっと日数を費やすのが好きなので、

795
00:35:11,820 --> 00:35:14,760


796
00:35:14,760 --> 00:35:17,280
推論はアプローチが非常に簡単で最も簡単な部分でした

797
00:35:17,280 --> 00:35:19,680


798
00:35:19,680 --> 00:35:22,520
ユーザーの使いやすさに関連するのはより難しい

799
00:35:22,520 --> 00:35:25,560
ので、実際には

800
00:35:25,560 --> 00:35:28,020
モデル仕様言語を改善して

801
00:35:28,020 --> 00:35:30,119
さらに簡単にする計画があります。技術的な理由から、現在は

802
00:35:30,119 --> 00:35:32,760
いくつかの補助ステートメントと

803
00:35:32,760 --> 00:35:34,859
モデル仕様言語がありますが、

804
00:35:34,859 --> 00:35:38,339
それを改善してさらに簡単にするために取り組んでいます。

805
00:35:38,339 --> 00:35:39,960


806
00:35:39,960 --> 00:35:41,280


807
00:35:41,280 --> 00:35:43,619
別の例は、

808
00:35:43,619 --> 00:35:45,960
前の例と似ていますが、より

809
00:35:45,960 --> 00:35:48,119
複雑で線形の

810
00:35:48,119 --> 00:35:50,520
二重振り子の動的システムを使用しており、システムは

811
00:35:50,520 --> 00:35:53,760
カオス的であり、その小さな

812
00:35:53,760 --> 00:35:56,460
部分には緑色の点として示されている多くのノイズが観察できます。 十分

813
00:35:56,460 --> 00:35:58,020


814
00:35:58,020 --> 00:36:00,800


815
00:36:00,800 --> 00:36:04,260
に優れたモデルが与えられた場合、

816
00:36:04,260 --> 00:36:06,839
他の隠れ状態をかなり

817
00:36:06,839 --> 00:36:10,320
高精度で推論できます。それに必要なコードも

818
00:36:10,320 --> 00:36:15,380
比較的短く、

819
00:36:15,480 --> 00:36:19,200


820
00:36:19,200 --> 00:36:21,359


821
00:36:21,359 --> 00:36:22,800
環境と対話するアクティブな推論エージェントを使用した例もあります。

822
00:36:22,800 --> 00:36:25,380
それで、左は、

823
00:36:25,380 --> 00:36:29,460
左上は、ええと、山の曲線問題を示しています。

824
00:36:29,460 --> 00:36:32,220
非常に有名な問題です。

825
00:36:32,220 --> 00:36:34,200
左下は、軌道や風の強い状況で倒立振子が落ちないよう制御しようとするアクティブな推論エージェントを示しています。

826
00:36:34,200 --> 00:36:36,599


827
00:36:36,599 --> 00:36:39,300


828
00:36:39,300 --> 00:36:42,780


829
00:36:42,780 --> 00:36:44,760
また、

830
00:36:44,760 --> 00:36:47,520
振り子を制御するエージェントのデモもあります。 環境は常に変化する

831
00:36:47,520 --> 00:36:50,640
ため、右側には

832
00:36:50,640 --> 00:36:52,560
エンジン付きの振り子が表示されます。エンジンには

833
00:36:52,560 --> 00:36:54,900
エンジンの力が限られており、

834
00:36:54,900 --> 00:36:57,780
エージェント自体が目標に到達する必要があり

835
00:36:57,780 --> 00:36:59,940
、目標は赤い円で示されます。

836
00:36:59,940 --> 00:37:02,240
そのため、

837
00:37:02,240 --> 00:37:04,740
このデモでは基本的に

838
00:37:04,740 --> 00:37:06,599
リアルタイムで環境を変更し、エージェントがどのように

839
00:37:06,599 --> 00:37:08,760
反応するかを確認できるため、測定値のノイズ量に合わせて

840
00:37:08,760 --> 00:37:11,099
振り子の質量をスラングで変更したり、

841
00:37:11,099 --> 00:37:13,980


842
00:37:13,980 --> 00:37:15,780


843
00:37:15,780 --> 00:37:18,300
最大エンジン出力などを

844
00:37:18,300 --> 00:37:20,700
エージェントが適切に変更できるように目標を変更したりできます 目標を達成する

845
00:37:20,700 --> 00:37:23,220
ために可能な限り最善の行動方針を推測しようとしますが、

846
00:37:23,220 --> 00:37:25,800


847
00:37:25,800 --> 00:37:28,079
反応が止まることはありません。

848
00:37:28,079 --> 00:37:30,440
ええと、目標に正しく到達できなくなるように

849
00:37:30,440 --> 00:37:33,960
古代の力を制限することも実際には可能ですが、

850
00:37:33,960 --> 00:37:36,180


851
00:37:36,180 --> 00:37:39,320
エージェントはそうするでしょう まだ試してみてください、

852
00:37:39,320 --> 00:37:42,960
スマート ナビゲーションと衝突回避を備えた他のクールなデモがまだありますが、

853
00:37:42,960 --> 00:37:46,380


854
00:37:46,380 --> 00:37:48,119
これらはまだ活発に研究中であり、

855
00:37:48,119 --> 00:37:50,160
そのコードは公開されていませんが、

856
00:37:50,160 --> 00:37:52,260
すぐに利用可能になる予定ですが、

857
00:37:52,260 --> 00:37:55,380
たとえばこの例では、

858
00:37:55,380 --> 00:37:57,240
エージェントのセットを定義できます。

859
00:37:57,240 --> 00:37:59,460
境界線と一連の

860
00:37:59,460 --> 00:38:02,640
目的地が表示されるので、彼らがどのように

861
00:38:02,640 --> 00:38:06,540
ルートをまとめて解決しようとしているのかがわかります。

862
00:38:06,540 --> 00:38:07,200


863
00:38:07,200 --> 00:38:10,079


864
00:38:10,079 --> 00:38:13,020
マップ内にいくつかの静的な障害物があるので、エージェントが目標を達成するために最適な経路をどのように見つけられるかがわかります。

865
00:38:13,020 --> 00:38:15,839


866
00:38:15,839 --> 00:38:18,839


867
00:38:18,839 --> 00:38:21,320
衝突の可能性を回避します。

868
00:38:21,320 --> 00:38:23,940
また、

869
00:38:23,940 --> 00:38:27,119
静的な障害物がある必要はありません。障害物

870
00:38:27,119 --> 00:38:30,000
自体が動く可能性があるため、このデモでは、

871
00:38:30,000 --> 00:38:32,820


872
00:38:32,820 --> 00:38:35,099


873
00:38:35,099 --> 00:38:37,140
下から上に円または

874
00:38:37,140 --> 00:38:40,260
障害物に移動する障害物のマップをナビゲートする何百ものエージェントがあり、エージェントが表示されます。

875
00:38:40,260 --> 00:38:42,900
小さなドットであり、左から右に移動する必要がありますので、基本的には

876
00:38:42,900 --> 00:38:45,240
いかなる種類の汚染も避けることができます。

877
00:38:45,240 --> 00:38:47,220


878
00:38:47,220 --> 00:38:50,820
また、先ほども述べたように、

879
00:38:50,820 --> 00:38:52,740
効率的でリアルタイムの

880
00:38:52,740 --> 00:38:55,260
推論を実行したいと考えていますが、低消費

881
00:38:55,260 --> 00:38:57,900
電力、低パフォーマンス、低

882
00:38:57,900 --> 00:39:00,180
パフォーマンスのデバイス上でも同様に実行します。 たとえば Raspberry Pi

883
00:39:00,180 --> 00:39:03,300
または Coolpy として、Cool Pi 上でベイジアン オーディオ ソース分離を

884
00:39:03,300 --> 00:39:05,820
実行することに成功した結果がいくつかあります。そのため、

885
00:39:05,820 --> 00:39:07,500


886
00:39:07,500 --> 00:39:10,079


887
00:39:10,079 --> 00:39:13,440
アクティブに実行することも実際に可能です。Coolpy

888
00:39:13,440 --> 00:39:16,260
上でもアクティブ推論エージェントを実行しようとします。

889
00:39:16,260 --> 00:39:20,040
前述の倒立

890
00:39:20,040 --> 00:39:21,440
振子

891
00:39:21,440 --> 00:39:23,160
と、

892
00:39:23,160 --> 00:39:25,079
前述したように、

893
00:39:25,079 --> 00:39:29,220
大きなモデル スコープも必要です。

894
00:39:29,220 --> 00:39:31,980
基本的に RX 推論は、

895
00:39:31,980 --> 00:39:33,960


896
00:39:33,960 --> 00:39:36,599
前述の問題を解決するように設計されていません。具体的には、

897
00:39:36,599 --> 00:39:38,520


898
00:39:38,520 --> 00:39:40,980
リポジトリにさまざまなサンプルの大きなセットがあり、さまざまな

899
00:39:40,980 --> 00:39:42,300
モデル、さまざまなデータ、さまざまな

900
00:39:42,300 --> 00:39:44,040
影響制約があります。

901
00:39:44,040 --> 00:39:46,380
線形

902
00:39:46,380 --> 00:39:48,060
回帰、隠れマルコフ モデル、自動

903
00:39:48,060 --> 00:39:50,640
回帰モデル、階層

904
00:39:50,640 --> 00:39:53,520
モデル、混合モデル、ガウス過程などの例があるので、

905
00:39:53,520 --> 00:39:56,760
このアプローチは非常に多用途です。

906
00:39:56,760 --> 00:40:00,060
たとえば、

907
00:40:00,060 --> 00:40:02,880
これを

908
00:40:02,880 --> 00:40:05,220
従来のソフトウェア ライブラリのようなものと比較すると、次のようになります。

909
00:40:05,220 --> 00:40:07,200
たとえば、

910
00:40:07,200 --> 00:40:09,060
共通フィルターを解決するライブラリがあるとすると、非常に優れたライブラリになる可能性があります。

911
00:40:09,060 --> 00:40:11,579
超高速である可能性があります。最高の

912
00:40:11,579 --> 00:40:13,920
パフォーマンスが得られます。非常に

913
00:40:13,920 --> 00:40:15,119
信頼性が高く、非常に

914
00:40:15,119 --> 00:40:17,820
優れています。しかし、

915
00:40:17,820 --> 00:40:20,460
この特定のモデルの

916
00:40:20,460 --> 00:40:22,859
共通フィルターの権利によって制限されており、実際には変更できません。

917
00:40:22,859 --> 00:40:25,400


918
00:40:25,400 --> 00:40:29,240
私たちは自由に独自のモデルを定義できます。

919
00:40:29,240 --> 00:40:31,800


920
00:40:31,800 --> 00:40:33,720
基本的に

921
00:40:33,720 --> 00:40:36,599
共通フィルタリング方程式と同等に機能するモデルを簡単に定義できます。

922
00:40:36,599 --> 00:40:38,700
つまり、

923
00:40:38,700 --> 00:40:40,500
オブジェクト追跡について前に示したデモでは、

924
00:40:40,500 --> 00:40:42,839
基本的には共通フィルタでした。

925
00:40:42,839 --> 00:40:43,980


926
00:40:43,980 --> 00:40:47,160
確率モデルで書かれていました

927
00:40:47,160 --> 00:40:49,140


928
00:40:49,140 --> 00:40:52,200
そうですね、それはこのプレゼンテーションへの私のちょっとした追加でしたので、

929
00:40:52,200 --> 00:40:55,079
私たちのソフトウェアは

930
00:40:55,079 --> 00:40:57,960
無料です、MIT ライセンスであり、

931
00:40:57,960 --> 00:41:00,240
GitHub で利用できるオープンソースです

932
00:41:00,240 --> 00:41:03,540
ええと、私たちがどこで発表できるかに感謝します

933
00:41:03,540 --> 00:41:05,400


934
00:41:05,400 --> 00:41:09,920
質問があれば喜んでお答えします、ありがとう、すごい、すごい、わかりました、

935
00:41:12,180 --> 00:41:14,960


936
00:41:15,000 --> 00:41:17,700


937
00:41:17,700 --> 00:41:19,980
チャットで簡単な質問をします

938
00:41:19,980 --> 00:41:22,619
マルコは

939
00:41:22,619 --> 00:41:24,900
聞き逃したらごめんなさい、他のエージェントの動作に

940
00:41:24,900 --> 00:41:27,540
リアルタイムで適応する衝突回避のデモです

941
00:41:27,540 --> 00:41:29,220
、それとも

942
00:41:29,220 --> 00:41:32,720
集合的に事前に計算されたものですか パス

943
00:41:33,240 --> 00:41:35,880
ええと、基本的には超

944
00:41:35,880 --> 00:41:38,099
リアルタイムではありません。

945
00:41:38,099 --> 00:41:39,839
このパスの計算は速いですが、5 秒

946
00:41:39,839 --> 00:41:42,599
程度かかるかもしれません。しかし、私たちは基本的に

947
00:41:42,599 --> 00:41:44,820
リアルタイムにするために取り組んでいます。そのため、何が問題なのかはわかっています。

948
00:41:44,820 --> 00:41:47,460
どこを改善すべきかはわかっています。

949
00:41:47,460 --> 00:41:50,339
そして、私たちはそれを気分が悪くなるようにします はい、

950
00:41:50,339 --> 00:41:53,400
ほぼ

951
00:41:53,400 --> 00:41:55,440
次の質問と同じです

952
00:41:55,440 --> 00:41:57,960
他の方法との比較データはありますか、

953
00:41:57,960 --> 00:42:00,000
より一般的にはどのような種類の

954
00:42:00,000 --> 00:42:02,520
ベンチマークまたは何を異なる設定で業界と話し合っているとき、

955
00:42:02,520 --> 00:42:04,619


956
00:42:04,619 --> 00:42:07,800
人々はそのキラーを探しているのはどのような感じですか

957
00:42:07,800 --> 00:42:09,599
能動推論のアプリですか、それとも

958
00:42:09,599 --> 00:42:13,920
主要な尺度を探しているのですか。

959
00:42:13,920 --> 00:42:16,260
えー、私は個人的に HMC のようなサンプリング ベースの手法との比較に関する大きな論文を持っています。

960
00:42:16,260 --> 00:42:19,200


961
00:42:19,200 --> 00:42:23,220
また、私の博士課程では、この

962
00:42:23,220 --> 00:42:25,079
結果は

963
00:42:25,079 --> 00:42:29,280
他のサンプリング ベースの手法との比較もあるでしょう。 非常に

964
00:42:29,280 --> 00:42:31,680
長い話で、短いサンプリングベースの手法では、

965
00:42:31,680 --> 00:42:33,900
この種の

966
00:42:33,900 --> 00:42:36,119
高度な推論をリアルタイムで

967
00:42:36,119 --> 00:42:38,640
実行することはできません。非常に時間がかかります。

968
00:42:38,640 --> 00:42:40,740


969
00:42:40,740 --> 00:42:42,420


970
00:42:42,420 --> 00:42:44,400


971
00:42:44,400 --> 00:42:46,560
大規模な環境がある場合、アクティブな影響を与えるために実際に必要な大きな問題にはあまり対応できません。 非常に複雑になります

972
00:42:46,560 --> 00:42:49,619


973
00:42:49,619 --> 00:42:53,940
モデルには未知の変数がたくさん含まれることになります ええと、

974
00:42:53,940 --> 00:42:56,520
比較する論文があり、

975
00:42:56,520 --> 00:42:58,380
基本的には、私たちのアプローチの方が

976
00:42:58,380 --> 00:43:01,859
はるかに優れたスケールであることが示されているので、私は個人的には

977
00:43:01,859 --> 00:43:05,180
通常のMacBookラップトップで実行しています

978
00:43:05,180 --> 00:43:08,660
200万個の

979
00:43:08,660 --> 00:43:12,060
未知の変数を加えたモデルを実行すると、

980
00:43:12,060 --> 00:43:15,240
非常に高速でした。その後、

981
00:43:15,240 --> 00:43:17,760
サンプリングベースの方法の場合、

982
00:43:17,760 --> 00:43:19,980
100個ほどの変数を含むモデルにいることになるかもしれません。

983
00:43:19,980 --> 00:43:21,780
その後、2

984
00:43:21,780 --> 00:43:24,300
時間かそこら待ってから、それが回転します。

985
00:43:24,300 --> 00:43:28,020
あなたのチェーンが収束しなかったことはわかりました、ええと、

986
00:43:28,020 --> 00:43:30,980
そのようなものは

987
00:43:31,980 --> 00:43:34,560
クールです、ええと、メッセージパッシングとファクターグラフがどこまで進んだかについてチャットでコメントしている人々です、そして

988
00:43:34,560 --> 00:43:37,500


989
00:43:37,500 --> 00:43:41,040


990
00:43:41,040 --> 00:43:43,380
バイアスラボとバートにまったく感謝しています、私たちは

991
00:43:43,380 --> 00:43:44,520


992
00:43:44,520 --> 00:43:46,680
このエキサイティングなラインに間違いなく感謝しています

993
00:43:46,680 --> 00:43:48,420
研究 つまり、そこには学ぶべきことがたくさんあり

994
00:43:48,420 --> 00:43:50,400
、

995
00:43:50,400 --> 00:43:52,440
方程式を見る

996
00:43:52,440 --> 00:43:54,720
と石に書かれたように見えることもありますが、

997
00:43:54,720 --> 00:43:56,400


998
00:43:56,400 --> 00:43:59,099
変分自由エネルギーを知っていることが始まりと終わりのようなものですが、プレゼンテーションでは実際に次の

999
00:43:59,099 --> 00:44:00,720
ように示しています

1000
00:44:00,720 --> 00:44:04,020
いいえ、私たちはハンズオンです。そこで

1001
00:44:04,020 --> 00:44:06,180
解釈可能性が得られます。モジュール性が

1002
00:44:06,180 --> 00:44:08,700
実際に実装される場所であり、

1003
00:44:08,700 --> 00:44:11,400
それは情報ロジスティクスの

1004
00:44:11,400 --> 00:44:13,800
課題のようなものです。その時点では難解な哲学の質問のようなものではありません。

1005
00:44:13,800 --> 00:44:16,980


1006
00:44:16,980 --> 00:44:19,800
いや、実際のところ、つまり、

1007
00:44:19,800 --> 00:44:22,859
それはええと言うべきです 私たちはこれに時間がかかりました

1008
00:44:22,859 --> 00:44:25,619
つまり、私たちは天才ではないので、私たちの研究室は

1009
00:44:25,619 --> 00:44:28,200
8年以上存在し、そして

1010
00:44:28,200 --> 00:44:30,119
研究室のすべての人々を見てください、

1011
00:44:30,119 --> 00:44:33,060


1012
00:44:33,060 --> 00:44:35,700
これが今の場所に機能するまでに、多くの間違った方向で、何年も何年もかかりました

1013
00:44:35,700 --> 00:44:38,359
とても長い道のりです

1014
00:44:38,359 --> 00:44:42,060
が、現時点では、

1015
00:44:42,060 --> 00:44:44,640


1016
00:44:44,640 --> 00:44:47,339
将来のある時点でそうなると確信しています。3

1017
00:44:47,339 --> 00:44:48,839
か月後か 1 年後かは言いたくありませんが、

1018
00:44:48,839 --> 00:44:52,440
私たちはそれを実現します。 ボタンを

1019
00:44:52,440 --> 00:44:54,780


1020
00:44:54,780 --> 00:44:56,700
押すだけで人々が生成モデルを設計できるツールボックスを作成できるようになり

1021
00:44:56,700 --> 00:44:59,040
、影響を忘れることができます。

1022
00:44:59,040 --> 00:45:00,420


1023
00:45:00,420 --> 00:45:02,400
もう幼児のことを心配する必要はありません。

1024
00:45:02,400 --> 00:45:05,520
高速かつ自動化され、それが実現し

1025
00:45:05,520 --> 00:45:07,400
ます。 それは数年以内に起こるでしょう、

1026
00:45:07,400 --> 00:45:10,500
そしてもしかしたら他の誰かが

1027
00:45:10,500 --> 00:45:12,839
さらに優れたツールボックスを書くかもしれませんが、

1028
00:45:12,839 --> 00:45:14,960
私たちのツールボックスでもそれができるとかなり自信を持っています。

1029
00:45:14,960 --> 00:45:18,300


1030
00:45:18,300 --> 00:45:21,240


1031
00:45:21,240 --> 00:45:24,780


1032
00:45:24,780 --> 00:45:26,280
ディープ ラーニングと生成 AI の成功は、

1033
00:45:26,280 --> 00:45:29,280


1034
00:45:29,280 --> 00:45:32,099


1035
00:45:32,099 --> 00:45:34,640
ビッグ データのビッグ コンピューターとツールボックス

1036
00:45:34,640 --> 00:45:38,280
tensorflow によるビッグ データの可用性のおかげで成功するのであれば十分に成功します。また、すべての成功には、

1037
00:45:38,280 --> 00:45:40,740
エージェントが独自のデータを収集するため、ビッグ データは必要ありません。

1038
00:45:40,740 --> 00:45:42,839
またはフィルターでは、

1039
00:45:42,839 --> 00:45:45,119
大きなコンピューターのアクティブ・インタレスト・エージェントは必要ありません。

1040
00:45:45,119 --> 00:45:47,700


1041
00:45:47,700 --> 00:45:49,920
彼らが電力リソースを管理していることは知っていますが、

1042
00:45:49,920 --> 00:45:51,119


1043
00:45:51,119 --> 00:45:53,099


1044
00:45:53,099 --> 00:45:54,980


1045
00:45:54,980 --> 00:45:57,300
プログラミングとアクティブ推論エージェントの

1046
00:45:57,300 --> 00:45:59,280
プログラミングによる影響を手作業で行うのは

1047
00:45:59,280 --> 00:46:00,599
不可能なので

1048
00:46:00,599 --> 00:46:04,140
、非常に優れたツールボックスが必要です。

1049
00:46:04,140 --> 00:46:06,300
これを本当に自動化してくれるツールボックスです。

1050
00:46:06,300 --> 00:46:08,160


1051
00:46:08,160 --> 00:46:10,140
私たちの例が、それを行うための最初の 2 つの

1052
00:46:10,140 --> 00:46:13,140
ボックスのうちの 1 つになることを願っています。他の

1053
00:46:13,140 --> 00:46:15,720
人たちもそれに取り組んでいると確信しています。

1054
00:46:15,720 --> 00:46:18,480


1055
00:46:18,480 --> 00:46:20,839
そして、より良いツールボックスが登場するでしょう。しかし、楽観的なメッセージは次のとおりだと思います。

1056
00:46:20,839 --> 00:46:24,300
それは必ず起こります

1057
00:46:24,300 --> 00:46:26,760
、そしてそのようなツールボックスができたら、

1058
00:46:26,760 --> 00:46:28,859
実際に大規模なコミュニティが

1059
00:46:28,859 --> 00:46:31,260
エージェントの構築を開始できるようになり、

1060
00:46:31,260 --> 00:46:32,579
実際に

1061
00:46:32,579 --> 00:46:33,960


1062
00:46:33,960 --> 00:46:36,180
現場で展開可能なエージェントが機能することを示すことができ、

1063
00:46:36,180 --> 00:46:38,339


1064
00:46:38,339 --> 00:46:40,260
強化フローティングエージェントよりもうまく機能することを確認できます。 または、

1065
00:46:40,260 --> 00:46:42,780
そこにあるものは何

1066
00:46:42,780 --> 00:46:44,940
でも、ええと、それは非常に前向きで希望に満ちたメッセージだと思います、

1067
00:46:44,940 --> 00:46:48,240


1068
00:46:48,240 --> 00:46:50,160
それは私たちが期待しているものです、それは私たちが好むものです、

1069
00:46:50,160 --> 00:46:52,980
ええ、ええ、

1070
00:46:52,980 --> 00:46:57,560
どちらかからの最後のコメント、

1071
00:46:59,280 --> 00:47:01,260
ええと私たちからのコメント、いいえ、私は

1072
00:47:01,260 --> 00:47:03,839
ただとてもです 機会が得られて嬉しいです、

1073
00:47:03,839 --> 00:47:07,020
そして、ええと、そうしたいです、ええと、ええと、

1074
00:47:07,020 --> 00:47:09,420


1075
00:47:09,420 --> 00:47:13,440
誰もがこのツールボックスをダウンロードできます、ええと、

1076
00:47:13,440 --> 00:47:15,960
現時点では、あなたはツールボックスを

1077
00:47:15,960 --> 00:47:18,599
扱うにはまだプログラマーであるべきだと

1078
00:47:18,599 --> 00:47:19,680


1079
00:47:19,680 --> 00:47:22,500
思います。

1080
00:47:22,500 --> 00:47:25,800


1081
00:47:25,800 --> 00:47:27,960
私たちが望んでいるように完璧に磨かれているわけではないことはわかっていますが、それは

1082
00:47:27,960 --> 00:47:30,119
すぐに登場します、来年には登場します。

1083
00:47:30,119 --> 00:47:31,800
ほぼすべての人が使用できる優れたツールボックスが登場します

1084
00:47:31,800 --> 00:47:34,260
が、興味のある人は、

1085
00:47:34,260 --> 00:47:35,640


1086
00:47:35,640 --> 00:47:37,680


1087
00:47:37,680 --> 00:47:39,480
ここでスラブを購入することに興味がある人もいます。

1088
00:47:39,480 --> 00:47:43,500
博士課程の学生向けのポジションが空いているので、ええと、

1089
00:47:43,500 --> 00:47:47,099


1090
00:47:47,099 --> 00:47:48,900


1091
00:47:48,900 --> 00:47:52,040
私たちと一緒に仕事をすることに興味がある人々からメールを受け取ることができてうれしいです、ディミトリに感謝します、

1092
00:47:52,619 --> 00:47:56,599


1093
00:47:56,640 --> 00:47:59,400
最後に何かあります、いいえ、それは本当にありがとう、ええ、

1094
00:47:59,400 --> 00:48:01,560
とても素晴らしいものをプレゼントする可能性があることにもう一度感謝します ここに来るのは

1095
00:48:01,560 --> 00:48:03,000


1096
00:48:03,000 --> 00:48:05,460
クールです、そうそう、今年の後半には、

1097
00:48:05,460 --> 00:48:08,940
あなたの最近の取り組みについて 2 部構成で話し合う予定です。

1098
00:48:08,940 --> 00:48:11,400
そのため、詳細について詳しく説明していきます。

1099
00:48:11,400 --> 00:48:14,579


1100
00:48:14,579 --> 00:48:16,260
エコシステム内の研究所の人々も

1101
00:48:16,260 --> 00:48:19,319
同様に興奮してくれることを願っています。 みんな、

1102
00:48:19,319 --> 00:48:24,319
ありがとう、大丈夫、ありがとう、バイバイ、大丈夫、

1103
00:48:32,940 --> 00:48:35,720
大丈夫、

1104
00:48:37,260 --> 00:48:40,040


1105
00:48:43,200 --> 00:48:46,079
次のインターバルまで

1106
00:48:46,079 --> 00:48:48,680


