1
00:00:07,280 --> 00:00:10,260
大家好，欢迎大家回来，

2
00:00:10,260 --> 00:00:14,639
这是 2023 年 8 月 22 日在主动推理研究所举行的第三届应用主动推理研讨会的第二个间歇期，

3
00:00:14,639 --> 00:00:17,039


4
00:00:17,039 --> 00:00:19,500


5
00:00:19,500 --> 00:00:23,220


6
00:00:23,220 --> 00:00:26,760
这将是另一个协议和

7
00:00:26,760 --> 00:00:30,240
令人兴奋的间歇期，我们将

8
00:00:30,240 --> 00:00:33,420
与 Jean Francois Cloutier 一起拉开帷幕

9
00:00:33,420 --> 00:00:36,300
理论家的第一步，所以

10
00:00:36,300 --> 00:00:39,780
JF 感谢您的加入并感谢您的

11
00:00:39,780 --> 00:00:41,940
演示，如果有人

12
00:00:41,940 --> 00:00:44,399
对本演示或任何

13
00:00:44,399 --> 00:00:46,620
其他演示有疑问，请直接将其放入

14
00:00:46,620 --> 00:00:49,379
实时聊天中，我会做到的，我可以，所以感谢

15
00:00:49,379 --> 00:00:52,099
JF 您

16
00:00:54,239 --> 00:00:57,660
嗯嗯，谢谢丹尼尔，

17
00:00:57,660 --> 00:01:00,840
我是一名软件工程师，

18
00:01:00,840 --> 00:01:03,660
在一家名为 smartrent 的公司编写

19
00:01:03,660 --> 00:01:07,320
智能家居系统软件，我还在

20
00:01:07,320 --> 00:01:09,360
主动

21
00:01:09,360 --> 00:01:11,880
推理研究所从事一个名为机器人学

22
00:01:11,880 --> 00:01:14,600
和体现项目的研究项目，

23
00:01:14,600 --> 00:01:18,420
我目前的重点是无监督

24
00:01:18,420 --> 00:01:21,720
学习 在

25
00:01:21,720 --> 00:01:24,420
我今天的演讲中，我的演讲题为“

26
00:01:24,420 --> 00:01:27,900
理论家集体的第一步

27
00:01:27,900 --> 00:01:30,240
”，我将首先简要回顾

28
00:01:30,240 --> 00:01:31,979
该项目，

29
00:01:31,979 --> 00:01:36,420
然后深入探讨最近的进展，然后

30
00:01:36,420 --> 00:01:39,060
我将总结我所认为的

31
00:01:39,060 --> 00:01:42,799
下一步

32
00:01:43,860 --> 00:01:47,579
自 2017 年以来，这个项目一直很好，我一直在尝试

33
00:01:47,579 --> 00:01:51,960
乐高机器人和认知模型，

34
00:01:51,960 --> 00:01:55,920
我这样做是为了我自己的教育，

35
00:01:55,920 --> 00:01:59,220
因为呃，我想我们大多数人

36
00:01:59,220 --> 00:02:01,259
在构建它时都会更好地理解一些东西，

37
00:02:01,259 --> 00:02:02,100


38
00:02:02,100 --> 00:02:06,240
你在这里看到的是我最新的机器人

39
00:02:06,240 --> 00:02:08,580
模型 这是一个漫游者，

40
00:02:08,580 --> 00:02:12,239
它有一大堆传感器和

41
00:02:12,239 --> 00:02:15,720
许多效应执行器，

42
00:02:15,720 --> 00:02:17,400
嗯，事实上，这些传感器和

43
00:02:17,400 --> 00:02:19,200
执行器可以理解为形成

44
00:02:19,200 --> 00:02:24,738
我的机器人毯子的标记，

45
00:02:26,340 --> 00:02:29,459
去年我在研讨会上介绍了机器人

46
00:02:29,459 --> 00:02:32,160
的历史 项目

47
00:02:32,160 --> 00:02:35,459
是呃，然后是状态，

48
00:02:35,459 --> 00:02:36,780
嗯，这是雄心，

49
00:02:36,780 --> 00:02:39,959
我提出了一个认知模型，

50
00:02:39,959 --> 00:02:42,959
从主动推理的角度实现了预测处理，

51
00:02:42,959 --> 00:02:45,540
所以它们

52
00:02:45,540 --> 00:02:47,519
生成了模型，有

53
00:02:47,519 --> 00:02:50,160
预测，有预测错误，

54
00:02:50,160 --> 00:02:51,660


55
00:02:51,660 --> 00:02:54,720
嗯，这些生成模型为机器人设置了动画，

56
00:02:54,720 --> 00:02:57,720
以便它们漫游避免

57
00:02:57,720 --> 00:03:01,019
障碍呃观察他们的呃同伴

58
00:03:01,019 --> 00:03:04,080
，并以一种非常简单的方式建立

59
00:03:04,080 --> 00:03:08,160
另一个机器人的心理理论，他们

60
00:03:08,160 --> 00:03:11,360
可以从观察中

61
00:03:11,360 --> 00:03:14,220
推断呃另一个机器人有有

62
00:03:14,220 --> 00:03:16,440
缺陷的食物食物在这里

63
00:03:16,440 --> 00:03:20,159
作为一张纸放在地板上，

64
00:03:20,159 --> 00:03:23,159
然后 呃会尝试跟踪

65
00:03:23,159 --> 00:03:25,680
另一个机器人来获取食物

66
00:03:25,680 --> 00:03:28,680
和有趣的东西，比如这样的

67
00:03:28,680 --> 00:03:31,640
实现呃结合了呃

68
00:03:31,640 --> 00:03:33,720
多重处理和功能

69
00:03:33,720 --> 00:03:35,280
计算

70
00:03:35,280 --> 00:03:40,040
在实现中没有任何概率

71
00:03:41,040 --> 00:03:42,959
我想也许你会呃看到它们在

72
00:03:42,959 --> 00:03:44,760
行动 这是去年展示的内容，

73
00:03:44,760 --> 00:03:48,659
但只是为了了解它们所做的事情，

74
00:03:48,659 --> 00:03:50,700
我这里有两个机器人，

75
00:03:50,700 --> 00:03:53,700
一个叫卡尔和安迪，我在

76
00:03:53,700 --> 00:03:55,560
知道我要在会议上展示之前给它们命名了，

77
00:03:55,560 --> 00:03:57,299


78
00:03:57,299 --> 00:04:01,799
所以呃，它们受益于一系列

79
00:04:01,799 --> 00:04:06,239
培训 他们呃学会了如何嗯

80
00:04:06,239 --> 00:04:11,280
呃找到哪些政策比

81
00:04:11,280 --> 00:04:14,819
其他人能更好地实现他们的目标，呃

82
00:04:14,819 --> 00:04:17,279
左边的一个人立即找到了食物

83
00:04:17,279 --> 00:04:21,060
兄弟，但更接近

84
00:04:21,060 --> 00:04:24,660
基座呃那里的灯塔

85
00:04:24,660 --> 00:04:27,120
模拟了食物的气味

86
00:04:27,120 --> 00:04:27,860
嗯

87
00:04:27,860 --> 00:04:31,440
恐惧 发生碰撞，

88
00:04:31,440 --> 00:04:35,280
然后匆忙后退，因为我们会看到

89
00:04:35,280 --> 00:04:38,180
另一个机器人观察到这一切，

90
00:04:38,180 --> 00:04:40,979
看到另一个机器人

91
00:04:40,979 --> 00:04:44,759
后退时感到惊慌，呃决定

92
00:04:44,759 --> 00:04:48,479
分享这种情绪并后​​退

93
00:04:48,479 --> 00:04:53,360
好吧，所以你知道呃有趣的东西，

94
00:04:56,400 --> 00:05:00,120
嗯，从一开始就

95
00:05:00,120 --> 00:05:02,160
实现了不同的认知模型，

96
00:05:02,160 --> 00:05:03,600
但它们都有一个共同点，那就是

97
00:05:03,600 --> 00:05:07,500
它们实现了心灵社会，

98
00:05:07,500 --> 00:05:09,300
那么什么是心灵社会，

99
00:05:09,300 --> 00:05:12,600
心灵社会是一个概念

100
00:05:12,600 --> 00:05:17,479
嗯嗯嗯，心灵不是一个整体的

101
00:05:17,479 --> 00:05:22,440
呃结构，而是由简单的

102
00:05:22,440 --> 00:05:25,680
参与者组成，独立的参与者以

103
00:05:25,680 --> 00:05:28,580
简单的方式相互作用，

104
00:05:28,580 --> 00:05:31,740
心灵的观点是

105
00:05:31,740 --> 00:05:34,199
由马文·明斯基嗯在

106
00:05:34,199 --> 00:05:38,120
50年前提出的，所以这不是

107
00:05:40,080 --> 00:05:44,100
最近我去年提出的是一个

108
00:05:44,100 --> 00:05:46,740
心灵社会，其中包含一个层次结构，

109
00:05:46,740 --> 00:05:50,100
我称之为认知参与者，每个

110
00:05:50,100 --> 00:05:51,660
认知参与者都是一个独立的

111
00:05:51,660 --> 00:05:52,740
过程，

112
00:05:52,740 --> 00:05:55,919
每个认知参与者都有一个范围，也有一个

113
00:05:55,919 --> 00:05:56,780


114
00:05:56,780 --> 00:06:00,479
抽象级别，所以

115
00:06:00,479 --> 00:06:01,979
例如你会有一个委托

116
00:06:01,979 --> 00:06:03,900
参与者 关心

117
00:06:03,900 --> 00:06:05,240
食物的位置，

118
00:06:05,240 --> 00:06:08,280
它会对食物位置有信念和

119
00:06:08,280 --> 00:06:11,039
看法，

120
00:06:11,039 --> 00:06:12,900
这些会反馈到更高层次的

121
00:06:12,900 --> 00:06:16,259
认知参与者，比如说食物方法，

122
00:06:16,259 --> 00:06:18,840
它关心靠近

123
00:06:18,840 --> 00:06:21,960
食物等等，等等这些

124
00:06:21,960 --> 00:06:25,380
连接参与者再次沟通 用

125
00:06:25,380 --> 00:06:27,120
简单的方式来说，这是一个心灵社会，

126
00:06:27,120 --> 00:06:29,580
他们通过发出

127
00:06:29,580 --> 00:06:32,280
关于

128
00:06:32,280 --> 00:06:35,340
其他认知参与者的信念的预测来进行交流，

129
00:06:35,340 --> 00:06:37,740


130
00:06:37,740 --> 00:06:40,440
当其他人对他们的信念做出的预测

131
00:06:40,440 --> 00:06:44,460
不准确时，他们通过发出预测错误来进行交流，从而

132
00:06:44,460 --> 00:06:48,600
导致呃连接参与者

133
00:06:48,600 --> 00:06:52,139
处理这些 呃预测错误，

134
00:06:52,139 --> 00:06:53,880
并将它们与他们自己的

135
00:06:53,880 --> 00:06:58,500
预测相结合，创建一组更新的

136
00:06:58,500 --> 00:07:01,740
感知，这些感知被合成为

137
00:07:01,740 --> 00:07:05,039
信念，这些信念导致

138
00:07:05,039 --> 00:07:07,699
嗯行动，以消除

139
00:07:07,699 --> 00:07:10,740
消极信念和价值或验证

140
00:07:10,740 --> 00:07:12,360
积极信念，

141
00:07:12,360 --> 00:07:15,360
现在它来自所有

142
00:07:15,360 --> 00:07:18,600
这些的相互作用 连接参与者，看似

143
00:07:18,600 --> 00:07:22,380
有目的的行为出现，

144
00:07:22,380 --> 00:07:25,500
因此是成功的，但学习

145
00:07:25,500 --> 00:07:29,880
非常有限，这个认知层次结构

146
00:07:29,880 --> 00:07:33,259
和参与者是

147
00:07:33,259 --> 00:07:36,780
预先定义的，

148
00:07:36,780 --> 00:07:39,599
机器人会做的唯一学习就是

149
00:07:39,599 --> 00:07:43,580
发现哪些行动政策倾向于

150
00:07:43,580 --> 00:07:47,300
更有效，

151
00:07:50,160 --> 00:07:54,000
所以显然我的机器人不是整体的

152
00:07:54,000 --> 00:07:57,479
主动推理代理，

153
00:07:57,479 --> 00:08:01,039
所以问题是为什么我会

154
00:08:01,039 --> 00:08:04,740
很好地使用心智社会架构，

155
00:08:04,740 --> 00:08:09,599
因为我同意呃

156
00:08:09,599 --> 00:08:12,660
概念，即所有智能都是

157
00:08:12,660 --> 00:08:14,699
集体智能，

158
00:08:14,699 --> 00:08:17,819
并且这篇论文使呃

159
00:08:17,819 --> 00:08:20,879
呃，非常有说服力的论点，

160
00:08:20,879 --> 00:08:22,560
我将引用一些对

161
00:08:22,560 --> 00:08:24,319


162
00:08:24,319 --> 00:08:26,639
我的

163
00:08:26,639 --> 00:08:30,080
思想演变很重要的论文，这是其中之一，

164
00:08:30,720 --> 00:08:33,659
这篇论文将智力视为一个

165
00:08:33,659 --> 00:08:34,860
过程，

166
00:08:34,860 --> 00:08:37,080
而不是一种财产，它是一个

167
00:08:37,080 --> 00:08:40,620
制定的过程 由相互作用的部分组成，

168
00:08:40,620 --> 00:08:42,958
而不是个人的财产，

169
00:08:42,958 --> 00:08:44,940


170
00:08:44,940 --> 00:08:47,820
所以心灵社会基本上是，

171
00:08:47,820 --> 00:08:51,720
它实际上是一系列

172
00:08:51,720 --> 00:08:54,660
相互作用的过程，

173
00:08:54,660 --> 00:08:58,440
这些过程共同产生了

174
00:08:58,440 --> 00:09:01,440
完全智能的行为，现在是

175
00:09:01,440 --> 00:09:04,380
我个人对智能的定义

176
00:09:04,380 --> 00:09:08,220
是呃自我维持和

177
00:09:08,220 --> 00:09:10,560
主动的意义创造，因为

178
00:09:10,560 --> 00:09:14,160


179
00:09:14,160 --> 00:09:15,300


180
00:09:15,300 --> 00:09:19,380
在耗散和动态环境中，自主代理作为系统非常重要，

181
00:09:19,380 --> 00:09:21,480
这指导了

182
00:09:21,480 --> 00:09:26,720
我现在在这个项目中所做的所有工作，

183
00:09:27,300 --> 00:09:30,720
如果你想要一个嗯描述，

184
00:09:30,720 --> 00:09:33,200
详细描述呃在

185
00:09:33,200 --> 00:09:37,320
哪里 我的项目是在一年前发表的，

186
00:09:37,320 --> 00:09:40,380


187
00:09:40,380 --> 00:09:42,839
我在 xenodome 上发表了一篇论文，你现在可以

188
00:09:42,839 --> 00:09:45,800
查一下，

189
00:09:47,459 --> 00:09:50,940
去年我想

190
00:09:50,940 --> 00:09:54,899
从预先建立的一个特定的

191
00:09:54,899 --> 00:09:59,040
心灵社会转向一个博学的社会

192
00:09:59,040 --> 00:10:01,560
我想看看，

193
00:10:01,560 --> 00:10:04,620
嗯，我是否可以对一个自主机器人进行编程，使其

194
00:10:04,620 --> 00:10:08,459
通过与其环境的交互，在心灵社会中进化。

195
00:10:08,459 --> 00:10:11,760


196
00:10:11,760 --> 00:10:13,860
现在，人们可能会认为编程

197
00:10:13,860 --> 00:10:18,420
自主性是一种矛盾，嗯，

198
00:10:18,420 --> 00:10:21,360
是的，是的，这是一个

199
00:10:21,360 --> 00:10:24,060
很好的观点，但我不这么认为

200
00:10:24,060 --> 00:10:28,380
如果我编写和

201
00:10:28,380 --> 00:10:31,560
安装我的机器人的程序赋予了本

202
00:10:31,560 --> 00:10:34,680
构自主权，使

203
00:10:34,680 --> 00:10:37,920
机器人能够构建自己的身份，

204
00:10:37,920 --> 00:10:40,920
并且赋予了适应性，使

205
00:10:40,920 --> 00:10:44,640
机器人能够

206
00:10:44,640 --> 00:10:46,260
通过其交互来修改自身，那么我认为这不是问题 有了

207
00:10:46,260 --> 00:10:48,600
环境，我认为，

208
00:10:48,600 --> 00:10:54,000
呃，机器人，呃，现在将是真正的

209
00:10:54,000 --> 00:10:55,920
自主性，

210
00:10:55,920 --> 00:10:59,700
因为自主性，嗯，机器人

211
00:10:59,700 --> 00:11:01,500
固有地存在于机器人中，

212
00:11:01,500 --> 00:11:04,740
机器人中的某些东西必须处于危险之中，

213
00:11:04,740 --> 00:11:07,620
在这种情况下，这绝对

214
00:11:07,620 --> 00:11:10,440
是机器人的生存。 机器人心灵社会

215
00:11:10,440 --> 00:11:13,019
现在，

216
00:11:13,019 --> 00:11:15,720
机器人的物理结构

217
00:11:15,720 --> 00:11:19,560
没有受到威胁，它的生存没有受到

218
00:11:19,560 --> 00:11:21,540
威胁，除非它从架子上掉下来，

219
00:11:21,540 --> 00:11:22,320


220
00:11:22,320 --> 00:11:24,839
但因为我打算

221
00:11:24,839 --> 00:11:27,720
嗯让我的机器人从经验中发展出它的

222
00:11:27,720 --> 00:11:31,800
心灵社会，我也期望

223
00:11:31,800 --> 00:11:34,019
如果失败的话，心灵社会

224
00:11:34,019 --> 00:11:37,500
将在其成长

225
00:11:37,500 --> 00:11:40,200
和维持自身的尝试中灭亡，

226
00:11:40,200 --> 00:11:43,019
所以这就是

227
00:11:43,019 --> 00:11:45,540
当前和未来该

228
00:11:45,540 --> 00:11:48,540
项目的利害攸关之处，那就是机器人在

229
00:11:48,540 --> 00:11:50,279
我的机器人社会的生存中生存下来，

230
00:11:50,279 --> 00:11:53,660
而这种生存 将是一种

231
00:11:53,660 --> 00:11:57,660
存在的表达，

232
00:11:57,660 --> 00:12:00,180
机器人需要

233
00:12:00,180 --> 00:12:02,399
在其环境中进行互动，以便

234
00:12:02,399 --> 00:12:03,540
生存，

235
00:12:03,540 --> 00:12:06,300
无论它对

236
00:12:06,300 --> 00:12:08,820
环境有何意义，都将基于

237
00:12:08,820 --> 00:12:11,940
机器人社会本质上的生存必要性

238
00:12:11,940 --> 00:12:15,120


239
00:12:15,120 --> 00:12:16,620


240
00:12:16,620 --> 00:12:19,500
如果不是这种情况，我的我将在游戏中占有一席之地，因为

241
00:12:19,500 --> 00:12:21,180
制作实际上会驻留在其他地方，

242
00:12:21,180 --> 00:12:23,100
它会驻留在

243
00:12:23,100 --> 00:12:25,260
我的程序员的脑海中，

244
00:12:25,260 --> 00:12:27,540
当我观察呃机器人时，但我

245
00:12:27,540 --> 00:12:30,180
想 意义建立

246
00:12:30,180 --> 00:12:33,180
在机器人思想本身的生存之上，

247
00:12:33,180 --> 00:12:34,920


248
00:12:34,920 --> 00:12:37,560
所以现在这是关键，

249
00:12:37,560 --> 00:12:41,640
我所说的不断发展和

250
00:12:41,640 --> 00:12:44,399
成长的思想社会是什么意思，而不是

251
00:12:44,399 --> 00:12:46,980
我之前展示的给定的思想社会，

252
00:12:46,980 --> 00:12:48,899


253
00:12:48,899 --> 00:12:50,459
我想要

254
00:12:50,459 --> 00:12:54,600
嗯，我想要 认知参与者被

255
00:12:54,600 --> 00:12:58,459
创建为

256
00:12:58,459 --> 00:13:01,139
通过与环境的交互动态地相互联系，

257
00:13:01,139 --> 00:13:03,360


258
00:13:03,360 --> 00:13:05,940
所以我想要一个活跃的

259
00:13:05,940 --> 00:13:07,700


260
00:13:07,700 --> 00:13:10,560
认知

261
00:13:10,560 --> 00:13:12,839
参与者集体，现在是这样可行的，这是

262
00:13:12,839 --> 00:13:14,579
一个大问题，

263
00:13:14,579 --> 00:13:17,220
以便并尝试 回答这个

264
00:13:17,220 --> 00:13:19,620
问题呃我也会

265
00:13:19,620 --> 00:13:22,260
回答呃问题，比如

266
00:13:22,260 --> 00:13:25,380
必须先验什么以及可以很好地

267
00:13:25,380 --> 00:13:28,260
发现什么我已经有了

268
00:13:28,260 --> 00:13:31,380
答案的要素我知道嗯

269
00:13:31,380 --> 00:13:36,420
传感器和呃效应器以及嗯

270
00:13:36,420 --> 00:13:38,820
认知

271
00:13:38,820 --> 00:13:41,399
包裹它们的原始认知演员将被赋予这个，

272
00:13:41,399 --> 00:13:43,139
这基本上就像你与生俱来的，

273
00:13:43,139 --> 00:13:46,380
可能会有一个嗯元

274
00:13:46,380 --> 00:13:50,220
认知演员，其角色将

275
00:13:50,220 --> 00:13:53,060
是呃监督和指导

276
00:13:53,060 --> 00:13:56,279
呃所有其他认知演员的进化，但这

277
00:13:56,279 --> 00:14:00,019
就是 这是我的假设

278
00:14:00,720 --> 00:14:03,959
我可以想象一个我的机器人的测试环境，它将

279
00:14:03,959 --> 00:14:06,959
测试它的

280
00:14:06,959 --> 00:14:10,139
生存能力我可以想象，例如，

281
00:14:10,139 --> 00:14:13,980
当机器人移动或

282
00:14:13,980 --> 00:14:18,300
计算它时，它使用

283
00:14:18,300 --> 00:14:20,279
模拟的有限能量存储，

284
00:14:20,279 --> 00:14:23,279
并且该能量存储是

285
00:14:23,279 --> 00:14:26,459
当机器人消耗食物时进行补充，这

286
00:14:26,459 --> 00:14:29,420
将通过在地板上的

287
00:14:29,420 --> 00:14:31,980
彩色纸片上进行补充，

288
00:14:31,980 --> 00:14:34,139


289
00:14:34,139 --> 00:14:35,700
嗯，我将确保它

290
00:14:35,700 --> 00:14:37,680
需要两种食物来源才能

291
00:14:37,680 --> 00:14:39,240
正确生存，这将被代表

292
00:14:39,240 --> 00:14:41,399
例如，通过一张黄纸和一张绿纸，

293
00:14:41,399 --> 00:14:43,800
这样可以防止机器人

294
00:14:43,800 --> 00:14:46,320
只是简单地找到一个

295
00:14:46,320 --> 00:14:48,899
食物来源并驻扎在

296
00:14:48,899 --> 00:14:52,019
其上方，这样环境中也会包含

297
00:14:52,019 --> 00:14:54,480
障碍物，因此机器人需要

298
00:14:54,480 --> 00:14:57,560
学习如何导航以避免 障碍

299
00:14:57,560 --> 00:15:01,139
找到不同的食物来源，

300
00:15:01,139 --> 00:15:03,800
并确保它在

301
00:15:03,800 --> 00:15:06,660
不同的食物来源之间交替以

302
00:15:06,660 --> 00:15:10,139
生存，并且

303
00:15:10,139 --> 00:15:13,680
将进化的心灵社会将呃

304
00:15:13,680 --> 00:15:14,839
希望

305
00:15:14,839 --> 00:15:18,000
能够进化成功地做到这一点，否则

306
00:15:18,000 --> 00:15:21,000
如果没有的话

307
00:15:21,000 --> 00:15:25,260
随着资源的消失，它会缩小，并且

308
00:15:25,260 --> 00:15:28,620
基本上会死亡，所以这就是

309
00:15:28,620 --> 00:15:33,380
这个机器人的利害关系，

310
00:15:33,779 --> 00:15:36,540
现在这项工作采用了许多

311
00:15:36,540 --> 00:15:38,399
框架，

312
00:15:38,399 --> 00:15:39,360


313
00:15:39,360 --> 00:15:41,880
我所说的框架是指一个有用的

314
00:15:41,880 --> 00:15:44,220
概念和约束系统，

315
00:15:44,220 --> 00:15:47,699
它可以指导呃 实施得

316
00:15:47,699 --> 00:15:49,920
很好，显然有自由

317
00:15:49,920 --> 00:15:51,480
能原理和主动

318
00:15:51,480 --> 00:15:54,660
推理呃框架，

319
00:15:54,660 --> 00:15:55,860
嗯，

320
00:15:55,860 --> 00:15:59,160
但是我认为这是 IC 主动

321
00:15:59,160 --> 00:16:03,420
推理框架，它

322
00:16:03,420 --> 00:16:07,440
描述了

323
00:16:07,440 --> 00:16:12,180
在这种情况下必须实现的目标，呃减少了代理的

324
00:16:12,180 --> 00:16:14,699
呃变分自由能，但是 它

325
00:16:14,699 --> 00:16:16,620
没有指导我

326
00:16:16,620 --> 00:16:19,380
实现如何构建这个机器人，

327
00:16:19,380 --> 00:16:20,820


328
00:16:20,820 --> 00:16:25,260
我需要的是框架，并且我

329
00:16:25,260 --> 00:16:28,860
将使用呃两个框架，其中一个

330
00:16:28,860 --> 00:16:30,300


331
00:16:30,300 --> 00:16:33,180
是我从项目一开始就一直在使用的框架 演员

332
00:16:33,180 --> 00:16:34,139
模型

333
00:16:34,139 --> 00:16:37,500
呃演员模型呃将计算

334
00:16:37,500 --> 00:16:39,060
视为

335
00:16:39,060 --> 00:16:43,380
嗯呃进程的多样性

336
00:16:43,380 --> 00:16:45,000
独立的进程有自己的

337
00:16:45,000 --> 00:16:47,399
私有内部状态并且

338
00:16:47,399 --> 00:16:49,440


339
00:16:49,440 --> 00:16:51,899
通过消息严格地相互通信嗯

340
00:16:51,899 --> 00:16:54,660
昨天在呃间隔一呃

341
00:16:54,660 --> 00:16:57,600
基思杜格呃呃在演员模型上介绍了

342
00:16:57,600 --> 00:17:01,199
并提出我们应该使用

343
00:17:01,199 --> 00:17:02,759
参与者模型来

344
00:17:02,759 --> 00:17:05,459
很好地实现主动推理代理，我完全

345
00:17:05,459 --> 00:17:06,780
同意他们的观点，

346
00:17:06,780 --> 00:17:09,959
我将使用的另一个呃框架

347
00:17:09,959 --> 00:17:13,500
是符号人工智能的一个特例，

348
00:17:13,500 --> 00:17:16,619
称为应用程序接收引擎和

349
00:17:16,619 --> 00:17:18,980
大部分 演示将是关于

350
00:17:18,980 --> 00:17:21,780
对立引擎及其

351
00:17:21,780 --> 00:17:24,379
实现，

352
00:17:24,959 --> 00:17:28,319
所以这就是我们所处的位置，呃，该项目

353
00:17:28,319 --> 00:17:32,040
位于主动

354
00:17:32,040 --> 00:17:35,640
推理作为一个领域、什么和

355
00:17:35,640 --> 00:17:39,059
作为一种架构的心灵社会以及

356
00:17:39,059 --> 00:17:43,140
作为一种计算形式的符号人工智能的交叉点，所以

357
00:17:43,140 --> 00:17:45,600
这就是其中 这个项目就在这个

358
00:17:45,600 --> 00:17:48,020
十字路口，

359
00:17:48,960 --> 00:17:51,840
你知道从哪里开始，所以我想深入

360
00:17:51,840 --> 00:17:52,620


361
00:17:52,620 --> 00:17:55,980
研究

362
00:17:55,980 --> 00:17:58,740
一种更广泛的学习形式，从

363
00:17:58,740 --> 00:18:02,520
逻辑上讲，第一步是学习

364
00:18:02,520 --> 00:18:05,580
如何预测，所以

365
00:18:05,580 --> 00:18:06,980
我想

366
00:18:06,980 --> 00:18:12,360
启用一个认知参与者 我们将从

367
00:18:12,360 --> 00:18:15,240
单个认知参与者开始，

368
00:18:15,240 --> 00:18:17,220
学习如何理解其本地

369
00:18:17,220 --> 00:18:20,880
环境，即所谓的“unvelt”和“

370
00:18:20,880 --> 00:18:23,460
有意义”

371
00:18:23,460 --> 00:18:28,100
意味着至少能够预测

372
00:18:28,100 --> 00:18:31,080
传入的感觉，因此它需要学习

373
00:18:31,080 --> 00:18:33,918
预测

374
00:18:36,660 --> 00:18:38,400


375
00:18:38,400 --> 00:18:41,220
什么 将被提供给认知演员a

376
00:18:41,220 --> 00:18:45,500
uh，将会有uh 感觉uh 的历史

377
00:18:45,500 --> 00:18:50,640
被分解为离散的时间单位，

378
00:18:50,640 --> 00:18:51,660


379
00:18:51,660 --> 00:18:55,559
因此时间n 减3 和N 减2 和

380
00:18:55,559 --> 00:18:57,960
减1 时间n 是当前

381
00:18:57,960 --> 00:19:00,320
时刻，

382
00:19:00,539 --> 00:19:02,400
因此这些将被记住

383
00:19:02,400 --> 00:19:04,380


384
00:19:04,380 --> 00:19:06,240
然后我们想要从中得到的

385
00:19:06,240 --> 00:19:11,039
是能够预测

386
00:19:11,039 --> 00:19:14,880
在时间 uh T

387
00:19:14,880 --> 00:19:17,700
等于 n 加一和加二时下一组传入的感觉，

388
00:19:17,700 --> 00:19:19,679
为了

389
00:19:19,679 --> 00:19:21,600
能够预测 uh 未来的

390
00:19:21,600 --> 00:19:24,059
观察结果，我们需要某种

391
00:19:24,059 --> 00:19:25,679
预测器

392
00:19:25,679 --> 00:19:28,200
从记忆的

393
00:19:28,200 --> 00:19:30,480
观察中学到的函数

394
00:19:30,480 --> 00:19:33,179
现在可以

395
00:19:33,179 --> 00:19:36,419
通过两种非常通用的方式来构建这种预测能力，一种是

396
00:19:36,419 --> 00:19:39,600
通过统计，进行模式

397
00:19:39,600 --> 00:19:42,600
分析，并且能够预测

398
00:19:42,600 --> 00:19:44,760
最可能的情况，这是

399
00:19:44,760 --> 00:19:47,580
标准的当前机器学习

400
00:19:47,580 --> 00:19:51,419
方法，或者我们可以

401
00:19:51,419 --> 00:19:55,440
通过

402
00:19:55,440 --> 00:19:58,160
开发一个因果模型来预测

403
00:19:58,160 --> 00:20:03,480
产生这些

404
00:20:03,480 --> 00:20:04,500
感觉的因果模型，

405
00:20:04,500 --> 00:20:08,160
并根据这种理解预测

406
00:20:08,160 --> 00:20:13,940
下一步应该理性观察到什么，

407
00:20:16,080 --> 00:20:18,660
所以这都是关于

408
00:20:18,660 --> 00:20:20,039
意义构建的，

409
00:20:20,039 --> 00:20:23,880
现在什么是意义构建我该如何做

410
00:20:23,880 --> 00:20:26,340
理解感官输入

411
00:20:26,340 --> 00:20:27,299
意味着要从中

412
00:20:27,299 --> 00:20:29,460


413
00:20:29,460 --> 00:20:32,580


414
00:20:32,580 --> 00:20:34,320


415
00:20:34,320 --> 00:20:35,460


416
00:20:35,460 --> 00:20:37,860


417
00:20:37,860 --> 00:20:41,580
获得有意义的体验，

418
00:20:41,580 --> 00:20:44,520
这不仅仅是数据，不仅仅是

419
00:20:44,520 --> 00:20:47,340
数据片段 必须有

420
00:20:47,340 --> 00:20:50,820
有意义的体验，

421
00:20:50,820 --> 00:20:54,299
我所说的体验是指感觉的概念化

422
00:20:54,299 --> 00:20:55,559


423
00:20:55,559 --> 00:20:58,620
以及它们在时间和

424
00:20:58,620 --> 00:21:02,640
空间上的统一，因此理解这些输入

425
00:21:02,640 --> 00:21:04,320
将意味着

426
00:21:04,320 --> 00:21:06,960
产生有意义的体验，这些体验是

427
00:21:06,960 --> 00:21:09,299
感觉的概念化和统一，

428
00:21:09,299 --> 00:21:11,820
现在的体验是

429
00:21:11,820 --> 00:21:14,220


430
00:21:14,220 --> 00:21:17,700
如果它是由因果模型承保的，

431
00:21:17,700 --> 00:21:21,360
那么体验是有意义的，被认为是

432
00:21:21,360 --> 00:21:24,860


433
00:21:24,860 --> 00:21:27,360
潜在生成模型的结果，

434
00:21:27,360 --> 00:21:29,640
我们已经建模了生成过程，

435
00:21:29,640 --> 00:21:31,140


436
00:21:31,140 --> 00:21:33,960
我希望意义是

437
00:21:33,960 --> 00:21:36,299
主体固有的，并且只有当主体

438
00:21:36,299 --> 00:21:39,600
是 真正自主，如果这个含义

439
00:21:39,600 --> 00:21:41,760
是基于前面讨论的生存法则，

440
00:21:41,760 --> 00:21:45,379


441
00:21:46,380 --> 00:21:48,900
那么扩展是如何工作的，

442
00:21:48,900 --> 00:21:52,260
如何将其放入计算机代码中

443
00:21:52,260 --> 00:21:54,659
令人惊讶的是，为此我们参考了

444
00:21:54,659 --> 00:21:58,520
伊曼纽尔·康德的哲学，

445
00:21:58,520 --> 00:22:02,159
逆向工程方法，

446
00:22:02,159 --> 00:22:05,100
嗯问自己必须实体是什么

447
00:22:05,100 --> 00:22:08,100
为了获得经验而做的事情

448
00:22:08,100 --> 00:22:10,620
类似于自由能

449
00:22:10,620 --> 00:22:13,080
原理的大道，可以

450
00:22:13,080 --> 00:22:16,200
解释为大多数有机体为

451
00:22:16,200 --> 00:22:18,480
维持其存在而所做的事情，所以在手动

452
00:22:18,480 --> 00:22:22,679
操作中，我们尝试逆向工程

453
00:22:22,679 --> 00:22:26,159
嗯认知

454
00:22:27,720 --> 00:22:31,080
嗯问自己一个生物体

455
00:22:31,080 --> 00:22:33,600
所需的最小认知装置是什么 实体

456
00:22:33,600 --> 00:22:36,059
拥有经验，

457
00:22:36,059 --> 00:22:40,020
并且他在对

458
00:22:40,020 --> 00:22:43,380
纯粹理性的批判中记录了一点

459
00:22:43,380 --> 00:22:44,940
括号，

460
00:22:44,940 --> 00:22:47,400
嗯，

461
00:22:47,400 --> 00:22:50,220
纯粹理性批评家这个标题的含义不是我想象的那样，

462
00:22:50,220 --> 00:22:51,539


463
00:22:51,539 --> 00:22:53,340
嗯，它实际上更接近于一段

464
00:22:53,340 --> 00:22:56,880
时期的情况 认可、

465
00:22:56,880 --> 00:22:59,700
批评是一个法律术语，是

466
00:22:59,700 --> 00:23:02,460
你提出自己的观点和纯粹理性的地方，呃我们

467
00:23:02,460 --> 00:23:03,900
现在翻译的是一个优先

468
00:23:03,900 --> 00:23:05,280
认知，

469
00:23:05,280 --> 00:23:06,840
所以

470
00:23:06,840 --> 00:23:08,100
嗯

471
00:23:08,100 --> 00:23:10,559
他的工作想要确定必须发生什么才能

472
00:23:10,559 --> 00:23:12,299
创造一种连贯的体验，

473
00:23:12,299 --> 00:23:13,500


474
00:23:13,500 --> 00:23:16,799
在时间和空间上是统一的

475
00:23:16,799 --> 00:23:19,380
嗯和 通过逆向工程

476
00:23:19,380 --> 00:23:22,860
识别作为一个既

477
00:23:22,860 --> 00:23:27,918
完整又重要的系统，它是最小的

478
00:23:31,140 --> 00:23:34,320
好吧所以让我们

479
00:23:34,320 --> 00:23:36,419
嗯我会尝试给你呃张贴

480
00:23:36,419 --> 00:23:41,280
呃邮票呃版本的呃呃

481
00:23:41,280 --> 00:23:44,880
伊曼纽尔理论呃专注于统觉的合成

482
00:23:44,880 --> 00:23:47,520
统一

483
00:23:47,520 --> 00:23:49,679
首先，有一个真实的世界，

484
00:23:49,679 --> 00:23:51,600
它超出了我们的直接

485
00:23:51,600 --> 00:23:54,659
经验，呃，它是一个名义上的世界，它

486
00:23:54,659 --> 00:23:57,900
永远对我们隐藏起来，

487
00:23:57,900 --> 00:24:04,200
嗯，作为一个现实，但我们这样做了，

488
00:24:04,200 --> 00:24:06,659
它会影响我们的感觉中枢，

489
00:24:06,659 --> 00:24:09,780
所以我们有很多直觉 站点

490
00:24:09,780 --> 00:24:12,539
声音触摸气味

491
00:24:12,539 --> 00:24:16,380
嗯最初是分开的

492
00:24:16,380 --> 00:24:20,039
然后我们需要呃网络它们

493
00:24:20,039 --> 00:24:22,940
在时间和空间上将它们连接在

494
00:24:22,940 --> 00:24:25,200
空间中

495
00:24:25,200 --> 00:24:30,480
嗯嗯是声音和并且并且

496
00:24:30,480 --> 00:24:34,440
站点呃描述单个事物

497
00:24:34,440 --> 00:24:39,059
嗯嗯是一件事 呃在另一个呃后面或呃在

498
00:24:39,059 --> 00:24:41,039
另一个

499
00:24:41,039 --> 00:24:43,679
呃里面，并且及时地发生在

500
00:24:43,679 --> 00:24:48,480
呃之后其他事情之前，然后在

501
00:24:48,480 --> 00:24:51,360
更高的层次上呃意义被赋予

502
00:24:51,360 --> 00:24:54,500
这些呃网络化直觉

503
00:24:54,500 --> 00:24:58,860
通过概念和判断规则

504
00:24:58,860 --> 00:25:02,940
呃这些是关于什么

505
00:25:02,940 --> 00:25:05,580
可以的概括 不可能是

506
00:25:05,580 --> 00:25:10,340
嗯，这就是我们现在所经历的事实证明，

507
00:25:12,900 --> 00:25:16,200


508
00:25:16,200 --> 00:25:19,020
这种感知的综合统一是

509
00:25:19,020 --> 00:25:19,620
嗯

510
00:25:19,620 --> 00:25:24,179
自动化意义构建的蓝图嗯，

511
00:25:24,179 --> 00:25:25,200


512
00:25:25,200 --> 00:25:27,659
这有点呃有趣我认为

513
00:25:27,659 --> 00:25:30,419
18世纪的哲学将呃

514
00:25:30,419 --> 00:25:33,779
与呃21世纪相关 世纪呃

515
00:25:33,779 --> 00:25:35,520
技术发展

516
00:25:35,520 --> 00:25:38,880
，这就是发生的事情，并且

517
00:25:38,880 --> 00:25:42,059
由理查德·埃文斯（Richard Evans）发表，

518
00:25:42,059 --> 00:25:44,460
并且所有在论文中都使

519
00:25:44,460 --> 00:25:47,760
感官输入变得有意义，他们开发了

520
00:25:47,760 --> 00:25:49,860
应用程序接收引擎，

521
00:25:49,860 --> 00:25:52,799
他们将我们的

522
00:25:52,799 --> 00:25:55,860
感知的合成统一作为软件需求并

523
00:25:55,860 --> 00:25:59,820
成功 将呃它们实施到一个

524
00:25:59,820 --> 00:26:01,380
软件应用程序接收

525
00:26:01,380 --> 00:26:04,679
引擎中，并将其应用于许多呃

526
00:26:04,679 --> 00:26:07,080
练习，

527
00:26:07,080 --> 00:26:10,980
他们得到了非常好的结果，

528
00:26:10,980 --> 00:26:14,460
所以反对引擎是

529
00:26:14,460 --> 00:26:15,860
机器学习的一个实例，它是

530
00:26:15,860 --> 00:26:18,600
无监督的机器学习，并且它

531
00:26:18,600 --> 00:26:22,260
运行在 非常小的数据集，

532
00:26:22,260 --> 00:26:25,860
生成人类可读的

533
00:26:25,860 --> 00:26:27,240
生成模型

534
00:26:27,240 --> 00:26:29,279
，当我读到这篇论文时，我意识到

535
00:26:29,279 --> 00:26:31,799
这正是我的机器人

536
00:26:31,799 --> 00:26:34,799
所需要的，

537
00:26:34,799 --> 00:26:37,799
那么在

538
00:26:37,799 --> 00:26:41,820
给定一系列观察到的状态的情况下，应用程序感知引擎可以做得很好，

539
00:26:41,820 --> 00:26:43,919


540
00:26:43,919 --> 00:26:47,820
它找到了一个生成模型

541
00:26:47,820 --> 00:26:52,080
可以重建过去的状态，但最

542
00:26:52,080 --> 00:26:55,740
重要的是预测未来的状态，

543
00:26:55,740 --> 00:26:59,580
并且状态被定义为一组

544
00:26:59,580 --> 00:27:03,059
同时的观测感觉

545
00:27:03,059 --> 00:27:05,960
直觉，

546
00:27:07,919 --> 00:27:09,179
因此

547
00:27:09,179 --> 00:27:11,480
感知引擎

548
00:27:11,480 --> 00:27:14,760
搜索可以重建观察的因果理论

549
00:27:14,760 --> 00:27:17,580
我说搜索是

550
00:27:17,580 --> 00:27:20,880
因为这种因果理论不是

551
00:27:20,880 --> 00:27:23,400
由观察决定，

552
00:27:23,400 --> 00:27:25,320
嗯，它必须被发现，它必须被发现，

553
00:27:25,320 --> 00:27:28,200
但

554
00:27:28,200 --> 00:27:30,600
一旦

555
00:27:30,600 --> 00:27:32,460
找到，就

556
00:27:32,460 --> 00:27:35,520
可以根据

557
00:27:35,520 --> 00:27:37,679
观察进行验证，看看它是否可以

558
00:27:37,679 --> 00:27:41,039
重新创建它们，并将它们扩展

559
00:27:41,039 --> 00:27:42,900
到未来

560
00:27:42,900 --> 00:27:46,220
和过去

561
00:27:47,159 --> 00:27:51,000
那么什么是因果理论 因果

562
00:27:51,000 --> 00:27:54,659
理论是一个逻辑程序，

563
00:27:54,659 --> 00:27:58,140
它有许多组件

564
00:27:58,140 --> 00:28:00,840
嗯它们在因果理论中

565
00:28:00,840 --> 00:28:02,039
会有

566
00:28:02,039 --> 00:28:04,620
嗯 观察到的呃关系中的对象和谓词，

567
00:28:04,620 --> 00:28:07,740
所以从

568
00:28:07,740 --> 00:28:10,620
观察中我们可以提取 观察到了哪些对象

569
00:28:10,620 --> 00:28:13,080
以及

570
00:28:13,080 --> 00:28:14,400
观察到了这些对象的哪些属性，以及可能

571
00:28:14,400 --> 00:28:16,200


572
00:28:16,200 --> 00:28:17,700
观察到了哪些关系和这些对象，这就是

573
00:28:17,700 --> 00:28:20,880
开始然后我们有潜在

574
00:28:20,880 --> 00:28:23,700
对象类型对象和谓词，因此

575
00:28:23,700 --> 00:28:26,279
我们可能想要想象因果理论

576
00:28:26,279 --> 00:28:30,240
想象隐藏对象可能处于以下类型

577
00:28:30,240 --> 00:28:32,340
对象和可能隐藏的 uh

578
00:28:32,340 --> 00:28:34,980
属性和 uh 对象之间的关系

579
00:28:34,980 --> 00:28:38,580
uh 潜在含义未观察到并

580
00:28:38,580 --> 00:28:40,799
给定观察到的和

581
00:28:40,799 --> 00:28:44,880
未观察到的 um uh uh 对象和和

582
00:28:44,880 --> 00:28:45,740
和以及和

583
00:28:45,740 --> 00:28:48,559
谓词它

584
00:28:48,559 --> 00:28:50,820


585
00:28:50,820 --> 00:28:52,380
首先导出规则对这些谓词的所有约束

586
00:28:52,380 --> 00:28:54,720
什么是允许的所以

587
00:28:54,720 --> 00:28:59,039
例如在 前面不能呃a

588
00:28:59,039 --> 00:29:01,260
不能同时在B前面

589
00:29:01,260 --> 00:29:04,140
B同时在B后面所以

590
00:29:04,140 --> 00:29:05,539
一个对象不能在另一个对象前面

591
00:29:05,539 --> 00:29:09,000
又在它后面所以它们是对谓词的约束

592
00:29:09,000 --> 00:29:10,260


593
00:29:10,260 --> 00:29:13,919
然后有一些规则适用于

594
00:29:13,919 --> 00:29:16,080
任何同时观察的集合

595
00:29:16,080 --> 00:29:19,919
必须符合什么呃呃然后

596
00:29:19,919 --> 00:29:22,679
有一些规则，给定一个状态将

597
00:29:22,679 --> 00:29:25,380
推断出下一个状态，然后可能是一些

598
00:29:25,380 --> 00:29:29,039
初始状态，我们可以从这个初始状态呃呃

599
00:29:29,039 --> 00:29:33,120
运行因果理论，

600
00:29:33,120 --> 00:29:37,380
那么是什么让因果理论

601
00:29:37,380 --> 00:29:39,120
首先很好地统一 为了理解观察的意义，所有这些都需要统一起来，

602
00:29:39,120 --> 00:29:40,500


603
00:29:40,500 --> 00:29:41,779


604
00:29:41,779 --> 00:29:44,940
有不同的维度，所以如果

605
00:29:44,940 --> 00:29:46,620
因果理论涉及许多

606
00:29:46,620 --> 00:29:48,299
对象，所有这些对象都必须

607
00:29:48,299 --> 00:29:50,220
直接或间接相关，

608
00:29:50,220 --> 00:29:52,559
没有任何对象完全独立于空间漂浮在空间中。

609
00:29:52,559 --> 00:29:54,419
其他对象，

610
00:29:54,419 --> 00:29:57,240
所以它们必须都是相关的，

611
00:29:57,240 --> 00:29:59,940
嗯，所以它们在空间上是统一的，组成

612
00:29:59,940 --> 00:30:03,000
因果理论的所有谓词，

613
00:30:03,000 --> 00:30:05,059
比如

614
00:30:05,059 --> 00:30:09,299
前面的、后面的、它们必须受到

615
00:30:09,299 --> 00:30:11,520
约束，这样，

616
00:30:11,520 --> 00:30:15,000
例如，前面的不能

617
00:30:15,000 --> 00:30:17,940
同时存在 比如后面或者一盏灯

618
00:30:17,940 --> 00:30:20,820
不能同时打开和关闭，

619
00:30:20,820 --> 00:30:23,760
所以对

620
00:30:23,760 --> 00:30:26,940
呃谓词有一些限制，这创造了

621
00:30:26,940 --> 00:30:28,919
概念统一

622
00:30:28,919 --> 00:30:31,620
，然后是静态统一，其中所有

623
00:30:31,620 --> 00:30:33,299
同时关系必须满足

624
00:30:33,299 --> 00:30:35,820
美学规则和时间统一，其中

625
00:30:35,820 --> 00:30:38,360
所有状态都必须满足 按

626
00:30:38,360 --> 00:30:40,500
因果规则排序，

627
00:30:40,500 --> 00:30:43,520
我们将看到示例，

628
00:30:43,740 --> 00:30:45,299
所以让我们

629
00:30:45,299 --> 00:30:46,799


630
00:30:46,799 --> 00:30:49,679
从一

631
00:30:49,679 --> 00:30:52,860
组观察的示例开始，我们正在

632
00:30:52,860 --> 00:30:55,140
观察的是两个灯，

633
00:30:55,140 --> 00:30:58,440
并且灯可以在任何

634
00:30:58,440 --> 00:31:00,840
离散的时刻

635
00:31:00,840 --> 00:31:04,980
打开或关闭，所以这里我们有

636
00:31:04,980 --> 00:31:10,260
一系列呃观察呃和一个

637
00:31:10,260 --> 00:31:11,539
时刻，

638
00:31:11,539 --> 00:31:13,919
第一盏灯关了，第二个

639
00:31:13,919 --> 00:31:17,039
晚上亮了，然后

640
00:31:17,039 --> 00:31:19,020
第一盏灯亮了，第二盏灯

641
00:31:19,020 --> 00:31:21,799
关了，

642
00:31:22,220 --> 00:31:25,740
然后两者都亮了等等，

643
00:31:25,740 --> 00:31:28,740
我把葡萄条放在那里，

644
00:31:28,740 --> 00:31:31,380
嗯，以表明也许 观察

645
00:31:31,380 --> 00:31:33,240
并不完整，所以在一个阶段我们

646
00:31:33,240 --> 00:31:35,520
只能看到第二盏灯，或者可能

647
00:31:35,520 --> 00:31:37,620
还有其他灯或其他我们

648
00:31:37,620 --> 00:31:41,600
看不到的物体，但这就是我们观察到的，

649
00:31:42,960 --> 00:31:45,419
所以

650
00:31:45,419 --> 00:31:47,880
你将这些观察结果

651
00:31:47,880 --> 00:31:49,320
[音乐]

652
00:31:49,320 --> 00:31:51,059
嗯在离散时间输入

653
00:31:51,059 --> 00:31:53,460
到 我们的感知引擎

654
00:31:53,460 --> 00:31:55,440
和情节感知引擎

655
00:31:55,440 --> 00:31:58,799
搜索因果理论，

656
00:31:58,799 --> 00:32:02,760
当应用于初始

657
00:32:02,760 --> 00:32:06,000
条件时，假设灯 a

658
00:32:06,000 --> 00:32:09,779
关闭且灯 B 亮起，它将创建一条

659
00:32:09,779 --> 00:32:12,980
呃重新创建的观察结果，

660
00:32:12,980 --> 00:32:15,659
即 um

661
00:32:15,659 --> 00:32:20,039
cover 是一个超集，与 初步

662
00:32:20,039 --> 00:32:23,220
观察，如果发生这种情况，那么

663
00:32:23,220 --> 00:32:26,039
我们的因果理论是一个很好的理论，

664
00:32:26,039 --> 00:32:30,299
现在因果理论可以推断出

665
00:32:30,299 --> 00:32:32,880
隐藏对象隐藏

666
00:32:32,880 --> 00:32:35,100
关系的存在以及它实际上可能需要的东西，

667
00:32:35,100 --> 00:32:37,820


668
00:32:38,039 --> 00:32:42,000
所以这是一个

669
00:32:42,000 --> 00:32:44,940
由我生成的因果理论的例子 我自己

670
00:32:44,940 --> 00:32:46,559
实现了应用程序接收

671
00:32:46,559 --> 00:32:49,380
引擎，因为我重新实现了

672
00:32:49,380 --> 00:32:52,200
应用程序接收引擎，正如

673
00:32:52,200 --> 00:32:55,279
理查德·埃文斯（Richard Evans）的论文中所描述的那样，嗯，

674
00:32:55,279 --> 00:32:57,799


675
00:32:57,799 --> 00:33:01,440
我对此运行了

676
00:33:01,440 --> 00:33:04,740
关于两个灯上的灯的一组观察，呃一开一

677
00:33:04,740 --> 00:33:07,559
关在 任何时间点，

678
00:33:07,559 --> 00:33:10,559
它都找到了一个结果，它

679
00:33:10,559 --> 00:33:13,440
在 64 秒内找到了结果，

680
00:33:13,440 --> 00:33:15,419
这是一个完美的匹配，它

681
00:33:15,419 --> 00:33:20,100
实际上发明了一种

682
00:33:20,100 --> 00:33:24,000
称为“踩一

683
00:33:24,000 --> 00:33:26,159
”的关系，我们可以想象一下，

684
00:33:26,159 --> 00:33:29,100
它实际上意味着 连接到

685
00:33:29,100 --> 00:33:32,519
并且它发现了一个静态规则和一个因果

686
00:33:32,519 --> 00:33:36,539
规则呃它说灯

687
00:33:36,539 --> 00:33:40,320
在任何时刻都亮着如果

688
00:33:40,320 --> 00:33:43,200
连接到它的灯关闭

689
00:33:43,200 --> 00:33:46,559
并且它发现了一个因果规则说

690
00:33:46,559 --> 00:33:52,919
嗯灯打开 如果它连接

691
00:33:52,919 --> 00:33:56,159
到另一个也关闭的灯，

692
00:33:56,159 --> 00:33:59,279
那么灯就会关闭，这就是灯如何随着

693
00:33:59,279 --> 00:34:02,159
时间的推移而变化，它们的状态是打开和关闭，并且它

694
00:34:02,159 --> 00:34:03,840
提出了初始条件，

695
00:34:03,840 --> 00:34:05,820
表明a

696
00:34:05,820 --> 00:34:08,580
首先连接到有

697
00:34:08,580 --> 00:34:10,980
一个对象a 光称为物体一，

698
00:34:10,980 --> 00:34:13,739
我们看不到，但我们

699
00:34:13,739 --> 00:34:16,339
想象那里有a连接到它，

700
00:34:16,339 --> 00:34:19,199
光物体一连接到B

701
00:34:19,199 --> 00:34:22,679
，光B连接到物体一，

702
00:34:22,679 --> 00:34:24,480
这就是它现在发现的因果规则，

703
00:34:24,480 --> 00:34:27,020


704
00:34:27,839 --> 00:34:31,199
如果我们呃 运行呃这个因果规则

705
00:34:31,199 --> 00:34:33,060
产生一个跟踪

706
00:34:33,060 --> 00:34:36,359
，正如你所看到的，跟踪与观察相匹配，

707
00:34:36,359 --> 00:34:40,260
它添加了一个新对象，所以

708
00:34:40,260 --> 00:34:43,379
覆盖范围非常

709
00:34:43,379 --> 00:34:45,599
好，在这种情况下是完美的，我们的因果

710
00:34:45,599 --> 00:34:47,879
理论是一个很好的理论，它实际上是一个

711
00:34:47,879 --> 00:34:49,139
完美的理论，

712
00:34:49,139 --> 00:34:51,179
它不是 它不一定是

713
00:34:51,179 --> 00:34:53,599
唯一的，但

714
00:34:54,418 --> 00:34:58,020
这个因果理论是统一的，

715
00:34:58,020 --> 00:35:00,839
所以回到汗博士对

716
00:35:00,839 --> 00:35:04,140
这种感知的综合统一性的要求，

717
00:35:04,140 --> 00:35:07,320
不是每个因果理论都

718
00:35:07,320 --> 00:35:09,119
会这样做，尽管它可能

719
00:35:09,119 --> 00:35:11,940
预测正确，但除非

720
00:35:11,940 --> 00:35:16,400
它统一得很好，否则它可能没有意义，是吗？

721
00:35:17,700 --> 00:35:20,280
我们已经看到了第四

722
00:35:20,280 --> 00:35:21,540
维度，有四个维度的

723
00:35:21,540 --> 00:35:23,820
统一，它在空间上特别

724
00:35:23,820 --> 00:35:27,300
统一吗？我们所有的物体都

725
00:35:27,300 --> 00:35:28,680


726
00:35:28,680 --> 00:35:32,640
直接或间接地相互连接，

727
00:35:32,640 --> 00:35:34,920
这很好，

728
00:35:34,920 --> 00:35:37,560
所以我们有空间统一，

729
00:35:37,560 --> 00:35:39,780
我们有概念统一吗，所以我们

730
00:35:39,780 --> 00:35:42,000
有这个新的谓词，我们有两个

731
00:35:42,000 --> 00:35:45,020
谓词正确 uh Fred 一个我们

732
00:35:45,020 --> 00:35:48,300
翻译为连接到的谓词，然后

733
00:35:48,300 --> 00:35:50,280
谓词说 uh 无论灯

734
00:35:50,280 --> 00:35:51,839
是开还是关，

735
00:35:51,839 --> 00:35:55,320
我们有一个约束，说

736
00:35:55,320 --> 00:35:56,160
um

737
00:35:56,160 --> 00:35:59,520
a 灯只能连接到

738
00:35:59,520 --> 00:36:03,060
另一个灯，所以红色的灯有一个 对它的约束，它是

739
00:36:03,060 --> 00:36:07,140


740
00:36:07,140 --> 00:36:11,040
排他性的，所以一个对象

741
00:36:11,040 --> 00:36:14,339
不能传播一到两个对象，

742
00:36:14,339 --> 00:36:16,140
你不能连接到两个对象，这是一个

743
00:36:16,140 --> 00:36:18,060
被发现的约束，是

744
00:36:18,060 --> 00:36:21,420
因果理论的一部分，也是

745
00:36:21,420 --> 00:36:23,280
隐含的

746
00:36:23,280 --> 00:36:27,720
um a uh the uh 谓词的呃关系

747
00:36:27,720 --> 00:36:31,020
作为 on 或 off 的值，它

748
00:36:31,020 --> 00:36:33,540
不能同时存在，所以

749
00:36:33,540 --> 00:36:35,820
它在概念上是统一的，

750
00:36:35,820 --> 00:36:39,119
它是静态统一的还是

751
00:36:39,119 --> 00:36:42,660
静态规则的规则很好地遵守呃

752
00:36:42,660 --> 00:36:44,640
例如静态规则会说

753
00:36:44,640 --> 00:36:50,040
呃鉴于 b uh 将 uh 连接到 a，如果 B

754
00:36:50,040 --> 00:36:53,460
关闭，则 a 必须打开，因此如果您查看

755
00:36:53,460 --> 00:36:57,060
B 关闭的任何 uh 位置，a

756
00:36:57,060 --> 00:36:59,040
将打开，您可以对

757
00:36:59,040 --> 00:37:02,400
uh 每个其他 uh 灯以及

758
00:37:02,400 --> 00:37:04,320
灯之间的关系执行此操作，因此

759
00:37:04,320 --> 00:37:07,260
他们都遵守静态规则，

760
00:37:07,260 --> 00:37:10,680
因果规则说，例如，

761
00:37:10,680 --> 00:37:13,140
如果 B 连接到 a，

762
00:37:13,140 --> 00:37:16,740
那么如果 a 关闭，那么 B 必须关闭，

763
00:37:16,740 --> 00:37:20,940
所以如果你看呃 B 假设 e 或 B

764
00:37:20,940 --> 00:37:22,920
关闭，

765
00:37:22,920 --> 00:37:25,040


766
00:37:25,740 --> 00:37:32,060
嗯，如果我 抱歉，如果呃 B 连接到 a，

767
00:37:33,119 --> 00:37:35,460
是的，

768
00:37:35,460 --> 00:37:38,460
如果 a 关闭了

769
00:37:38,460 --> 00:37:43,020
B 必须关闭，所以如果 a 关闭了 b b 就会

770
00:37:43,020 --> 00:37:45,960
关闭下一步，所以这也是正确的，所以

771
00:37:45,960 --> 00:37:47,400


772
00:37:47,400 --> 00:37:51,000
从统计上来说，呃我们是真的，

773
00:37:51,000 --> 00:37:53,579
暂时我们是真的，

774
00:37:53,579 --> 00:37:57,720
我们是统一的 当然，我们

775
00:37:57,720 --> 00:38:00,920
得到了康德博士的竖起大拇指，

776
00:38:00,920 --> 00:38:04,980
我们的因果理论是统一的，因此

777
00:38:04,980 --> 00:38:08,400
它对感觉输入的观察有意义，

778
00:38:08,400 --> 00:38:11,220


779
00:38:11,220 --> 00:38:15,780
现在这不是偶然的，嗯，

780
00:38:15,780 --> 00:38:18,300
不可能会出现在

781
00:38:18,300 --> 00:38:20,820
主动推理中 该项目在

782
00:38:20,820 --> 00:38:24,180
主动推理和康德之间存在联系，

783
00:38:24,180 --> 00:38:26,700
它贯穿了著名的 19

784
00:38:26,700 --> 00:38:30,119
世纪德国工程师赫尔曼·冯·汉姆·霍尔茨（Hermann Von

785
00:38:30,119 --> 00:38:31,500
ham Holtz），

786
00:38:31,500 --> 00:38:34,079
他是康德的弟子，他

787
00:38:34,079 --> 00:38:36,180
发展了视觉

788
00:38:36,180 --> 00:38:38,940
感知理论，使可汗的

789
00:38:38,940 --> 00:38:41,220
认识论得以操作，事实上它预示着

790
00:38:41,220 --> 00:38:44,820
预测处理 呃，在 1995 年，彼得·

791
00:38:44,820 --> 00:38:48,359
戴恩 (Peter Dane) 和杰夫·辛顿 (Jeff Hinton) 呃，开发了

792
00:38:48,359 --> 00:38:50,460
elmholz 机器，名字是在他的 Hunter 中，

793
00:38:50,460 --> 00:38:52,440


794
00:38:52,440 --> 00:38:54,119
它是一种人工神经

795
00:38:54,119 --> 00:38:55,920
网络，经过训练，可以

796
00:38:55,920 --> 00:38:58,740
根据原始数据集创建一个通用模型，

797
00:38:58,740 --> 00:39:00,599
它可以解释

798
00:39:00,599 --> 00:39:03,060
数据的隐藏结构，

799
00:39:03,060 --> 00:39:05,520
所以正如你所看到的，

800
00:39:05,520 --> 00:39:08,280
有一个链接，

801
00:39:08,280 --> 00:39:10,320
在这篇论文中进行了讨论和阐述，这是一篇非常

802
00:39:10,320 --> 00:39:12,599
非常有趣的论文，

803
00:39:12,599 --> 00:39:14,900
好吧，

804
00:39:14,900 --> 00:39:18,180
括号很近，所以我们

805
00:39:18,180 --> 00:39:19,740
从这个角度来研究感知引擎

806
00:39:19,740 --> 00:39:22,140


807
00:39:22,140 --> 00:39:23,940


808
00:39:23,940 --> 00:39:25,740
现在让我们从机器学习的角度来看待它，

809
00:39:25,740 --> 00:39:28,260


810
00:39:28,260 --> 00:39:29,099


811
00:39:29,099 --> 00:39:31,500
我们的观察构成了一个

812
00:39:31,500 --> 00:39:34,260
训练集，它是一个非常小的

813
00:39:34,260 --> 00:39:39,180
应用程序引擎是

814
00:39:39,180 --> 00:39:42,180
学习算法，所学到的

815
00:39:42,180 --> 00:39:45,660
输出是一个因果理论，

816
00:39:45,660 --> 00:39:49,320
所以 学习过程是

817
00:39:49,320 --> 00:39:54,000
无监督的逻辑推理，

818
00:39:54,000 --> 00:39:57,420
嗯，输出是人类可读的逻辑

819
00:39:57,420 --> 00:39:58,260
程序，

820
00:39:58,260 --> 00:40:01,400
所以我们在这里看到，

821
00:40:01,400 --> 00:40:06,060
与更

822
00:40:06,060 --> 00:40:07,859
流行的机器学习形式存在一些深刻的差异，因为

823
00:40:07,859 --> 00:40:11,579
训练集真的很小，

824
00:40:11,579 --> 00:40:16,380
嗯 呃学习的产物

825
00:40:16,380 --> 00:40:19,859
呃实际上是一个人类

826
00:40:19,859 --> 00:40:22,920
可读的工件，在这种情况下是一个逻辑

827
00:40:22,920 --> 00:40:25,339
程序

828
00:40:25,560 --> 00:40:28,500
所以这是训练集

829
00:40:28,500 --> 00:40:33,839
嗯呃作为输入灯

830
00:40:34,020 --> 00:40:35,700


831
00:40:35,700 --> 00:40:37,460


832
00:40:37,460 --> 00:40:42,900
在时间一关闭B在时间一打开一个

833
00:40:42,900 --> 00:40:45,780
学期 在第二个时间打开，在

834
00:40:45,780 --> 00:40:48,180
第二个时间关闭，等等，

835
00:40:48,180 --> 00:40:51,440


836
00:40:52,020 --> 00:40:55,380
这就是训练集，你将其输入到嗯呃

837
00:40:55,380 --> 00:40:58,500
痴迷感知引擎算法中，

838
00:40:58,500 --> 00:41:03,720
然后得出一个呃因果呃理论

839
00:41:03,720 --> 00:41:06,420
所以更详细一点呃

840
00:41:06,420 --> 00:41:09,960
算法是什么 首先，它

841
00:41:09,960 --> 00:41:10,980


842
00:41:10,980 --> 00:41:14,880


843
00:41:14,880 --> 00:41:17,160
从观察中提取 um 呃观察对象扩展对象对象类型和谓词，

844
00:41:17,160 --> 00:41:20,280
因此我们有

845
00:41:20,280 --> 00:41:23,339
对象 A 对象 B 我们作为

846
00:41:23,339 --> 00:41:24,960
对象类型引导，因此这是观察的所有部分，

847
00:41:24,960 --> 00:41:26,760
并且成为观察的一部分

848
00:41:26,760 --> 00:41:29,520
词汇范围，

849
00:41:29,520 --> 00:41:32,579
然后对立引擎

850
00:41:32,579 --> 00:41:34,020
想象

851
00:41:34,020 --> 00:41:37,320
未观察到的对象类型和

852
00:41:37,320 --> 00:41:40,680
关系和

853
00:41:40,680 --> 00:41:43,020
属性的谓词，这成为潜在

854
00:41:43,020 --> 00:41:45,420
词汇，所以有一个想象的步骤，

855
00:41:45,420 --> 00:41:48,420
然后使用组合

856
00:41:48,420 --> 00:41:50,820
词汇，你知道范围

857
00:41:50,820 --> 00:41:53,880
和潜在词汇组合起来

858
00:41:53,880 --> 00:41:57,000
看起来 对于统一的因果理论，一组

859
00:41:57,000 --> 00:41:58,920
约束规则和初始

860
00:41:58,920 --> 00:42:03,839
条件，它们服从 um 的规则

861
00:42:03,839 --> 00:42:04,740


862
00:42:04,740 --> 00:42:08,780
um 合成的约束 um

863
00:42:08,780 --> 00:42:12,420
我们感知的统一

864
00:42:12,420 --> 00:42:14,640
um 一旦它有了这个因果理论，并且在

865
00:42:14,640 --> 00:42:16,619
初始条件下，它将

866
00:42:16,619 --> 00:42:18,960
因果理论应用于这些 条件并

867
00:42:18,960 --> 00:42:20,339
产生一个轨迹

868
00:42:20,339 --> 00:42:23,220
呃，如果你想要的话，它会重新创建观察结果，

869
00:42:23,220 --> 00:42:26,099
并增强它们，并将

870
00:42:26,099 --> 00:42:27,480
它们扩展到未来

871
00:42:27,480 --> 00:42:29,820
呃现在它查看这个轨迹，并将

872
00:42:29,820 --> 00:42:30,900
其与

873
00:42:30,900 --> 00:42:33,780
覆盖范围的初始观察结果进行比较，并决定

874
00:42:33,780 --> 00:42:36,660
这是否是一个好的因果理论 然后

875
00:42:36,660 --> 00:42:38,240
它还会查看因果理论

876
00:42:38,240 --> 00:42:41,280
复杂性，有多少规则，规则有多复杂等等，

877
00:42:41,280 --> 00:42:42,660


878
00:42:42,660 --> 00:42:45,300
以及复杂性的衡量标准，因此，如果

879
00:42:45,300 --> 00:42:48,720
我们在两个等效覆盖范围的因果理论之间做出选择，

880
00:42:48,720 --> 00:42:52,140


881
00:42:52,140 --> 00:42:54,540
应用程序接收引擎将

882
00:42:54,540 --> 00:42:57,420
选择最不复杂的一个

883
00:42:57,420 --> 00:42:58,980


884
00:42:58,980 --> 00:43:00,839
现在奥卡姆剃刀如果你看一下这个算法，你会

885
00:43:00,839 --> 00:43:05,040
发现绿色的框

886
00:43:05,040 --> 00:43:08,579
不是确定性的，这就是

887
00:43:08,579 --> 00:43:10,560
搜索发生的地方我们可以放置

888
00:43:10,560 --> 00:43:13,619
不同类型的对象我们可以找到

889
00:43:13,619 --> 00:43:15,839
不同类型的规则所以这

890
00:43:15,839 --> 00:43:19,380
就是这个 是现在搜索发生的地方，

891
00:43:19,380 --> 00:43:20,520


892
00:43:20,520 --> 00:43:23,280
我们的感知是使用

893
00:43:23,280 --> 00:43:27,119
逻辑推理来实现的，实际上它使用呃

894
00:43:27,119 --> 00:43:29,579
三种形式的逻辑推理，

895
00:43:29,579 --> 00:43:31,260
我们更熟悉的

896
00:43:31,260 --> 00:43:34,800
是呃演绎，其中给定的规则

897
00:43:34,800 --> 00:43:38,579
和原因我们推断出结果然后

898
00:43:38,579 --> 00:43:40,859
有呃归纳其中 给定原因

899
00:43:40,859 --> 00:43:43,020
和结果，我们寻找规则，这就是

900
00:43:43,020 --> 00:43:45,660
科学所做的正确的事情，寻找

901
00:43:45,660 --> 00:43:48,119
可以解释呃影响的规则，

902
00:43:48,119 --> 00:43:49,380
给定原因，

903
00:43:49,380 --> 00:43:52,319
那么就存在绑架，给定

904
00:43:52,319 --> 00:43:54,359
规则，给定我们观察到的

905
00:43:54,359 --> 00:43:57,000
结果，我们正在寻找原因

906
00:43:57,000 --> 00:43:58,500
在这种情况下，我们正在寻找潜在

907
00:43:58,500 --> 00:44:00,960
对象，这些对象之间的潜在或关系，

908
00:44:00,960 --> 00:44:02,880


909
00:44:02,880 --> 00:44:06,000
然后您可以将溯因和归纳结合起来，您将得到

910
00:44:06,000 --> 00:44:08,640


911
00:44:08,640 --> 00:44:10,079
本质上的观察效果，​​并且您正在

912
00:44:10,079 --> 00:44:12,839
寻找原因和规则，这

913
00:44:12,839 --> 00:44:15,420
就是应用程序接收引擎的内容 确实

914
00:44:15,420 --> 00:44:17,940
如此，这就是算法中的

915
00:44:17,940 --> 00:44:20,099
嗯，这些类型的推论，嗯，

916
00:44:20,099 --> 00:44:21,900


917
00:44:21,900 --> 00:44:24,300
所以定位潜在对象，这是

918
00:44:24,300 --> 00:44:26,160
一种绑架形式，

919
00:44:26,160 --> 00:44:29,160
想象一下，找到规则，

920
00:44:29,160 --> 00:44:32,280
这显然是一种归纳形式

921
00:44:32,280 --> 00:44:36,900
，然后将规则应用到呃

922
00:44:36,900 --> 00:44:38,940
因果理论的

923
00:44:38,940 --> 00:44:41,460
一些初始条件来创建

924
00:44:41,460 --> 00:44:43,200
跟踪井，这就是推论，当

925
00:44:43,200 --> 00:44:45,060
我们有了原因的初始

926
00:44:45,060 --> 00:44:46,980
条件，我们有了因果

927
00:44:46,980 --> 00:44:49,800
理论的规则，然后我们产生了

928
00:44:49,800 --> 00:44:52,079
影响的跟踪，这就是推论，所以应用

929
00:44:52,079 --> 00:44:55,079
程序接收引擎使用 所有形式

930
00:44:55,079 --> 00:44:58,319
的逻辑推理

931
00:44:58,319 --> 00:45:01,440
，现在只是提醒一下，

932
00:45:01,440 --> 00:45:04,740
感知引擎的输出，也就是

933
00:45:04,740 --> 00:45:06,960
所学到的东西，实际上是人类

934
00:45:06,960 --> 00:45:09,480
可读的，你可能想将其

935
00:45:09,480 --> 00:45:12,619


936
00:45:12,619 --> 00:45:17,940
与传统的浮点数数组进行比较。 这是

937
00:45:17,940 --> 00:45:21,240


938
00:45:21,240 --> 00:45:23,400
当今流行的机器学习形式，所以

939
00:45:23,400 --> 00:45:25,740
这就是

940
00:45:25,740 --> 00:45:28,200
应用程序接收引擎实际生成的内容，因为它运行在一组

941
00:45:28,200 --> 00:45:31,079
观察结果上，它生成

942
00:45:31,079 --> 00:45:34,440
一个逻辑程序，该程序是人类

943
00:45:34,440 --> 00:45:36,180
可读的，只有当您查看它时，

944
00:45:36,180 --> 00:45:38,400
您唯一需要做的就是 一种

945
00:45:38,400 --> 00:45:40,619
猜测是

946
00:45:40,619 --> 00:45:42,480
pred 的含义是什么，如果你想得好，

947
00:45:42,480 --> 00:45:44,460
也许它意味着连接到，也许

948
00:45:44,460 --> 00:45:47,520
灯连接在观察者

949
00:45:47,520 --> 00:45:50,460
视线之外的一块木板下面，

950
00:45:50,460 --> 00:45:54,319


951
00:45:54,720 --> 00:45:57,240
但找到一个统一的因果理论

952
00:45:57,240 --> 00:46:01,020
很难，所以 我们必须猜测潜在

953
00:46:01,020 --> 00:46:03,359
对象和谓词是什么，

954
00:46:03,359 --> 00:46:06,420
隐藏的灯光是什么，

955
00:46:06,420 --> 00:46:09,060
灯光之间的隐藏关系是什么，我们

956
00:46:09,060 --> 00:46:11,099
必须发现哪些约束可能适用

957
00:46:11,099 --> 00:46:13,260
于谓词，

958
00:46:13,260 --> 00:46:15,000
以及

959
00:46:15,000 --> 00:46:17,000
我们想要重新创建的初始条件是什么 跟踪

960
00:46:17,000 --> 00:46:20,160
uh 适用于同时观测的静态规则是什么

961
00:46:20,160 --> 00:46:23,099
，然后

962
00:46:23,099 --> 00:46:26,119
给出

963
00:46:26,119 --> 00:46:29,520
时间 T 的 uh 观测值将预测

964
00:46:29,520 --> 00:46:32,280
时间 t 加一的观测值的因果规则是什么，

965
00:46:32,280 --> 00:46:34,260
这很难，

966
00:46:34,260 --> 00:46:36,780
因为事实上它是非极性的

967
00:46:36,780 --> 00:46:39,660
多项式困难呃，搜索空间

968
00:46:39,660 --> 00:46:42,300
随着输入的大小呈指数增长，输入的大小

969
00:46:42,300 --> 00:46:44,819
是

970
00:46:44,819 --> 00:46:47,160
呃意外范围和潜在

971
00:46:47,160 --> 00:46:49,500
词汇的大小，

972
00:46:49,500 --> 00:46:51,780
所以就像在国际象棋中一样，你无法呃

973
00:46:51,780 --> 00:46:54,599
预测到最后一步的结果

974
00:46:54,599 --> 00:46:56,660
由于感知引擎常见的神经爆炸，

975
00:46:56,660 --> 00:46:59,579
你无法

976
00:46:59,579 --> 00:47:01,920
系统地遍历

977
00:47:01,920 --> 00:47:04,500
可能的因果理论的整个空间来找到一个好的因果理论，

978
00:47:04,500 --> 00:47:08,720
因为它太大了，

979
00:47:09,960 --> 00:47:12,359
所以对位引擎的工作就是

980
00:47:12,359 --> 00:47:15,000
在一个大得可笑的干草堆中找到一个因果理论

981
00:47:15,000 --> 00:47:17,700


982
00:47:17,700 --> 00:47:19,319


983
00:47:19,319 --> 00:47:23,280
在我的实现中，我遵循

984
00:47:23,280 --> 00:47:27,839
呃中的建议，

985
00:47:27,839 --> 00:47:30,300
并且我还遵循

986
00:47:30,300 --> 00:47:33,359
理查德·埃文斯论文中的实现，

987
00:47:33,359 --> 00:47:36,480


988
00:47:36,480 --> 00:47:39,599
首先将搜索空间分成呃块我有一个区域，该区域

989
00:47:39,599 --> 00:47:40,680
说

990
00:47:40,680 --> 00:47:42,540
嗯所以有多少潜在对象

991
00:47:42,540 --> 00:47:44,520
我们允许的对象和谓词类型 那么，

992
00:47:44,520 --> 00:47:48,500


993
00:47:48,500 --> 00:47:51,480
试图感知因果理论的认知行动者的想象力的极限是什么，

994
00:47:51,480 --> 00:47:54,420


995
00:47:54,420 --> 00:47:56,339
它的想象力的极限是什么，在

996
00:47:56,339 --> 00:47:58,740
这个

997
00:47:58,740 --> 00:48:01,319
有限想象力的区域内，

998
00:48:01,319 --> 00:48:03,300
我们

999
00:48:03,300 --> 00:48:06,420
将其雕刻成模板，在其中我们

1000
00:48:06,420 --> 00:48:08,819
好吧，我们将使用这些潜在

1001
00:48:08,819 --> 00:48:12,300
对象类型，这些潜在对象，

1002
00:48:12,300 --> 00:48:14,579
呃，基本上我们将使用什么词汇特定

1003
00:48:14,579 --> 00:48:16,680
词汇，我们将

1004
00:48:16,680 --> 00:48:18,119
使用对象一，我们将

1005
00:48:18,119 --> 00:48:21,540
在顶部使用对象呃线程一 在

1006
00:48:21,540 --> 00:48:26,280
uh 谓词上观察到的 uh 以及观察到的

1007
00:48:26,280 --> 00:48:29,460
A 和 B 灯，我们将在

1008
00:48:29,460 --> 00:48:32,460
规则上设置最大复杂度，

1009
00:48:32,460 --> 00:48:35,220
看看在 uh 内我们是否可以找到

1010
00:48:35,220 --> 00:48:37,740
适合此模板的因果理论，因此这

1011
00:48:37,740 --> 00:48:40,079
是搜索空间的划分

1012
00:48:40,079 --> 00:48:42,920
并且将搜索空间分解为

1013
00:48:42,920 --> 00:48:45,660
区域和模板，

1014
00:48:45,660 --> 00:48:46,920
呃，

1015
00:48:46,920 --> 00:48:49,440
我们有应用

1016
00:48:49,440 --> 00:48:53,760
启发式的范围，现在为什么要使用启发式，因为

1017
00:48:53,760 --> 00:48:56,579
系统遍历并且它不能

1018
00:48:56,579 --> 00:48:59,160
在合理的时间内完成，有

1019
00:48:59,160 --> 00:49:02,579
太多的候选因果理论

1020
00:49:02,579 --> 00:49:05,640
需要寻找一个好的因果理论 因此，我们使用

1021
00:49:05,640 --> 00:49:07,740
启发式方法，我们发现我们

1022
00:49:07,740 --> 00:49:11,220
找到了可能

1023
00:49:11,220 --> 00:49:13,740
更快地找到一个好的解决方案的方法，尽管冒着

1024
00:49:13,740 --> 00:49:17,700
错过它的风险，但至少呃，我们会

1025
00:49:17,700 --> 00:49:20,339
在合理的时间内得到答案或没有答案，

1026
00:49:20,339 --> 00:49:22,200
并且有很多

1027
00:49:22,200 --> 00:49:24,780
我在感知器引擎的实现中实施的启发式方法

1028
00:49:24,780 --> 00:49:26,880


1029
00:49:26,880 --> 00:49:27,660


1030
00:49:27,660 --> 00:49:29,940
很好，在某些时候，

1031
00:49:29,940 --> 00:49:31,800
你花的时间不会超过这个

1032
00:49:31,800 --> 00:49:34,740
时间来研究一个区域或一个

1033
00:49:34,740 --> 00:49:36,060
模板

1034
00:49:36,060 --> 00:49:38,339
哦，有多任务处理，问题

1035
00:49:38,339 --> 00:49:40,260
实际上正如他们所说的令人尴尬的那样

1036
00:49:40,260 --> 00:49:42,660
并行 你可以并行探索多个

1037
00:49:42,660 --> 00:49:44,160
区域和多个模板

1038
00:49:44,160 --> 00:49:46,740
，因此要充分利用

1039
00:49:46,740 --> 00:49:49,500
多核呃计算机

1040
00:49:49,500 --> 00:49:51,119
呃你想确保你不会

1041
00:49:51,119 --> 00:49:53,700
重复自己，所以你不想呃

1042
00:49:53,700 --> 00:49:56,339
遍历同一个区域呃两次或者

1043
00:49:56,339 --> 00:49:58,500
看同一个谜题两次

1044
00:49:58,500 --> 00:50:02,280
你想要满足你的理论可能是一个

1045
00:50:02,280 --> 00:50:04,380
足够好的理论就很好我们不想

1046
00:50:04,380 --> 00:50:06,599
寻找完美的一个必然

1047
00:50:06,599 --> 00:50:09,119
我们可能没有时间

1048
00:50:09,119 --> 00:50:11,220
嗯如果你处于一个困境中你想早点失败 没有

1049
00:50:11,220 --> 00:50:13,380
发现任何好东西的区域，你

1050
00:50:13,380 --> 00:50:16,440
可能想很快离开它，冒着可能

1051
00:50:16,440 --> 00:50:18,960
找不到

1052
00:50:18,960 --> 00:50:21,720
就在地平线上的好东西的风险，但

1053
00:50:21,720 --> 00:50:23,520
你想要不耐烦，

1054
00:50:23,520 --> 00:50:26,460
你想扔你可能想要的骰子

1055
00:50:26,460 --> 00:50:29,640
将其混合起来，以便每次

1056
00:50:29,640 --> 00:50:31,260
您针对同一问题运行 Apple Citron 引擎时，

1057
00:50:31,260 --> 00:50:33,780
呃，您可能会先找到一个解决方案，

1058
00:50:33,780 --> 00:50:37,920
一个不同的解决方案，

1059
00:50:37,920 --> 00:50:40,440
嗯，您想要呃，首先选择简单的

1060
00:50:40,440 --> 00:50:42,780
解决方案，您可能不想尝试

1061
00:50:42,780 --> 00:50:45,119
一切来采样您想要的总和 从

1062
00:50:45,119 --> 00:50:48,300


1063
00:50:48,300 --> 00:50:50,760
搜索空间中最简单的呃部分开始，首先要明智

1064
00:50:50,760 --> 00:50:52,980
，等等，最

1065
00:50:52,980 --> 00:50:56,280
重要的是要有选择性，所以拒绝任何

1066
00:50:56,280 --> 00:50:59,579
会破坏

1067
00:50:59,579 --> 00:51:01,200
我们

1068
00:51:01,200 --> 00:51:02,339
感知

1069
00:51:02,339 --> 00:51:05,720
与所有这些的统一约束的呃因果理论

1070
00:51:05,819 --> 00:51:08,520
嗯，运行我对

1071
00:51:08,520 --> 00:51:10,619
应用程序接收引擎的解释给出了非常好的

1072
00:51:10,619 --> 00:51:13,680
结果，所以在这里我做了一次运行，这

1073
00:51:13,680 --> 00:51:15,839
不是精心挑选的，决定进行

1074
00:51:15,839 --> 00:51:19,859
一系列七次运行，收集

1075
00:51:19,859 --> 00:51:24,180
数据并显示它，在这次运行中我

1076
00:51:24,180 --> 00:51:25,980
设置了 应用程序位置引擎只

1077
00:51:25,980 --> 00:51:29,520
接受完美的因果理论，一个

1078
00:51:29,520 --> 00:51:32,460
会产生完全

1079
00:51:32,460 --> 00:51:36,300
覆盖观察结果的痕迹，所以我

1080
00:51:36,300 --> 00:51:39,420
运行了七次，第一个

1081
00:51:39,420 --> 00:51:41,220
在四秒内成功建立，

1082
00:51:41,220 --> 00:51:44,160
第二个花了 102 秒，所以有

1083
00:51:44,160 --> 00:51:46,020
一些 按照

1084
00:51:46,020 --> 00:51:47,700
搜索内容的顺序进行随机化

1085
00:51:47,700 --> 00:51:50,579
涉及运气，正如我所说，

1086
00:51:50,579 --> 00:51:52,619
嗯，第三个一秒，

1087
00:51:52,619 --> 00:51:56,280
这非常酷，第四

1088
00:51:56,280 --> 00:51:59,819
个墙花了 204 秒

1089
00:51:59,819 --> 00:52:04,440
，然后是 96 12.99，所以呃，现在

1090
00:52:04,440 --> 00:52:05,880
这里的分布多好啊

1091
00:52:05,880 --> 00:52:07,920
我说好吧，我会在

1092
00:52:07,920 --> 00:52:10,500


1093
00:52:10,500 --> 00:52:12,900
我之前展示的那两个灯的同一个呃训练集上再次运行感知引擎，

1094
00:52:12,900 --> 00:52:14,339


1095
00:52:14,339 --> 00:52:17,460
但这次我说嗯我会呃

1096
00:52:17,460 --> 00:52:20,700
我会接受这个理论

1097
00:52:20,700 --> 00:52:23,579
至少有 80 个 具有

1098
00:52:23,579 --> 00:52:27,660
85 或更多的覆盖范围，所以它预测它

1099
00:52:27,660 --> 00:52:30,480
它足够好地重新创建观察结果，

1100
00:52:30,480 --> 00:52:35,160
但并不完美，我呃

1101
00:52:35,160 --> 00:52:37,200
时间将其限制为 30 秒，所以你有

1102
00:52:37,200 --> 00:52:39,839
30 秒的时间来找到它

1103
00:52:39,839 --> 00:52:42,960
嗯 第一次运行它签署了一个因果

1104
00:52:42,960 --> 00:52:46,920
理论，准确率是 75% 呃，

1105
00:52:46,920 --> 00:52:50,040
然后是同样的准确率，同样的

1106
00:52:50,040 --> 00:52:53,160
覆盖范围 10 秒 11 秒，它达到了 80

1107
00:52:53,160 --> 00:52:58,140
29 秒，它找到了一个完美的理论，然后

1108
00:52:58,140 --> 00:53:00,720
11 它发现了 87 的覆盖范围，然后就停

1109
00:53:00,720 --> 00:53:03,240
在那里，这已经足够好了，再次达到 75

1110
00:53:03,240 --> 00:53:06,240
100 是它

1111
00:53:06,240 --> 00:53:10,200
在 18 秒和 75 零秒内发现的第一个高于 85 的值，所以

1112
00:53:10,200 --> 00:53:12,359
又是一个很好的分布，所以我们

1113
00:53:12,359 --> 00:53:14,280
进入了一个合理的时间，我们不是在

1114
00:53:14,280 --> 00:53:15,599
谈论小时，而是在

1115
00:53:15,599 --> 00:53:18,599
谈论秒，我是我。 我希望嗯

1116
00:53:18,599 --> 00:53:20,700
做进一步的优化并将其

1117
00:53:20,700 --> 00:53:24,359
缩小到更小的范围，以便

1118
00:53:24,359 --> 00:53:27,480
认知参与者可以说嗯嗯我想

1119
00:53:27,480 --> 00:53:29,700
理解这些观察结果

1120
00:53:29,700 --> 00:53:31,200
嗯

1121
00:53:31,200 --> 00:53:33,839
查询感知引擎并获得

1122
00:53:33,839 --> 00:53:37,020
答案一个因果理论可能是

1123
00:53:37,020 --> 00:53:40,460
几个 这就是我的希望，

1124
00:53:40,559 --> 00:53:43,020
现在有一些有趣的事情，先生，碰巧的是，使

1125
00:53:43,020 --> 00:53:45,059


1126
00:53:45,059 --> 00:53:46,619
应用程序感知引擎难以找到良好

1127
00:53:46,619 --> 00:53:49,619
因果理论的原因在形式上等同于

1128
00:53:49,619 --> 00:53:51,660
使整个认知科学变得

1129
00:53:51,660 --> 00:53:53,700
困难的原因，这就是本文提出的情况

1130
00:53:53,700 --> 00:53:56,339
并证明了 案例相当

1131
00:53:56,339 --> 00:53:58,440
商，

1132
00:53:58,440 --> 00:54:01,940
所以呃

1133
00:54:03,680 --> 00:54:06,480
认知科学想要找到模型

1134
00:54:06,480 --> 00:54:10,099
函数或算法来

1135
00:54:10,099 --> 00:54:12,960
解释

1136
00:54:12,960 --> 00:54:16,099
嗯情境行为，所以你你输入

1137
00:54:16,099 --> 00:54:20,339
呃你输入这个认知

1138
00:54:20,339 --> 00:54:21,900
科学机器

1139
00:54:21,900 --> 00:54:24,780
嗯情境和行为对，

1140
00:54:24,780 --> 00:54:27,300
你想出来 它是一个模型，一个

1141
00:54:27,300 --> 00:54:30,140
解释，一个函数或一个算法，可以

1142
00:54:30,140 --> 00:54:33,300


1143
00:54:33,300 --> 00:54:37,440
很好地解释它，论文提出了这样的情况：

1144
00:54:37,440 --> 00:54:41,040
如果解释的

1145
00:54:41,040 --> 00:54:44,520
大小是有限的，那么

1146
00:54:44,520 --> 00:54:46,260
问题是可以计算的，

1147
00:54:46,260 --> 00:54:48,180
但在参议院中是不易处理的

1148
00:54:48,180 --> 00:54:49,319
这意味着它自然而然地具有

1149
00:54:49,319 --> 00:54:51,420
爆炸性，但是一旦你有了一个解决方案，

1150
00:54:51,420 --> 00:54:55,020
它就可以计算和处理，以

1151
00:54:55,020 --> 00:54:57,900
验证该解决方案是否良好，它

1152
00:54:57,900 --> 00:55:01,619
解释了

1153
00:55:01,619 --> 00:55:04,079
你试图很好地理解的数据，这就是

1154
00:55:04,079 --> 00:55:05,819
这相当于以前的等价物

1155
00:55:05,819 --> 00:55:07,440
应用程序接收引擎正在做什么，

1156
00:55:07,440 --> 00:55:09,619


1157
00:55:10,619 --> 00:55:11,400
嗯，

1158
00:55:11,400 --> 00:55:14,160
我的实现是在序言中完成的，

1159
00:55:14,160 --> 00:55:17,220
我不会详细介绍它

1160
00:55:17,220 --> 00:55:19,260
大约有一千行序言，我

1161
00:55:19,260 --> 00:55:21,660
只会说序言是一种编程

1162
00:55:21,660 --> 00:55:24,660
语言，呃，使用演绎推理

1163
00:55:24,660 --> 00:55:27,119
作为其模型 回溯的计算，

1164
00:55:27,119 --> 00:55:29,880


1165
00:55:29,880 --> 00:55:31,680
所以本质上它会搜索它

1166
00:55:31,680 --> 00:55:34,400
寻找一个解决方案，

1167
00:55:34,400 --> 00:55:37,859
如果它采取了错误的

1168
00:55:37,859 --> 00:55:40,680
分支，如果你想要的话，就会回溯，并且

1169
00:55:40,680 --> 00:55:43,020
我们将寻找一种不同的方式来

1170
00:55:43,020 --> 00:55:47,819
满足程序的一行，

1171
00:55:47,819 --> 00:55:50,700
所以 这么说吧，它可以

1172
00:55:50,700 --> 00:55:54,000
遍历一个搜索空间，呃，

1173
00:55:54,000 --> 00:55:55,380


1174
00:55:55,380 --> 00:55:58,260
当我们在序言中编程时，它可以让我们免费遍历搜索点，我不会

1175
00:55:58,260 --> 00:55:59,940
详细介绍，但你可以

1176
00:55:59,940 --> 00:56:03,300
在这里看到一些序言代码，这很

1177
00:56:03,300 --> 00:56:07,020
有趣。 序言

1178
00:56:07,020 --> 00:56:09,960
程序类似于

1179
00:56:09,960 --> 00:56:12,059
试图解决的问题的逻辑描述，

1180
00:56:12,059 --> 00:56:14,460
我认为这非常酷，

1181
00:56:14,460 --> 00:56:16,220
并且

1182
00:56:16,220 --> 00:56:19,079
序言环境通过

1183
00:56:19,079 --> 00:56:21,000
所谓的约束处理

1184
00:56:21,000 --> 00:56:23,640
规则进行了增强，这是序言的扩展，

1185
00:56:23,640 --> 00:56:26,040


1186
00:56:26,040 --> 00:56:28,020
基本上在程序中添加了溯因推理 你可以说

1187
00:56:28,020 --> 00:56:30,359
假设这是真的，直到被证明

1188
00:56:30,359 --> 00:56:34,800
不然，呃，呃，

1189
00:56:34,800 --> 00:56:37,319
CHR 规则，

1190
00:56:37,319 --> 00:56:40,380
嗯，呃，验证它是否可以被

1191
00:56:40,380 --> 00:56:42,180
证明，

1192
00:56:42,180 --> 00:56:44,819
所以，嗯，我再说一遍，我根本不要求你

1193
00:56:44,819 --> 00:56:46,559
理解这句话，但我想要

1194
00:56:46,559 --> 00:56:48,420
你会意识到这段代码

1195
00:56:48,420 --> 00:56:51,059
实际上是执行因果理论的代码，

1196
00:56:51,059 --> 00:56:52,559


1197
00:56:52,559 --> 00:56:54,420
嗯，静态和因果规则来

1198
00:56:54,420 --> 00:56:57,119
构建痕迹，它很小，它

1199
00:56:57,119 --> 00:56:59,579
非常强大，所以结合 CHR 中的序言，

1200
00:56:59,579 --> 00:57:01,380


1201
00:57:01,380 --> 00:57:03,839
嗯，我发现非常强大，

1202
00:57:03,839 --> 00:57:05,880
我很兴奋 我是一名

1203
00:57:05,880 --> 00:57:07,260
程序员，

1204
00:57:07,260 --> 00:57:08,940
下一步

1205
00:57:08,940 --> 00:57:13,680
好下一步，既然我们已经通过认知呃演员解决了呃

1206
00:57:13,680 --> 00:57:16,920
个人学习呃，

1207
00:57:16,920 --> 00:57:18,119


1208
00:57:18,119 --> 00:57:21,960
我想

1209
00:57:21,960 --> 00:57:26,460
从呃感觉转向呃信念，并转向

1210
00:57:26,460 --> 00:57:31,640
验证或消除信念

1211
00:57:31,680 --> 00:57:34,200
嗯很多的政策 这些信念实际上

1212
00:57:34,200 --> 00:57:36,119
脱离了我们的感知，潜在的对象和

1213
00:57:36,119 --> 00:57:37,980
潜在的关系和属性

1214
00:57:37,980 --> 00:57:40,079
可以被视为信念，那么

1215
00:57:40,079 --> 00:57:41,339
还有其他类型的信念

1216
00:57:41,339 --> 00:57:44,700
可以从未感知到的事物中获得，

1217
00:57:44,700 --> 00:57:47,160


1218
00:57:47,160 --> 00:57:49,920
它们将是内省信念，呃，

1219
00:57:49,920 --> 00:57:54,540
呃 嗯，沟通，

1220
00:57:54,540 --> 00:57:57,480
认知认知行为者

1221
00:57:57,480 --> 00:57:59,300
在能力

1222
00:57:59,300 --> 00:58:01,920
预测率方面表现

1223
00:58:01,920 --> 00:58:05,640
如何，嗯，嗯，我们的

1224
00:58:05,640 --> 00:58:09,059
感知正在做的怎么样，以及是否与

1225
00:58:09,059 --> 00:58:12,119
其他认知行为者互动，

1226
00:58:12,119 --> 00:58:14,099
是否相关，

1227
00:58:14,099 --> 00:58:16,980
我会有感觉，这

1228
00:58:16,980 --> 00:58:20,099
将为 这些信念，所以，如果

1229
00:58:20,099 --> 00:58:24,059
感觉是体内平衡风险的信号，

1230
00:58:24,059 --> 00:58:27,359
资源损失，身体

1231
00:58:27,359 --> 00:58:30,300
伤害，太多的预测错误，那就是

1232
00:58:30,300 --> 00:58:33,180
饥饿、痛苦和恐惧，

1233
00:58:33,180 --> 00:58:35,640
随着时间的推移，感觉会带走信念，

1234
00:58:35,640 --> 00:58:37,339


1235
00:58:37,339 --> 00:58:40,280
污染的信念和规范，

1236
00:58:40,280 --> 00:58:44,040
好的信念，坏的信念会想要成为

1237
00:58:44,040 --> 00:58:48,299
通过将由

1238
00:58:48,299 --> 00:58:49,859


1239
00:58:49,859 --> 00:58:51,540
认知参与者

1240
00:58:51,540 --> 00:58:55,140
和每个认知参与者合成的策略来消除或验证 将会发出 呃 使其

1241
00:58:55,140 --> 00:58:57,059
他人可用 嗯

1242
00:58:57,059 --> 00:59:01,020
它的 API

1243
00:59:01,020 --> 00:59:02,700
对于这个认知参与者的信念可以做出什么预测

1244
00:59:02,700 --> 00:59:06,660


1245
00:59:06,660 --> 00:59:10,140
其他人可以采取哪些行动 呃呃询问

1246
00:59:10,140 --> 00:59:12,540
连接连接演员，

1247
00:59:12,540 --> 00:59:16,920
然后作为认知演员呃呃相互

1248
00:59:16,920 --> 00:59:18,660
连接

1249
00:59:18,660 --> 00:59:21,960
呃当连接演员形成

1250
00:59:21,960 --> 00:59:24,119
其他认知演员的嗯带

1251
00:59:24,119 --> 00:59:27,420
然后嗯适应演员将能够

1252
00:59:27,420 --> 00:59:28,980
预测其他人的信念

1253
00:59:28,980 --> 00:59:31,400


1254
00:59:31,400 --> 00:59:34,319
制定

1255
00:59:34,319 --> 00:59:36,480
由其他认知参与者实施的行动制定的政策

1256
00:59:36,480 --> 00:59:37,500


1257
00:59:37,500 --> 00:59:39,900
，最终

1258
00:59:39,900 --> 00:59:42,540
我们将拥有一个心灵社会，它是

1259
00:59:42,540 --> 00:59:47,460
一堆交叉的恩恩带

1260
00:59:47,460 --> 00:59:51,780
所以嗯那就是它

1261
00:59:51,780 --> 00:59:55,140
所以我明白我的社会

1262
00:59:55,140 --> 00:59:57,480
是什么 一个由集体理论家组成的复杂系统，

1263
00:59:57,480 --> 00:59:59,520


1264
00:59:59,520 --> 01:00:02,160
我将尝试进一步推进这个

1265
01:00:02,160 --> 01:00:04,799
项目，以回答这个问题：

1266
01:00:04,799 --> 01:00:06,900
理论家集体是否可以

1267
01:00:06,900 --> 01:00:10,500
自我组织以积极维持自身，

1268
01:00:10,500 --> 01:00:13,980
所以感谢积极努力

1269
01:00:13,980 --> 01:00:16,200
研究所邀请我出席并

1270
01:00:16,200 --> 01:00:18,119
为 为这个项目提供一个家

1271
01:00:18,119 --> 01:00:20,220
，以及持续的支持和

1272
01:00:20,220 --> 01:00:21,240
鼓励，

1273
01:00:21,240 --> 01:00:25,500
我稍后会在 Discord 上见到你，谢谢你，

1274
01:00:25,500 --> 01:00:29,640
太棒了，谢谢 JF 刚刚结束

1275
01:00:29,640 --> 01:00:32,240
会议，我将阅读两个问题

1276
01:00:32,240 --> 01:00:35,579
，让我们也许在

1277
01:00:35,579 --> 01:00:38,160
即将到来的机器人学中解决它们

1278
01:00:38,160 --> 01:00:40,079
因此，如果您对这个项目感到兴奋，那么

1279
01:00:40,079 --> 01:00:43,260
我们当然都对符号

1280
01:00:43,260 --> 01:00:45,420
主动推理感到兴奋，加入 Discord 并

1281
01:00:45,420 --> 01:00:47,040
参与机器人技术并体现

1282
01:00:47,040 --> 01:00:49,200
它，但我将

1283
01:00:49,200 --> 01:00:51,119
在聊天中放弃 David Williams 提出的这两个问题，他

1284
01:00:51,119 --> 01:00:53,880
写了一个如何 重要的是

1285
01:00:53,880 --> 01:00:55,559
在现实世界中进行这项工作，而不是

1286
01:00:55,559 --> 01:00:58,260


1287
01:00:58,260 --> 01:00:59,940
在模拟中进行，以及机器人工具包中缺少哪些工具或组件

1288
01:00:59,940 --> 01:01:02,880
来使这项研究更容易、

1289
01:01:02,880 --> 01:01:04,740
更好，我知道这些是您有

1290
01:01:04,740 --> 01:01:06,480
很多想法的事情，所以我

1291
01:01:06,480 --> 01:01:08,460
期待呃讨论 与你一起，

1292
01:01:08,460 --> 01:01:11,480
谢谢你，JF，

1293
01:01:11,940 --> 01:01:15,619
谢谢你，和平，

1294
01:01:16,079 --> 01:01:18,740
好吧，

1295
01:01:19,680 --> 01:01:22,399
再见，

1296
01:01:24,180 --> 01:01:25,920
这是一个很棒的

1297
01:01:25,920 --> 01:01:28,079
赛格威，来自惊喜

1298
01:01:28,079 --> 01:01:29,880


1299
01:01:29,880 --> 01:01:32,520
最小化特工中的集体行为两个，惊喜

1300
01:01:32,520 --> 01:01:35,339
最小化特工中的集体行为我

1301
01:01:35,339 --> 01:01:37,920
想欢迎康纳，

1302
01:01:37,920 --> 01:01:40,079
嘿抱歉，我刚刚打开音频，所以我

1303
01:01:40,079 --> 01:01:44,660
刚刚听到了最后一个 你说的事是的

