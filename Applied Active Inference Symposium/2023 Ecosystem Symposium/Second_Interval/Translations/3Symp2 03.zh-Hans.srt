1
00:00:00,359 --> 00:00:03,199
好吧，

2
00:00:05,940 --> 00:00:08,820
问候，好吧，我们的下一个

3
00:00:08,820 --> 00:00:12,300
会议嘿嘿 Bert 问候

4
00:00:12,300 --> 00:00:14,280
很好，你做得很好很好很好

5
00:00:14,280 --> 00:00:15,059


6
00:00:15,059 --> 00:00:17,220
嗯我们的下一个会议是与鸟类设备

7
00:00:17,220 --> 00:00:20,580
Dimitri bagayev 和 Bart van Erp 它将

8
00:00:20,580 --> 00:00:22,740
被称为用户友好的合成

9
00:00:22,740 --> 00:00:24,720
主动推理设计

10
00:00:24,720 --> 00:00:27,480
特工和我知道很多人都

11
00:00:27,480 --> 00:00:30,119
非常兴奋地看到这项真正

12
00:00:30,119 --> 00:00:32,759
实用且前沿的工作，所以

13
00:00:32,759 --> 00:00:35,100
伯特，请让我们知道我们如何提供

14
00:00:35,100 --> 00:00:36,600
支持，

15
00:00:36,600 --> 00:00:40,680
好吧，太好了，好吧，我的音频很好，是的，

16
00:00:40,680 --> 00:00:44,040
听起来不错，那么我会 分享我的

17
00:00:44,040 --> 00:00:46,739
屏幕呃

18
00:00:46,739 --> 00:00:48,719
我希望我选择了正确的一个我不

19
00:00:48,719 --> 00:00:52,079
工作它的缩放通常看起来不错它

20
00:00:52,079 --> 00:00:55,140
看起来不错是的好吧超级

21
00:00:55,140 --> 00:00:57,719
嗯很好非常感谢丹尼尔

22
00:00:57,719 --> 00:01:00,239
主持这个呃研讨会我一直在

23
00:01:00,239 --> 00:01:02,100
观看一些演讲它是 真的太棒了，

24
00:01:02,100 --> 00:01:05,400
呃，我们真的很荣幸

25
00:01:05,400 --> 00:01:07,619
有机会展示自己，所以

26
00:01:07,619 --> 00:01:09,780
我们也像其他一些人一样

27
00:01:09,780 --> 00:01:11,640
有兴趣开发一个用于

28
00:01:11,640 --> 00:01:13,920
主动推理的工具箱

29
00:01:13,920 --> 00:01:17,760
，所以这张图片或它展示了

30
00:01:17,760 --> 00:01:18,900
我们是

31
00:01:18,900 --> 00:01:20,820
什么，嗯什么 我们正在谈论或我们

32
00:01:20,820 --> 00:01:23,700
感兴趣的东西，所以左边是一位女士，

33
00:01:23,700 --> 00:01:26,100


34
00:01:26,100 --> 00:01:27,420
嗯，我们要

35
00:01:27,420 --> 00:01:30,119
尝试获得一个激光笔，她

36
00:01:30,119 --> 00:01:33,600
对真空清洁机器人的奖励行为有一个想法，

37
00:01:33,600 --> 00:01:36,000
所以她正在

38
00:01:36,000 --> 00:01:37,799
写 下来她有一个文字

39
00:01:37,799 --> 00:01:39,900
表达，但在公寓里走动，

40
00:01:39,900 --> 00:01:42,420
应用吸力，直到地板干净为止，

41
00:01:42,420 --> 00:01:45,180
不要触摸物体，当她

42
00:01:45,180 --> 00:01:47,400
回到狗身边时，这样就不那么

43
00:01:47,400 --> 00:01:50,520
难了，我会用

44
00:01:50,520 --> 00:01:52,259
三颗星中的一颗星来评价 就

45
00:01:52,259 --> 00:01:55,560
指定的难度级别而言，

46
00:01:55,560 --> 00:01:58,320
但这还不足以对这些

47
00:01:58,320 --> 00:02:00,000
机器人进行正确的编程，因为她

48
00:02:00,000 --> 00:02:02,939
现在真正需要做的是指定一个

49
00:02:02,939 --> 00:02:06,299
生成模型，而且呃，你知道

50
00:02:06,299 --> 00:02:09,479


51
00:02:09,479 --> 00:02:12,420
机器人必须四处移动，有效应器和执行器 施加

52
00:02:12,420 --> 00:02:15,360
吸力直到地板干净，这样

53
00:02:15,360 --> 00:02:18,480
传感器可能是相机就不会接触

54
00:02:18,480 --> 00:02:20,459
物体，所以也许必须进行物体

55
00:02:20,459 --> 00:02:23,099
识别，这是一个非常困难的

56
00:02:23,099 --> 00:02:25,680
任务，在这里提出这个生成

57
00:02:25,680 --> 00:02:28,680
模型，最重要的是

58
00:02:28,680 --> 00:02:31,860
她必须指定这种类型

59
00:02:31,860 --> 00:02:34,140
现在就

60
00:02:34,140 --> 00:02:36,300
这个

61
00:02:36,300 --> 00:02:39,120
生成模型的概率分布而言，奖励行为非常困难，我

62
00:02:39,120 --> 00:02:40,560
将给予两颗星评价，

63
00:02:40,560 --> 00:02:42,720
因为

64
00:02:42,720 --> 00:02:45,060
她为此模型要做的下一件事

65
00:02:45,060 --> 00:02:47,220
是指定推理

66
00:02:47,220 --> 00:02:49,800
过程来进行实际的主动

67
00:02:49,800 --> 00:02:52,379
推理和自由职业 实时最小化

68
00:02:52,379 --> 00:02:53,400


69
00:02:53,400 --> 00:02:56,459
或这个复杂的模型，实际上这

70
00:02:56,459 --> 00:02:59,540
几乎是不可能的，只有少数

71
00:02:59,540 --> 00:03:02,940
专家才能真正编写

72
00:03:02,940 --> 00:03:04,319


73
00:03:04,319 --> 00:03:06,540
一些非常困难的模型中变分自由能最小化的程序，

74
00:03:06,540 --> 00:03:09,780
所以我们一直在

75
00:03:09,780 --> 00:03:12,599
努力的是尝试 自动化

76
00:03:12,599 --> 00:03:14,580
推理任务，所以摆脱

77
00:03:14,580 --> 00:03:17,459
三颗星，是的，她仍然需要

78
00:03:17,459 --> 00:03:20,159
指定她的模型，但从长远

79
00:03:20,159 --> 00:03:23,220
来看，我们试图摆脱这种情况，所以从

80
00:03:23,220 --> 00:03:25,500
长远来看，我们希望我们能得到一个

81
00:03:25,500 --> 00:03:27,720
工具箱，现在我们 谈论五年

82
00:03:27,720 --> 00:03:31,440
十年吧，文本描述

83
00:03:31,440 --> 00:03:33,780
足以指定一些

84
00:03:33,780 --> 00:03:36,959
具有初始先验的初始模型，其他

85
00:03:36,959 --> 00:03:39,060
一切都只是状态参数

86
00:03:39,060 --> 00:03:42,120
的自动推理学习

87
00:03:42,120 --> 00:03:44,280
模型的结构适应，甚至

88
00:03:44,280 --> 00:03:48,360
可能基于她的反馈更新

89
00:03:48,360 --> 00:03:52,440
先验，所以这就是 从长远来看，

90
00:03:52,440 --> 00:03:55,140
如果我们能够自动执行推理任务，那么我们会非常高兴，

91
00:03:55,140 --> 00:04:00,060


92
00:04:00,060 --> 00:04:02,459
所以为什么

93
00:04:02,459 --> 00:04:04,560
为主动推理代理指定推理如此困难，

94
00:04:04,560 --> 00:04:07,819
我们有这么多竞争的

95
00:04:07,819 --> 00:04:11,519
kpi，我们想做 这

96
00:04:11,519 --> 00:04:15,180
适用于大型模型范围不仅适用于 ABCD

97
00:04:15,180 --> 00:04:17,720
模型，而且也许还有连续

98
00:04:17,720 --> 00:04:19,738
变量和

99
00:04:19,738 --> 00:04:22,440
生物模型，对必须非常

100
00:04:22,440 --> 00:04:24,960
用户友好，您真的不希望她担心

101
00:04:24,960 --> 00:04:29,220
代码的稳健性，

102
00:04:29,220 --> 00:04:30,960
我们不希望她担心

103
00:04:30,960 --> 00:04:32,880
是否

104
00:04:32,880 --> 00:04:36,180
嗯，两个变量之间有良好的

105
00:04:36,180 --> 00:04:38,220
关系，

106
00:04:38,220 --> 00:04:40,320
嗯，我们想要更新状态

107
00:04:40,320 --> 00:04:42,540
参数，甚至是模型，

108
00:04:42,540 --> 00:04:45,060
模型结构必须是低功耗的，

109
00:04:45,060 --> 00:04:48,180
因为这些天使通常在边缘设备上运行，

110
00:04:48,180 --> 00:04:50,759
所以它们必须在

111
00:04:50,759 --> 00:04:53,340
电池供电的情况下运行 实时，

112
00:04:53,340 --> 00:04:55,979
因为如果没有实时推理，你就无法学习如何骑

113
00:04:55,979 --> 00:04:58,139
自行车，

114
00:04:58,139 --> 00:05:01,259
而且最重要的是，你实际上想要最大限度地

115
00:05:01,259 --> 00:05:03,000
减少现实的变化，你

116
00:05:03,000 --> 00:05:04,740
想要至少做到同样好，或者

117
00:05:04,740 --> 00:05:06,780
至少在附近 如果你要

118
00:05:06,780 --> 00:05:09,720
进行手动推导，其中一些，

119
00:05:09,720 --> 00:05:11,880
这是一个相当相互咬合的权利，

120
00:05:11,880 --> 00:05:14,520
如果你呃，你想最小

121
00:05:14,520 --> 00:05:16,740
化变分自由能，但你必须

122
00:05:16,740 --> 00:05:19,259
实时且低功率地进行，是的，

123
00:05:19,259 --> 00:05:21,479
这种相互咬合对吧 所以

124
00:05:21,479 --> 00:05:23,340
这些都是

125
00:05:23,340 --> 00:05:27,600
我们想要的困难的关键绩效指标，是的，

126
00:05:27,600 --> 00:05:30,000
它们都很重要，你不能只

127
00:05:30,000 --> 00:05:31,380
去掉

128
00:05:31,380 --> 00:05:33,180
一个，因为那样整个系统就

129
00:05:33,180 --> 00:05:35,520
无法工作，

130
00:05:35,520 --> 00:05:37,320


131
00:05:37,320 --> 00:05:40,860
所以当你阅读有关主动推理的论文时，

132
00:05:40,860 --> 00:05:44,039
你经常也会阅读和 现在我们

133
00:05:44,039 --> 00:05:46,259
实现变异多样性最小化，

134
00:05:46,259 --> 00:05:49,380
这可以通过在图表上传递消息来完成

135
00:05:49,380 --> 00:05:53,639
，我想首先澄清

136
00:05:53,639 --> 00:05:56,039
为什么它必须通过在图表上传递消息来完成，

137
00:05:56,039 --> 00:05:57,539


138
00:05:57,539 --> 00:05:58,919
我将通过给出一个非常简短的答案来做到这一点

139
00:05:58,919 --> 00:06:00,120


140
00:06:00,120 --> 00:06:02,960
，然后做 一个例子，简短的回答

141
00:06:02,960 --> 00:06:08,759
是，贝叶斯推理涉及

142
00:06:08,759 --> 00:06:11,340
计算非常大的乘积总和，

143
00:06:11,340 --> 00:06:13,199
就像您在左侧看到的那样，

144
00:06:13,199 --> 00:06:16,160
这是一个乘积 AC

145
00:06:16,160 --> 00:06:19,800
adbc，然后我们以 AC 加 80 的形式发送它们，

146
00:06:19,800 --> 00:06:21,840
依此类推，这是乘积的总和

147
00:06:21,840 --> 00:06:26,039
现在我们通过分配律知道，

148
00:06:26,039 --> 00:06:28,380
左边的这个也可以

149
00:06:28,380 --> 00:06:31,860
像右边一样计算如果

150
00:06:31,860 --> 00:06:34,259
我把它相乘，我得到一个乘以C加上

151
00:06:34,259 --> 00:06:36,900
一个乘以D等等，这是和的

152
00:06:36,900 --> 00:06:39,000
乘积，并且有

153
00:06:39,000 --> 00:06:41,819
完全相同的事情，唯一的

154
00:06:41,819 --> 00:06:44,400
区别是计算

155
00:06:44,400 --> 00:06:47,160
左侧需要四次加法，抱歉需要

156
00:06:47,160 --> 00:06:49,979
四次乘法和三个加法

157
00:06:49,979 --> 00:06:52,919
来计算右侧需要两次

158
00:06:52,919 --> 00:06:54,300
加法和一次

159
00:06:54,300 --> 00:06:57,600
乘法，因此右侧的

160
00:06:57,600 --> 00:07:00,240
计算成本要便宜得多

161
00:07:00,240 --> 00:07:03,259
通常，当我们写下

162
00:07:03,259 --> 00:07:05,819
边缘化和亚洲推理时，

163
00:07:05,819 --> 00:07:08,639
我们会在

164
00:07:08,639 --> 00:07:11,460
左侧写下信息传递

165
00:07:11,460 --> 00:07:13,500
在图表上的作用，它会自动将

166
00:07:13,500 --> 00:07:16,919
其转换为更深层次的内容，以

167
00:07:16,919 --> 00:07:20,099
评估总和的乘积，我' 我会举

168
00:07:20,099 --> 00:07:22,259
一个例子，

169
00:07:22,259 --> 00:07:23,460


170
00:07:23,460 --> 00:07:27,900
所以这里是一个例子，

171
00:07:27,900 --> 00:07:31,319
七个变量 X1 X2 到 X7 的模型 F，

172
00:07:31,319 --> 00:07:34,319
这个模型恰好是

173
00:07:34,319 --> 00:07:39,300
X1 fbx2 的 F A 因式分解，依此类推，现在我们可以

174
00:07:39,300 --> 00:07:42,479
在 a 中将这个因式分解绘制为图表

175
00:07:42,479 --> 00:07:44,699
，什么 我们这样做，这被称为

176
00:07:44,699 --> 00:07:46,919
福尼风格因子图，我们所做的是

177
00:07:46,919 --> 00:07:51,300
为每个因子 F A 分配一个节点，

178
00:07:51,300 --> 00:07:54,780
这样 FB 得到一个注释，FC 得到一个注释

179
00:07:54,780 --> 00:07:58,020
，我们将系统中的变量

180
00:07:58,020 --> 00:08:00,720
与边关联起来，一条边

181
00:08:00,720 --> 00:08:03,780
连接到 一个节点，如果该变量是

182
00:08:03,780 --> 00:08:07,440
该函数的参数，则 FC 是

183
00:08:07,440 --> 00:08:12,060
X1 X2 X 3 的 F 的函数，这

184
00:08:12,060 --> 00:08:14,880
意味着 FC 连接到边 X1

185
00:08:14,880 --> 00:08:20,039
X2 X3，而 FD 只是 X4 的函数，因此

186
00:08:20,039 --> 00:08:24,419
如果 D 仅连接到 边缘 X4 所以

187
00:08:24,419 --> 00:08:26,580
你可以在这张图中看到的是，这张

188
00:08:26,580 --> 00:08:28,500
图只不过是

189
00:08:28,500 --> 00:08:31,399


190
00:08:31,399 --> 00:08:35,339
我们现在对该模型的因式分解假设的可视化，

191
00:08:35,339 --> 00:08:37,860
如果我对大

192
00:08:37,860 --> 00:08:41,820
边缘化感兴趣，则任务会整合除

193
00:08:41,820 --> 00:08:47,220
X3 之外的所有变量，因此 X1 X2  X4

194
00:08:47,220 --> 00:08:49,680
等等到 X7 我对此很感兴趣，

195
00:08:49,680 --> 00:08:51,540


196
00:08:51,540 --> 00:08:52,860
然后

197
00:08:52,860 --> 00:08:55,800
利用这个

198
00:08:55,800 --> 00:08:58,560
因式分解，我可以将这个总和

199
00:08:58,560 --> 00:09:03,620
基本上重写为

200
00:09:03,620 --> 00:09:09,060
总和的乘积，如下所示，

201
00:09:09,060 --> 00:09:10,980
您将在下面看到这

202
00:09:10,980 --> 00:09:13,080
精确地计算出 同样的事情，但我利用

203
00:09:13,080 --> 00:09:16,519
了这个分配律，例如

204
00:09:16,519 --> 00:09:22,080
FC 不包含 X4 不包含 X5，所以我将它移到

205
00:09:22,080 --> 00:09:25,080
左侧的求和符号上，

206
00:09:25,080 --> 00:09:30,660
FB 也不包含 X4 X5 x67，所以我将

207
00:09:30,660 --> 00:09:32,760
它一直移到

208
00:09:32,760 --> 00:09:35,700
左边，当你这样做时，你会在这里留下

209
00:09:35,700 --> 00:09:38,279
一个表达式，

210
00:09:38,279 --> 00:09:42,480
其中我只有一些超过两个两个

211
00:09:42,480 --> 00:09:44,519
变量，在这里我必须对

212
00:09:44,519 --> 00:09:46,860
六个变量求和，这里超过两个，这里

213
00:09:46,860 --> 00:09:49,920
超过两个，所以你可以想象如果每个

214
00:09:49,920 --> 00:09:53,760
变量都这么说 X1  X2 如果每个

215
00:09:53,760 --> 00:09:56,399
变量有 10 个有趣的值

216
00:09:56,399 --> 00:09:57,959
需要求和，

217
00:09:57,959 --> 00:10:00,180
那么我这里有

218
00:10:00,180 --> 00:10:03,360
原始的边缘化问题 我

219
00:10:03,360 --> 00:10:06,240
有 10 的 6 次方所以有一百万

220
00:10:06,240 --> 00:10:08,940
项，这里

221
00:10:08,940 --> 00:10:12,000
是红色的我有 100 个项，这里有

222
00:10:12,000 --> 00:10:14,940
100 个，这里我有 100 所以这里我有

223
00:10:14,940 --> 00:10:18,060
300 个项，这里我有 100 万个

224
00:10:18,060 --> 00:10:20,820
项，所以当

225
00:10:20,820 --> 00:10:23,240


226
00:10:23,240 --> 00:10:24,920


227
00:10:24,920 --> 00:10:28,620
我们利用这个分配律时，计算复杂性会大大降低吗？

228
00:10:28,620 --> 00:10:31,860
现在事实证明，如果你把

229
00:10:31,860 --> 00:10:36,000
这个写出来，你可以将这些

230
00:10:36,000 --> 00:10:38,459
中间因素与 图表上的消息，

231
00:10:38,459 --> 00:10:40,620
这只是一种解释，一种

232
00:10:40,620 --> 00:10:43,860
视觉解释，就好像

233
00:10:43,860 --> 00:10:45,720
FC

234
00:10:45,720 --> 00:10:49,140
从 fa 接收消息，然后 FB

235
00:10:49,140 --> 00:10:51,839
接收，或者 FC

236
00:10:51,839 --> 00:10:55,260
从 FB 接收来自 X 的消息，并计算传出

237
00:10:55,260 --> 00:10:58,740
消息 mu X3，对于 Fe 也是如此，

238
00:10:58,740 --> 00:11:01,680
因此 Fe 接收消息 来自

239
00:11:01,680 --> 00:11:04,920
相邻因子 FD 和 FF 并

240
00:11:04,920 --> 00:11:07,640
计算传出消息

241
00:11:07,640 --> 00:11:12,660
或 X3，因此您在这里看到的是

242
00:11:12,660 --> 00:11:15,660
整个边缘化过程可以

243
00:11:15,660 --> 00:11:18,899
基本上表示为计算

244
00:11:18,899 --> 00:11:20,820
图上的一些消息

245
00:11:20,820 --> 00:11:22,860
并将其中一些消息

246
00:11:22,860 --> 00:11:25,500
彼此相乘 and and and and and 这就是

247
00:11:25,500 --> 00:11:27,540
你如何进行推理的基础，以及

248
00:11:27,540 --> 00:11:29,399
如何进行变分自由能

249
00:11:29,399 --> 00:11:33,959
最小化，所以这

250
00:11:33,959 --> 00:11:38,220
在分解模型中有效，但我想说，

251
00:11:38,220 --> 00:11:40,140
如果你的模型没有

252
00:11:40,140 --> 00:11:42,180
分解并且你有很多

253
00:11:42,180 --> 00:11:45,300
变量，呃，没有 你

254
00:11:45,300 --> 00:11:48,240
可以进行正确的推理，这样任何严肃的

255
00:11:48,240 --> 00:11:51,000
模型都会被分解，就像大脑

256
00:11:51,000 --> 00:11:54,779
几乎是稀疏的，几乎是空的一样，我们有

257
00:11:54,779 --> 00:11:58,019
大约100亿个神经元，

258
00:11:58,019 --> 00:11:59,940
每个神经元连接到几千个

259
00:11:59,940 --> 00:12:02,519
其他神经元，所以如果我画出

260
00:12:02,519 --> 00:12:04,800
这样的图 几乎是空的，它

261
00:12:04,800 --> 00:12:08,700
非常稀疏，所以除了消息传递之外，没有其他

262
00:12:08,700 --> 00:12:10,620
方法可以在大脑中进行推理，

263
00:12:10,620 --> 00:12:12,540


264
00:12:12,540 --> 00:12:14,519
所以这就是为什么消息传递只是

265
00:12:14,519 --> 00:12:16,200
因为它比

266
00:12:16,200 --> 00:12:18,500
其他任何东西都更有效，

267
00:12:18,500 --> 00:12:22,440
那么问题是你计算哪条消息

268
00:12:22,440 --> 00:12:25,920
如何计算 你计算消息，

269
00:12:25,920 --> 00:12:28,320
因为有不同的方法可以

270
00:12:28,320 --> 00:12:30,360
正确地做到这一点，我们也在

271
00:12:30,360 --> 00:12:32,160
主动推理论文中读到，你可以

272
00:12:32,160 --> 00:12:34,339
通过变分消息传递或

273
00:12:34,339 --> 00:12:37,440
期望最大化或置信

274
00:12:37,440 --> 00:12:39,240
传播和

275
00:12:39,240 --> 00:12:42,360
变分拉普拉斯来做到这一点，所有这些术语都

276
00:12:42,360 --> 00:12:46,260
证明存在一个保护伞

277
00:12:46,260 --> 00:12:48,300
所有这些方法传递

278
00:12:48,300 --> 00:12:50,700
框架的框架，这个伞形框架

279
00:12:50,700 --> 00:12:53,220
被称为约束更好的

280
00:12:53,220 --> 00:12:56,459
自由能最小化，我尝试

281
00:12:56,459 --> 00:12:57,920


282
00:12:57,920 --> 00:13:02,040
通过这张幻灯片来说明这一点，

283
00:13:02,040 --> 00:13:05,160
所以这里我有这个图，这只是

284
00:13:05,160 --> 00:13:06,980
一个示例图，

285
00:13:06,980 --> 00:13:11,839
其中我的生成模型是 基本上

286
00:13:11,839 --> 00:13:17,399
分解 dnfe 的 F A FB FC ，我

287
00:13:17,399 --> 00:13:19,560
也在这里写过，所以现在这是

288
00:13:19,560 --> 00:13:21,779
自由能的变化，

289
00:13:21,779 --> 00:13:25,260
现在我没有对 X 的 Q 做出任何假设，

290
00:13:25,260 --> 00:13:29,399
所以 X 的 Q 仍然是 X1 的 Q X2 X3

291
00:13:29,399 --> 00:13:32,820
只是一个 联合总体变量并且它

292
00:13:32,820 --> 00:13:34,079
没有任何因式分解

293
00:13:34,079 --> 00:13:36,120
假设，

294
00:13:36,120 --> 00:13:39,240
嗯，

295
00:13:39,240 --> 00:13:41,940
假设后验类型遵循

296
00:13:41,940 --> 00:13:43,920
先验

297
00:13:43,920 --> 00:13:47,339
即生成模型的因式分解假设是有意义的，所以如果我们

298
00:13:47,339 --> 00:13:49,260
做出这个假设

299
00:13:49,260 --> 00:13:51,959
，这意味着我们将

300
00:13:51,959 --> 00:13:55,320
假设 Q X 现在也是 a 的

301
00:13:55,320 --> 00:13:57,180


302
00:13:57,180 --> 00:14:01,620
X 的 qas 的乘积，其中 a 的 X 的 qas 代表对

303
00:14:01,620 --> 00:14:04,320
注释的信念，我的意思

304
00:14:04,320 --> 00:14:08,220
是 B 的 Q 是 a 是

305
00:14:08,220 --> 00:14:10,760
该节点的后验信念，意味着它是

306
00:14:10,760 --> 00:14:13,800
后验信念 对

307
00:14:13,800 --> 00:14:17,700
连接到这些节点的边的信念就像 FB 一样是

308
00:14:17,700 --> 00:14:20,760
X1 X2 X 4 的函数，

309
00:14:20,760 --> 00:14:23,220
也就是说，如果您使用先验

310
00:14:23,220 --> 00:14:26,279
模型或生成模型，那么 B 的 Q 则

311
00:14:26,279 --> 00:14:28,500
该节点的变分后验也将

312
00:14:28,500 --> 00:14:32,839
取决于 X1 X2 X4 并且不依赖于 其他

313
00:14:32,839 --> 00:14:36,660
因素，如果你这样做，那么你

314
00:14:36,660 --> 00:14:39,720
会将一些变量计算为双倍，

315
00:14:39,720 --> 00:14:43,380
因为 X1 是对 F A 的信念的一部分，

316
00:14:43,380 --> 00:14:47,399
也是对 FB 的信念的一部分，所以

317
00:14:47,399 --> 00:14:49,860
我们只需要通过除以

318
00:14:49,860 --> 00:14:53,760
边缘的信念来折扣，这

319
00:14:53,760 --> 00:14:57,240
意味着我 现在假设

320
00:14:57,240 --> 00:15:01,680
我的后验信念

321
00:15:01,680 --> 00:15:05,639
被分为对音符的局部信念

322
00:15:05,639 --> 00:15:08,100
和对变量的边缘的局部信念，

323
00:15:08,100 --> 00:15:09,540


324
00:15:09,540 --> 00:15:12,779
这将使事情变得简单得多，

325
00:15:12,779 --> 00:15:16,860
事实上，如果我的图是一棵树，并且这里是一

326
00:15:16,860 --> 00:15:19,560
棵树，我会做消息 传递

327
00:15:19,560 --> 00:15:21,600
那棵树，我可以假设我可以

328
00:15:21,600 --> 00:15:23,579
做到完美，一切都是线性

329
00:15:23,579 --> 00:15:25,800
高斯，然后我得到完美的贝叶斯

330
00:15:25,800 --> 00:15:28,980
推理，没有近似值，所以

331
00:15:28,980 --> 00:15:32,100
这是一个很好的假设，有时

332
00:15:32,100 --> 00:15:33,959
计算消息仍然非常困难，

333
00:15:33,959 --> 00:15:35,279
因为

334
00:15:35,279 --> 00:15:38,660
即使是单个

335
00:15:38,660 --> 00:15:41,040
来自这些节点的消息仍然

336
00:15:41,040 --> 00:15:44,100
积分或求和，

337
00:15:44,100 --> 00:15:46,019
特别是积分可能是一个

338
00:15:46,019 --> 00:15:47,760
问题，我们可能没有分析

339
00:15:47,760 --> 00:15:51,480
答案，所以我们有时做的是添加

340
00:15:51,480 --> 00:15:53,100
额外的

341
00:15:53,100 --> 00:15:56,279
假设，我们会说很好的

342
00:15:56,279 --> 00:15:59,519
FD 的后验信念我可以 一般来说，我不会计算

343
00:15:59,519 --> 00:16:01,139
它，

344
00:16:01,139 --> 00:16:03,420
但我现在假设它是

345
00:16:03,420 --> 00:16:06,300
一个高斯分布，这使得它变得更容易，或者我们

346
00:16:06,300 --> 00:16:08,399
可以做一个额外的因式分解

347
00:16:08,399 --> 00:16:09,959
假设，

348
00:16:09,959 --> 00:16:13,260
并说对 FB 的后验信念，

349
00:16:13,260 --> 00:16:16,320
这实际上是对关节

350
00:16:16,320 --> 00:16:20,420
X1 X2 X4 的信念 被分解为

351
00:16:20,420 --> 00:16:25,380
对 X1 的独立信念和

352
00:16:25,380 --> 00:16:26,940
对

353
00:16:26,940 --> 00:16:29,880
X2 和 X4 的信念，

354
00:16:29,880 --> 00:16:30,740


355
00:16:30,740 --> 00:16:34,920
这些附加假设如果我也强加

356
00:16:34,920 --> 00:16:36,839
它们，这就是我

357
00:16:36,839 --> 00:16:39,899
现在所说的如果我如果我如果我全部替换

358
00:16:39,899 --> 00:16:42,540
在 X 的 Q 中我得到 所谓的

359
00:16:42,540 --> 00:16:45,180
受约束的无贝塔能量，这

360
00:16:45,180 --> 00:16:47,459
与奥本海默电影中的死亡相同，

361
00:16:47,459 --> 00:16:50,339
这是汉斯贝塔，它以它的名字命名，

362
00:16:50,339 --> 00:16:51,899


363
00:16:51,899 --> 00:16:53,820
嗯，所以

364
00:16:53,820 --> 00:16:56,360
我们现在有一个图表，

365
00:16:56,360 --> 00:17:00,839
它是高度因式分解的，我们

366
00:17:00,839 --> 00:17:02,480


367
00:17:02,480 --> 00:17:07,079
对笔记和对

368
00:17:07,079 --> 00:17:09,660
嗯有局部信念 边缘，它们

369
00:17:09,660 --> 00:17:11,819
用红色表示，我们有

370
00:17:11,819 --> 00:17:14,040
绿色的附加约束，可能有

371
00:17:14,040 --> 00:17:16,559
高斯或平均场约束或

372
00:17:16,559 --> 00:17:19,859
其他约束，现在我们将假设

373
00:17:19,859 --> 00:17:21,059
约束可以

374
00:17:21,059 --> 00:17:22,679
计算所有消息，现在我们可以通过以下方式

375
00:17:22,679 --> 00:17:24,959
自动化此操作 做出不同的

376
00:17:24,959 --> 00:17:27,179
假设，我们可以将其转化为

377
00:17:27,179 --> 00:17:30,059
期望最大化或信念

378
00:17:30,059 --> 00:17:32,280
传播或

379
00:17:32,280 --> 00:17:32,820
嗯

380
00:17:32,820 --> 00:17:35,280
混合形式关闭我们可以将其转化为

381
00:17:35,280 --> 00:17:37,620


382
00:17:37,620 --> 00:17:40,020
您听说过的任何相关消息传递算法，所以这是一个非常

383
00:17:40,020 --> 00:17:42,960
好的伞形框架，基本上

384
00:17:42,960 --> 00:17:46,320
涵盖了所有内容并且那里

385
00:17:46,320 --> 00:17:49,260
我们已经在《熵杂志》上写了一篇关于这个问题的相当长的论文，

386
00:17:49,260 --> 00:17:51,059


387
00:17:51,059 --> 00:17:53,700
您

388
00:17:53,700 --> 00:17:57,200
可以在其中阅读有关其工作原理的所有数学知识，

389
00:17:57,200 --> 00:18:00,240
因此我们讨论了为什么要

390
00:18:00,240 --> 00:18:02,700
传递消息，因为它是

391
00:18:02,700 --> 00:18:05,160
进行推理和推理的最有效方法

392
00:18:05,160 --> 00:18:06,900
我们已经讨论了要计算哪些消息，

393
00:18:06,900 --> 00:18:08,760
即

394
00:18:08,760 --> 00:18:10,679
我们将

395
00:18:10,679 --> 00:18:12,900
变分自由能转化为一种

396
00:18:12,900 --> 00:18:14,760
称为约束更好自由能的东西，

397
00:18:14,760 --> 00:18:17,400
然后我们可以计算消息，

398
00:18:17,400 --> 00:18:20,940
剩下的唯一的事情就是

399
00:18:20,940 --> 00:18:23,100
我们什么时候正确传递这些消息，

400
00:18:23,100 --> 00:18:25,080
消息的序列是什么 哪一个先出现，

401
00:18:25,080 --> 00:18:25,980


402
00:18:25,980 --> 00:18:27,360


403
00:18:27,360 --> 00:18:29,760
嗯，这是我们看到很多论文的地方，

404
00:18:29,760 --> 00:18:30,840


405
00:18:30,840 --> 00:18:31,559
嗯，

406
00:18:31,559 --> 00:18:34,020
你有正确的控制流，什么是

407
00:18:34,020 --> 00:18:36,419
好的控制流，你必须说好吧，

408
00:18:36,419 --> 00:18:38,520
这是我的主动推理算法，

409
00:18:38,520 --> 00:18:41,100
首先我指定一个模型，然后

410
00:18:41,100 --> 00:18:43,320
让我们对每个进行推理 时间步长

411
00:18:43,320 --> 00:18:45,780
收集新的观察更新状态更新

412
00:18:45,780 --> 00:18:48,960
期望的未来

413
00:18:48,960 --> 00:18:51,720
权利等等计算预期自由能

414
00:18:51,720 --> 00:18:55,140
选择策略等等

415
00:18:55,140 --> 00:18:58,799
这种程序

416
00:18:58,799 --> 00:19:01,200
主动推理的问题是

417
00:19:01,200 --> 00:19:03,600
这里有嵌套的for循环这是一个for

418
00:19:03,600 --> 00:19:06,600
循环这是 另一个 for 循环，对于

419
00:19:06,600 --> 00:19:09,179
每个策略，我将

420
00:19:09,179 --> 00:19:11,580
不得不进入呃未来，所以我将

421
00:19:11,580 --> 00:19:13,380
有另一个时间循环，所以它是 for 循环中的

422
00:19:13,380 --> 00:19:15,780
四个循环中的 for 循环，这

423
00:19:15,780 --> 00:19:17,700
将在计算方面完全爆炸

424
00:19:17,700 --> 00:19:19,140


425
00:19:19,140 --> 00:19:23,520
复杂性，因此，一些非常

426
00:19:23,520 --> 00:19:25,980
聪明的人编写了非常聪明的

427
00:19:25,980 --> 00:19:27,900
算法来执行此操作，速度更快，复杂的

428
00:19:27,900 --> 00:19:30,960
推理分支时间

429
00:19:30,960 --> 00:19:33,179
积极影响动态编程，

430
00:19:33,179 --> 00:19:36,299
我们最近提出的非常聪明的建议

431
00:19:36,299 --> 00:19:37,320


432
00:19:37,320 --> 00:19:41,460
最终所有这些建议都

433
00:19:41,460 --> 00:19:44,660
归结为一个特定的 消息

434
00:19:44,660 --> 00:19:47,160
传递时间表

435
00:19:47,160 --> 00:19:50,039
一旦我们承诺在图上传递消息

436
00:19:50,039 --> 00:19:51,900
作为我们的推理过程，

437
00:19:51,900 --> 00:19:54,780
它就是唯一正在发生的事情，

438
00:19:54,780 --> 00:19:56,520
所有这些

439
00:19:56,520 --> 00:19:59,160
或复杂的推理和授予

440
00:19:59,160 --> 00:20:02,160
时间主动推理它所做的就是

441
00:20:02,160 --> 00:20:04,140
安排它所说的第一个

442
00:20:04,140 --> 00:20:06,000
消息的消息 然后这条消息 然后这条

443
00:20:06,000 --> 00:20:09,960
消息 我并不是说，作为

444
00:20:09,960 --> 00:20:12,120
这些算法的幻灯片，它们非常聪明，

445
00:20:12,120 --> 00:20:14,039
正如我们在 asvine Paul 的演示中看到的那样，

446
00:20:14,039 --> 00:20:16,260
如果您从常规推理转向复杂推理，您会得到巨大的改进，

447
00:20:16,260 --> 00:20:17,820


448
00:20:17,820 --> 00:20:20,700
但它是 很高兴

449
00:20:20,700 --> 00:20:22,799
认识到

450
00:20:22,799 --> 00:20:25,919
这些算法只是在图中指定哪条

451
00:20:25,919 --> 00:20:28,080
消息在哪条消息之后，

452
00:20:28,080 --> 00:20:29,880


453
00:20:29,880 --> 00:20:32,220
所以这是一个示例，

454
00:20:32,220 --> 00:20:35,100
这是一个图形和

455
00:20:35,100 --> 00:20:37,200
消息

456
00:20:37,200 --> 00:20:38,039


457
00:20:38,039 --> 00:20:40,500
序列的示例，这是一条消息，然后

458
00:20:40,500 --> 00:20:43,200
消息 H2 和消息 3 上升，

459
00:20:43,200 --> 00:20:46,559
然后我们从 FC 到 f f ，这里它

460
00:20:46,559 --> 00:20:49,260
匹配 5，然后我们转到 Fe，

461
00:20:49,260 --> 00:20:51,559
这可以对应于

462
00:20:51,559 --> 00:20:54,299
动态时间编程 efe 或

463
00:20:54,299 --> 00:20:56,820
复杂推理的序列，

464
00:20:56,820 --> 00:20:58,799
嗯，这种方法有几个问题

465
00:20:58,799 --> 00:21:00,840
，我们基本上可以

466
00:21:00,840 --> 00:21:04,440
让用户指定一个

467
00:21:04,440 --> 00:21:06,419
聪明的算法首先，

468
00:21:06,419 --> 00:21:08,340
你必须是专家才能

469
00:21:08,340 --> 00:21:10,559
正确地做这件事，只有这些人非常聪明，

470
00:21:10,559 --> 00:21:14,580
所以这意味着，嗯，如果我们让它

471
00:21:14,580 --> 00:21:17,160
留给

472
00:21:17,160 --> 00:21:18,900
嗯，让我们对公司的工程师说，

473
00:21:18,900 --> 00:21:21,059
那就好，这是更高的

474
00:21:21,059 --> 00:21:22,620
概率 不会得到正确的结果，

475
00:21:22,620 --> 00:21:24,960
这是非常不幸的，

476
00:21:24,960 --> 00:21:27,900
但是还有另一个问题，那就是从

477
00:21:27,900 --> 00:21:29,940
某种意义上来说，它是

478
00:21:29,940 --> 00:21:31,440


479
00:21:31,440 --> 00:21:33,419
消息传递计划中的全局变量，所有

480
00:21:33,419 --> 00:21:36,059
节点都会被访问，因为如果一个节点

481
00:21:36,059 --> 00:21:38,700
不会被访问，那么我们不应该'

482
00:21:38,700 --> 00:21:40,860
图表中没有它，这意味着如果

483
00:21:40,860 --> 00:21:44,159
一个节点基本上崩溃，则消息

484
00:21:44,159 --> 00:21:46,559
传递时间表无效，我必须

485
00:21:46,559 --> 00:21:48,480
重置我的系统，

486
00:21:48,480 --> 00:21:50,580
如果您驾驶一架无人机，如果它已部署并且

487
00:21:50,580 --> 00:21:53,039
在现场，并且节点崩溃，则

488
00:21:53,039 --> 00:21:56,520
晶体管烧毁并且 我

489
00:21:56,520 --> 00:21:58,320
现在必须完全重置我的系统，我

490
00:21:58,320 --> 00:22:00,179
必须计算一个新的消息传递

491
00:22:00,179 --> 00:22:01,559
时间表，

492
00:22:01,559 --> 00:22:03,179
然后你不进行推理，

493
00:22:03,179 --> 00:22:05,100
你知道你的无人机飞到

494
00:22:05,100 --> 00:22:09,120
墙上，所以这不稳健，这也与

495
00:22:09,120 --> 00:22:12,059
我们相同的原因 可能

496
00:22:12,059 --> 00:22:14,940
实际上想要取出一个节点，我们

497
00:22:14,940 --> 00:22:17,280
可能想要修剪很多，我们

498
00:22:17,280 --> 00:22:20,100
可能想要进行结构适应，

499
00:22:20,100 --> 00:22:21,780
但

500
00:22:21,780 --> 00:22:23,700
我们无法进行结构适应，

501
00:22:23,700 --> 00:22:26,039
因为我们必须重置系统，

502
00:22:26,039 --> 00:22:29,039
重新计算消息传递时间表，因此

503
00:22:29,039 --> 00:22:32,340
这种程序风格 工程师

504
00:22:32,340 --> 00:22:35,640
应用程序纯粹指定

505
00:22:35,640 --> 00:22:37,559
此消息之后出现的消息有一些

506
00:22:37,559 --> 00:22:40,799
缺点，它不是很健壮，

507
00:22:40,799 --> 00:22:42,600
如果你想做得非常聪明，

508
00:22:42,600 --> 00:22:46,980
你必须是真正的专家，所以

509
00:22:46,980 --> 00:22:50,280
更好的系统就是我们所说的反应式

510
00:22:50,280 --> 00:22:52,080
消息传递

511
00:22:52,080 --> 00:22:56,700
，它非常好 与第一场会议中的内容相关，

512
00:22:56,700 --> 00:22:59,580
呃，称为演员

513
00:22:59,580 --> 00:23:01,919
模型 Keith Duggar 对演员模型做了一个很好的

514
00:23:01,919 --> 00:23:04,020
演示，

515
00:23:04,020 --> 00:23:07,679
所以我们要做的是我们会说我们

516
00:23:07,679 --> 00:23:09,960
不会有一个全局消息传递

517
00:23:09,960 --> 00:23:12,480
时间表，工程师不会再

518
00:23:12,480 --> 00:23:15,480
指定任何内容

519
00:23:15,480 --> 00:23:17,640
工程师必须编写的推理代码

520
00:23:17,640 --> 00:23:21,000
只是对任何自由能

521
00:23:21,000 --> 00:23:23,460
最小化机会做出反应，换句话说，

522
00:23:23,460 --> 00:23:25,440
没有推理代码，它是

523
00:23:25,440 --> 00:23:27,059
完全自动化的，

524
00:23:27,059 --> 00:23:28,559


525
00:23:28,559 --> 00:23:31,620
嗯，我们将通过注释内的本地触发来替换此全局消息

526
00:23:31,620 --> 00:23:34,559
传递计划，

527
00:23:34,559 --> 00:23:37,679
因此每个节点 现在只是

528
00:23:37,679 --> 00:23:40,320
一个自治系统，它对

529
00:23:40,320 --> 00:23:42,440
最小化其自由能感兴趣，

530
00:23:42,440 --> 00:23:45,980
呃，它可以通过发送消息来做到这一点，

531
00:23:45,980 --> 00:23:50,100
什么时候它会做得这么好，它会接收

532
00:23:50,100 --> 00:23:52,500
消息我的意思是，当它看到

533
00:23:52,500 --> 00:23:54,120
这些消息时，感觉就像哦，

534
00:23:54,120 --> 00:23:55,799
有 我有机会通过

535
00:23:55,799 --> 00:23:57,360


536
00:23:57,360 --> 00:24:00,299
发送消息来最小化免费能源购买或期望免费进入，

537
00:24:00,299 --> 00:24:02,039
然后将发送一条

538
00:24:02,039 --> 00:24:05,460
消息，每个节点将自行异步执行此操作，

539
00:24:05,460 --> 00:24:08,159
这样您就可以获得

540
00:24:08,159 --> 00:24:10,320
并行分布式处理或

541
00:24:10,320 --> 00:24:13,559
并发处理，

542
00:24:13,559 --> 00:24:16,440
原则上 Keys 称之为 um 你可以

543
00:24:16,440 --> 00:24:20,280
同时在许多呃计算机上玩这个游戏

544
00:24:20,280 --> 00:24:25,280
，所以你会获得巨大的优势，

545
00:24:25,280 --> 00:24:27,480
首先你不必编写

546
00:24:27,480 --> 00:24:30,240
困难的代码，其次你可以进行

547
00:24:30,240 --> 00:24:33,840
多线程，或者你可以

548
00:24:33,840 --> 00:24:35,400
在上面运行它 同时有多台计算机

549
00:24:35,400 --> 00:24:36,480


550
00:24:36,480 --> 00:24:40,980
等等，还有鲁棒性

551
00:24:40,980 --> 00:24:42,659


552
00:24:42,659 --> 00:24:45,419
嗯嗯嗯优势，因为如果一条笔记

553
00:24:45,419 --> 00:24:49,140
崩溃了，那么没有什么可以阻止

554
00:24:49,140 --> 00:24:50,580
系统找到另一条

555
00:24:50,580 --> 00:24:53,880
路径，如果这个节点在这条路径上崩溃了这条

556
00:24:53,880 --> 00:24:56,760
路径，从这里的消息三

557
00:24:56,760 --> 00:24:59,220
现在不 不起作用，所以我不能

558
00:24:59,220 --> 00:25:02,520
再从呃不从 X 向 Fe 发送任何东西，

559
00:25:02,520 --> 00:25:04,919
那么我刚刚在这里发送了一条新消息，

560
00:25:04,919 --> 00:25:08,340
为什么不呢？就像水从

561
00:25:08,340 --> 00:25:11,340
山上掉下来，它曲折

562
00:25:11,340 --> 00:25:13,679
地下降到值中，你就可以在

563
00:25:13,679 --> 00:25:16,080
哪里放置了 遇到障碍物时，它只是

564
00:25:16,080 --> 00:25:18,120
找到另一条路径，

565
00:25:18,120 --> 00:25:21,840
不是首选路径，必须

566
00:25:21,840 --> 00:25:24,360
找到第二条第二最佳

567
00:25:24,360 --> 00:25:26,039
路径，因为第一条路径已被

568
00:25:26,039 --> 00:25:27,960
阻挡，这就是

569
00:25:27,960 --> 00:25:29,700
该系统中将要发生的情况，

570
00:25:29,700 --> 00:25:32,279
这就是大自然的方式

571
00:25:32,279 --> 00:25:34,200
它会尝试找到最佳路径

572
00:25:34,200 --> 00:25:35,580
和最简单的路径，如果不可用，

573
00:25:35,580 --> 00:25:37,559
那么我们会执行第二个最佳路径，

574
00:25:37,559 --> 00:25:39,360
这也是您可以使用

575
00:25:39,360 --> 00:25:41,820
反应式消息传递所做的事情，这样您就可以

576
00:25:41,820 --> 00:25:43,980
证明您可以进行结构

577
00:25:43,980 --> 00:25:45,720
适应，

578
00:25:45,720 --> 00:25:49,440
而且它更加健壮 你

579
00:25:49,440 --> 00:25:53,100
还可以得到，呃，让我们

580
00:25:53,100 --> 00:25:55,980
与其他无人机有机会相遇吧，

581
00:25:55,980 --> 00:25:58,080
靠近的无人机可以开始

582
00:25:58,080 --> 00:26:00,900
相互通信，当

583
00:26:00,900 --> 00:26:02,760
它们远离时，它们会停止

584
00:26:02,760 --> 00:26:04,860
相互通信，这不是问题，

585
00:26:04,860 --> 00:26:09,240
因为你基本上可以改变

586
00:26:09,240 --> 00:26:11,640
谁改变了

587
00:26:11,640 --> 00:26:13,279
um

588
00:26:13,279 --> 00:26:16,080
节点可以动态地改变它们与谁

589
00:26:16,080 --> 00:26:18,240
通信以及他们想听谁的声音，这就是

590
00:26:18,240 --> 00:26:22,020


591
00:26:22,020 --> 00:26:24,840
数据的工作方式，也是当我们

592
00:26:24,840 --> 00:26:26,700


593
00:26:26,700 --> 00:26:29,820
通过消息传递进行反应式 um 编程区域时它的工作方式，

594
00:26:29,820 --> 00:26:32,760
所以总而言之，

595
00:26:32,760 --> 00:26:35,100
我们感兴趣的是

596
00:26:35,100 --> 00:26:38,900
在主动影响代理中进行自动化推理，

597
00:26:38,900 --> 00:26:42,419
因为这

598
00:26:42,419 --> 00:26:46,260
基本上是一种只适合专家的操作，这种

599
00:26:46,260 --> 00:26:48,779
主动推理技术不会

600
00:26:48,779 --> 00:26:51,240
成功，除非你有更多的

601
00:26:51,240 --> 00:26:54,360
人，呃，让我们将其民主化，我们

602
00:26:54,360 --> 00:26:58,080
让有能力的工程师能够

603
00:26:58,080 --> 00:27:00,600
开发出好的代理 你不必

604
00:27:00,600 --> 00:27:02,640
是世界上顶尖的专家

605
00:27:02,640 --> 00:27:04,679
来开发一个主动推理

606
00:27:04,679 --> 00:27:08,880
代理，现在为了自动化

607
00:27:08,880 --> 00:27:11,400
推理你必须进行消息传递，

608
00:27:11,400 --> 00:27:12,600
我已经讨论过为了提高

609
00:27:12,600 --> 00:27:15,179
效率我也讨论了哪些

610
00:27:15,179 --> 00:27:17,039
消息

611
00:27:17,039 --> 00:27:19,620
不应该传递 你一定要遵循

612
00:27:19,620 --> 00:27:22,919
这个框架，但是受约束的更好的

613
00:27:22,919 --> 00:27:25,919
自由能框架非常方便，

614
00:27:25,919 --> 00:27:27,480
它是一个伞形框架，

615
00:27:27,480 --> 00:27:29,340
基本上，

616
00:27:29,340 --> 00:27:30,179


617
00:27:30,179 --> 00:27:34,340


618
00:27:34,340 --> 00:27:38,760
当 Nas 传递反应性传递时，它涵盖了所有有趣的其他消息传递计算，

619
00:27:38,760 --> 00:27:40,559


620
00:27:40,559 --> 00:27:42,720
它是完全自动化的，所以你不需要

621
00:27:42,720 --> 00:27:44,880


622
00:27:44,880 --> 00:27:48,000
原则上不再编写任何代码了，它来了，你可以进行

623
00:27:48,000 --> 00:27:49,740
并行分布式处理，它对

624
00:27:49,740 --> 00:27:51,539
结构变化很鲁棒，你可以

625
00:27:51,539 --> 00:27:53,880
学习新的推理路径，所以

626
00:27:53,880 --> 00:27:56,340
这里有很多优点，

627
00:27:56,340 --> 00:27:57,659
现在

628
00:27:57,659 --> 00:28:00,120
我们该怎么做，

629
00:28:00,120 --> 00:28:02,520
嗯，我想介绍一个工具箱，

630
00:28:02,520 --> 00:28:05,820
我们一直在研究 RX infer，

631
00:28:05,820 --> 00:28:09,539
我们在荷兰南部埃因霍温大学的实验室就是这么做的，

632
00:28:09,539 --> 00:28:11,520


633
00:28:11,520 --> 00:28:13,260
我们有一个

634
00:28:13,260 --> 00:28:17,059
实验室，这个实验室叫做 bislab，这里有

635
00:28:17,059 --> 00:28:21,059
博士后和助理教授，

636
00:28:21,059 --> 00:28:23,220
博士生们，我们已经在这方面工作了

637
00:28:23,220 --> 00:28:27,419
很多年，其中一些人，

638
00:28:27,419 --> 00:28:28,080


639
00:28:28,080 --> 00:28:31,440
比如 Albert 和 Ismail，谢谢，嗯，我们

640
00:28:31,440 --> 00:28:33,980
写了论文，

641
00:28:33,980 --> 00:28:36,960
我们最好的工作，我们已经将其整合

642
00:28:36,960 --> 00:28:39,059
到一个工具箱中，

643
00:28:39,059 --> 00:28:41,700
这个工具箱被称为 RX 推断，

644
00:28:41,700 --> 00:28:43,740
你可以，如果 你想看看你

645
00:28:43,740 --> 00:28:46,980
可以去网站 archiver.ml

646
00:28:46,980 --> 00:28:50,779
嗯并要求我们的会议以

647
00:28:50,779 --> 00:28:53,159
我刚才讨论的方式工作呃

648
00:28:53,159 --> 00:28:55,679
它确实传递消息它试图最大限度地

649
00:28:55,679 --> 00:28:57,539
减少对更好的自由能的限制

650
00:28:57,539 --> 00:29:00,299
这意味着它可以 想出各种

651
00:29:00,299 --> 00:29:04,020
呃消息传递算法，

652
00:29:04,020 --> 00:29:07,860
嗯，它将以一种反应性的方式做到这一点，

653
00:29:07,860 --> 00:29:10,440
他们会尝试实时、

654
00:29:10,440 --> 00:29:12,419
低功耗地做到这一点，以及我们

655
00:29:12,419 --> 00:29:13,919
现在谈论的所有关键绩效指标，当然还没有

656
00:29:13,919 --> 00:29:18,299
完成，但是 嗯，它很实用，喜欢

657
00:29:18,299 --> 00:29:20,899
展示一些演示，我将把

658
00:29:20,899 --> 00:29:24,059
它留给 Dimitri 和 Bart，他们是

659
00:29:24,059 --> 00:29:27,779
我实验室的两名高级 PC 学生来展示

660
00:29:27,779 --> 00:29:30,320
演示，

661
00:29:30,899 --> 00:29:33,720
所以我将停止

662
00:29:33,720 --> 00:29:36,440
分享

663
00:29:37,500 --> 00:29:42,360
精彩的内容，谢谢你们，很棒的演讲，当然，

664
00:29:42,360 --> 00:29:45,480
呃，你们能听到我的声音吗？ 是的，

665
00:29:45,480 --> 00:29:50,279
好吧，我会尝试分享我的屏幕，好吧，

666
00:29:50,279 --> 00:29:52,559
所以你应该看到它现在

667
00:29:52,559 --> 00:29:54,000
看起来

668
00:29:54,000 --> 00:29:57,600
不错，好吧，所以，大家好，呃，我是

669
00:29:57,600 --> 00:30:00,059
呃 Dimitri bag，所以我是

670
00:30:00,059 --> 00:30:01,740
Bioslap 的博士生，我来自

671
00:30:01,740 --> 00:30:04,320
科技大学 嗯，是的，我有一个

672
00:30:04,320 --> 00:30:06,659
关于实际软件

673
00:30:06,659 --> 00:30:09,240
开发和偏差实验室的小演示，是的，

674
00:30:09,240 --> 00:30:12,240
在过去的几年里，我们显着

675
00:30:12,240 --> 00:30:15,000
改进了我们的工具，

676
00:30:15,000 --> 00:30:17,460
基本上我的整个博士都致力于

677
00:30:17,460 --> 00:30:19,919
实现伯特正在谈论的这个想法，

678
00:30:19,919 --> 00:30:22,380
就像 实现

679
00:30:22,380 --> 00:30:23,940
可能的变分反应消息，

680
00:30:23,940 --> 00:30:25,679
在本演示中，我只是想向

681
00:30:25,679 --> 00:30:28,559
您展示您实际上可以

682
00:30:28,559 --> 00:30:31,799
使用这个理论做什么，

683
00:30:31,799 --> 00:30:35,279
好吧，所以基本上，为了自动化

684
00:30:35,279 --> 00:30:36,659
主动推理，我们需要

685
00:30:36,659 --> 00:30:38,760
自动化贝叶斯影响，我们有

686
00:30:38,760 --> 00:30:40,860
呃我们有 已经有很多解决方案了，

687
00:30:40,860 --> 00:30:44,520
因为我只是 Stan Pyro numpyre，

688
00:30:44,520 --> 00:30:46,740
它是由谷歌互联网资助的，是

689
00:30:46,740 --> 00:30:49,200
由微软图灵资助的，在 7 月份的

690
00:30:49,200 --> 00:30:52,820
IMC 中，还有很多很多所以呃，基本上

691
00:30:52,820 --> 00:30:54,960
这些解决方案真的非常好，

692
00:30:54,960 --> 00:30:56,880
所以呃，他们真的很擅长

693
00:30:56,880 --> 00:31:00,000
原型设计以及我们的目标是

694
00:31:00,000 --> 00:31:02,460
最终能够部署这种

695
00:31:02,460 --> 00:31:05,279
系统，而不仅仅是原型，

696
00:31:05,279 --> 00:31:06,720
我们真正关注的是

697
00:31:06,720 --> 00:31:08,760
这种最终

698
00:31:08,760 --> 00:31:12,299
入侵推理的特定属性，所以它必须是低

699
00:31:12,299 --> 00:31:15,539
功耗自适应实时可扩展的，它

700
00:31:15,539 --> 00:31:17,340
也必须是用户的 最后是友好的，

701
00:31:17,340 --> 00:31:19,559


702
00:31:19,559 --> 00:31:22,760
如果你希望它有用，它必须支持大范围的模型，

703
00:31:22,760 --> 00:31:26,399
所以在偏差实验室，我们希望构建这样一个

704
00:31:26,399 --> 00:31:30,559
具有如此好的属性的软件，

705
00:31:30,559 --> 00:31:33,480
而且它始终与交易者有关，所以

706
00:31:33,480 --> 00:31:35,100
我们在一个方面做得更好 特定

707
00:31:35,100 --> 00:31:37,140
领域，也许还有其他软件

708
00:31:37,140 --> 00:31:39,480
库，它们在不同领域可能会更好，

709
00:31:39,480 --> 00:31:41,520
所以但我们确实

710
00:31:41,520 --> 00:31:44,159
专注于这个特定属性，所以

711
00:31:44,159 --> 00:31:47,039
是的，我会重申

712
00:31:47,039 --> 00:31:48,779
一点最好的演示，所以我们如何

713
00:31:48,779 --> 00:31:50,760
实现这一点，所以我们想象我们有

714
00:31:50,760 --> 00:31:53,520
一个 环境，我们有一个代理，呃，

715
00:31:53,520 --> 00:31:55,020
代理允许采取一些

716
00:31:55,020 --> 00:31:57,720
行动，代理基本上

717
00:31:57,720 --> 00:32:00,480
需要的是为其环境提出某种

718
00:32:00,480 --> 00:32:02,580
足够好的概率模型，

719
00:32:02,580 --> 00:32:03,779


720
00:32:03,779 --> 00:32:06,600
以便进行耐心推理，

721
00:32:06,600 --> 00:32:09,360
呃，在我们的框架中，我们编码 该

722
00:32:09,360 --> 00:32:11,520
模型作为因子图，不仅对

723
00:32:11,520 --> 00:32:15,000
观察结果进行建模，还对行动

724
00:32:15,000 --> 00:32:17,539
和期望的未来进行建模，

725
00:32:17,539 --> 00:32:20,820
这种方法允许我们将

726
00:32:20,820 --> 00:32:23,279


727
00:32:23,279 --> 00:32:26,460
变量和隐藏状态之间的复杂关系分解为

728
00:32:26,460 --> 00:32:28,919
某种结构和局部块，

729
00:32:28,919 --> 00:32:31,440
呃，它不是一个块 它不再是一个

730
00:32:31,440 --> 00:32:34,679
黑匣子，所以呃，模型本身

731
00:32:34,679 --> 00:32:36,120
可能有某种背景

732
00:32:36,120 --> 00:32:39,419
动机解释，它可能会编码

733
00:32:39,419 --> 00:32:41,340
你关于某些

734
00:32:41,340 --> 00:32:43,200
特定物理系统的先验知识，

735
00:32:43,200 --> 00:32:46,559
呃，这些块的局部性

736
00:32:46,559 --> 00:32:49,080
基本上允许你扩展到

737
00:32:49,080 --> 00:32:50,880
数百万个变量和隐藏状态

738
00:32:50,880 --> 00:32:53,399
它允许您预先优化它，

739
00:32:53,399 --> 00:32:55,520
或者可能在不同的地方使用某种不同的

740
00:32:55,520 --> 00:32:57,659
近似策略，

741
00:32:57,659 --> 00:33:01,440
所以它也允许很多非常

742
00:33:01,440 --> 00:33:03,600
好的属性，

743
00:33:03,600 --> 00:33:06,480
并且我们使用反应式消息传递来

744
00:33:06,480 --> 00:33:08,159
运行实际的变分版本

745
00:33:08,159 --> 00:33:11,279
推理，它使用反应式

746
00:33:11,279 --> 00:33:13,140
在幕后编程以最小化

747
00:33:13,140 --> 00:33:14,700


748
00:33:14,700 --> 00:33:17,820
能量变化的近似值，是的，正如 berdos 提到的，

749
00:33:17,820 --> 00:33:22,399
它与参与者模型

750
00:33:22,399 --> 00:33:26,039
和基本上间接传输非常相关，你可以将

751
00:33:26,039 --> 00:33:28,380
不同的节点视为参与者

752
00:33:28,380 --> 00:33:29,760
本身，

753
00:33:29,760 --> 00:33:32,460
呃，所以它们基本上有一个

754
00:33:32,460 --> 00:33:34,620
目的是 发送一条使能量最小化的变分消息，

755
00:33:34,620 --> 00:33:36,539


756
00:33:36,539 --> 00:33:38,760
呃，这是一个非常简短且非常

757
00:33:38,760 --> 00:33:40,799
高级的描述，但它本质上就是

758
00:33:40,799 --> 00:33:44,519
正在发生的事情，所以我们不会将彼此

759
00:33:44,519 --> 00:33:47,580
交互的不同代理视为

760
00:33:47,580 --> 00:33:49,980
参与者，但我们也将

761
00:33:49,980 --> 00:33:52,260
其实际组成部分视为

762
00:33:52,260 --> 00:33:54,779
底层模型作为参与者本身，

763
00:33:54,779 --> 00:33:57,000
就像一个非常分层的结构，

764
00:33:57,000 --> 00:34:01,260
所以这是这个推理的主要中心思想，

765
00:34:01,260 --> 00:34:03,600


766
00:34:03,600 --> 00:34:06,840
所以这里是第一个例子，

767
00:34:06,840 --> 00:34:08,879
我们可以在动态系统中进行推理

768
00:34:08,879 --> 00:34:11,760
，我认为这个例子已经很

769
00:34:11,760 --> 00:34:13,619
老了 就像

770
00:34:13,619 --> 00:34:16,679
两年前一样，我们跟踪物体的位置，

771
00:34:16,679 --> 00:34:18,359
给出一些噪声测量值，这些测量值由

772
00:34:18,359 --> 00:34:22,379
绿点表示，

773
00:34:22,379 --> 00:34:24,899
我们无法观察到它的实际信号，

774
00:34:24,899 --> 00:34:27,540
但我们可以绘制它，呃 estron 是

775
00:34:27,540 --> 00:34:30,000
蓝色的，反转信号显示为

776
00:34:30,000 --> 00:34:32,699
红色 并且数据集是无限的

777
00:34:32,699 --> 00:34:34,739
推论，只是对其做出反应，并且

778
00:34:34,739 --> 00:34:37,159
不会假设任何特定的数据大小，只是

779
00:34:37,159 --> 00:34:39,359
尽快在您的观察中做出反应

780
00:34:39,359 --> 00:34:40,619


781
00:34:40,619 --> 00:34:42,719
呃是的，我实际上不确定

782
00:34:42,719 --> 00:34:46,080
Zoom 共享我的屏幕有多顺利呃也许

783
00:34:46,080 --> 00:34:48,239
你可以看到 它在动画中有点滞后，

784
00:34:48,239 --> 00:34:49,980
我不确定，因为

785
00:34:49,980 --> 00:34:51,899
Zoom 可能不会以全帧速率共享它，

786
00:34:51,899 --> 00:34:53,280


787
00:34:53,280 --> 00:34:55,260
而且在右侧，您

788
00:34:55,260 --> 00:34:58,500
可以看到我们如何定义模型，在我们的

789
00:34:58,500 --> 00:35:00,240
框架中，我们使用珠宝作为

790
00:35:00,240 --> 00:35:01,880
编程语言

791
00:35:01,880 --> 00:35:04,619
所以基本上这就是

792
00:35:04,619 --> 00:35:06,180
定义这个特定模型

793
00:35:06,180 --> 00:35:09,240
并在数据集上运行推理所需的一切，

794
00:35:09,240 --> 00:35:11,820
实际上我喜欢花更多的时间

795
00:35:11,820 --> 00:35:14,760
来绘制它而不是在法国，所以

796
00:35:14,760 --> 00:35:17,280
推理是一个简单的最容易的部分，

797
00:35:17,280 --> 00:35:19,680
因为接近是很多 更难

798
00:35:19,680 --> 00:35:22,520
与用户友好性相关，

799
00:35:22,520 --> 00:35:25,560
所以我们实际上有计划改进

800
00:35:25,560 --> 00:35:28,020
我们的模型规范语言，使其变得

801
00:35:28,020 --> 00:35:30,119
更加容易，所以现在出于技术原因，

802
00:35:30,119 --> 00:35:32,760
我们有一些辅助语句和

803
00:35:32,760 --> 00:35:34,859
模型规范语言，但我们正在

804
00:35:34,859 --> 00:35:38,339
努力改进它，使其变得更加

805
00:35:38,339 --> 00:35:39,960
容易，

806
00:35:39,960 --> 00:35:41,280
呃

807
00:35:41,280 --> 00:35:43,619
这是 另一个例子

808
00:35:43,619 --> 00:35:45,960
与前一个类似，但使用了更

809
00:35:45,960 --> 00:35:48,119
复杂和线性的

810
00:35:48,119 --> 00:35:50,520
双摆动力系统，该系统是

811
00:35:50,520 --> 00:35:53,760
混乱的，我们可以在它的这一小部分上观察到

812
00:35:53,760 --> 00:35:56,460
很多噪音，也表示

813
00:35:56,460 --> 00:35:58,020
为绿点，

814
00:35:58,020 --> 00:36:00,800
呃，尽管如此 给

815
00:36:00,800 --> 00:36:04,260
定足够好的模型呃，你可以以

816
00:36:04,260 --> 00:36:06,839
相当高的精度推断出其他隐藏状态，

817
00:36:06,839 --> 00:36:10,320
并且所需的代码

818
00:36:10,320 --> 00:36:15,380
也相对较短，是的，

819
00:36:15,480 --> 00:36:19,200
我们还有呃示例，其中包含与环境

820
00:36:19,200 --> 00:36:21,359
交互的主动推理代理

821
00:36:21,359 --> 00:36:22,800


822
00:36:22,800 --> 00:36:25,380
呃所以左边呃

823
00:36:25,380 --> 00:36:29,460
它是 左边显示了呃是的山

824
00:36:29,460 --> 00:36:32,220
曲线问题非常著名的问题

825
00:36:32,220 --> 00:36:34,200
左下侧显示了一个主动

826
00:36:34,200 --> 00:36:36,599
推理代理，它试图控制倒立摆

827
00:36:36,599 --> 00:36:39,300
在有

828
00:36:39,300 --> 00:36:42,780
风的条件下掉落轨道和风

829
00:36:42,780 --> 00:36:44,760
我们还有一个控制摆的代理的演示

830
00:36:44,760 --> 00:36:47,520
一个不断变化的

831
00:36:47,520 --> 00:36:50,640
环境，所以在右侧你会看到

832
00:36:50,640 --> 00:36:52,560
一个带有引擎的钟摆，

833
00:36:52,560 --> 00:36:54,900
引擎的功率有限，

834
00:36:54,900 --> 00:36:57,780
代理本身需要达到

835
00:36:57,780 --> 00:36:59,940
目标，目标被指示为红色

836
00:36:59,940 --> 00:37:02,240
圆圈，所以

837
00:37:02,240 --> 00:37:04,740
基本上在这个演示中我们 可以

838
00:37:04,740 --> 00:37:06,599
实时改变环境并查看

839
00:37:06,599 --> 00:37:08,760
代理如何反应，这样您就可以改变

840
00:37:08,760 --> 00:37:11,099
其俚语上的摆质量来

841
00:37:11,099 --> 00:37:13,980
测量测量中的噪音量，或者

842
00:37:13,980 --> 00:37:15,780
我们可以改变目标，我们可以改变

843
00:37:15,780 --> 00:37:18,300
最大发动机功率等等，以便

844
00:37:18,300 --> 00:37:20,700
代理 仍然会尝试推断最佳

845
00:37:20,700 --> 00:37:23,220
可能的行动方案以

846
00:37:23,220 --> 00:37:25,800
达到其目标，并且它永远不会停止

847
00:37:25,800 --> 00:37:28,079
反应，

848
00:37:28,079 --> 00:37:30,440
嗯，它实际上也有可能

849
00:37:30,440 --> 00:37:33,960
限制古老的力量，这样它就

850
00:37:33,960 --> 00:37:36,180
不再可能正确地达到目标，

851
00:37:36,180 --> 00:37:39,320
但智能体会 仍然尝试

852
00:37:39,320 --> 00:37:42,960
呃，我们还有其他很酷的演示，具有智能

853
00:37:42,960 --> 00:37:46,380
导航和避免碰撞呃，这些演示

854
00:37:46,380 --> 00:37:48,119
仍在积极研究中，

855
00:37:48,119 --> 00:37:50,160
并且它们的代码尚未公开，

856
00:37:50,160 --> 00:37:52,260
很快就会发布，但

857
00:37:52,260 --> 00:37:55,380
例如在这个例子中，我们可以用

858
00:37:55,380 --> 00:37:57,240
它们定义一组代理

859
00:37:57,240 --> 00:37:59,460
边界和一组

860
00:37:59,460 --> 00:38:02,640
目的地，因此我们可以看到他们如何

861
00:38:02,640 --> 00:38:06,540
尝试一起解决其根源，

862
00:38:06,540 --> 00:38:07,200
嗯，

863
00:38:07,200 --> 00:38:10,079
我们可以在地图中设置一些静态障碍，

864
00:38:10,079 --> 00:38:13,020
我们可以看到智能体如何找到

865
00:38:13,020 --> 00:38:15,839
最佳路径

866
00:38:15,839 --> 00:38:18,839
以实现其目标 避免

867
00:38:18,839 --> 00:38:21,320
任何可能的碰撞

868
00:38:21,320 --> 00:38:23,940
，也没有必要有

869
00:38:23,940 --> 00:38:27,119
静态障碍物，因为障碍物

870
00:38:27,119 --> 00:38:30,000
本身可能会移动，所以在这个演示中，我们

871
00:38:30,000 --> 00:38:32,820
有数百个代理在障碍物

872
00:38:32,820 --> 00:38:35,099
地图中导航，这些障碍物

873
00:38:35,099 --> 00:38:37,140
从下到上移动到圆圈或

874
00:38:37,140 --> 00:38:40,260
描绘了障碍物和代理 作为

875
00:38:40,260 --> 00:38:42,900
小点，它们需要从左到右

876
00:38:42,900 --> 00:38:45,240
基本上避免任何类型的

877
00:38:45,240 --> 00:38:47,220
污染

878
00:38:47,220 --> 00:38:50,820
呃，正如我也提到的，我们希望

879
00:38:50,820 --> 00:38:52,740
执行高效和实时的

880
00:38:52,740 --> 00:38:55,260
推理，但我们也像低

881
00:38:55,260 --> 00:38:57,900
功耗低性能呃在低

882
00:38:57,900 --> 00:39:00,180
性能设备上那样做 以 Raspberry Pi

883
00:39:00,180 --> 00:39:03,300
或 Coolpy 为例，我们在 Cool Pi 上

884
00:39:03,300 --> 00:39:05,820
成功运行

885
00:39:05,820 --> 00:39:07,500
贝叶斯音频源分离取得了一些结果，

886
00:39:07,500 --> 00:39:10,079
因此实际上

887
00:39:10,079 --> 00:39:13,440
我们也可能运行主动，我们尝试

888
00:39:13,440 --> 00:39:16,260
也在 Coolpy 上运行主动推理代理，

889
00:39:16,260 --> 00:39:20,040
因此 前面提到的倒立

890
00:39:20,040 --> 00:39:21,440
摆

891
00:39:21,440 --> 00:39:23,160
，

892
00:39:23,160 --> 00:39:25,079
正如我提到的，

893
00:39:25,079 --> 00:39:29,220
我们还需要有一个大的模型范围，

894
00:39:29,220 --> 00:39:31,980
基本上 RX 推断并没有被

895
00:39:31,980 --> 00:39:33,960
设计来解决任何

896
00:39:33,960 --> 00:39:36,599
上述问题，具体来说，

897
00:39:36,599 --> 00:39:38,520


898
00:39:38,520 --> 00:39:40,980
我们的存储库中有大量不同的示例，不同的模型，

899
00:39:40,980 --> 00:39:42,300
不同的数据，不同的

900
00:39:42,300 --> 00:39:44,040
影响约束

901
00:39:44,040 --> 00:39:46,380
呃，我们有线性回归的例子，

902
00:39:46,380 --> 00:39:48,060
隐藏马尔可夫模型，自动

903
00:39:48,060 --> 00:39:50,640
回归模型，层次结构模型，混合模型，

904
00:39:50,640 --> 00:39:53,520
高斯过程等等，所以

905
00:39:53,520 --> 00:39:56,760
这种方法非常通用，

906
00:39:56,760 --> 00:40:00,060
例如，如果

907
00:40:00,060 --> 00:40:02,880
你将它与

908
00:40:02,880 --> 00:40:05,220
传统的软件库进行比较，

909
00:40:05,220 --> 00:40:07,200
你可以让我们 说有一个解决

910
00:40:07,200 --> 00:40:09,060
通用过滤器的库可能是一个非常好的

911
00:40:09,060 --> 00:40:11,579
库也许超级快具有顶级

912
00:40:11,579 --> 00:40:13,920
性能工作得很好并且非常

913
00:40:13,920 --> 00:40:15,119
可靠

914
00:40:15,119 --> 00:40:17,820
呃它非常好但是你

915
00:40:17,820 --> 00:40:20,460
受到这个特定模型

916
00:40:20,460 --> 00:40:22,859
通用过滤权的限制并且你不能

917
00:40:22,859 --> 00:40:25,400
真正改变

918
00:40:25,400 --> 00:40:29,240
我们可以自由地定义我们自己的模型，

919
00:40:29,240 --> 00:40:31,800
我们可以很容易地

920
00:40:31,800 --> 00:40:33,720
定义一个模型，该模型本质

921
00:40:33,720 --> 00:40:36,599
上与通用过滤

922
00:40:36,599 --> 00:40:38,700
方程等效，因此基本上在

923
00:40:38,700 --> 00:40:40,500
我之前展示的有关对象

924
00:40:40,500 --> 00:40:42,839
跟踪的演示中，它本质上是一个通用

925
00:40:42,839 --> 00:40:43,980
过滤器

926
00:40:43,980 --> 00:40:47,160
是用概率模型编写的，

927
00:40:47,160 --> 00:40:49,140


928
00:40:49,140 --> 00:40:52,200
嗯，是的，这是我对

929
00:40:52,200 --> 00:40:55,079
本演示文稿的一点补充，因此我们的软件是

930
00:40:55,079 --> 00:40:57,960
免费的，它是 MIT 许可证，并且

931
00:40:57,960 --> 00:41:00,240
在 GitHub 上提供开源代码，

932
00:41:00,240 --> 00:41:03,540
嗯，是的，我们会很高兴能够在

933
00:41:03,540 --> 00:41:05,400
我们的地方进行演示 我很

934
00:41:05,400 --> 00:41:09,920
乐意回答任何问题，谢谢，

935
00:41:12,180 --> 00:41:14,960


936
00:41:15,000 --> 00:41:17,700
太棒了，好吧，我只是在聊天中问一个简单的

937
00:41:17,700 --> 00:41:19,980
问题，

938
00:41:19,980 --> 00:41:22,619
马可问

939
00:41:22,619 --> 00:41:24,900
抱歉，如果我错过了，这是

940
00:41:24,900 --> 00:41:27,540
避免碰撞的演示，实时适应

941
00:41:27,540 --> 00:41:29,220
其他代理行为，还是

942
00:41:29,220 --> 00:41:32,720
集体预先计算的 路径

943
00:41:33,240 --> 00:41:35,880
嗯，所以基本上它们不是呃超级

944
00:41:35,880 --> 00:41:38,099
实时，它们

945
00:41:38,099 --> 00:41:39,839
计算这条路径的速度很快，但可能五秒

946
00:41:39,839 --> 00:41:42,599
左右，但我们基本上正在努力

947
00:41:42,599 --> 00:41:44,820
使其实时，所以我们知道问题是什么，

948
00:41:44,820 --> 00:41:47,460
我们知道在哪里改进

949
00:41:47,460 --> 00:41:50,339
我们会让它感觉很糟糕是的，

950
00:41:50,339 --> 00:41:53,400
几乎就像

951
00:41:53,400 --> 00:41:55,440
下一个问题，你是否有一些

952
00:41:55,440 --> 00:41:57,960
与其他方法的比较数据，

953
00:41:57,960 --> 00:42:00,000
更一般地说，什么类型的

954
00:42:00,000 --> 00:42:02,520
基准，或者当你

955
00:42:02,520 --> 00:42:04,619
在不同的环境中与行业交谈时，

956
00:42:04,619 --> 00:42:07,800
人们喜欢寻找那个杀手？

957
00:42:07,800 --> 00:42:09,599
主动推理的应用程序或者他们正在

958
00:42:09,599 --> 00:42:13,920
寻找什么关键措施

959
00:42:13,920 --> 00:42:16,260
呃所以我个人有一篇

960
00:42:16,260 --> 00:42:19,200
关于与基于采样的

961
00:42:19,200 --> 00:42:23,220
方法（如 HMC）进行比较的大论文，而且在我的博士

962
00:42:23,220 --> 00:42:25,079
论文中，如果不是其他基于采样的方法，也会有一个比较

963
00:42:25,079 --> 00:42:29,280


964
00:42:29,280 --> 00:42:31,680
长话短说，基于采样的方法

965
00:42:31,680 --> 00:42:33,900
无法

966
00:42:33,900 --> 00:42:36,119
真正实时运行这种复杂的推理，

967
00:42:36,119 --> 00:42:38,640
它们非常耗时，它们

968
00:42:38,640 --> 00:42:40,740
不能很好地扩展到大问题，

969
00:42:40,740 --> 00:42:42,420
而这是主动影响所真正需要的，

970
00:42:42,420 --> 00:42:44,400
因为如果你有一个

971
00:42:44,400 --> 00:42:46,560
大环境 非常复杂，你

972
00:42:46,560 --> 00:42:49,619


973
00:42:49,619 --> 00:42:53,940
的模型中会有很多未知变量，所以是的，

974
00:42:53,940 --> 00:42:56,520
有一篇论文进行了比较，

975
00:42:56,520 --> 00:42:58,380
基本上我们表明，是的，我们的方法

976
00:42:58,380 --> 00:43:01,859
扩展得更好，所以我个人只

977
00:43:01,859 --> 00:43:05,180
在普通的 MacBook 笔记本电脑上运行

978
00:43:05,180 --> 00:43:08,660
运行具有 200 万个

979
00:43:08,660 --> 00:43:12,060
未知变量的模型，速度相当

980
00:43:12,060 --> 00:43:15,240
快，然后如果

981
00:43:15,240 --> 00:43:17,760
基于采样的方法，您可能会

982
00:43:17,760 --> 00:43:19,980
发现自己处于具有大约 100 个变量的模型中，

983
00:43:19,980 --> 00:43:21,780
然后您等待两个

984
00:43:21,780 --> 00:43:24,300
小时左右，然后它就变成了

985
00:43:24,300 --> 00:43:28,020
发现你的链没有收敛，所以呃

986
00:43:28,020 --> 00:43:30,980
或者类似的事情

987
00:43:31,980 --> 00:43:34,560
很酷是的，嗯，人们在聊天中评论，

988
00:43:34,560 --> 00:43:37,500
比如消息传递

989
00:43:37,500 --> 00:43:41,040
和因子图已经走了多远，所以对于

990
00:43:41,040 --> 00:43:43,380
偏差实验室和 Bert 来说，我们

991
00:43:43,380 --> 00:43:44,520
绝对

992
00:43:44,520 --> 00:43:46,680
欣赏这条令人兴奋的路线

993
00:43:46,680 --> 00:43:48,420
研究我的意思是那里有很多东西要学

994
00:43:48,420 --> 00:43:50,400
，有时看看

995
00:43:50,400 --> 00:43:52,440
方程式，它看起来就像是

996
00:43:52,440 --> 00:43:54,720
写在石头上的，只是

997
00:43:54,720 --> 00:43:56,400
开始和结束，你知道

998
00:43:56,400 --> 00:43:59,099
变分自由能，但在你的

999
00:43:59,099 --> 00:44:00,720
演示中，你真的表现得像

1000
00:44:00,720 --> 00:44:04,020
不，我们是动手实践，这就是我们

1001
00:44:04,020 --> 00:44:06,180
获得可解释性的地方，模块化

1002
00:44:06,180 --> 00:44:08,700
是它真正实现的地方，这

1003
00:44:08,700 --> 00:44:11,400
就像一个信息物流

1004
00:44:11,400 --> 00:44:13,800
挑战，它不像一个深奥的

1005
00:44:13,800 --> 00:44:16,980
哲学问题，不，

1006
00:44:16,980 --> 00:44:19,800
不，确实，我的意思是

1007
00:44:19,800 --> 00:44:22,859
我应该说，呃 我的意思是

1008
00:44:22,859 --> 00:44:25,619
我们不是天才，所以我们的实验室

1009
00:44:25,619 --> 00:44:28,200
已经存在了八年多了，你

1010
00:44:28,200 --> 00:44:30,119
看到实验室里的所有人，我们花了

1011
00:44:30,119 --> 00:44:33,060
很多很多年的时间，有很多

1012
00:44:33,060 --> 00:44:35,700
错误的方向，才让它达到

1013
00:44:35,700 --> 00:44:38,359
现在的水平 所以这是一条很长的路，

1014
00:44:38,359 --> 00:44:42,060
但目前我非常

1015
00:44:42,060 --> 00:44:44,640
有信心在未来的某个时候，

1016
00:44:44,640 --> 00:44:47,339
我

1017
00:44:47,339 --> 00:44:48,839
不想在三个月或一年内说，

1018
00:44:48,839 --> 00:44:52,440
但我们 将能够编写一个

1019
00:44:52,440 --> 00:44:54,780
工具箱，允许人们设计

1020
00:44:54,780 --> 00:44:56,700
一个生成模型，只需按一个

1021
00:44:56,700 --> 00:44:59,040
按钮，然后忘记

1022
00:44:59,040 --> 00:45:00,420
影响，您不必再担心

1023
00:45:00,420 --> 00:45:02,400
婴儿了，它将是

1024
00:45:02,400 --> 00:45:05,520
快速和自动化的，这将会发生，

1025
00:45:05,520 --> 00:45:07,400
它将发生 几年内就会发生，

1026
00:45:07,400 --> 00:45:10,500
呃，也许其他人会

1027
00:45:10,500 --> 00:45:12,839
编写一个更好的工具箱，但我

1028
00:45:12,839 --> 00:45:14,960
非常有信心，即使我们的工具箱

1029
00:45:14,960 --> 00:45:18,300
也能够做到这一点，所以

1030
00:45:18,300 --> 00:45:21,240
嗯，我认为是的，你知道人们

1031
00:45:21,240 --> 00:45:24,780
谈论呃，所以为什么不' 如果

1032
00:45:24,780 --> 00:45:26,280
深度学习和生成人工智能的成功是

1033
00:45:26,280 --> 00:45:29,280


1034
00:45:29,280 --> 00:45:32,099
由于

1035
00:45:32,099 --> 00:45:34,640
大数据大计算机和工具箱

1036
00:45:34,640 --> 00:45:38,280
张量流的大数据可用性以及我们

1037
00:45:38,280 --> 00:45:40,740
不需要大数据的所有成功，因为代理

1038
00:45:40,740 --> 00:45:42,839
收集自己的数据，那么我们就已经取得了成功。 或者在

1039
00:45:42,839 --> 00:45:45,119
过滤器中，我们不需要大型计算机

1040
00:45:45,119 --> 00:45:47,700
主动兴趣代理，

1041
00:45:47,700 --> 00:45:49,920
您知道他们管理自己的电力

1042
00:45:49,920 --> 00:45:51,119
资源，

1043
00:45:51,119 --> 00:45:53,099
但我们需要一个非常好的工具箱，

1044
00:45:53,099 --> 00:45:54,980
因为

1045
00:45:54,980 --> 00:45:57,300
编程和主动推理代理手动编程的

1046
00:45:57,300 --> 00:45:59,280
影响是

1047
00:45:59,280 --> 00:46:00,599
不可行的，

1048
00:46:00,599 --> 00:46:04,140
所以我们需要一个非常好的工具箱

1049
00:46:04,140 --> 00:46:06,300
真正实现自动化的工具箱，

1050
00:46:06,300 --> 00:46:08,160
我们希望

1051
00:46:08,160 --> 00:46:10,140
我们的示例将是最先

1052
00:46:10,140 --> 00:46:13,140
做到这一点的两个盒子之一，我相信其他

1053
00:46:13,140 --> 00:46:15,720
人也将致力于它，

1054
00:46:15,720 --> 00:46:18,480
并且将会出现更好的工具箱，

1055
00:46:18,480 --> 00:46:20,839
但我认为乐观的

1056
00:46:20,839 --> 00:46:24,300
消息是 这将会发生，呃，

1057
00:46:24,300 --> 00:46:26,760
一旦我们有了这样的工具箱，

1058
00:46:26,760 --> 00:46:28,859
那么我们实际上可以让一个大社区

1059
00:46:28,859 --> 00:46:31,260
开始构建代理，我们实际上可以

1060
00:46:31,260 --> 00:46:32,579


1061
00:46:32,579 --> 00:46:33,960


1062
00:46:33,960 --> 00:46:36,180
在现场展示可部署代理，

1063
00:46:36,180 --> 00:46:38,339
它们可以工作，而且比加固浮动代理工作得更好

1064
00:46:38,339 --> 00:46:40,260
或者无论

1065
00:46:40,260 --> 00:46:42,780
什么，

1066
00:46:42,780 --> 00:46:44,940
嗯，所以我认为这是一个非常

1067
00:46:44,940 --> 00:46:48,240
积极和充满希望的信息，

1068
00:46:48,240 --> 00:46:50,160
这就是我们所期望的，这就是

1069
00:46:50,160 --> 00:46:52,980


1070
00:46:52,980 --> 00:46:57,560


1071
00:46:59,280 --> 00:47:01,260


1072
00:47:01,260 --> 00:47:03,839
我们更喜欢的 很高兴呃很好得到

1073
00:47:03,839 --> 00:47:07,020
这个机会，呃是的我想呃

1074
00:47:07,020 --> 00:47:09,420
所以是的嗯

1075
00:47:09,420 --> 00:47:13,440
每个人都可以下载这个工具箱嗯

1076
00:47:13,440 --> 00:47:15,960
我认为你现在仍然

1077
00:47:15,960 --> 00:47:18,599
应该是一个使用该工具箱的程序员

1078
00:47:18,599 --> 00:47:19,680


1079
00:47:19,680 --> 00:47:22,500
，我希望你很友好，因为你

1080
00:47:22,500 --> 00:47:25,800
知道它还没有完全按照

1081
00:47:25,800 --> 00:47:27,960
我们想要的方式完善，但它即将到来，它将

1082
00:47:27,960 --> 00:47:30,119
在明年推出，

1083
00:47:30,119 --> 00:47:31,800
将会有一个很好的工具箱供几乎

1084
00:47:31,800 --> 00:47:34,260
每个人使用，但有兴趣的人，

1085
00:47:34,260 --> 00:47:35,640


1086
00:47:35,640 --> 00:47:37,680
甚至有兴趣

1087
00:47:37,680 --> 00:47:39,480
在这里购买平板的人，我们 博士生有空缺

1088
00:47:39,480 --> 00:47:43,500
职位，所以

1089
00:47:43,500 --> 00:47:47,099
我们很高兴收到有

1090
00:47:47,099 --> 00:47:48,900
兴趣与我们合作的人发来的电子邮件，

1091
00:47:48,900 --> 00:47:52,040


1092
00:47:52,619 --> 00:47:56,599
谢谢迪米特里，结束语中的任何内容

1093
00:47:56,640 --> 00:47:59,400
不仅如此，再次感谢您，是的，有

1094
00:47:59,400 --> 00:48:01,560
机会展示超级好的作品

1095
00:48:01,560 --> 00:48:03,000


1096
00:48:03,000 --> 00:48:05,460
很酷，是的，今年晚些时候我们将

1097
00:48:05,460 --> 00:48:08,940
讨论您最近的两部分工作，

1098
00:48:08,940 --> 00:48:11,400
因此我们将深入探讨

1099
00:48:11,400 --> 00:48:14,579
细节，我希望

1100
00:48:14,579 --> 00:48:16,260
生态系统中的研究所的人们

1101
00:48:16,260 --> 00:48:19,319
会感到兴奋 我们都很

1102
00:48:19,319 --> 00:48:24,319
感谢你，好的，谢谢你，再见，好的，

1103
00:48:32,940 --> 00:48:35,720


1104
00:48:37,260 --> 00:48:40,040
好的，

1105
00:48:43,200 --> 00:48:46,079
下一个间隔

1106
00:48:46,079 --> 00:48:48,680
我们是

