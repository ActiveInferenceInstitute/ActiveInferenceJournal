SPEAKER_00:
Alright, hey everyone, it's October 24th, 23, and we're in our second discussion of Chapter 8 in Cohort 4.

So, we can do any number of things, but does anyone want to begin with any thoughts on Chapter 8?

We can look over past notes.

We can look at the extant questions.

We can hear any new questions.

We can look at the text.


SPEAKER_01:
Yeah, we have a very simple question.

In the continuous case, is there some kind of standard code to use to try modeling?

I mean, to test some very simple models as there is for the discrete case with the SPM framework?


SPEAKER_00:
That's a very good question.

I'll give my thought, just it may not be fully accurate.

In the MATLAB, SPM-based and Python, PyMDP-based code, there's been an emphasis on the discrete modeling.

In the Rx and Fur Julia package, I believe that there's a lot more continuous time models.


SPEAKER_02:
Okay.


SPEAKER_00:
So I'm not offhand familiar with any continuous time implementations.

We can look at the implementations table that we have.

Eventually, I'd love to see these repositories, of course, expand and grow, but also annotated.

with different features of the model.

So then we could filter and say, I'm looking for this language, continuous time, hierarchical model, but almost all of the Python that I've seen was discreet.


SPEAKER_02:
Okay.


SPEAKER_00:
Any other random thoughts or questions?

Otherwise, we can look at some popular questions.

And look at the notes.

Does anyone have any

just even from outside of active inference thoughts on continuous and discrete time anything with digital and analog do we see one of them as being the general case of the other or do they both derive from a point

Wangshan?


SPEAKER_02:
Yes, Daniel.

I'm just wondering, what is the fundamental difference between continuous time model and discrete time model?

Is that the fundamental difference is in terms of the state transition?

In the continuous model, it's represented as a differential equation.

And in the dynamic model, in the discrete model, it's expressed as a kind of a difference.


SPEAKER_00:
Great question.

Does anyone have a thought on this?


SPEAKER_02:
Yeah.

Here, what does continuous mean?

Continuous in time or continuous in the state space?

uh or refer to both i suppose it you know mostly means it means the continuous scene in time right now um does anyone want to give a thought on this


SPEAKER_00:
Yes, it is referring to the treatment of time.

So here in figure 4-3, we have basically chapter 7 and chapter 8 laid out.

In the discrete time setting, then let's talk about what's the same first.

Broadly, their architecture is the same.

That's why they're being laid out this way.

What else is the same?

Priors are set the same way.

similarly enough d and also the upstairs the policy selection apparatus is broadly the same we're still dealing with free energy based policy selection mechanics um also what's the same is the hidden state to observable mapping the partially observable setting with two so

really what's different is kind of like the core of the horizon here in the discrete time setting we have explicit hidden state um or external state um calculations at given time points t minus one t t plus one right those themselves as you pointed out could be continuous

So that could be like a number between zero and one.

Um, but we're estimating that at 1 PM, 2 PM, 3 PM, 4 PM.

Right.

So, and then, um, in the continuous time setting, we only are keeping an explicit prediction of the hidden state at the current moments X.

And then we're dealing with the past and the future with a Taylor series expansion, also known as the generalized coordinates.

So here, whereas B plays the role of a Markov transition matrix in the discrete time model and has a kind of straightforward interpretation where you have the hidden state at a given time, you multiply it by the B, and then you basically transition into the next state.

right the analogous role in the continuous time setting is a temporal derivative right and so we're extending out a Taylor series which technically goes forever usually the accuracy of a Taylor series expansion begins to drop off quite rapidly unless it's a repetitive signal um

So then in the continuous time setting, I guess you could have a discrete state space.

Like, you know, the light switch is either on or off.

And we're going to have a model that's continuous in time of being on or off.

that doesn't mean it's the best way but it's definitely a good point that you're raising which is that the treatment of time has a um very strong bearing on the semantics of the generative model whereas whether a given variable like an observation or a hidden state

is itself continuous or discrete is a little bit of a smaller difference this this figure 4.3 okay yeah um um yeah a question to continue sorry one chance are you are you done


SPEAKER_01:
No, no, no, go ahead.

Go ahead.

Okay.

Oh yeah.

So, uh, to go on on this, uh, in the discrete time, um, in the implementation, uh, within each step, there is some kind of continuous updating of the neural activity associated with all the states.

Um, so.


SPEAKER_00:
uh you know how does that uh go in this picture yeah this is also a very good question like the the this kind of interpolative yeah continuous dynamical component that seems to be extraneous or

it's unclear if it's purely interpolative, like if a calculation is being done here, here, here, and here, and then it just being like kind of like spline fit, or rather if there is a continuous time differential equation or something, but then if there was a exact concordance,

of the discrete time and some differential equation solving underneath why wouldn't we just focus on that concordance i don't know if this is accessory code inside of spm uh i mean that's linked to the to the message passing within each step


SPEAKER_01:
So within each step, you know, if you have, for example, I mean, usually they use 16 steps to implement the message passing.

And you will have this differential equation implemented as, you know, 16 different updates in a discretization of...


SPEAKER_00:
okay so then would we say that this is truly a continuous time interpolation or is it just that we're doing like 16 with we're treating each time step in the discrete model as like an Epoch and then having 16 kind of adjustment steps within the cheaper yeah the later is my understanding yeah so it could be

so that they're well neurobiologically they analogize this to the local field potentials which is like a EEG recording but just statistically the rate of change of log expectations so using message passing they can continue to run message passing

Okay, well, let's assume the trivial case, which is the variable is already exactly update.

It's already at its stationary state.

So new irrelevant information comes in.

Then whether you message passed one time or a million times, it wouldn't really matter.


UNKNOWN:
Right.


SPEAKER_00:
contrast there might be a situation which is going to be more prevalent where there is some amount of bayesian updating that needs to occur um the whole point of using free energy is that we're able to approach problems that we can't do one step exact bays on we have something that's incrementally optimizable

through message passing with free energy minimization.

So then how many rounds of message passing do you have to do?

Well, one approach is when the rate of change of free energy or the rate of change of log expectations is low,

Um, or sometimes I've seen when like the overall Delta is small, like just when round after round, we're getting small updates, but, but both of those ha have a degree of freedom because maybe you could continue in that slow regime for a long time, just like any, uh, model.

So they're doing multiple message passing rounds.

have you run the code to to reproduce 7.13 uh not this one no okay yeah I think that would be helpful to see because other even still like does it message pass up to here and then it goes down to there and is that 0.2 or is two


SPEAKER_01:
well I would I would say that for each I mean each step is composed of three steps here uh and for each small step you have this uh you know 16 by default uh message passing did they say the 16 in the text or is that from the paper


SPEAKER_00:
uh well that's uh the default implementation with spm uh okay about the text here yeah sorry okay yes interesting I I think also this is a uh a place to look at the rx infer um toolkit

as well as the reactive message passing variant.

So in the SPM-based message passing, every message, basically one round is advanced.

Every single node, messages are propagated across the entire network.

In the reactive message passing setting,

it opens the door to like a just-in-time type operation where different nodes can be receiving messages at different rates.

In fact, later today, we have live stream 55.0 on message passing.

And then in the coming two weeks with Magnus Kudel on message passing.

But it makes me wonder like,

Is there still message passing in the continuous time model?

I'm tempted to say yes, any Bayes graph, since any Bayes graph has a message passing dual.

then whatever the semantics of the base graph are whether it's describing markov transition probabilities or whether it's describing a temporal derivative for a taylor series expansion you still could construct the message passing to do that um i i i'm actually even gonna

bring in this one slide from message passing just because it uh okay three kinds of graphs i and interestingly all three of these kinds of graphs come into play in the textbook but i think in this 2017 paper they they lay it out most clearly bayesian graphs

nodes are variables edges are dependencies figure 4.3 base graph 40 factor graph nodes are functions of a distribution over variables edges represent variables per se

So here's 4.3.

Well, here's figure 7.3, same thing, 4.3.

So these two are equivalent.

Now this, which is to say 4.3, is equivalent to this Forney factor graph.

And then the third kind of graph is the neural network.

Nodes are sufficient statistics

edges are exchanges of sufficient statistics.

So it's kind of interesting.

On one hand, we shouldn't be super surprised because the graph is obviously an extremely general type of data.

So the idea that there would be like multiple kinds of graphs, it's not too surprising.


SPEAKER_02:
Can you give an example of the neural networks graph?

Which one is the one we just showed on page 26?

On page 26, you have Bayesian graph and the factor graph, right?


SPEAKER_00:
Yeah.

So here on the top are the Bayes graphs.

So these two are literally identical.

This is from the textbook.

Hashtag group.

And this is from the graphical brain paper, which I'll just put into the chat just in case you want to see.

Then every Bayes graph, any Bayesian network can be expressed as a factor graph.

So basically, they contain the same necessary and sufficient information.

However, there are operations and procedures that can be done on a factor graph that cannot be done on the Bayesian graph representation.

So under the hood, which is, I think, something to investigate in SPM and Python and Julia, when we specify our generative model as a Bayes graph,

And then we use standardized routines for message passing.

It's very interesting to ask, well, what's happening under the hood that converts that base graph into a factor graph?

The advantage of the factor graph, key advantage, is that as these numbers suggest, you can create node local procedural logistics.

So you can develop per node,

an order of operations that calculates that node, which allows you to develop a procedure to accurately update the entire graph.

Whereas if this base graph is presented, it's kind of like, well, should we calculate this part first or should we calculate that part first?

Is it even going to matter?

Okay, now the third kind of graph, the neural network or circuit.

Again, this is, I think, worthwhile to go into because I think when they're talking about a neural network,

this could this could be wrong but um these are the kind of yeah let's let's look in graphical brain just to see if they give an example the neural network yeah yeah because i'm not sure if they're okay yeah okay we'll get okay here we go

Here's a neural network graph.

So I don't know if this includes standard slash mainstream neural network architecture, like ConvNet type stuff.

I'm not sure if it would include that.

And then also we've seen neural slash cognitive architectural representations described as a base graph, for example,

in let's say here chapter five well so that's figure five two predictive coding

so here they these kinds of things now on one hand I see that I see that in terms of um sufficient statistics of unknown variables and other auxiliary variables like prediction errors that's literally what's happening here the mean is the summary statistic of the central tendency and then the um error residual

but I'm not sure if this can be interpreted both as a base graph and a neural graph or if this is one or the other because in either case it's slightly different in its representation one key piece that I think is happening here is there's like multiple at each layer

but I'm not sure if that's being if these threes or the two at each are being used to describe three time points kind of as traditional or whether it's alluding to the idea that there's a population of neurons and then the variable is a summary statistic on like a rate code

should not be taken too seriously.


SPEAKER_02:
Yeah, and certainly if they are kind of have one to one correspondence among the three graphs.


SPEAKER_00:
Yeah, that would be a great like that would be like the triple play with the three kinds of graphs, whereas they only really show two in connection.

Figure 11.

Figure 9.

What?

But here's what figure 10 looks like.

This looks a lot like figure 5.5.

We have the prefrontal, the sort of abstraction goal selection, then the descending prediction down into the dopaminergic policy selection.

We talked about the trade-off between basically habit-driven policy selection on the left and

And then expected free energy sharpened policy updating on the right.

That's like the dopaminergic tone.

And then the descending prediction down to the spinal arc with a kind of simple differential based set point predictor, sensory motor actuator.

This is like literally the same.

We have that prefrontal stack.

Here, we have a policy and a G. And then, ultimately, a descent into the spinal arc.

But what makes this... Question one, what makes this

different than just saying well it's a base network with a neural semantics I mean don't the nodes as unknown variables already have an interpretation as sufficient statistics question one question two oh yeah go ahead


SPEAKER_01:
yeah one thing is that's you know when you have category categorical distributions to get the sufficient statistic you need the full distribution uh well you know continuous time I think they always work with um Gaussian distribution you know in which you know having the mean and standard deviation is enough yeah they're they're definitely working commonly with the Gaussian family yeah


SPEAKER_00:
although in the hierarchical Gaussian setting the hierarchical Gaussian filter has high expressivity so it's not like they can only model simple things no no yeah yeah so how what makes this a neural network

are they using neural network like many machine learning researchers would use neural network today sigmoid activation function all that i don't exactly expect so um so how is this different than a bayesian network part one and then are are these models in content could these models be simply

It does not include continuous message passing.

So here they're dealing with categorical and continuous state spaces.

Okay.

Oh, see, but here these generalized observations describe a trajectory in continuous time.

So here we see the x, x prime, x double prime.

So this is a lot like- The derivatives over time?


SPEAKER_02:
First order, second order over time?


SPEAKER_00:
Yeah.

Okay.

And those are the generalized coordinates of motion.

The position of the car, the velocity of the car, acceleration of the car, and so on.

And then the more derivatives that you have,

that's using the Taylor series or the generalized coordinates to expand out.

Livestream 26 on the Bayesian mechanics for stationary processes or something like that, that is very helpful.

Like, let's just say you had a pendulum just moving back and forth.

Well, its position is obviously never the same moment to moment.

It's changing.

its velocity is changing moment to moment but you're going to get to a derivative not that high up for a pendulum where that derivative is not changing and that is stationarity on the generalized coordinates or if you had something that was moving around in a circle again the position is changing the velocity would always be changing like the actual vector heading would be different at each moment

but the Excel oh it's accelerating a little bit forward and to the left it's going counterclockwise so that would be stationary so that's a huge advantage of the continuous time is like if you can find the articulation where something has a regular

mechanics, then the the generalized coordinates, the Taylor series expansion, like, capture it really, really, really concisely.

Whereas if you were doing a discrete model of that something going around in a circle,


SPEAKER_02:
you you would I don't know maybe struggle to to pull out that simplicity especially yeah I'm thinking when you implement this uh continuous time model in computer you have to discretize the time anyway right yeah this is a great question

well, it didn't becomes a discrete times, if it discrete the time, will it become a discrete model?

Or it's actually fundamentally different from the discrete model?


SPEAKER_00:
You're right.

I would say,

that still would not be called a discrete time model because discrete time model, the B matrix would be, you know, the Markov transition probabilities.

Whereas here you're still trying to learn the derivative.

So then you take some approach, like you have some Delta T and then you shrink the Delta T. And if you find that as you're shrinking the Delta T you're converging on your estimate,

of the derivative, we're studying the line y equals x. And we start with a delta x of 5.

And we find the slope is 1.

And then we do delta x equals 4.

It's still a slope of 1.

So we're converged in our estimate of slope as we shrink the delta.

So then we feel confident in our discretization

but we're still in the continuous time setting, but we're just needing to take this digital approximation on the continuous, on estimating the continuous time dynamics.

Lance DaCosta is one of the researchers who has, I think,

expanded on this some of the most because in in 26

Christopher Lustrii, BASI mechanics for stationary processes here's where there was the discussion of the non non stationary steady States stationary non stationary steady States in the generalized coordinate settings also even with three.

Christopher Lustrii, layers like X X prime X double prime that corresponds to PID control in engineering the something integral derivative.

Um, so this is a very common engineering, um, technique then, um, in 52, this question of the Delta T came into play.

So like, obviously we want the underlying free energy landscape to be smooth because we want it to be like analytically

well behaved we want to be able to take derivatives so we want the free energy landscape to be smooth but we're doing it on digital computers so there has to be some approximation step in in space and time even if we're dealing conceptually with analytical space that is continuous in space continuous in time um so how does that work well

in this paper they talk about how do you do inference on that um on the Delta T how do you decide how much that step should be and there's a very evocative um image so we're the ball is rolling to the bottom of the hill we always talk about this

But we're on a computer simulating the ball rolling to the bottom of the hill.

So we are going to make these discretizations.

Now, how much time should we simulate?

Again, we have the equations that say that the ball is going to roll smoothly in time, smoothly in space.

But we need to simulate that.

they talk about this um Delta T question in terms of accelerated optimization like you could choose a Delta T that was so ridiculously small that it basically you know it wasn't moving like it was just super super you were just modifying a parameter by like a billionth um

conversely you could make Delta T that would lead to these kind of like chaotic sampling because you'd be like you'd be like okay the ball's here and it's headed this way and then you just go okay now let's just put it over there and then now it's like a totally different space and then it's like whoa what is happening now it's going that way so if your jump is too big then you're you're like you're getting kind of like

I don't know if you'd say you're getting aliased on that space, but if you're taking too large of jumps, you're not actually going to detect the regularities landscape.

You'd be on the side of the bull and you'd overshoot and you'd find yourself way off the curve.

You'd have to recorrect back to the curve and then you'd find yourself going way down here.

And so then there's this kind of second order inference question about what the delta T should be

then they talk about like um that in terms of the ball rolling to the bottom of the hill with different fluid viscosities so if you're like in honey you stay kind of move you never really reach a terminal acceleration velocity versus if you're like in water versus air you like gain more speed

And so that leverages the position of the ball on the bull and the vector direction.

But then knowing how far you should go is a higher derivative question.

It's like if the car's going one mile an hour, then there's going to be a delta T that's going to lead to optimal sampling of that car.

like one second later.

But then if the car's going a thousand miles an hour, you might want the delta T to be shorter.

Do all of these, like, and I think this, again, returns to the code question.

Do we just like swap out?

continuous time if we have a model with a given state space how hard is it to go from a continuous to a discrete time implementation like is it could we just flag it up at the top and just say we're going to do both then we're just going to see what they look like or you know

Is it a flag or a setting that can just be called?

Or does it require more of a structural custom creation for one or the other such that it's a little bit harder to repurpose?

I don't know.

In fact, I've done very little with the continuous time models.

But the Rx and Fur... The Rx and Fur...

it certainly is fine with continuous.


SPEAKER_02:
So this is the package for continuous time models.


SPEAKER_00:
Um, it's actually a, a package for, um, like message passing and basic graphs generally.

So you can make, you don't need, this isn't even an active inference specific package.

And so I think some of the reasons why pyMDP gets more use, at least today, first off more people know Python than Julia.

Second off pyMDP like SPM has multiple methods.

that are specifically relevant for doing active inference generative models like there's a class to define the the pomdp agent so that makes it a lot easier to define whereas here here's you can do active inference but um

you have to write it from scratch basically but so it's all there because if you if you can frame it as a bayesian graph and we know that we can then rx infer is a general base graph implementation approach which allows you to specify the base graph

And then under the hood, I believe flips it into the message passing format and actually does the inference with message passing.

But these are, these are very.

So yeah, or just saying I'm, I'm not a Julia expert either, but like some features that are presented already in RX and fur are very promising.

Let's see if there's continuous time specifically.

Yeah.

Good.


SPEAKER_02:
Try not to SPM the discrete case act.

try it out it's it's quite nice using the spm package oh yeah totally i haven't tried any other packages yeah i think this could be a good


SPEAKER_00:
I mean, birth of rise.

And again, we're having a live stream in the coming weeks with the authors of this package.

And so we can ask these kinds of questions.

But just, I mean, let's like,

This textbook, the 2022 textbook that we're ostensibly discussing is kind of the MATLAB SPM era and approach.

Yes.

PyMDP represents a sort of partially first principles approach, partially ported over from SPM approach.

and they've focused their development on discrete time modeling.

What is the name again?

PyMDP.


SPEAKER_02:
PyMDP.


SPEAKER_00:
Yeah.

Inferactively, the PyMDP package.

Whereas RxInfer set out to solve a significantly more general problem of just doing Bayesian inference.

But using PyMDP to construct arbitrary Bayesian graphs is probably not the best package for that.

But again, it has all these helpful methods for making POMDPs.

Movement is a classic case of continuous time modeling.

the analog real-time continuous nature of proprioception and actuation so sensory motor control this is an absolutely classic setting for continuous time modeling by thinking about what that continuous time model is in the game of doing not as

maximizing utility or reward function per se but reducing divergence to a set point and finding paths or trajectories in a space towards a set point already this foreshadows this kind of like sensory motor continuous layer

then a higher order discrete now it could be discrete time but at the very least discrete state space with like selection of different goals so you know to oversimplify the brain is send is is um setting discrete preferred states for the body to be in

then the body uses its um basal intelligence to realize paths navigate paths to that set point there is a discussion i think we may have talked last week about this some about the sensory attenuation

about the precision Dynamics we talked about like getting up out of a chair we talked about moving with the eyes the eye Cicade and about how as during the execution of a movement you're still getting sensory feedback and so if you expect the consequences of a movement like when I when I um

move my eyes or move my head, I'm expecting all of the visual input to change a certain way.

When I get out of a chair, I'm expecting my touch receptors to feel a certain way.

Those expectations are calibrated out so that they do not rise to our attention.

And so that can be understood in terms of a transient suppression of attention, which is attenuation,

then once the body is fixed again or the gaze is fixed again there's a re-engagement of precision so you know pay attention to when things outside of your control are happening but calibrate out the expected sensory consequences of action and the easiest way if you know that there's going to be like um you know if you know that you're going to drop something loud

just turn off your hearing for a split second while you drop something loud instead of engaging in in some more sophisticated like noise cancellation method they then move to an ecological analogy with a generalized lock of Volterra dynamics this is also called winterless competition because like plants are before carnivores like

none of them can like win they're all in this oscillatory relationship in this three-dimensional space and that's also been used to model winnerless neural dynamics like if you have two brain regions that have a mutual inhibitory relationship like the one that's on top inhibits the other one um

until the repression switch happens.

So that's explicitly brought into this winnerless competition.

Locke and Volterra was some of the earlier models of sequential actions in active inference.

And this Thomas Parr in the book stream 2.1, I think, he talked about this.

So like there was sort of the continuous time, this was like 2008, 2012, right?

the continuous time models were great with like real time flow, but doing like a, so it was all good for, you know, the arm, close the arm.

Okay, now open the arm, now close the arm.

But to do a multi-stage action, how do you get that into continuous time?

so the first approach that was shown here was um like saying how do you get a multi-stage action where first I want the plant population to drop then I want this carnivore population to go up or something so there are ways to tune the continuous relationships so that you can get um a kind of canonical unrolling

in response to a certain stimuli or endogenously generated which is what they did in the handwriting case however as thomas pointed to people wanted to account for explicit planning because even though the models tuned up to do this kind of repetitive scribble there was no explicit planning and so that motivated the development of the discrete time formalism

and the POMDP formalism, which had been widely used for planning.

And now we're kind of merging back those streams with continuous and discrete times, especially in light of the recent advances in Bayesian mechanics with path integrals, g-theory, these kinds of topics.

Learning in continuous models,

generalized synchrony now generalized synchrony you could also think about this in a discrete time setting but it works really nicely in a continuous time setting too this was um this specifically coupled Lorenz system

explored more in livestream 34 on the stochastic chaos and Markov blankets turns out that you can get generalized synchrony between um two chaotic systems between two non-chaotic systems and so on so you can get entrainment and generalized synchrony even when there's an analytical chaotic relationship

is it hard to fit chaotic processes in real life yes probably but in the example of the two birds that are like singing where their turn taking is described by like it's like you're like spiraling on one side of the lens attractor and then there's like a flip into the other side of the phase attractor that describes the turn taking and the generalized synchrony well

and combining the generalized synchrony plus learning with the two birds we can look at how like when we have a learning if the models didn't have learning obviously they would just continue to act along wherever however they were in the beginning but with learning they can come to have higher mutual information on each other closer to this like y equals x line

So that represents the tightening of the generalized synchrony, which doesn't mean lockstep.

It doesn't mean that they're singing at the same time.

It actually means that their turn-taking is sharper in its alternation.

Then in the close, missing line here, in the close of the chapter, they introduce the kind of

folk psychological model that gets explored in live stream 46 that we discussed earlier where we have a continuous time sensory motor actuation as a leaf in a higher order discrete time model then there are these just um examples of isocating with mixed or hybrid models

where we have a discrete time goal selection, and then the continuous time cicade.

Gaussian mixture model, big topic here about iterative clustering, kind of like k-means clustering.

And then they review 10 or 12 continuous time cycles.

settings.

So a very interesting one, certainly one that we could benefit a lot from having, like the same setting described with continuous and discrete time to get a better handle on

whether we, do we make the state space and then do we add the time layer and we can do it both?

Is there any downside to making models that way?

Or if we think back to chapter six and the recipe, is the decision that we make about continuous or discrete time something that happens very early and in a more committal way?

I don't know.

And the way that the packages are today may not be how packages are forever.


SPEAKER_02:
So then I have one question regarding the

the example given in chapter eight, this example, like all the figures, they are simulated by computers, right?

They are not the data connect from experiment or from the nature, right?


SPEAKER_00:
Correct.

In the examples here, the generative model was specified and then synthetic data were generated.

so that's kind of like the forward direction and then chapter nine is where we get into the discussion of okay now what if we have empirical data and we want to parameterize the generative model but here they just set the generative model and then synthesized data however they obviously set up the generative model to anticipate the kind of data that they were collecting in the lab

So this is the forward direction.

And then chapter nine is when we go into model-based data analysis with going from empirical data to parameterized generative models.

Cool.

Okay.


SPEAKER_02:
Thank you, Daniel.

Thanks.


SPEAKER_00:
Thank you.

Thank you, Esmail.

Thank you, Anshan.

Farewell.

Bye.


SPEAKER_02:
Thanks, Lloyd.


UNKNOWN:
Bye.