SPEAKER_01:
all right welcome everyone from cohort six and two-thirds um we're in chapter seven discussion and then also in cohort seven we're in chapter two so we'll maybe explore a little bit of both of them and also i'll just note that the octopus math sessions are in full effect

They're Tuesdays, one hour earlier than this.

The Zoom link is here and they're doing really fun.

The recordings are available and they're doing fun math education and Octopus is super knowledgeable.

So if anyone has questions from very basic background math to more speculative maths, I recommend they look at the recordings or go to those sessions.

All right.

So on seven or two, if it's relevant, what's something that anyone would like to begin with?


SPEAKER_03:
So for the discretization of time,

I feel like there were a few things that I wanted to be a little bit more defined.

Could you say a little bit about how you actually take this thing that the discretization of time or states seems like it could be broken up into smaller and smaller pieces, which kind of leads me to believe that there is some bundling that's going on behind the scenes.

And it makes me feel like I want this discretization as well as the definition of time to be brought into in a little bit more depth.

Could you say a little bit about your thoughts about that?


SPEAKER_01:
Yes, great question.

So there's a few different settings where you might be applying a discrete time model.

First, let's just go to figure 4.3.

kind of the Rosetta Stone with the discrete and the continuous time.

So this image highlights that with the same structural relationship amongst different variables,

we can have a discrete time or a continuous time active inference setting.

So that's kind of handled chapter seven and eight.

That's what a big part of the second part of the book is.

So how is time discretized?

Is this a claim about real time?

Is this like an ontological claim about time or how does it come into play instrumentally?

So sometimes you may be interested in making an example where there actually is a discrete time counter, like it's a metronome or a clock or you're using minutes or hours.

So again, whether or not you took a ontological position that time underlying the minutes was continuous, if you were measuring by the minute, whether you're doing trading or some other kind of measurement, you could still make a discrete time just by having some kind of click.

In the mouse teammates example, it's even less accurate.

problematic i think because there's no clock time wall time it's just action time so it's like action state step one and then an action is taken so that's kind of like chess time where it's discrete and there's not even a reference to a wall clock time so that's kind of the simplest setting is where there's no clock it's just like a chess game

Then the sort of intermediate setting is real time is happening, but you're modeling discrete units of time, like daily or hourly.

And then the sort of most open and challenging of the settings relatively is where you have a degree of freedom around how you discretize the time.

Like what should the time discretization be?

And so there, that is basically getting into a parameter sweep over possible delta Ts.

And then that gets into, okay, so now we have multiple possible models.

Some are ticking at a finer scale, some are ticking at a slower scale.

And then do we get like more accuracy or interpretability or are the benefits and accuracy and interpretability worth the increased cost for a faster ticking model?


SPEAKER_00:
So do you mind if I just try and reiterate this again?

So the question was, how do we make the choice about the sort of time that we're going to be modeling in the discrete sense?

So we're going to have either some absolute clock time or some purely ordinal sense of events following one another.

And the question is, how do we choose between those?

Because I think if that is the question, it would be very use case dependent.

So in something where there's a lot of interacting components, you're going to have to be aware of conflicts between events that can happen.

But if you're just modeling a mouse and a maze, maybe you can just have a global clock time and not have to worry about the clashes of events.

That's the only reason I bring up that.


SPEAKER_01:
yeah good and yeah here there's no clock at all it's just it's time point one and then an action is taken and then it's time point two right sorry that's what i meant you know you don't need a clock because you don't have to worry about clashes so i suppose i suppose it would be use case dependent um the choice let's say


SPEAKER_00:
Like there's nothing a priori in active infants that would perhaps necessitate one choice or the other.

At least I don't see how.


SPEAKER_01:
In the chapter six recipe, I mean, this is a... Yeah, go ahead.


SPEAKER_00:
Well, I just mean, let's say you're trying to just decide which of those two kinds of times you want to have without the specific use case, that is to say, the specific example.

I'm trying to think.

There's nothing that would mitigate in favor of one or the other.

It's very use case dependent, I think.

I could be wrong, though.


SPEAKER_01:
Yeah.

In the particulars, every single aspect of the generative model is system or use case specific.

There's nothing that you could reduce your uncertainty about further without reference to a particular system.


SPEAKER_00:
Yeah, yeah.


SPEAKER_01:
Like even in the chapter six recipe, that's one of the questions is, you know, what form should the model have?

Should we use discrete time, discrete state space, continuous time, continuous state space, or hybrids of them?

So at the system independent scale, we're just learning the motifs and the possible moves.

then they're all then then they're selected from and composed in making generative model for a specific situation so like in chapter seven it starts off familiarizing with the discrete time partially observable downstairs sense making part of

hidden state temperature in the room observation thermometer readings or in the in the chapter 7 case it's the true note that was meant to be played and then this is the observed note that's listened to d is your beginning prior on hidden state it just kicks off this markov chain and then after that it the the prior for the following hidden state is just the preceding hidden state

A maps from hidden states to observations, so it can be run forward in the so-called generative direction.

Again, it's a little confusing with the namespace because the whole thing is a generative model, but it's generating data, synthetic data.

like generating observations conditioned upon the temperature of the room, or in the recognition direction, taking in observations from the thermometer and then making inference about what the likely hidden state of the room is,

And then B is a transition operator.

So S is hidden state at a given time.

B is the discrete time state update function.

Then you get hidden state at the next time point.

So this is kind of the downward facing E that ends up being the downstairs of the POMDP.

So this highlights just the partially observable component, and then action is brought in later.

And the example in chapter seven is listening to music.

So we can look more at that example, or we can go anywhere or any question that someone prefers.


SPEAKER_00:
I have a question, I suppose, maybe following on from that POMDP with action.

So I think that's figure 7.3, if I'm not mistaken.

But if anyone else has something they want to jump in with, please don't let me stop you.

So 7.3 here.

There's a bit of a discussion about this.

We've introduced action now.

Well, we've introduced policies now.

Very nice.

We need the EFE to score these policies.

The question that I have is about, and this is not really, I don't really see here in this chapter where it's kind of finessed, but

on the next page i don't know if that's relatively easy to do equation 7.4 they actually give the expect free energy um and of course the the you know within the various terms you've got pi your policy um just kind of um you know interpreting this pi pi is a sequence of actions so there is in my mind let's say you know i'm trying to think how do i model some particular um event or you know system

It's going to be kind of bad to have to try and form approximate posterior beliefs over sequences of actions.

That's going to get quite massive very quickly.

You're going to have to form exponentially many approximate posterior beliefs for one more action that you add to your policy.

So there arises pretty quickly this necessity to deal with that problem.

And I'm just wondering if in the text or in general, if there is a relatively, let's say, kind of first pass way we can deal with this problem, the one that comes to mind

immediately is to just assume that the um the the approximate posterior over policies is you can just do a mean field thing so instead of having to do you know beliefs over things that are 16 times into the future you just say okay i'm going to assume that i can multiply the probability of action one versus action two versus action three and form posterior beliefs over that over you know individual actions and sort of just you know take the product um but nevertheless this this is something that is a little bit more of a general

uh query that i've had for a long time about the efe you know you have to to kind of you're sort of forced to deal with this problem of how to uh represent beliefs over policies because those policies can get so enormous very quickly so i'm sorry that's maybe not too uh well formed but alas that is my question if anyone wants to jump in yeah does anyone want to give any thoughts or or


SPEAKER_01:
Is it related to anything someone's thought or wondered?

And then let's explore it.


SPEAKER_02:
Yeah, so I've actually seen something somewhat similar to this question recently.

where, you know, like the naive way is to do Monte Carlo sampling, right?

And you just, you're looking over, like you said, like every possibility in this really deep tree.

And then there's Markov chain Monte Carlo sampling, where you're doing it very intelligently.

And there's a lot, I'm just starting to read on these things, but there's a lot of depth to that.

And it serves as a basis to,

sort of the alternative approach to probabilistic programming from RxInfer.


SPEAKER_00:
Yeah, it's quite different.


SPEAKER_02:
Yeah, it's quite different, but it can... I guess just one use case I've seen it on is where you condition on each pass time step, and like with RxInfer, you can kind of go back, you can trace every single step through it.

So...

just like a high level of this algorithm.

You sample, you know, one step and you're like, okay, this is pretty good.

And then based on you condition off that you sample another.

And if you run into a problem, you go back to like the last good state and then you try a different direction.

Um, that's the high level.

There's a lot of other really smart optimizations on it.

Um, but it, it can allow for example, like very effective path finding, um,

with minimal tree exploration.


SPEAKER_00:
Yeah, yeah.


SPEAKER_02:
Oh yeah, go ahead.


SPEAKER_00:
I was just going to say, yeah, that sounds really cool.

I actually did my honors project on this problem last year, and I have a heuristic tree search thing.

But the pain associated with that is, oh, you still have to enumerate some amount of actions into the future for some amount of policies.

And that gets very painful very quickly.

So things like heuristic tree search, things like, I suppose, some kind of Monte Carlo something,

um they're sort of the only things that i'm aware of uh for for doing this kind of sampling based thing if we're not going to do arcs and fur type stuff maybe we're getting a little bit far afield now but um this is look let's just let's connect it back to to the the basic problem and there's a variety of methods to to solve it so the fundamental issue is that


SPEAKER_01:
if we have a given number of affordances per time step let's just say there's two like left or right like it's a branching tree then for a function of growing time horizon that you're considering there's an exponentially growing number of total policies because it's it's doubling so it's just like that's the problem of chess it's a problem of getting specific about planning

any other kind of control method so then there's some some uh structural methods that can ameliorate this so one thing is like you might do a parameter sweep or search like what time horizon do i really need to plan for like do you need to plan 50 moves in chess or what fraction of the the value can you get with five moves of planning or something

there's, especially in active inference, there's nested modeling.

So let's just say we were doing a move every minute.

We could, and we wanted to model 120

moves in the future well that might be like a huge number of exponentially exploding minutes or maybe it's only two hours okay so then we have computational methods for approximating these complex um computations

Because we're going to think of it as this kind of inference problem.

And just because you can write out the inference problem, it's like, okay, but now the observations, it's a 4K video, 60 frames per second.

And the hidden state is going to be like, you know, so just because you can write the equation simply doesn't mean like that there's enough computational resources on earth to calculate it.

But the equation still might be very simple.

So then when that is happening, there are, as kind of mentioned, there's several approaches ranging from different sampling based approaches, which attempt to empirically approximate complex or large or high dimensional distributions by

speckling all over them or taking smart paths through them and then looking to reconstruct the entire posterior so in this case we have like an action prior is what we're taking into this whole inference question we want to update that action prior

we want to update the probabilities of taking different actions according to their expected free energy which is to say we want to like up rank actions policies um that contribute pragmatic value observing future observations with our preferences and and those that contribute epistemic value okay so that's this question a few few different ways to deal with it you can structurally deal with it

with changing the structure-generative model.

You can do sampling-based or variational inference-based approaches.

Let's also get specific.

Here's in PyMDP tutorial one.

This is what it looks like to get the expected free energy.

So this is like operationalizing an equation like this.

And this is...

programmed in the PyMDP imperative style.

So it's going to give a sort of procedural code for how you calculate the expected free energy for each policy.

What expected free energy does is it just takes in the policy vector and for each policy considered separately, it calculates this value.

So it's shown here.

And there's other ways to compute it.

There's other ways to write out the procedure to compute this, but this is that sort of imperative style of PyMDP, where calculations are described that take in certain inputs, combine them in certain ways, and result in certain outputs, in this case, like the expected free energy of moving left or right.

um then there's the just more again general questions for machine learning about like uh policy rollouts branching time active inference this was described in several papers this is a method of heuristic tree search like rolling out certain areas of the tree um that's oh leave there

But yes, expected free energy calculations can be having growing computational complexity because if you want to be dealing with something that's a large policy space over long times, then that's a pretty large challenge.


SPEAKER_00:
Yeah, it's frustrating to have such a nice, beautiful equation that quote-unquote solves it.

And it's theoretically beautiful, but it's very, very difficult in practice for, I suppose, non-toy problems to actually do.

Anyway, that was my main concern.


SPEAKER_01:
Yeah, I mean, look at the computational resources and compare it with other methods.

Because it isn't that each of these expected free energy calculations are necessarily that resource intensive.

Also, they can be paralyzed in the dispatch because computing the G for policy one and policy two, those are separate.

So that's a highly paralyzable step.

And again, it just depends on the overall, like if you had a simulation with a thousand nest mates making a single step of action, then the computational bottleneck in that simulation might not be, gee, if you were doing a single agent doing a thousand time steps of planning, maybe it would be.


SPEAKER_00:
Yeah, that's probably how we actually get around it is by having many agents kind of work together with relatively low timescales.

Yeah.

Interesting to think about.

Pretty, pretty cool.


SPEAKER_01:
Yeah.

I mean, multi-agents and or nested models reduce the need for explicit planning.

because they have fewer explicitly planned state or like in live stream 42 with the robot slam the simultaneous localization mapping the lower level model was the postural model so extensive planning wasn't needed there because it was like body posture then the higher level model was essentially the location of the warehouse

so then again planning was rarely more than one or two nodes deep so yeah that's because you had that extra extra structure of this multi-layer uh model I suppose yeah yeah yeah whereas trying to plan posture to get across the warehouse would have seemed intractable

Oh, awesome.

Thank you, Harris.

Yes, exactly.

Yeah.

Then also, this is sort of, this would be the deeper, the deeper tech angle would be like, as discussed in some of the message passing and Magnus Kuhldahl's work in Livestream 55, generalized free energy encompasses variational and expected free energy, and it enables

another kind of non-planning based way to talk about reducing uncertainty about policy in the future okay stockfish uses alpha beta pruning search algorithm alpha beta pruning improves minimax search by avoiding variations that will never be reached in optimal play because either player will be wrecked the game yeah that's that's a classic chess algorithm and you can implement in your in your script

Um, any, any, you could say only evaluate G for the even policies or, um, any policy with three of the same of, um, action selected in a row, just remove it.

So th there's th it's not like we're pro crusties and we're being forced to do a calculation.

These are just ways that you can choose what you want to calculate.

But it also may be a lot clearer in a specific case.

And each of these are just matrix operations.

So again, if you're dealing with massive matrices that you can't coarse grain or discretize, so you have a large matrix and you want to have continuous approximations and et cetera, it's like, well, then you're setting up for a larger problem.

But if your matrices are discrete or sparse, then these are super fast calculations.

And that's kind of the amazing thing is there isn't any need, this is again, the contrast with the reward learning.

There's no secondary like, well, let's calculate the reward associated with the policy, question mark, question mark, question mark, and then use that to update policy.

It's like, no, just directly calculate these exact conditional probabilities that are written here, reweight your policy prior into the policy posterior, and then select from it.

Or like shown in policy five, here's a more of a biological inspiration on that challenge with the dopamine balance.

So here it's saying, well, this is sort of habit on the left.

Here, policy is being determined just by the habit.

So E is the policy prior.

And so this is the kind of like thinking fast system one.

And then here's thinking slow system two, where there's a deliberative reweighting of policy.

So then there's this second level question, which is when should I deliberate

And if maybe only deliberation has to be engaged in a tiny fraction of cases and habits can be carried through or updated and then just reused.

Okay, chapter seven, so.

starts off again raise your hand or or write if you have a question but it starts off familiarizing with the partially observable markov model or just the hidden markov model just introducing okay we're putting some space with a matrix between the temperature in the room and the thermometer reading

So if it were fully observable, like here's the location of the chess piece on the board, and this is the observation of the chess piece on the board, then it's a fully observable Markov process.

There's an example with music playing.

Then action is brought in.

action is not intervening in the hidden state directly it's not it's not reaching into the hidden state of the room's temperature and modifying it it's more like selecting an index card from the b tensor and then selecting which index card of b is going to get applied to update the state so then it's like there's one matrix transition matrix that describes

air conditioner on and there's one that describes heater on and then the air conditioner one maps like 25 24 maps 24 to 23 so it just drops all the temperatures down by one and the heater one maps all the temperatures up by one so what action does is select which slice of b is going to be used

to multiply with the prior state of S to reach the current state of S. So then the question arises, well, how do you choose which policy to take?

And here you could just use habit, like use just a fixed decision rule or probabilistic draw from a fixed policy prior, or there could be another way to select, and that's G,

one important figure for g is 2.6 so here's g again pragmatic value is now here on the first term that it it it doesn't matter whether it's first or second term pragmatic value epistemic value so an important relationship to remember is if you only have pragmatic value

then you have utility maximization.

So in a situation where there either is no epistemic value to gain, or it's just not considered, the special case of expected free energy without epistemic value is Bayesian decision theory, expected utility theory.

Conversely, if you have no pragmatic value, again, it's a situation that doesn't have it, or you're choosing not to model it, or you have like a uniform preference over outcomes, measurements, then you just get two, three, four, five, and you get InfoMax.

So then having both, it then begets this question, how do you balance both?

And that's where we see some of the slightly potentially inflated language around dissolving the explore-exploit dilemma.

Does it dissolve it or does it articulate it so that we have a degree of freedom to balance it and adaptively explore solutions?

But is that dissolving it?

So just writing it out this way, like doesn't solve action selection in general or for a specific case, but it's a setting that allows modeling a tremendous range of cases, which isn't an answer in itself, but that's kind of the reason why there's so much parameterization to do and why fine tuning

the balance between these two is an interesting topic okay back to seven interesting it just like reloaded differently didn't it okay

then action comes into play.

We took that music listening example, but this was a passive music listening example.

So now we're considering action inference.

Unified inference problem, sense making downstairs, action selection upstairs.

Little bit more detail, revisiting equation 2.6.

saying here's the functional that's used to update the policy distribution it's an energy-based functional that has a pragmatic and an epistemic component sometimes it gets a little tricky with like are we talking about the negative free energy or the the the negative of the free energy

Suffice to say, just check the script and see how the values are being stored, and then just confirm it and verify it with what you know is a good policy in a limited situation, what you know is going to be an inferior one relatively, and just calibrate it and reflect it, and then add it in the documentation.

So then we get to the team A's, the classic decision example.

Here, we only have like one A matrix, but it turns out that you can actually have multiple As that can have the same or different shapes.

So it's kind of like parallel As.

A1 is mapping the sense-making relationship between location and the observation of the location.

The reason why there's four columns is because there's four locations, one, two, three, four.

But the reason why there's five rows is because there's like five sense-making outcomes because the bottom location can either give this L or the R. So when we're in context one, which is to say that the bottom Q is gonna reveal an R, then deterministically being there will reveal the R.

again this just begets the question this is just all modeling well how does the mouse come to know that locations reflect their location or how does it come to know the semantics of R how does it come to associate R with the right side like that that is the question that's what then but then you focus the map it's like saying well um it's a subway map of the city but then where where are the power lines

It's like, there's a lot of ways to make models of the situation.

The second A component is mapping from location to either the absence of either food or aversive stimuli, or mapping the probability of measuring the either food or aversive stimuli.

Here's context one, where the queue tells you it's on the right.

And if you go to the right, 98% of the time, there's the food.

Here's context two.

So you see a swap.

Now the one is here.

If you go to the queue, you get the L, and now the 98 is there.

But the 98 was here, and the one was there.

So that's the kind of like matrix surgery that in the nitty gritty, a lot of this gets down to.

It's like, what are the rows and the columns of A?

Now we get into B. Here, these are, as PyMDP goes into in a lot of depth, you have transition for controllable transitions and uncontrollable transitions.

uncontrollable transitions are one where the agent's policy selection has no efficacy so it's not really a control setting it's more just like a time series unfolding it's kind of like a passive inference element

And then the B matrix describes the agent's beliefs about its efficacy of action.

Again, this is another question.

What if the driver believes that pushing on the gas will have this B matrix effect on their acceleration, but actually the car has a different acceleration?

if that were the question you were modeling then you might look at a situation where there's a mismatch between the believed efficacy and the actual efficacy but the simpler setting is one where like what the agent believes an action will do is what it actually does but that's a major degree of freedom in modeling is how do agents have accurate representations of sense making in action

then so it just it's the abc's it's like sesame street then it goes into describing preferences just like reflecting the one and the two of the a a1 is location a2 is basically food so c1 corresponds to location there's a negative one kicking it off the starting blocks and then it has a flat locational preference

This gets into interpretability and AI alignment and safety in all these topics, because here we can say, it's not learning a proxy measure.

There is no pragmatic value being contributed by moving up in the teammates or moving to the right.

we can interpret this model and say, it does have an E to the sixth pragmatic preference for getting food.

That is contributing to pragmatic policy these ways.

You could even do trace back and you could look at how the expected free energy values were contributed to by specific pragmatic and epistemic value components.

And in the simple case, it's all just matrix math.

So that's the preferences.

Here, again, the thing to kind of look out for is are the preferences being encoded in exponent form already, in which case a six is e to the sixth fold preference, or you might choose in your program or in the program that you're using, six might reflect a six-fold preference.

And then under the hood, it gets exponentiated and just dealt with a different way.

A, B, C, D. Here, D1, location.

It begins with perfect knowledge that it's 100% in the starting location.

D2, that's about the food.

So D2 is saying, so it's about the food context.

It has an equal probability here.

This is also alluding a little bit to the learning by counting.

So this one, one is like, it's one half of one, one.

So it's 0.5, 0.5.

But learning by counting, what that would look like would be every time that you, so this is trial by trial learning.

So let's just say that it was on the right side.

Then you could change this to one third,

one comma two so then that would be equivalent to saying point three and point six seven and then now let's just say it went to right again it'd be one fourth one comma three then it'd be point two five point seven five so that's the learning by counting because you basically just increment what you've seen and then if it's one million one million then it's like a higher precision belief

because seeing one more is only going to move your update a tiny bit.

The team is again mobilized to focus a little bit on exploration exploitation setting and information forging.

Continuing on the epistemic value theme,

They move into an isochade paradigm, but it's separated from where it's brought up by several pages.

There's a box that talks about precision just in a general sense.

Here's a saccade model.

There are isochade models with discrete and continuous elements.

Then a discussion on learning.

If there's no hyper prior, there's no hyper parameter for a given parameter of interest, the base case is that it's fixed and not learnable.

So when we're looking at the T maze, we're looking at like this A matrix, this A matrix is being used to run forward inference, like to run sensemaking.

and um to the extent that it has values that contribute to it it also contributes epistemic values to different policy but the a matrix itself is not learnable it is not an object of inference it's not updated the values are not updated in the base case but this describes how you could make a bayesian model where there is updating of the a the b etc

This is the learning by counting.

More unpacking of equation 2.6.

More different decompositions of expected free energy.

And demonstrating that in this maze paper.

It's bringing in a lot of topics.

Structure learning, viewing alternative structural models, including with different numbers of parameters, as essentially a policy choice of the modeler.

So then that allows you to have the meta-Bayesian approach to Bayesian model selection.

And then here, hierarchical nested modeling.

and a nested model.

So seven is kind of a lot.

But it covers starting from a passive listening example all the way on through action and then some of these

uh doing a little bit of showing not telling on unifying cognitive modeling and treating different cognitive phenomena in terms of free energy does anyone have a question or we can look at some of the written questions or please please add many questions to these tables


SPEAKER_00:
Nothing for me right now.

Sorry.


SPEAKER_01:
This was some I think this was Eric sounds from several years ago.


SPEAKER_00:
like even taking another level of meta there is no dilemma explore exploits already stated in the clearest way yeah i mean there's trade-offs of that kind everywhere efficiency and robustness and so on so it's not like you have to choose one or the other or that if you choose one you can't choose the other yeah i suppose it's you know

if he gives you a principled way perhaps of deciding which one you should trade off at any given time or maybe that's what it's meant by it solves it but yeah it's it's a question for interpretation of what it means to solve it's like saying because we have a volume knob you don't have to worry about the volume it's like no it means the sound engineer is worried about the volume

It's like he has a principled way of controlling it.


SPEAKER_01:
Yeah.

And there's an interpretable, simple way.

So, for example, you could have an agent with a fixed epistemic value.

So kind of certain uncertainties, known unknowns about the world.

And then there's a policy on pragmatic value, policy on the preferences.

Like I scale up and down how much I am excited about food.

but studying is always the same amount so then when i want to focus on studying i just kind of turn down how much i care about food or turn it up if i want food or you could say i don't have control over c in this case and then you could explore well but could we tune the epistemic side to modify essentially the curiosity from lower to higher levels to affect the same concept

But whether you're modifying the scale of the pragmatic value or the scale of the epistemic value, you still need to then have this question, well, what would make an adaptive approach to navigating that trade-off?

Let's just see what else we have.

What I cannot create, I do not understand.

Some people feel, again, more funny comments that people have written.

The mild answer?

Okay.

The mild answer.

You need to implement the algorithms and see how they perform.

Well, the cool thing is there's notebooks like in RxInfer and PyMDP where even if you don't have any program language installed locally, like just in the browser, you can hit play and get the active inference agent.

That may help certain people.

If you'd like to contribute to those efforts and improve the notebooks, that's a great way because a lot of people will benefit from it.

Stronger answer here?

Okay, let's see.

Math and theory and hand-waving about how the brain might do thus and so are all weak tea.

The only way to really prove the idea is to build artifacts and do interesting things, especially things that other methods cannot accomplish.

That's sort of the embodied robotics,

J. F. Claudia moral computation method.

Rows and columns, these are great understanding checks.

Like if you look at the rows and the columns of all the matrices that are reflected in figure 7.3,

you basically understand the discrete time active inference model, because that's what it is.

Each of these are matrices or tensors, and then the operations are essentially manipulations or multiplications on these matrices.

So that's a very deflationary approach to active inference, but it's super informative because it's like, there's not like some other magic layer that then is applied here.

similarities and differences between prediction error and free energy gradients that's a good one does that does that show up in uh chapter seven like um prediction error specifically it looks like it's in the caption

some people use them including sometimes even possibly authors who who know better slash differently but and there's so it's you know words words words Etc Etc Etc but a prediction error is denominated in the units of what the prediction is about like if I predict that it's going to be 30 degrees and then it's 32 degrees the prediction error was two degrees

Surprise is denominated in units of information theory, like the nats or the bits, depending on base E or base two.

And then free energy is a unitless quantity that's just a calculation.

So you could have a free energy, relative free energy, just like you could have a maximum likelihood or a likelihood value for 30 degrees and 32 degrees, you can have a free energy value for 30 and 32 degrees,

as part of the model fitting with respect to a generative model.

But once you get into talking about free energy or surprise, you're talking about with reference to a given generative model.

Whereas prediction error in the kind of narrowest sense, also it does entail the model making the prediction, but it is denominated in the units of what the prediction is about.


SPEAKER_02:
Hmm.


SPEAKER_03:
I like that, talking about what the prediction is about, because I think the two aren't inherently so related.

For example, if I'm trying to improve my pragmatics or something like that, in the sense that maybe I'm playing a fighting game, and if I'm understanding this correctly, the actual loss, what the model is reflecting back is that I'm practicing my combos.

I'm practicing something inside of that that is going to be some instrumental thing that I want in order to improve the game.

but in me doing that i actually start to lose more often so the actual expected law the actual thing that i expect to see is me improving my model of how the game works while the actual reality of it is that i am losing at the game more i think that's a interesting thing oh okay so it's like a game where um you're or it's like i wonder what will happen if i play this differently


SPEAKER_01:
And then you might be learning more, even though the so kind of leaning into the epistemic side.

Like, yeah, what if I what if I try to play with what with just this weird chess strategy?

With a longer term pragmatic value or something?


SPEAKER_00:
an interesting point about the um prediction errors being denominated in specific units because it's it's called you know it's about some qualitative phenomena out there whereas the vfe is or you know for it's just more about the fit of your beliefs that's that's something i hadn't considered yeah free energy value is a lot like a model likelihood value for several reasons first off model likelihood saying maximum likelihood ml


SPEAKER_01:
is minimum surprise.

So when we say that free energy is kind of bounding surprise,

Like in the special case or in the complete case, the free energy is one of the same as the surprise minimization, which would make it the evidence maximization.

Or in the sort of more general approximation case, it's heading closer and closer towards minimizing surprise.

So it's heading closer and closer to maximizing model evidence.

But key similarity with likelihood estimates

uh or free energy estimates or like sum of squares is they're not comparable across different settings like the sum of squares the l2 norm that's used in linear regression that depends on the number of data points you add another data point and even if it doesn't change the regression line it's going to like it's it changes the sum of the squares of the residuals but

that that so that's why the sum of squares are not compared for like dips data sets with different numbers of value so free energy or also see EG sum of squares likelihoods they're like a statistical diagnostic I mean these are summary variables on Maps

again this is part of the the deflationary educational elements which is like once free energy is seen as the calculation that it's described as in the textbook it puts some of the discussions around real systems and their free energy into a different light

Because it'd be like, well, would this person also argue that the sum of squares of the regression between height and weight is a real thing in the world?

Okay, would they argue that the free energy value of the relationship between height and weight is a real thing in the world?

So then what is the claim?

Any last thoughts or what people plan to like add for questions or work on for the coming few weeks?


SPEAKER_00:
I guess the only thing is the thing that I find is natural to follow on from this discussion is the kind of stuff I brought up earlier about particular ways to deal with the explosion in the policy space.

That's kind of where I feel like this whole chapter, like where you would want to go after this, let's say.

So that's one thing I'm very interested in is trying to further those heuristic means of navigating those very large spaces.


SPEAKER_01:
Yep, that's an important topic.

I mean, also when build things out and whether timing them, like just using logging and timing functions in the script or using other ways,

just explore and be like, yeah, what does the runtime look, when I plot the runtime for one, two, three, four, five step time horizon, like what does that look like?

And then this model stream 6.1, this is really interesting work with the branching time active inference.

And this is some of the only, still actually,

some of the only computational complexity like big O notation I don't know why it's not loading but for active inference so so look at that if you're interested in in computational complexity estimates but that's another great advantage that with rx infer and everything we will um realize which is like we let's just say that we knew okay temperature it's a number between one and a hundred

Observations, number between 100.

This has this defined dimensionality.

This has this defined dimensionality.

In the discrete time, we could say exactly the RAM and the CPU and all these other attributes about the model statically.

So then you could anticipate resourcing deterministically, even for a probabilistic model.

There's a lot of things like that.

And then you can say, well, now we have three ways to implement this.

We could do the full policy rollout.

That's going to be $19.99.

Or here's the half off, but we only sample half the policies.


SPEAKER_02:
Daniel, would you be able to link that big old paper or talk you'd mentioned?

It's actually something I'm curious about.


SPEAKER_01:
branching model stream there's actually two papers i believe there's that there is the original paper and then there's a follow-up which is the kind of big o stuff i think yes link that or just add it you know any and then anywhere we search we'll find it but yeah that that that's cool and uh yeah that was like sort of our i think just last week in rx and for we were discussing like

how much other computation is there?

Like what is the overhead?

And then if the payload is this sort of like hypothetical minimum computational complexity of just storing the matrices and doing the operations, and then it's like, how much is the computational burden of the message passing?

And like what are the situations where the matrix math has a given computational complexity and then the message passing has like this or that?


SPEAKER_02:
Right.

Yeah, that's a big open question to me.

I'm hoping to read more about where it's covered just because there's so many different message passing scenarios.


SPEAKER_01:
Yes.

Okay.

So, all right.

Paper two.


SPEAKER_00:
that's the sort of theory.

And then paper one is the complexity time, complexity class analysis.

I believe.


SPEAKER_01:
Cool.

Thank you.

Cool.

Well, um, see all either at this time, like next week, or later today, Andrew will be facilitating, I believe.

So enjoy.

Talk to you soon and not anything till then.

All right.

Bye.

Bye.