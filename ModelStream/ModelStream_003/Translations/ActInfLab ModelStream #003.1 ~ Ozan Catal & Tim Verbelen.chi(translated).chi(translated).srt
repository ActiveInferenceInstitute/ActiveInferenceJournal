1
00:00:09,760 --> 00:00:10,320


2
00:00:10,320 --> 00:00:13,519
大家好，欢迎来到 actin flab，这

3
00:00:13,519 --> 00:00:17,600
是 actin flab 模型流编号 3.1，

4
00:00:17,600 --> 00:00:21,279
它是 2021 年 5 月 27 日

5
00:00:21,279 --> 00:00:23,680
，今天我们与 tim verbellen 和臭氧 catal 在这里，

6
00:00:23,680 --> 00:00:25,039


7
00:00:25,039 --> 00:00:27,920
我们将有一个

8
00:00:27,920 --> 00:00:29,599
关于他们最近

9
00:00:29,599 --> 00:00:31,679
学习生成状态的一些工作的模型流-

10
00:00:31,679 --> 00:00:33,360
用于主动推理的空间模型

11
00:00:33,360 --> 00:00:35,760
我们将进行演示，然后

12
00:00:35,760 --> 00:00:36,800
有一些时间

13
00:00:36,800 --> 00:00:39,520
进行问答，所以请随时

14
00:00:39,520 --> 00:00:40,559


15
00:00:40,559 --> 00:00:43,040
在聊天中写下任何问题，我们将

16
00:00:43,040 --> 00:00:44,160


17
00:00:44,160 --> 00:00:46,160
在对话中与他们联系，再次感谢

18
00:00:46,160 --> 00:00:47,360
tim 和 ozon

19
00:00:47,360 --> 00:00:48,960
加入我们 今天我们真的很

20
00:00:48,960 --> 00:00:50,800
期待你要分享的东西，

21
00:00:50,800 --> 00:00:54,480
所以请把它拿走，

22
00:00:54,960 --> 00:00:58,719
再次感谢，谢谢丹尼尔邀请我们，

23
00:00:58,719 --> 00:01:01,440
所以我是 tim verde，我们将与 uh Rosencattel 一起

24
00:01:01,440 --> 00:01:02,800


25
00:01:02,800 --> 00:01:05,920
在我们的论文上讨论一下学习

26
00:01:05,920 --> 00:01:08,000
用于主动推理的替代状态空间模型，

27
00:01:08,000 --> 00:01:10,880
所以我们都是

28
00:01:10,880 --> 00:01:12,000


29
00:01:12,000 --> 00:01:15,840
比利时 imek kent 大学的研究

30
00:01:15,840 --> 00:01:18,080


31
00:01:18,080 --> 00:01:19,119


32
00:01:19,119 --> 00:01:21,920


33
00:01:21,920 --> 00:01:22,720


34
00:01:22,720 --> 00:01:26,400
人员 智能机器人

35
00:01:26,400 --> 00:01:29,439
所以在我们开始

36
00:01:29,439 --> 00:01:32,560
之前可能会简短介绍

37
00:01:32,560 --> 00:01:34,400
一下我们做什么 我们的目标是什么

38
00:01:34,400 --> 00:01:35,759
所以基本上我们想要制造

39
00:01:35,759 --> 00:01:38,159
智能机器人 所以在

40
00:01:38,159 --> 00:01:42,000
我们位于甘斯的实验室中，我们有一个非常大的

41
00:01:42,000 --> 00:01:43,840
相当大的空间，我们有

42
00:01:43,840 --> 00:01:46,240
一些空间 一方面是机器人操纵器，

43
00:01:46,240 --> 00:01:47,920
另一方面也是

44
00:01:47,920 --> 00:01:50,320
驾驶和飞行机器人

45
00:01:50,320 --> 00:01:51,119


46
00:01:51,119 --> 00:01:53,840
，我们通常

47
00:01:53,840 --> 00:01:55,520
在这些东西上附加各种传感器

48
00:01:55,520 --> 00:01:58,399
，然后我们想要处理传感器

49
00:01:58,399 --> 00:01:59,200
信息

50
00:01:59,200 --> 00:02:03,119
并为这些东西推断一些有用的动作

51
00:02:03,119 --> 00:02:03,840


52
00:02:03,840 --> 00:02:07,759
，当然还有主动推理 是一种很酷的

53
00:02:07,759 --> 00:02:09,280


54
00:02:09,280 --> 00:02:12,879
尝试和

55
00:02:13,120 --> 00:02:15,760
进一步调查的方法，在这种

56
00:02:15,760 --> 00:02:18,800
情况下，基本上这项工作

57
00:02:18,800 --> 00:02:22,080
正在完成，

58
00:02:22,080 --> 00:02:24,480
所以你为什么要费心学习

59
00:02:24,480 --> 00:02:27,280
状态空间，所以如果你查看近年来的

60
00:02:27,280 --> 00:02:30,720
活跃推理论文，

61
00:02:30,720 --> 00:02:34,000
那么通常你会

62
00:02:34,000 --> 00:02:35,200
发现 一个

63
00:02:35,200 --> 00:02:38,640
类似于幻灯片上的

64
00:02:38,640 --> 00:02:40,480
数字，所以你有这个数字，你正在

65
00:02:40,480 --> 00:02:42,879


66
00:02:42,879 --> 00:02:44,959


67
00:02:44,959 --> 00:02:46,480
建模你正在调查的环境类型

68
00:02:46,480 --> 00:02:49,519
然后是关于

69
00:02:49,519 --> 00:02:50,640
模型应该是什么样子的完整描述，

70
00:02:50,640 --> 00:02:54,560
以便您定义状态空间，然后

71
00:02:54,560 --> 00:02:57,200
可能或在离散状态空间的情况下，

72
00:02:57,200 --> 00:02:58,959
您

73
00:02:58,959 --> 00:03:02,000
定义所谓的 a b c 和 d

74
00:03:02,000 --> 00:03:03,360
矩阵，

75
00:03:03,360 --> 00:03:06,239
它定义了似然模型，

76
00:03:06,239 --> 00:03:07,599
所以

77
00:03:07,599 --> 00:03:09,440


78
00:03:09,440 --> 00:03:11,200
当您处于某种状态时，看到某个观察的可能性有多大，

79
00:03:11,200 --> 00:03:13,760
或者是否转换模型，呃

80
00:03:13,760 --> 00:03:15,200
，您如何从

81
00:03:15,200 --> 00:03:19,360
一种状态转换到另一种状态等等

82
00:03:19,360 --> 00:03:23,200
，最近，当我们进行这项

83
00:03:23,200 --> 00:03:23,920


84
00:03:23,920 --> 00:03:26,720
研究时，我们也看到了其他一些人

85
00:03:26,720 --> 00:03:27,599
想想

86
00:03:27,599 --> 00:03:31,680
是的，嗯，我们可以在这些主动推理方法中

87
00:03:31,680 --> 00:03:34,080
使用这些新颖的

88
00:03:34,080 --> 00:03:35,760
深度学习技术进行更多的学习

89
00:03:35,760 --> 00:03:38,799


90
00:03:38,799 --> 00:03:41,440
吗？例如，kai 会

91
00:03:41,440 --> 00:03:42,400
受苦，

92
00:03:42,400 --> 00:03:45,440
嗯，谁说你提议

93
00:03:45,440 --> 00:03:48,480
基本上学习一种状态空间

94
00:03:48,480 --> 00:03:48,799
for

95
00:03:48,799 --> 00:03:51,519
for 山地车，但他仍然

96
00:03:51,519 --> 00:03:53,040
需要在状态向量中

97
00:03:53,040 --> 00:03:55,599
显式编码一些

98
00:03:55,599 --> 00:03:57,120
环境信息

99
00:03:57,120 --> 00:04:00,159
，

100
00:04:00,159 --> 00:04:02,319
还有来自

101
00:04:02,319 --> 00:04:04,080
baro 的一些工作 n Millage

102
00:04:04,080 --> 00:04:08,000
，他基本上

103
00:04:08,000 --> 00:04:11,120
在学习策略而

104
00:04:11,120 --> 00:04:11,680


105
00:04:11,680 --> 00:04:15,280
不是状态空间方面做了更多的学习，所以嗯基本上使用了

106
00:04:15,280 --> 00:04:17,199
带有小状态空间的决策过程的工作

107
00:04:17,199 --> 00:04:18,959
，你基本上

108
00:04:18,959 --> 00:04:19,759
可以

109
00:04:19,759 --> 00:04:22,880
处理原始状态空间

110
00:04:22,880 --> 00:04:24,720
和环境的观察

111
00:04:24,720 --> 00:04:26,320
给了

112
00:04:26,320 --> 00:04:28,320
你基本上适合作为状态空间的地方

113
00:04:28,320 --> 00:04:29,840
，

114
00:04:29,840 --> 00:04:32,560
然后他可以研究如何学习

115
00:04:32,560 --> 00:04:32,880


116
00:04:32,880 --> 00:04:36,160
给定这些状态的动作，但是所以

117
00:04:36,160 --> 00:04:39,040
我们的工作基本上是关于如果你

118
00:04:39,040 --> 00:04:40,720
不知道状态空间怎么办如果你的

119
00:04:40,720 --> 00:04:42,000
观察结果

120
00:04:42,000 --> 00:04:45,199
很高 维度并且您不能真正

121
00:04:45,199 --> 00:04:47,199
将其直接用作您的状态空间您

122
00:04:47,199 --> 00:04:48,400
如何

123
00:04:48,400 --> 00:04:51,280
定义模型您如何提出

124
00:04:51,280 --> 00:04:53,360
它也许作为一个具体的例子假设

125
00:04:53,360 --> 00:04:54,080
我们

126
00:04:54,080 --> 00:04:56,160
在实验室中有一个驾驶机器人所以

127
00:04:56,160 --> 00:04:58,880
这是第一人称

128
00:04:58,880 --> 00:04:59,600
机器人的视图

129
00:04:59,600 --> 00:05:01,280
这是你得到的观察结果

130
00:05:01,280 --> 00:05:03,680
只是一个像素的正方形

131
00:05:03,680 --> 00:05:05,919
，然后是的，

132
00:05:05,919 --> 00:05:07,280
在这种情况下你的状态空间是什么，

133
00:05:07,280 --> 00:05:10,639
它可能是 ma 上的 xy 位置 p

134
00:05:10,639 --> 00:05:12,400
这可能与作为状态的机器人相关的东西

135
00:05:12,400 --> 00:05:13,759


136
00:05:13,759 --> 00:05:16,800
也可能是

137
00:05:16,800 --> 00:05:18,560
小心你正在接近电缆

138
00:05:18,560 --> 00:05:20,400
吸气剂所以可能有一个

139
00:05:20,400 --> 00:05:23,360
也可能有用

140
00:05:23,360 --> 00:05:25,039
的东西也许存储在你的

141
00:05:25,039 --> 00:05:25,759
残骸中

142
00:05:25,759 --> 00:05:28,400
的物品与 无论你有什么任务

143
00:05:28,400 --> 00:05:30,000
，它也可能是

144
00:05:30,000 --> 00:05:31,360
状态空间的一部分，

145
00:05:31,360 --> 00:05:33,440
也许有人类工人

146
00:05:33,440 --> 00:05:35,120
四处走动，你还需要对这些进行建模，

147
00:05:35,120 --> 00:05:35,759
所以

148
00:05:35,759 --> 00:05:38,479
这取决于你的机器人和你拥有的用例

149
00:05:38,479 --> 00:05:40,240
，它确实得到了手以及可能

150
00:05:40,240 --> 00:05:42,400
发生的事情 在环境

151
00:05:42,400 --> 00:05:45,759
中，

152
00:05:45,759 --> 00:05:49,520
定义一组要跟踪的简洁状态变得非常重要，

153
00:05:49,520 --> 00:05:50,639


154
00:05:50,639 --> 00:05:52,720
更不用说您需要一些模型

155
00:05:52,720 --> 00:05:54,639
，

156
00:05:54,639 --> 00:05:56,479
这就是模型，就像您如何

157
00:05:56,479 --> 00:05:57,759
从像素

158
00:05:57,759 --> 00:05:59,840
到过期位置一样，因此有

159
00:05:59,840 --> 00:06:01,520
一定的

160
00:06:01,520 --> 00:06:04,960
机器人技术中的方法是做

161
00:06:04,960 --> 00:06:08,400
这些事情的一部分，但它们都没有

162
00:06:08,400 --> 00:06:10,639
真正弄清楚

163
00:06:10,639 --> 00:06:11,680


164
00:06:11,680 --> 00:06:14,160
你想要做的任何事情所需要的完整的状态空间是

165
00:06:14,160 --> 00:06:15,840
什么

166
00:06:15,840 --> 00:06:18,479
，尤其是不是那种

167
00:06:18,479 --> 00:06:22,000
主动推理设置，

168
00:06:22,080 --> 00:06:25,039
所以在我们开始我们的方法之前，我将

169
00:06:25,039 --> 00:06:27,520
简要

170
00:06:27,759 --> 00:06:31,120
讨论一下主动推理，可能

171
00:06:31,120 --> 00:06:32,960
你们中的大多数人已经熟悉

172
00:06:32,960 --> 00:06:34,720
这个主题，但我只会

173
00:06:34,720 --> 00:06:37,840
排练一些东西，即使

174
00:06:37,840 --> 00:06:41,520
只是为了习惯我们的方式

175
00:06:41,520 --> 00:06:43,520
可以说，因为每个人

176
00:06:43,520 --> 00:06:45,440
都有自己的

177
00:06:45,440 --> 00:06:48,960
符号，对于专家来说，它至少

178
00:06:48,960 --> 00:06:51,120
会让我们都在同一个页面上，

179
00:06:51,120 --> 00:06:52,639


180
00:06:52,639 --> 00:06:56,080
所以这一切都始于有一个

181
00:06:56,080 --> 00:06:57,280
需要与环境交互的代理，

182
00:06:57,280 --> 00:07:00,240
并且代理被

183
00:07:00,240 --> 00:07:02,160
假定为

184
00:07:02,160 --> 00:07:04,160
从所谓的马尔可夫毯子中与环境分离，

185
00:07:04,160 --> 00:07:05,440


186
00:07:05,440 --> 00:07:08,319
因此一方面代理可以

187
00:07:08,319 --> 00:07:10,000
来自动作，

188
00:07:10,000 --> 00:07:12,960
这些动作会影响

189
00:07:12,960 --> 00:07:15,039
环境，这是

190
00:07:15,039 --> 00:07:18,240
一种生成过程，具有

191
00:07:18,240 --> 00:07:21,840
一些隐藏状态并为

192
00:07:21,840 --> 00:07:23,599
您提供 鉴于您的动作，

193
00:07:23,599 --> 00:07:25,039
它为您提供了一些感官

194
00:07:25,039 --> 00:07:27,039
观察，因此在这种情况下

195
00:07:27,039 --> 00:07:29,280
，机器人可能会

196
00:07:29,280 --> 00:07:30,400
四处行驶

197
00:07:30,400 --> 00:07:33,840
并在电机上施加一些电流，

198
00:07:33,840 --> 00:07:35,919
并且观察可能是一些 e

199
00:07:35,919 --> 00:07:37,520
来自相机的像素

200
00:07:37,520 --> 00:07:39,840
，然后代理的目标是

201
00:07:39,840 --> 00:07:41,280
建立一个生成模型

202
00:07:41,280 --> 00:07:43,840
，在其中他有自己的，呃，他建立

203
00:07:43,840 --> 00:07:45,520
自己的状态空间，基本上，

204
00:07:45,520 --> 00:07:49,360
他推导出动作

205
00:07:49,360 --> 00:07:51,919
如何对状态产生影响，以及

206
00:07:51,919 --> 00:07:53,840
这些状态随后将如何 生成

207
00:07:53,840 --> 00:07:55,919
这些观察结果，

208
00:07:55,919 --> 00:07:58,800
所以问题是我们如何构建一个

209
00:07:58,800 --> 00:07:59,919
生成模型

210
00:07:59,919 --> 00:08:02,319
，它实际上会自动

211
00:08:02,319 --> 00:08:05,680
出现一种适当的状态空间来

212
00:08:05,680 --> 00:08:09,599
学习这个模型，所以

213
00:08:09,599 --> 00:08:12,160
基本上生成模型看起来

214
00:08:12,160 --> 00:08:14,319
可能是一个部分可观察的

215
00:08:14,319 --> 00:08:17,759
马尔可夫决策过程，所以它只是 意味着

216
00:08:17,759 --> 00:08:18,319


217
00:08:18,319 --> 00:08:21,520
我们假设那是

218
00:08:21,520 --> 00:08:22,879
给定时间步的状态

219
00:08:22,879 --> 00:08:25,840
它只取决于之前的状态

220
00:08:25,840 --> 00:08:27,680
和

221
00:08:27,680 --> 00:08:30,960
你正在做的动作，每个状态

222
00:08:30,960 --> 00:08:33,760
都会产生一定的

223
00:08:33,760 --> 00:08:36,479
观察结果

224
00:08:36,719 --> 00:08:40,000
，所以我们最终

225
00:08:40,000 --> 00:08:42,640
得到所谓的 自由能原理，

226
00:08:42,640 --> 00:08:44,240
基本上我们想做的

227
00:08:44,240 --> 00:08:47,200
是建立一个模型，呃，它

228
00:08:47,200 --> 00:08:49,200
最大化对数证据，所以在这里

229
00:08:49,200 --> 00:08:52,399
你看到自由能的公式

230
00:08:52,399 --> 00:08:55,760
，你 可以用几种方式解开它，

231
00:08:55,760 --> 00:08:59,200
所以第一种方式基本上是

232
00:08:59,200 --> 00:09:00,000
通过

233
00:09:00,000 --> 00:09:02,800
说明最小化自由能

234
00:09:02,800 --> 00:09:03,440
实际上是

235
00:09:03,440 --> 00:09:07,680
最大化呃

236
00:09:07,680 --> 00:09:10,560
证据下限假设，如果

237
00:09:10,560 --> 00:09:11,279
你

238
00:09:11,279 --> 00:09:13,760
在这个自由能最小值，那么

239
00:09:13,760 --> 00:09:15,680
基本上你有你的近似值

240
00:09:15,680 --> 00:09:17,920
在这实际上等于

241
00:09:17,920 --> 00:09:19,120


242
00:09:19,120 --> 00:09:22,320
您的部队或非常接近您的部队之后

243
00:09:22,320 --> 00:09:22,800
，

244
00:09:22,800 --> 00:09:25,120
但第三行基本上是我们

245
00:09:25,120 --> 00:09:26,240
通常

246
00:09:26,240 --> 00:09:28,720
用于优化我们的模型的内容，这

247
00:09:28,720 --> 00:09:29,839
基本上是一方面

248
00:09:29,839 --> 00:09:33,279
您

249
00:09:33,279 --> 00:09:36,800
希望您的州解释

250
00:09:36,800 --> 00:09:39,200
解释的复杂性术语 尽可能简单的方法，

251
00:09:39,200 --> 00:09:40,880
而您希望以最高的

252
00:09:40,880 --> 00:09:42,480
准确度来预测

253
00:09:42,480 --> 00:09:44,959
您正在观察的任何内容，因此在这种

254
00:09:44,959 --> 00:09:45,839
情况下，我们的

255
00:09:45,839 --> 00:09:48,000
变分近似后验是

256
00:09:48,000 --> 00:09:49,600


257
00:09:49,600 --> 00:09:53,360
将观察结果和动作映射到

258
00:09:53,360 --> 00:09:55,440
推断您当前的当前

259
00:09:55,440 --> 00:09:57,760
状态，

260
00:09:58,000 --> 00:10:00,160
但是未来呢？ 在

261
00:10:00,160 --> 00:10:01,600
过去，你

262
00:10:01,600 --> 00:10:03,680
基本上知道你在做什么，你

263
00:10:03,680 --> 00:10:05,360
看到了观察

264
00:10:05,360 --> 00:10:08,880
到的，所以你可以

265
00:10:08,880 --> 00:10:12,079
推断出什么 ich states 会

266
00:10:12,079 --> 00:10:13,839
引起观察，所以

267
00:10:13,839 --> 00:10:15,440
这基本上是过去的优先事项，

268
00:10:15,440 --> 00:10:18,079
但是在未来，

269
00:10:18,079 --> 00:10:20,079
事情会发生一些变化，因为现在你

270
00:10:20,079 --> 00:10:22,079
不知道你会观察到什么

271
00:10:22,079 --> 00:10:24,320
，而且你必须选择

272
00:10:24,320 --> 00:10:25,680
你将要

273
00:10:25,680 --> 00:10:29,920
执行的操作 我们将基本上将

274
00:10:29,920 --> 00:10:31,839
它们表示为由所谓的政策产生的行动，

275
00:10:31,839 --> 00:10:33,120


276
00:10:33,120 --> 00:10:35,279
但在这种情况下，政策

277
00:10:35,279 --> 00:10:36,160
基本上就是

278
00:10:36,160 --> 00:10:39,279
是的，基本上是什么是

279
00:10:39,279 --> 00:10:42,640
一系列行动，嗯

280
00:10:42,640 --> 00:10:45,680
，你现在

281
00:10:45,680 --> 00:10:46,640


282
00:10:46,640 --> 00:10:49,839
不仅要对未来的状态，而且还要对 嗯，

283
00:10:49,839 --> 00:10:52,079
未来的观察，所以

284
00:10:52,079 --> 00:10:54,160
我认为我会通过做一些动作访问哪些状态，

285
00:10:54,160 --> 00:10:55,360


286
00:10:55,360 --> 00:10:57,600
但

287
00:10:57,600 --> 00:11:00,079
如果我访问这些状态，我认为我会看到什么样的观察，

288
00:11:00,079 --> 00:11:03,200


289
00:11:03,200 --> 00:11:05,040
那么自由能就变成了所谓的

290
00:11:05,040 --> 00:11:06,959
预期自由

291
00:11:06,959 --> 00:11:10,240
能 你可以

292
00:11:10,240 --> 00:11:14,000
按如下方式打开这个东西，

293
00:11:14,000 --> 00:11:16,959
所以基本上发生的事情是，

294
00:11:16,959 --> 00:11:17,279


295
00:11:17,279 --> 00:11:19,440
一方面你的呃

296
00:11:19,440 --> 00:11:20,880
你的

297
00:11:20,880 --> 00:11:24,160
引导模型的爱情概率减去

298
00:11:24,160 --> 00:11:24,720
你的

299
00:11:24,720 --> 00:11:28,000
呃你的对数概率 r 性别

300
00:11:28,000 --> 00:11:31,440
模型 嗯，现在不同的是，

301
00:11:31,440 --> 00:11:33,760
嗯，你还不知道

302
00:11:33,760 --> 00:11:35,440
未来的观察结果

303
00:11:35,440 --> 00:11:37,839
所以是的，你以政策为条件，

304
00:11:37,839 --> 00:11:39,600
所以一切都取决于

305
00:11:39,600 --> 00:11:42,800
你将采取的行动，你还必须

306
00:11:42,800 --> 00:11:45,440
接受期望

307
00:11:45,440 --> 00:11:46,000


308
00:11:46,000 --> 00:11:48,959
你期望的各种结果然后

309
00:11:48,959 --> 00:11:51,839
进入第二行你基本上会

310
00:11:51,839 --> 00:11:54,959
采取行动，

311
00:11:54,959 --> 00:11:56,560
如果你的模型经过充分

312
00:11:56,560 --> 00:11:58,639
训练，那么

313
00:11:58,639 --> 00:11:59,900
基本上你的

314
00:11:59,900 --> 00:12:01,839
[音乐]

315
00:12:01,839 --> 00:12:05,360
你的真实你的近似后验

316
00:12:05,360 --> 00:12:06,880
将非常

317
00:12:06,880 --> 00:12:08,959
接近真实的后验 然后这

318
00:12:08,959 --> 00:12:10,480
基本上可以让你

319
00:12:10,480 --> 00:12:13,680
重写最后一个学期

320
00:12:13,680 --> 00:12:17,120
，我现在明白了，我

321
00:12:17,120 --> 00:12:19,279
以不同的方式写了它，但是

322
00:12:19,279 --> 00:12:20,800
你可以将它

323
00:12:20,800 --> 00:12:25,040
重写为一个信息游戏

324
00:12:25,040 --> 00:12:29,440
并朝着首选结果前进，

325
00:12:29,440 --> 00:12:31,920
但你可以 还重写这里的阅读方式

326
00:12:31,920 --> 00:12:32,480


327
00:12:32,480 --> 00:12:34,480
，你基本上

328
00:12:34,480 --> 00:12:35,839
在未来的某个时候说好的，

329
00:12:35,839 --> 00:12:37,680
我会访问一些州，所以这是

330
00:12:37,680 --> 00:12:39,040


331
00:12:39,040 --> 00:12:42,320
给定政策的 s esta 的草率，你基本上

332
00:12:42,320 --> 00:12:43,200
把它

333
00:12:43,200 --> 00:12:46,240
替换为 一些先前的信念，无论

334
00:12:46,240 --> 00:12:46,880


335
00:12:46,880 --> 00:12:49,680
我实际选择哪种政策，我相信

336
00:12:49,680 --> 00:12:50,399


337
00:12:50,399 --> 00:12:52,320
在未来的某个时候我会意识到

338
00:12:52,320 --> 00:12:54,240
我的偏好，所以这就是为什么你在最后一个等式中失去

339
00:12:54,240 --> 00:12:54,720
了

340
00:12:54,720 --> 00:12:58,160
对政策的条件，

341
00:12:58,160 --> 00:13:00,399
所以

342
00:13:00,399 --> 00:13:02,399
这基本上变成了 kl 分歧

343
00:13:02,399 --> 00:13:03,279
说

344
00:13:03,279 --> 00:13:06,720
好的我想找到

345
00:13:06,720 --> 00:13:08,639
真正让我接近我喜欢的状态的政策

346
00:13:08,639 --> 00:13:09,279


347
00:13:09,279 --> 00:13:12,240


348
00:13:12,240 --> 00:13:14,000


349
00:13:14,000 --> 00:13:16,560


350
00:13:16,560 --> 00:13:18,560
是访问可以

351
00:13:18,560 --> 00:13:20,160
给我

352
00:13:20,160 --> 00:13:22,959
任何我无法预测的观察的状态，所以我不喜欢

353
00:13:22,959 --> 00:13:23,519
这些

354
00:13:23,519 --> 00:13:25,519
模棱两可的状态，我

355
00:13:25,519 --> 00:13:27,519
基本上不了解正在发生的

356
00:13:27,519 --> 00:13:30,000
事情，

357
00:13:30,720 --> 00:13:34,240
因此这将我们带到了

358
00:13:34,240 --> 00:13:37,920
整个主动推理方案，所以在每个

359
00:13:37,920 --> 00:13:38,880
时间步骤

360
00:13:38,880 --> 00:13:41,040
您基本上评估

361
00:13:41,040 --> 00:13:42,079


362
00:13:42,079 --> 00:13:45,680
了您的每项政策的预期自由能，然后您

363
00:13:45,680 --> 00:13:48,399
基本上假设您将选择

364
00:13:48,399 --> 00:13:49,360


365
00:13:49,360 --> 00:13:51,279
实际上将您的

366
00:13:51,279 --> 00:13:53,519
预期自由能最小化的政策，因此

367
00:13:53,519 --> 00:13:57,360
您采取 t 他在 uh 减去 g 上的 softmax

368
00:13:57,360 --> 00:13:59,120
并且你也用这个 gamma

369
00:13:59,120 --> 00:14:00,399
参数来衡量这个，就像精度一样，

370
00:14:00,399 --> 00:14:02,480
所以如果你有一个

371
00:14:02,480 --> 00:14:03,519
高精度，

372
00:14:03,519 --> 00:14:05,440
那么基本上你会得到一个

373
00:14:05,440 --> 00:14:07,199
非常大

374
00:14:07,199 --> 00:14:09,279
的 soft max 函数的输出，所以

375
00:14:09,279 --> 00:14:10,959
softmax 基本上会

376
00:14:10,959 --> 00:14:14,639
变成一个最大值，所以如果你稍微放松一下精度，那么你

377
00:14:14,639 --> 00:14:17,360
肯定会选择具有

378
00:14:17,360 --> 00:14:17,920
最低

379
00:14:17,920 --> 00:14:21,680
预期自由能的策略，

380
00:14:21,680 --> 00:14:24,240
然后基本上你

381
00:14:24,240 --> 00:14:24,720


382
00:14:24,720 --> 00:14:28,480
允许系统中的一些或更多随机性

383
00:14:28,480 --> 00:14:31,519
，然后基本上你最终会

384
00:14:31,519 --> 00:14:33,120


385
00:14:33,120 --> 00:14:36,399
根据 根据这个政策我应该采取的下一个

386
00:14:36,399 --> 00:14:37,600
行动是什么，

387
00:14:37,600 --> 00:14:39,839
但是

388
00:14:39,839 --> 00:14:42,000
当前进

389
00:14:42,000 --> 00:14:44,240
跟随实际时，给定政策的行动选择

390
00:14:44,240 --> 00:14:45,839
基本上

391
00:14:45,839 --> 00:14:48,560
只是一个确定性映射，所以

392
00:14:48,560 --> 00:14:49,600
政策就像

393
00:14:49,600 --> 00:14:52,160


394
00:14:52,160 --> 00:14:52,959


395
00:14:52,959 --> 00:14:54,720
你选择的特定行动序列一样 政策

396
00:14:54,720 --> 00:14:56,959
行动基本上是固定的，

397
00:14:56,959 --> 00:14:59,120
但理论上你也可以把它做成一个

398
00:14:59,120 --> 00:15:02,000
概率映射，

399
00:15:02,000 --> 00:15:05,279
所以现在让我们

400
00:15:05,279 --> 00:15:07,440
进入真正有趣的部分 工作

401
00:15:07,440 --> 00:15:09,600
的重点是我们如何

402
00:15:09,600 --> 00:15:11,920


403
00:15:11,920 --> 00:15:13,279
在

404
00:15:13,279 --> 00:15:16,720
如此活跃的推理密钥

405
00:15:17,040 --> 00:15:19,920
中学习具有深度神经网络的状态空间基本上

406
00:15:20,079 --> 00:15:22,800
我们有两个组件一个是

407
00:15:22,800 --> 00:15:24,639


408
00:15:24,639 --> 00:15:27,680
我从第一张

409
00:15:27,680 --> 00:15:30,399
幻灯片中排练的生成模型，我们有我们的近似

410
00:15:30,399 --> 00:15:31,680
后验模型

411
00:15:31,680 --> 00:15:33,839
和 基本上你可以看到这些方程有

412
00:15:33,839 --> 00:15:34,720
三个

413
00:15:34,720 --> 00:15:37,839
部分，第一

414
00:15:37,839 --> 00:15:38,240
部分

415
00:15:38,240 --> 00:15:41,519
基本上是一个转换模型，所以

416
00:15:41,519 --> 00:15:45,279
它输出

417
00:15:45,279 --> 00:15:48,399
你的状态概率给定你以前的状态

418
00:15:48,399 --> 00:15:51,920
和你在那个状态下做的动作

419
00:15:51,920 --> 00:15:55,120
第二部分哦是的，

420
00:15:55,120 --> 00:15:57,920
还有最初的 状态基本上

421
00:15:57,920 --> 00:15:59,519
也是过渡模型的一部分，但是

422
00:15:59,519 --> 00:16:00,800
您只需

423
00:16:00,800 --> 00:16:02,800
提供零动作，例如

424
00:16:02,800 --> 00:16:06,000
只是为了引导

425
00:16:06,000 --> 00:16:07,839
它第二部分处于准确模型下，

426
00:16:07,839 --> 00:16:10,000
因此在给定状态下，您希望有一个模型

427
00:16:10,000 --> 00:16:10,399


428
00:16:10,399 --> 00:16:12,320
来预测您将进行什么样的观察

429
00:16:12,320 --> 00:16:14,000
你会

430
00:16:14,000 --> 00:16:17,680
看到，最后你有

431
00:16:17,680 --> 00:16:20,079
后验模型，它给出了

432
00:16:20,079 --> 00:16:21,120
先前的状态

433
00:16:21,120 --> 00:16:23,920
动作，你当前的观察也

434
00:16:23,920 --> 00:16:24,880
必须预测

435
00:16:24,880 --> 00:16:28,480
嗯哪个 sta 您还必须推断出

436
00:16:28,480 --> 00:16:29,680
您处于哪种状态，

437
00:16:29,680 --> 00:16:32,880
因此基本上后验模型必须

438
00:16:32,880 --> 00:16:34,560
提出与过渡模型相同的东西，

439
00:16:34,560 --> 00:16:36,560
但此外

440
00:16:36,560 --> 00:16:38,480
它基本上可以访问您的循环，

441
00:16:38,480 --> 00:16:40,320


442
00:16:40,320 --> 00:16:43,199
并且类似于过渡模型

443
00:16:43,199 --> 00:16:44,800
来引导它 最初的

444
00:16:44,800 --> 00:16:46,399
观察你没有

445
00:16:46,399 --> 00:16:49,199
任何动作，但它可以

446
00:16:49,199 --> 00:16:50,079
通过与

447
00:16:50,079 --> 00:16:53,120
所有这三个组件

448
00:16:53,120 --> 00:16:54,720
相同的东西建模

449
00:16:54,720 --> 00:16:57,540


450
00:16:57,540 --> 00:16:58,800


451
00:16:58,800 --> 00:17:02,560


452
00:17:02,560 --> 00:17:05,760
三种

453
00:17:05,760 --> 00:17:09,119
模式，所以如果我们

454
00:17:09,119 --> 00:17:12,319
把它放在示意图中，我们基本上

455
00:17:12,319 --> 00:17:12,959
有

456
00:17:12,959 --> 00:17:16,160
这样的东西，所以给定你的状态

457
00:17:16,160 --> 00:17:18,720
，从上一个时间步开始的动作

458
00:17:18,720 --> 00:17:20,559
和从当前时间步的观察，

459
00:17:20,559 --> 00:17:21,599


460
00:17:21,599 --> 00:17:24,000
一方面你提供了

461
00:17:24,000 --> 00:17:25,439
之前的状态和动作到你的

462
00:17:25,439 --> 00:17:26,959
转换

463
00:17:26,959 --> 00:17:30,480
然后将

464
00:17:30,480 --> 00:17:33,760
输出当前状态分布的模型

465
00:17:33,760 --> 00:17:35,919
，在这种情况下，该分布

466
00:17:35,919 --> 00:17:36,880
基本上被

467
00:17:36,880 --> 00:17:39,360
建模为多元高斯

468
00:17:39,360 --> 00:17:41,120
分布，因此

469
00:17:41,120 --> 00:17:43,600
基本上输出 o  f 神经网络将

470
00:17:43,600 --> 00:17:44,559


471
00:17:44,559 --> 00:17:47,360
是高斯的均值和标准差，

472
00:17:47,360 --> 00:17:48,240


473
00:17:48,240 --> 00:17:50,160
现在您基本上使用此

474
00:17:50,160 --> 00:17:51,760
分布来

475
00:17:51,760 --> 00:17:54,480
生成下一个时间步的样本，

476
00:17:54,480 --> 00:17:56,000
因此后验

477
00:17:56,000 --> 00:17:59,120
模型也可以作为

478
00:17:59,120 --> 00:18:01,360
前一个时间步的状态和动作的输入

479
00:18:01,360 --> 00:18:03,679
但除了当前

480
00:18:03,679 --> 00:18:04,559
观察之外

481
00:18:04,559 --> 00:18:08,559
，它还

482
00:18:08,559 --> 00:18:12,640
对当前时间步进行预测，并且在采样之后，

483
00:18:12,640 --> 00:18:14,160
您基本上有了似然模型

484
00:18:14,160 --> 00:18:16,320
，然后可以生成

485
00:18:16,320 --> 00:18:20,000
对结果的预测

486
00:18:20,000 --> 00:18:23,520
，然后将该状态放入

487
00:18:23,520 --> 00:18:26,160
下一个时间步，并且 这个故事

488
00:18:26,160 --> 00:18:26,880
重复了，

489
00:18:26,880 --> 00:18:29,360
所以我已经提到

490
00:18:29,360 --> 00:18:31,440
我们每个神经网络的输出基本上

491
00:18:31,440 --> 00:18:36,240
是一个多元高斯的 uh 的平均值和标准偏差，

492
00:18:36,240 --> 00:18:40,840
其中

493
00:18:40,840 --> 00:18:43,280
um 具有对角

494
00:18:43,280 --> 00:18:46,760
协方差矩阵，我们使用

495
00:18:46,760 --> 00:18:49,440
重新参数化技巧来生成

496
00:18:49,440 --> 00:18:50,960
样本，所以基本上

497
00:18:50,960 --> 00:18:54,000
我们生成 通过 uh 进行采样

498
00:18:54,000 --> 00:18:54,799


499
00:18:54,799 --> 00:18:57,280
，然后将标准偏差

500
00:18:57,280 --> 00:18:57,840
乘以

501
00:18:57,840 --> 00:19:00,799
一些标准正态噪声，这

502
00:19:00,799 --> 00:19:02,480
基本上可以让你

503
00:19:02,480 --> 00:19:05,360


504
00:19:05,360 --> 00:19:06,320


505
00:19:06,320 --> 00:19:08,960
如果你从模型中抽取样本，你也可以通过这个神经网络反向传播梯度

506
00:19:08,960 --> 00:19:12,640


507
00:19:14,240 --> 00:19:16,240
，当然，在下一个时间

508
00:19:16,240 --> 00:19:18,240
步，你只是传播样本，

509
00:19:18,240 --> 00:19:22,000
然后故事基本上会重复，

510
00:19:22,400 --> 00:19:25,280
所以创建这样一个模型

511
00:19:25,280 --> 00:19:26,240
基本上

512
00:19:26,240 --> 00:19:29,520
首先收集动作观察序列的数据集，

513
00:19:29,520 --> 00:19:32,880
这样你

514
00:19:32,880 --> 00:19:36,640
就可以使用你的代理了，要么

515
00:19:36,640 --> 00:19:39,679
让它在环境中随机生成序列，

516
00:19:39,679 --> 00:19:41,039
要么

517
00:19:41,039 --> 00:19:43,120
在一个真正的机器人的情况下，例如

518
00:19:43,120 --> 00:19:44,640
你在环境中自己驾驶它，

519
00:19:44,640 --> 00:19:47,679
同时记录

520
00:19:47,679 --> 00:19:50,320
动作和观察结果

521
00:19:50,320 --> 00:19:53,360
，虽然模型没有收敛，但

522
00:19:53,360 --> 00:19:56,400
您从数据集中采样一些子序列，您

523
00:19:56,400 --> 00:19:57,679


524
00:19:57,679 --> 00:20:00,799


525
00:20:00,799 --> 00:20:03,200
估计访问过的状态并

526
00:20:03,200 --> 00:20:04,000
重建

527
00:20:04,000 --> 00:20:06,640
所有观察结果，然后您

528
00:20:06,640 --> 00:20:08,400
基本上反向传播自由

529
00:20:08,400 --> 00:20:09,840
能损失，所以

530
00:20:09,840 --> 00:20:12,480
这是 与开始时的自由能相同的公式，

531
00:20:12,480 --> 00:20:14,400
所以一方面

532
00:20:14,400 --> 00:20:15,280
你的后神经

533
00:20:15,280 --> 00:20:18,080
输出之间存在 kl 分歧

534
00:20:18,080 --> 00:20:18,480


535
00:20:18,480 --> 00:20:21,120
l 网络和你之前的

536
00:20:21,120 --> 00:20:22,559
神经网络

537
00:20:22,559 --> 00:20:24,159
，另一方面，你

538
00:20:24,159 --> 00:20:26,799
有这个重建错误

539
00:20:26,799 --> 00:20:28,960
，它基本上衡量

540
00:20:28,960 --> 00:20:30,880
你重建实际

541
00:20:30,880 --> 00:20:31,840
服务的好坏程度

542
00:20:31,840 --> 00:20:34,720
，使用这个损失函数你只需

543
00:20:34,720 --> 00:20:35,440
更新

544
00:20:35,440 --> 00:20:38,960
你的真实网络的参数，

545
00:20:38,960 --> 00:20:41,919
你 基本上构建一个模型，

546
00:20:41,919 --> 00:20:42,799
一方面

547
00:20:42,799 --> 00:20:46,000
能够

548
00:20:46,000 --> 00:20:47,440
根据您的

549
00:20:47,440 --> 00:20:50,640
观察推断

550
00:20:50,640 --> 00:20:53,679


551
00:20:53,679 --> 00:20:54,960
您的当前

552
00:20:54,960 --> 00:20:57,039


553
00:20:57,039 --> 00:20:58,720


554
00:20:58,720 --> 00:21:01,440
状态 然后只是

555
00:21:01,440 --> 00:21:04,559
在状态空间计划中使用

556
00:21:04,559 --> 00:21:05,280


557
00:21:05,280 --> 00:21:08,080
如果我做这个动作会发生什么，它

558
00:21:08,080 --> 00:21:09,919
会给你一个

559
00:21:09,919 --> 00:21:13,840
分布在下一个状态基本上

560
00:21:13,919 --> 00:21:17,600
所以然后我们来到计划部分

561
00:21:17,600 --> 00:21:19,440
所以一旦你有了这个模型 你

562
00:21:19,440 --> 00:21:21,520
能用它来让你的代理做

563
00:21:21,520 --> 00:21:25,200
有用的有用的事情吗？所以

564
00:21:25,200 --> 00:21:28,240
我们将使用蒙特卡洛采样，所以

565
00:21:28,240 --> 00:21:29,200


566
00:21:29,200 --> 00:21:31,600
这些架构的限制之一

567
00:21:31,600 --> 00:21:33,039


568
00:21:33,039 --> 00:21:36,159
是 基本上我们只近似

569
00:21:36,159 --> 00:21:38,320
下一个状态的分布，所以

570
00:21:38,320 --> 00:21:40,000
给定来自前一个状态的样本，

571
00:21:40,000 --> 00:21:42,559
并给出

572
00:21:42,559 --> 00:21:43,840


573
00:21:43,840 --> 00:21:45,760
我们近似下一个阶段的分布的动作，

574
00:21:45,760 --> 00:21:46,880
但是

575
00:21:46,880 --> 00:21:49,200
我们也在训练期间采样，所以我们

576
00:21:49,200 --> 00:21:52,080
永远不会有一个

577
00:21:52,080 --> 00:21:54,720
好的分布 假设我们提前 10 步

578
00:21:54,720 --> 00:21:57,039
，

579
00:21:57,120 --> 00:21:59,919
以便预测它们的分布，以便

580
00:21:59,919 --> 00:22:01,280
在未来更进一步，

581
00:22:01,280 --> 00:22:03,679
我们通过

582
00:22:03,679 --> 00:22:04,320
多次

583
00:22:04,320 --> 00:22:07,200
采样来近似这些分布，所以对于

584
00:22:07,200 --> 00:22:08,240
我们想要成为的每个策略，

585
00:22:08,240 --> 00:22:11,600
呃，我们想要

586
00:22:11,600 --> 00:22:14,960
评估样本和轨迹，呃

587
00:22:14,960 --> 00:22:17,360
，所有这些 做相同的动作，但这是

588
00:22:17,360 --> 00:22:18,880
由于采样可能

589
00:22:18,880 --> 00:22:20,960
会给我们在未来状态和观察方面的不同结果，

590
00:22:20,960 --> 00:22:22,320


591
00:22:22,320 --> 00:22:24,880
所以对于每个时间步，

592
00:22:24,880 --> 00:22:26,880
我们有一堆状态和

593
00:22:26,880 --> 00:22:29,440
一堆预测观察

594
00:22:29,440 --> 00:22:31,679
，然后我们使用样本拟合高斯分布

595
00:22:31,679 --> 00:22:32,559


596
00:22:32,559 --> 00:22:35,760
均值和方差，然后我们

597
00:22:35,760 --> 00:22:38,400
估计预期的自由能

598
00:22:38,400 --> 00:22:39,760
如下，

599
00:22:39,760 --> 00:22:43,679
所以一方面，

600
00:22:43,679 --> 00:22:46,159
如果你记得

601
00:22:46,159 --> 00:22:47,120
s，我们就有这个尺度发散 核心

602
00:22:47,120 --> 00:22:50,240


603
00:22:50,240 --> 00:22:53,760
根据一些先验 呃

604
00:22:53,760 --> 00:22:56,320
一些先验的状态偏好，你的状态分布有多好，所以你

605
00:22:56,320 --> 00:22:57,520
用这个

606
00:22:57,520 --> 00:22:59,280
这是正常的，这是令人作呕的

607
00:22:59,280 --> 00:23:01,039
分布来计算

608
00:23:01,039 --> 00:23:03,520
相对于这些先验的凝胶散度

609
00:23:03,520 --> 00:23:05,600
另一方面，你有这个

610
00:23:05,600 --> 00:23:06,880
熵项

611
00:23:06,880 --> 00:23:10,080
这对这些状态的模糊性进行了评分，

612
00:23:10,080 --> 00:23:10,720


613
00:23:10,720 --> 00:23:12,960
所以在这里我们基本上使用然后

614
00:23:12,960 --> 00:23:14,720


615
00:23:14,720 --> 00:23:18,480


616
00:23:18,480 --> 00:23:21,280
在我们的轨迹中生成的观察结果的熵，我们还添加了一个

617
00:23:21,280 --> 00:23:22,159
比例因子

618
00:23:22,159 --> 00:23:25,600
行来权衡两个项

619
00:23:25,600 --> 00:23:28,720
，

620
00:23:28,720 --> 00:23:32,559
这允许你制作一个代理

621
00:23:32,640 --> 00:23:35,440
风险更大，如果它更

622
00:23:35,440 --> 00:23:36,080
重视

623
00:23:36,080 --> 00:23:39,280
及早实现偏好是否你

624
00:23:39,280 --> 00:23:40,640
也可以

625
00:23:40,640 --> 00:23:42,640
做一个更谨慎的代理让我们

626
00:23:42,640 --> 00:23:44,320
说那真的

627
00:23:44,320 --> 00:23:47,360
不想最终进入一些

628
00:23:47,360 --> 00:23:51,520
模棱两可的状态，关键是

629
00:23:51,520 --> 00:23:54,320
我们在这里也有这种递归的

630
00:23:54,320 --> 00:23:56,240
概念 因此，

631
00:23:56,240 --> 00:23:59,279
我们提前 k 个时间步进行此推出

632
00:23:59,279 --> 00:24:00,400


633
00:24:00,400 --> 00:24:02,559
，然后对于未来，您

634
00:24:02,559 --> 00:24:05,840
可以递归地

635
00:24:06,000 --> 00:24:08,240
展望未来，让我们看看 y

636
00:24:08,240 --> 00:24:10,400
和 and

637
00:24:10,400 --> 00:24:13,279
也从那时开始聚合预期能量

638
00:24:13,279 --> 00:24:14,240


639
00:24:14,240 --> 00:24:18,880
，让它更清晰一点，嗯，

640
00:24:18,880 --> 00:24:22,240
让我们试着更好地形象化它，

641
00:24:22,240 --> 00:24:26,240
所以假设在当前的某个时间步 d，

642
00:24:26,240 --> 00:24:27,679
你处于状态，

643
00:24:27,679 --> 00:24:29,919
那么基本上你所做的就是使用

644
00:24:29,919 --> 00:24:32,159
你的 过渡模型

645
00:24:32,159 --> 00:24:35,919
说好的，因为我遵循或 c1

646
00:24:35,919 --> 00:24:39,200
嗯，下一个状态是什么

647
00:24:39,200 --> 00:24:41,440
，你从分布中抽取一个样本，

648
00:24:41,440 --> 00:24:43,279
所以这是

649
00:24:43,279 --> 00:24:46,400
s d 加一，跟随 paul c1

650
00:24:46,400 --> 00:24:48,720
，这件事你可以重复 k

651
00:24:48,720 --> 00:24:50,080
次，所以我们

652
00:24:50,080 --> 00:24:52,799
我们 把这个 k 放进去只是为了有某种

653
00:24:52,799 --> 00:24:53,520


654
00:24:53,520 --> 00:24:57,840
um 一些动作的力分级

655
00:24:57,840 --> 00:25:01,120
比如说，在一个驾驶机器人的

656
00:25:01,120 --> 00:25:02,000


657
00:25:02,000 --> 00:25:05,039
情况下，每 10 毫秒切换一次动作可能没有意义，

658
00:25:05,039 --> 00:25:08,320


659
00:25:08,320 --> 00:25:08,559


660
00:25:08,559 --> 00:25:10,720
假设你决定向前行驶 你想

661
00:25:10,720 --> 00:25:12,559
继续前进至少

662
00:25:12,559 --> 00:25:14,159
一段时间，所以这基本上

663
00:25:14,159 --> 00:25:16,240
就是这个 k 的来源，所以你

664
00:25:16,240 --> 00:25:17,679
在

665
00:25:17,679 --> 00:25:21,360
一些时间步长上遵循相同的 uh 政策

666
00:25:21,360 --> 00:25:24,400
，你基本上对这个结束时间进行采样，

667
00:25:24,400 --> 00:25:25,039
所以

668
00:25:25,039 --> 00:25:28,240
你嗯，你重复

669
00:25:28,240 --> 00:25:31,520
这个过程 ess 结束时间，因此您

670
00:25:31,520 --> 00:25:35,760
现在可以在每个时间步长以及

671
00:25:35,760 --> 00:25:37,919
您认为

672
00:25:37,919 --> 00:25:40,320
在

673
00:25:40,320 --> 00:25:43,200
遵循第一个政策之后您将访问的那种状态的样本，然后如果您有

674
00:25:43,200 --> 00:25:45,520
第二个政策，您可以为该政策做同样的事情

675
00:25:45,520 --> 00:25:49,600
，嗯，所以在这个 案例 嗯，

676
00:25:49,600 --> 00:25:53,360
我们只考虑两个潜在的策略

677
00:25:53,360 --> 00:25:56,240
，例如 uh go left or go right

678
00:25:56,240 --> 00:25:56,640
let's say

679
00:25:56,640 --> 00:25:58,400
[Music]

680
00:25:58,400 --> 00:26:01,919
然后 of 在这一点上，所以在

681
00:26:01,919 --> 00:26:04,400
时间步 t 加上 k 我们基本上可以

682
00:26:04,400 --> 00:26:05,600
重复

683
00:26:05,600 --> 00:26:08,400
这个过程，然后说

684
00:26:08,400 --> 00:26:10,080
如果在 k 时间之后怎么办 步骤我

685
00:26:10,080 --> 00:26:13,279
切换策略，也许我首先

686
00:26:13,279 --> 00:26:14,480
必须向左走，

687
00:26:14,480 --> 00:26:17,760
然后再向右转，

688
00:26:17,840 --> 00:26:20,880
或者我必须向左转两次，

689
00:26:20,880 --> 00:26:22,400
所以基本上你重复这个

690
00:26:22,400 --> 00:26:26,240
过程，这你基本上可以

691
00:26:26,240 --> 00:26:29,520
继续添加到搜索树，只要

692
00:26:29,520 --> 00:26:30,960


693
00:26:30,960 --> 00:26:33,440
你 计算能力允许你

694
00:26:33,440 --> 00:26:35,600
这么说

695
00:26:37,200 --> 00:26:39,600
然后我们如何计算预期的

696
00:26:39,600 --> 00:26:40,720
自由能

697
00:26:40,720 --> 00:26:44,559
所以我们采用我们的公式

698
00:26:44,559 --> 00:26:46,799
所以基本上我们所做的是在每个时间

699
00:26:46,799 --> 00:26:47,600
步

700
00:26:47,600 --> 00:26:50,640
我们首先使用似然模型来

701
00:26:50,640 --> 00:26:51,360
预测

702
00:26:51,360 --> 00:26:53,840
什么是观察值 我期望

703
00:26:53,840 --> 00:26:55,679
在这些状态下的离子，

704
00:26:55,679 --> 00:26:58,640
然后你看看你

705
00:26:58,640 --> 00:27:00,640
在某个时间步长的所有状态样本，

706
00:27:00,640 --> 00:27:03,520
然后这给你这个呃

707
00:27:03,520 --> 00:27:04,240


708
00:27:04,240 --> 00:27:06,320


709
00:27:06,320 --> 00:27:07,600
状态

710
00:27:07,600 --> 00:27:10,159
和观察的近似高斯分布，所以你把它们代

711
00:27:10,159 --> 00:27:11,279
入公式

712
00:27:11,279 --> 00:27:14,000
然后这个 给你一个数字

713
00:27:14,000 --> 00:27:15,440
，说这是

714
00:27:15,440 --> 00:27:18,880
预期的自由能，如果我认为我会

715
00:27:18,880 --> 00:27:21,679
处于 t 加 k 状态，我将

716
00:27:21,679 --> 00:27:23,840
遵循

717
00:27:23,840 --> 00:27:26,880
uh 之后的政策一，然后

718
00:27:26,880 --> 00:27:28,240
基本上你可以

719
00:27:28,240 --> 00:27:30,559
为这些子中的每一个执行此操作

720
00:27:30,559 --> 00:27:31,840
分支

721
00:27:31,840 --> 00:27:33,760
，这就是递归

722
00:27:33,760 --> 00:27:36,640
进入的地方，所以我们

723
00:27:36,640 --> 00:27:39,520
基本上说得很好

724
00:27:39,520 --> 00:27:41,679


725
00:27:41,679 --> 00:27:45,039


726
00:27:45,039 --> 00:27:48,320


727
00:27:48,320 --> 00:27:51,360


728
00:27:51,360 --> 00:27:53,120


729
00:27:53,120 --> 00:27:56,640
政策

730
00:27:56,640 --> 00:27:57,120
一和

731
00:27:57,120 --> 00:28:00,080
政策二的自由能根据呃

732
00:28:00,080 --> 00:28:01,440


733
00:28:01,440 --> 00:28:04,480
使用这个softmax函数提供的费率，所以

734
00:28:04,480 --> 00:28:05,440


735
00:28:05,440 --> 00:28:09,200
如果政策一的其中一个有一个非常非常低的

736
00:28:09,200 --> 00:28:11,520
预期自由能比较 d 脉冲

737
00:28:11,520 --> 00:28:12,240
c2

738
00:28:12,240 --> 00:28:14,720
然后基本上

739
00:28:14,720 --> 00:28:17,360
只添加策略一的预期自由能，

740
00:28:17,360 --> 00:28:20,480
如果它们是

741
00:28:20,480 --> 00:28:20,880
相同的，

742
00:28:20,880 --> 00:28:24,159
那么它们都将具有

743
00:28:24,159 --> 00:28:26,960
0.5 的权重，或者如果另一个是

744
00:28:26,960 --> 00:28:28,720
明显的赢家，那么它将主要

745
00:28:28,720 --> 00:28:31,360
是 这个东西的贡献，但是所以

746
00:28:31,360 --> 00:28:34,719
我们基本上把这些结合起来，

747
00:28:35,039 --> 00:28:37,440
假设你的代理人

748
00:28:37,440 --> 00:28:39,200
那时也会选择

749
00:28:39,200 --> 00:28:42,799
自由能最少的策略，

750
00:28:42,799 --> 00:28:43,360


751
00:28:43,360 --> 00:28:45,679
所以现在我们基本上

752
00:28:45,679 --> 00:28:47,919
可以估计未来的预期自由能

753
00:28:47,919 --> 00:28:50,080
是多少 我们在时间

754
00:28:50,080 --> 00:28:52,559
步 d 加上 3

755
00:28:52,559 --> 00:28:55,440
然后我们可以进一步 uh 上升到

756
00:28:55,440 --> 00:28:56,240


757
00:28:56,240 --> 00:28:59,520
3 所以对于每个分支的 um

758
00:28:59,520 --> 00:29:01,039
我们将使用公式的第一部分

759
00:29:01,039 --> 00:29:02,799
来

760
00:29:02,799 --> 00:29:05,440
估计这些高斯 uh 来

761
00:29:05,440 --> 00:29:07,200
计算大风散度和

762
00:29:07,200 --> 00:29:08,159
熵 术语

763
00:29:08,159 --> 00:29:10,480
，然后将其与我们

764
00:29:10,480 --> 00:29:12,000
已经

765
00:29:12,000 --> 00:29:15,200
为树的其余部分所拥有

766
00:29:15,200 --> 00:29:16,799
的基本

767
00:29:16,799 --> 00:29:19,600


768
00:29:19,600 --> 00:29:20,399


769
00:29:20,399 --> 00:29:23,760
相加，这是呃，这非常类似于我认为呃呃所谓的弗里斯滕呃提议的

770
00:29:23,760 --> 00:29:25,200
诡辩者 icated

771
00:29:25,200 --> 00:29:28,399
uh inference paper 所以基本上这是

772
00:29:28,399 --> 00:29:31,760
在未来的每一步，你

773
00:29:31,760 --> 00:29:32,399


774
00:29:32,399 --> 00:29:35,600
只考虑

775
00:29:35,600 --> 00:29:36,480


776
00:29:36,480 --> 00:29:39,520
你认为基本上是

777
00:29:39,520 --> 00:29:41,279
最好的分支的自由能，

778
00:29:41,279 --> 00:29:43,520
所以最后你会得到一个

779
00:29:43,520 --> 00:29:44,880
预期的自由能 为

780
00:29:44,880 --> 00:29:47,120
你的两个政策，然后你

781
00:29:47,120 --> 00:29:49,520


782
00:29:49,600 --> 00:29:52,840
选择最好的一个并开始采取

783
00:29:52,840 --> 00:29:54,799
相应的行动，所以

784
00:29:54,799 --> 00:29:57,679
我现在转向 ozon，他将提供

785
00:29:57,679 --> 00:29:59,600
更多关于

786
00:29:59,600 --> 00:30:01,679
我们所做的各种实验的细节，希望能

787
00:30:01,679 --> 00:30:03,840
提供更多关于这

788
00:30:03,840 --> 00:30:08,240
在实践中如何运作的见解 所以把它拿走

789
00:30:08,240 --> 00:30:11,360
是的，嗨，

790
00:30:11,360 --> 00:30:14,959
我有一些回声，

791
00:30:15,679 --> 00:30:18,159
也许现在已经解决了，是的，听起来不错，

792
00:30:18,159 --> 00:30:18,880
谢谢，

793
00:30:18,880 --> 00:30:22,399
好吧，所以我将简要介绍

794
00:30:22,399 --> 00:30:24,480
一下我们的初步经验，呃

795
00:30:24,480 --> 00:30:25,600


796
00:30:25,600 --> 00:30:28,799
实验，这些是我们像过去一样做的实验

797
00:30:28,799 --> 00:30:33,520
或者两年

798
00:30:33,520 --> 00:30:35,919
，所以我们

799
00:30:35,919 --> 00:30:38,480
做和报告的第一个实验是山地车

800
00:30:38,480 --> 00:30:41,760
，我认为这是一个相当知名的基准，

801
00:30:41,760 --> 00:30:42,480


802
00:30:42,480 --> 00:30:45,120
所以目标是让这个在

803
00:30:45,120 --> 00:30:46,960
驱动的汽车下，所以它没有

804
00:30:46,960 --> 00:30:48,640
足够的 有力量到达

805
00:30:48,640 --> 00:30:50,880
手山的顶部，但无论如何你都想到达

806
00:30:50,880 --> 00:30:52,159
它，

807
00:30:52,159 --> 00:30:56,559
所以理想情况下，你的代理应该在这里学习

808
00:30:56,559 --> 00:30:59,120
，它应该首先

809
00:30:59,120 --> 00:31:00,159
回到左边

810
00:31:00,159 --> 00:31:02,399
以获得足够的动力，

811
00:31:02,399 --> 00:31:03,679
这样它就可以

812
00:31:03,679 --> 00:31:06,480
爬上右边更陡峭的山峰

813
00:31:06,480 --> 00:31:06,960


814
00:31:06,960 --> 00:31:08,640
即使这是一个如此低

815
00:31:08,640 --> 00:31:10,080
维的问题，它只有

816
00:31:10,080 --> 00:31:11,519
位置和速度，

817
00:31:11,519 --> 00:31:13,120
它实际上是一个非常有趣

818
00:31:13,120 --> 00:31:14,559
的实验基准，

819
00:31:14,559 --> 00:31:16,720
因为没有

820
00:31:16,720 --> 00:31:19,039
贪婪的解决方案，所以任何

821
00:31:19,039 --> 00:31:21,760
只想立即实现其偏好的代理

822
00:31:21,760 --> 00:31:23,360
都会失败，因为它

823
00:31:23,360 --> 00:31:23,919
会 总是

824
00:31:23,919 --> 00:31:27,279
无法开车上山

825
00:31:27,279 --> 00:31:29,519
嗯，对于我们的实验，我们让它

826
00:31:29,519 --> 00:31:32,080
变得更加困难

827
00:31:32,080 --> 00:31:34,559
我们使完全可观察的山地车

828
00:31:34,559 --> 00:31:36,799
部分可观察，

829
00:31:36,799 --> 00:31:38,480
所以我们所做的是我们省略了

830
00:31:38,480 --> 00:31:40,720
速度信息

831
00:31:40,720 --> 00:31:43,200
，只提供了一些

832
00:31:43,200 --> 00:31:44,640
对实际位置的嘈杂估计，

833
00:31:44,640 --> 00:31:47,279
所以 代理实际上必须学习两

834
00:31:47,279 --> 00:31:49,120
件事它必须首先了解

835
00:31:49,120 --> 00:31:49,519
它的

836
00:31:49,519 --> 00:31:52,559
精确位置是什么，然后还要了解

837
00:31:52,559 --> 00:31:52,960
这个

838
00:31:52,960 --> 00:31:56,080
位置如何 rel 通过

839
00:31:56,080 --> 00:32:00,000
它的速度吸收动量，然后

840
00:32:00,000 --> 00:32:02,240
如果我们从设置开始，我们训练

841
00:32:02,240 --> 00:32:03,039


842
00:32:03,039 --> 00:32:06,240
蒂姆早些时候解释过的模型，嗯

843
00:32:06,240 --> 00:32:09,600
，它最基本的形式，你实际上可以

844
00:32:09,600 --> 00:32:10,480
学习

845
00:32:10,480 --> 00:32:14,240
一个状态空间，它非常模仿这些

846
00:32:14,240 --> 00:32:17,919
物理约束 系统

847
00:32:17,919 --> 00:32:20,880
通过最小化能量，所以如果你看

848
00:32:20,880 --> 00:32:21,519


849
00:32:21,519 --> 00:32:25,279
最右边的图，你会看到，

850
00:32:25,279 --> 00:32:28,880
嗯，你会看到这个正弦的 uh

851
00:32:28,880 --> 00:32:31,919
状态空间维度，这些

852
00:32:31,919 --> 00:32:35,679


853
00:32:35,679 --> 00:32:36,720


854
00:32:36,720 --> 00:32:39,360
在下图中非常模仿现实世界的实际观察结果，所以你可以在下图中

855
00:32:39,360 --> 00:32:40,720
看到 下面的图像我们有

856
00:32:40,720 --> 00:32:42,960
绿色的基本事实，它是

857
00:32:42,960 --> 00:32:44,240
通过

858
00:32:44,240 --> 00:32:47,440
卡片位置的实际轨迹，然后是

859
00:32:47,440 --> 00:32:50,080
我们的状态转换模型估计，所以

860
00:32:50,080 --> 00:32:54,159
我们在没有观察的情况下对位置的先前估计

861
00:32:54,159 --> 00:32:57,200
，然后在

862
00:32:57,200 --> 00:33:01,279
蓝线中，这有点难 看到

863
00:33:01,279 --> 00:33:03,360
您可以看到相同的估计，但现在

864
00:33:03,360 --> 00:33:05,200
通过观察进行了校正，因此它

865
00:33:05,200 --> 00:33:06,720
实际上只是后验模型

866
00:33:06,720 --> 00:33:08,320
输出

867
00:33:08,320 --> 00:33:10,399
，您可以看到这些形状

868
00:33:10,399 --> 00:33:11,919
在状态空间

869
00:33:11,919 --> 00:33:14,399
中返回 本身并没有说太多，

870
00:33:14,399 --> 00:33:15,679
但它至少给了你

871
00:33:15,679 --> 00:33:18,720
一种模糊的想法，至少

872
00:33:18,720 --> 00:33:20,559
状态空间正在捕捉

873
00:33:20,559 --> 00:33:22,559
与问题相关的东西我认为

874
00:33:22,559 --> 00:33:24,000
还有一个

875
00:33:24,000 --> 00:33:27,120
动画是的，所以

876
00:33:27,120 --> 00:33:29,039
是的，这和我说的结论是一样的

877
00:33:29,039 --> 00:33:31,200
现在你可以预测未来，

878
00:33:31,200 --> 00:33:34,880
正如你在橙色线中看到的那样，

879
00:33:34,880 --> 00:33:37,440
它现在似乎正在学习其状态空间中的速度，

880
00:33:37,440 --> 00:33:38,720


881
00:33:38,720 --> 00:33:42,320
如果你可以转到下一张幻灯片，

882
00:33:43,200 --> 00:33:46,799
嗯，是的，现在我们想

883
00:33:46,799 --> 00:33:50,240
真正弄清楚我们如何使用

884
00:33:50,240 --> 00:33:53,200
我们为活跃的婴儿学习的这个模型

885
00:33:53,200 --> 00:33:53,760


886
00:33:53,760 --> 00:33:56,240
，通常是在我们的 audi 中，

887
00:33:56,240 --> 00:33:57,279


888
00:33:57,279 --> 00:33:59,919
对于开车上山的奖励很少，但

889
00:33:59,919 --> 00:34:01,919
在我们最初的实验中，我们

890
00:34:01,919 --> 00:34:02,640


891
00:34:02,640 --> 00:34:06,000
对智能体如何从

892
00:34:06,000 --> 00:34:09,440
人类观察或演示中学习更感兴趣，所以

893
00:34:09,440 --> 00:34:12,480
我们记录了七个我认为是的 或者 5

894
00:34:12,480 --> 00:34:13,440
对不起

895
00:34:13,440 --> 00:34:16,399
5 um 人类在环境中的部署，

896
00:34:16,399 --> 00:34:18,079
就像带着卡片开车一样，

897
00:34:18,079 --> 00:34:20,800
所以你先左右走

898
00:34:20,800 --> 00:34:24,000
，然后我们将这些轨迹

899
00:34:24,000 --> 00:34:25,119
通过我们的模型

900
00:34:25,119 --> 00:34:27,760
一起推送到我们的通道 gh 我们的后验

901
00:34:27,760 --> 00:34:28,960
模型以获得首选状态

902
00:34:28,960 --> 00:34:30,159
分布，

903
00:34:30,159 --> 00:34:33,280
因此在此图中，如果您遵循这些轨迹，您可以看到

904
00:34:33,280 --> 00:34:35,599
八个不同的维度如何

905
00:34:35,599 --> 00:34:36,480
随着

906
00:34:36,480 --> 00:34:39,520
时间的推移而演变，

907
00:34:39,520 --> 00:34:41,359
因此在传播过程中，当然会给

908
00:34:41,359 --> 00:34:43,040
您在每个时间

909
00:34:43,040 --> 00:34:44,800
点的

910
00:34:44,800 --> 00:34:49,520
标准偏差 那个状态值，然后

911
00:34:49,520 --> 00:34:52,560
如果你在这个

912
00:34:52,560 --> 00:34:55,760
首选状态分布中使用这些，你

913
00:34:55,760 --> 00:35:00,400
计算g或者这个，甚至只是

914
00:35:00,400 --> 00:35:02,560
你的后验分布和

915
00:35:02,560 --> 00:35:03,839
你的

916
00:35:03,839 --> 00:35:06,880
首选分布之间的kl散度对于不同的

917
00:35:06,880 --> 00:35:08,320
轨迹随着时间的推移

918
00:35:08,320 --> 00:35:11,359
，你会听到每一个不同的颜色每一个

919
00:35:11,359 --> 00:35:13,200
不同的轨迹 是

920
00:35:13,200 --> 00:35:16,240
环境中的不同部署或环境的假想

921
00:35:16,240 --> 00:35:17,680
部署

922
00:35:17,680 --> 00:35:19,359
，您可以看到您实际上可以使用

923
00:35:19,359 --> 00:35:21,520
此优先分布来

924
00:35:21,520 --> 00:35:24,560
根据

925
00:35:24,560 --> 00:35:27,440
最低自由能对轨迹进行排名，因此您会看到

926
00:35:27,440 --> 00:35:28,720
蓝色

927
00:35:28,720 --> 00:35:31,200
曲线是唯一

928
00:35:31,200 --> 00:35:31,839
到达顶部的曲线

929
00:35:31,839 --> 00:35:33,680
也是模型似乎

930
00:35:33,680 --> 00:35:36,160
更喜欢的那个

931
00:35:36,720 --> 00:35:39,839
，然后在下一张幻灯片中，是的，

932
00:35:39,839 --> 00:35:43,040
我们实验了一个

933
00:35:43,040 --> 00:35:44,800
就实际自由能而言，这意味着什么，所以

934
00:35:44,800 --> 00:35:48,720
也用熵

935
00:35:48,960 --> 00:35:52,240
补偿，我们在这里所做的是，如果

936
00:35:52,240 --> 00:35:55,040
我们让代理观察世界

937
00:35:55,040 --> 00:35:56,880
一个时间步长，那么我们给它一个初始

938
00:35:56,880 --> 00:35:59,119
观察以获得

939
00:35:59,119 --> 00:36:02,160
一种引导 潜在样本

940
00:36:02,160 --> 00:36:03,839
，然后我们将仅使用先前的

941
00:36:03,839 --> 00:36:06,240
模型来想象

942
00:36:06,240 --> 00:36:09,119
如果您遵循某些策略会发生什么，

943
00:36:09,119 --> 00:36:10,560


944
00:36:10,560 --> 00:36:13,440
所以在这里我们考虑了三个策略，或者

945
00:36:13,440 --> 00:36:13,760
像

946
00:36:13,760 --> 00:36:15,440
呃两个可能的策略，您可以

947
00:36:15,440 --> 00:36:17,119
在三个时间步长切换，

948
00:36:17,119 --> 00:36:19,760
因此您可以

949
00:36:19,760 --> 00:36:20,880
左右移动 左

950
00:36:20,880 --> 00:36:23,599
等等，或者你可以从右开始，然后

951
00:36:23,599 --> 00:36:26,160
这些是蓝色曲线

952
00:36:26,160 --> 00:36:27,839
，我们看到如果没有

953
00:36:27,839 --> 00:36:29,680
初始速度，

954
00:36:29,680 --> 00:36:33,200
那么你会看到

955
00:36:33,200 --> 00:36:35,920
代理想象左右右的最优策略

956
00:36:35,920 --> 00:36:37,359
，

957
00:36:37,359 --> 00:36:40,400
所以首先向上走 离开然后直接

958
00:36:40,400 --> 00:36:43,440
冲向顶部

959
00:36:43,440 --> 00:36:45,040
嗯，实际上左边的点差最少

960
00:36:45,040 --> 00:36:46,720


961
00:36:46,720 --> 00:36:47,680


962
00:36:47,680 --> 00:36:49,440


963
00:36:49,440 --> 00:36:51,280


964
00:36:51,280 --> 00:36:54,160
s

965
00:36:54,160 --> 00:36:54,400
那

966
00:36:54,400 --> 00:36:59,280
首先向右，然后你会看到由于缺乏初始速度，

967
00:36:59,280 --> 00:37:01,440
仍然有一点点并且没有

968
00:37:01,440 --> 00:37:02,480
接近没有点差

969
00:37:02,480 --> 00:37:04,640
，

970
00:37:04,640 --> 00:37:06,320
但是代理已经知道

971
00:37:06,320 --> 00:37:09,760


972
00:37:09,760 --> 00:37:13,119
如果你去下一个，现在不可能到达顶部 幻灯片

973
00:37:13,119 --> 00:37:15,200
呃幻灯片 所以在这里我们做

974
00:37:15,200 --> 00:37:16,640
同样的实验，

975
00:37:16,640 --> 00:37:19,280
但是我们添加了一些随机的初始速度

976
00:37:19,280 --> 00:37:21,040
，我们再次让代理观察

977
00:37:21,040 --> 00:37:22,800
世界一个时间步

978
00:37:22,800 --> 00:37:24,800
，然后根据与以前相同的

979
00:37:24,800 --> 00:37:26,960
策略进行计划

980
00:37:26,960 --> 00:37:29,280
，首先你会看到

981
00:37:29,280 --> 00:37:30,800


982
00:37:30,800 --> 00:37:32,960
代理在其相信的结果上有很多更大的

983
00:37:32,960 --> 00:37:34,640
差异，这是由于

984
00:37:34,640 --> 00:37:38,160


985
00:37:38,160 --> 00:37:41,200
初始速度是多少的外部额外不确定性，而且

986
00:37:41,200 --> 00:37:43,680
这个初始速度可能会使

987
00:37:43,680 --> 00:37:44,640
以前

988
00:37:44,640 --> 00:37:47,599
不可行的政策变得可行，正如你

989
00:37:47,599 --> 00:37:48,880
在底部看到的那样，因为

990
00:37:48,880 --> 00:37:51,119
现在如果 代理认为是的，我的初始

991
00:37:51,119 --> 00:37:52,640
速度足够高，

992
00:37:52,640 --> 00:37:55,680
即使使用了更

993
00:37:55,680 --> 00:37:57,200
次优的策略之一

994
00:37:57,200 --> 00:37:58,640
，我仍然有可能达到

995
00:37:58,640 --> 00:38:01,200


996
00:38:01,359 --> 00:38:04,640
顶峰，如果您转到下一张幻灯片，

997
00:38:04,640 --> 00:38:06,320
请

998
00:38:06,320 --> 00:38:08,640
在这里我们 然后可以看到这个在行动中，所以

999
00:38:08,640 --> 00:38:10,320
这个动画

1000
00:38:10,320 --> 00:38:13,839
我们将想象的轨迹折叠

1001
00:38:13,839 --> 00:38:14,400
到实际的

1002
00:38:14,400 --> 00:38:18,560
轨迹，你会看到，

1003
00:38:18,560 --> 00:38:20,000
如果我们可以在开始时再次播放它

1004
00:38:20,000 --> 00:38:22,560
，

1005
00:38:22,560 --> 00:38:24,400
它相信更多的红色策略将

1006
00:38:24,400 --> 00:38:26,160
到达顶部，然后

1007
00:38:26,160 --> 00:38:29,280
随着它获得 更多动力哦，

1008
00:38:29,280 --> 00:38:30,960
它会相信所有蓝色政策

1009
00:38:30,960 --> 00:38:32,960
都会达到顶峰，甚至它也会

1010
00:38:32,960 --> 00:38:34,160
知道如果我现在

1011
00:38:34,160 --> 00:38:37,119
向左走所以我减速然后我不太

1012
00:38:37,119 --> 00:38:37,680
可能

1013
00:38:37,680 --> 00:38:41,680
达到顶峰所以我认为是的，

1014
00:38:41,680 --> 00:38:43,839
所以你现在可以看到他知道红色

1015
00:38:43,839 --> 00:38:46,720
不会达到顶峰

1016
00:38:46,720 --> 00:38:50,240
，是的，

1017
00:38:50,400 --> 00:38:52,560
嗯，然后

1018
00:38:52,560 --> 00:38:53,760
我们在此基础上进行的另一个实验

1019
00:38:53,760 --> 00:38:56,880
是，如果我们采用相同的方法，但

1020
00:38:56,880 --> 00:38:57,680
现在

1021
00:38:57,680 --> 00:39:00,240
我们转移到我们想要解决的问题类型的任务上，

1022
00:39:00,240 --> 00:39:01,760


1023
00:39:01,760 --> 00:39:02,960


1024
00:39:02,960 --> 00:39:06,000
所以你无法建模的高维呃观察

1025
00:39:06,000 --> 00:39:07,280
用手，

1026
00:39:07,280 --> 00:39:09,280
所以我们采取了另一个开放的 agm

1027
00:39:09,280 --> 00:39:10,720
环境，

1028
00:39:10,720 --> 00:39:14,240
赛车手，这里的目标是

1029
00:39:14,240 --> 00:39:16,720
驾驶红牌，正如你在右边的高分辨率图像上看到的那样

1030
00:39:16,720 --> 00:39:18,079


1031
00:39:18,079 --> 00:39:21,599
，在路上

1032
00:39:21,599 --> 00:39:25,040
，只要你能 d 然后我们

1033
00:39:25,040 --> 00:39:28,480
在一些人类演示上训练我们

1034
00:39:28,480 --> 00:39:31,760
的模型，然后你可以

1035
00:39:31,760 --> 00:39:32,480
看到

1036
00:39:32,480 --> 00:39:34,000
在右边的重建图像中，

1037
00:39:34,000 --> 00:39:36,800
它甚至已经在少数

1038
00:39:36,800 --> 00:39:39,280
可以学习预测的观察结果中，

1039
00:39:39,280 --> 00:39:40,880


1040
00:39:40,880 --> 00:39:42,560
所以我们做了完全相同的事情

1041
00:39:42,560 --> 00:39:44,960
之前，我认为这是一个动画，

1042
00:39:44,960 --> 00:39:46,720


1043
00:39:46,720 --> 00:39:49,760
是的，所以如果你然后使用

1044
00:39:49,760 --> 00:39:51,520
蒂姆在这张小卡片上解释的计划树，

1045
00:39:51,520 --> 00:39:53,119


1046
00:39:53,119 --> 00:39:55,440
它就会

1047
00:39:55,440 --> 00:39:56,160


1048
00:39:56,160 --> 00:39:58,240
知道道路，所以灰色区域很

1049
00:39:58,240 --> 00:40:01,200
重要，它应该留在这个

1050
00:40:01,200 --> 00:40:04,240
现在这个代理有点贪心，

1051
00:40:04,240 --> 00:40:05,440
因为它试图

1052
00:40:05,440 --> 00:40:08,560
走捷径以在

1053
00:40:08,560 --> 00:40:11,839
灰色部分上更快，你可以在这里看到，

1054
00:40:12,640 --> 00:40:15,440
好吧，如果我们可以转到下一张幻灯片，

1055
00:40:15,440 --> 00:40:16,960


1056
00:40:16,960 --> 00:40:20,079
也许现在这样，还有一个重要的一点

1057
00:40:20,079 --> 00:40:21,200
是

1058
00:40:21,200 --> 00:40:24,400
我们的主动入口

1059
00:40:24,400 --> 00:40:25,760
基于模型的方法

1060
00:40:25,760 --> 00:40:29,200
um 似乎比 uh 的

1061
00:40:29,200 --> 00:40:30,400


1062
00:40:30,400 --> 00:40:32,319
数据效率高得多，它似乎比基线 rl 代理的数据效率高

1063
00:40:32,319 --> 00:40:33,839
得多，

1064
00:40:33,839 --> 00:40:37,280
所以我们采用了 dqm，

1065
00:40:37,280 --> 00:40:39,359
因为这也是一种能够实现 com 的非策略

1066
00:40:39,359 --> 00:40:40,480
算法

1067
00:40:40,480 --> 00:40:44,160
削减它有点

1068
00:40:44,160 --> 00:40:46,560
类似于我们的方法，正如你

1069
00:40:46,560 --> 00:40:47,200
在

1070
00:40:47,200 --> 00:40:51,119
第一张图中看到的那样，对于安装车，

1071
00:40:51,119 --> 00:40:54,800
我们的模型很快

1072
00:40:54,800 --> 00:40:58,160
，很抱歉我们的模型是

1073
00:40:58,160 --> 00:40:59,440
橙色的，

1074
00:40:59,440 --> 00:41:03,200
我们的 mo 很快就知道至少有一些

1075
00:41:03,200 --> 00:41:04,720
方法可以到达顶部 然后

1076
00:41:04,720 --> 00:41:06,160


1077
00:41:06,160 --> 00:41:07,119


1078
00:41:07,119 --> 00:41:09,839
由于奖励的稀疏性，它只是改善了微笑

1079
00:41:09,839 --> 00:41:11,040
dqn 无法

1080
00:41:11,040 --> 00:41:14,560
快速学习，即使在进行了

1081
00:41:14,560 --> 00:41:16,640
1000 倍以上 1000 倍以上的

1082
00:41:16,640 --> 00:41:17,920
观察之后，它本身

1083
00:41:17,920 --> 00:41:20,160
也无法爬山

1084
00:41:20,160 --> 00:41:22,079
，甚至对于赛车手来说 更

1085
00:41:22,079 --> 00:41:22,560
糟糕的

1086
00:41:22,560 --> 00:41:26,319
是，我们在这里训练了 7 或 10 次

1087
00:41:26,319 --> 00:41:29,440
uh 部署，我们立即

1088
00:41:29,440 --> 00:41:31,760
能够获得 600 的奖励，而 dqn

1089
00:41:31,760 --> 00:41:35,920


1090
00:41:35,920 --> 00:41:38,079
即使在环境中进行了数千次部署后也无法获得相同水平的性能

1091
00:41:38,079 --> 00:41:39,359
，

1092
00:41:39,359 --> 00:41:42,640
所以如果我们可以

1093
00:41:42,640 --> 00:41:43,680
去 到下一张幻灯片

1094
00:41:43,680 --> 00:41:46,720
是的，然后我今天要讨论的最后一个实验

1095
00:41:46,720 --> 00:41:49,440


1096
00:41:49,440 --> 00:41:52,560
是机器人导航

1097
00:41:52,560 --> 00:41:55,680
或者更准确的机器人控制，所以

1098
00:41:55,680 --> 00:41:56,319
在这里我们使用

1099
00:41:56,319 --> 00:41:59,359
了 kuka 平台并安装了一些

1100
00:41:59,359 --> 00:42:01,200
传感器 最重要的是

1101
00:42:01,200 --> 00:42:03,839
，然后还可以放在笔记本电脑

1102
00:42:03,839 --> 00:42:06,800
上进行一些计算，

1103
00:42:06,800 --> 00:42:09,680
嗯，我认为传感器

1104
00:42:09,680 --> 00:42:11,200
与我们现在要讨论的内容并不真正相关，

1105
00:42:11,200 --> 00:42:12,960


1106
00:42:12,960 --> 00:42:15,119
所以我们开车到膝上的机器人身边

1107
00:42:15,119 --> 00:42:16,800
你可以在这部电影中看到，

1108
00:42:16,800 --> 00:42:19,040
就像使用操纵杆一样并

1109
00:42:19,040 --> 00:42:22,720
捕获了很多数据，我们只是用机器人

1110
00:42:22,720 --> 00:42:25,599
在过道上上下行驶，

1111
00:42:25,599 --> 00:42:28,880
现在这个环境

1112
00:42:28,880 --> 00:42:31,440
对机器人来说也有点挑战，因为所有

1113
00:42:31,440 --> 00:42:32,319
这些过道

1114
00:42:32,319 --> 00:42:36,160
都非常相似，就像机器人

1115
00:42:36,160 --> 00:42:38,400
知道 如果是过道，一两个通道

1116
00:42:38,400 --> 00:42:39,839
几乎是一样的，这台机器

1117
00:42:39,839 --> 00:42:41,359
很难理解，

1118
00:42:41,359 --> 00:42:45,520
所以在这张幻灯片中，你会

1119
00:42:45,520 --> 00:42:47,359
看到录音的样子，所以你

1120
00:42:47,359 --> 00:42:49,200
有一个骑手，一个

1121
00:42:49,200 --> 00:42:52,400
打火机和雷达脚，还有一些图像

1122
00:42:52,400 --> 00:42:54,960
是的，对不起，蒂姆 现在是正确的

1123
00:42:54,960 --> 00:42:56,240
幻灯片

1124
00:42:56,240 --> 00:42:59,280
，然后目标是

1125
00:42:59,280 --> 00:43:03,040
再次训练一个模型，该模型将能够

1126
00:43:03,040 --> 00:43:04,400


1127
00:43:04,400 --> 00:43:07,200
为机器人生成未来的观察结果我

1128
00:43:07,200 --> 00:43:08,319
不知道幻灯片上是否有动画

1129
00:43:08,319 --> 00:43:09,200


1130
00:43:09,200 --> 00:43:11,680
所以是的所以你看到了第一个

1131
00:43:11,680 --> 00:43:12,880
高分辨率 图片  这是真正的

1132
00:43:12,880 --> 00:43:13,839
观察结果

1133
00:43:13,839 --> 00:43:16,640
，这就是模型认为

1134
00:43:16,640 --> 00:43:17,760


1135
00:43:17,760 --> 00:43:20,079
如果机器人首先右转然后

1136
00:43:20,079 --> 00:43:22,319
继续驾驶

1137
00:43:22,319 --> 00:43:25,359
你在几帧前看到的小鬼神器会发生的事情

1138
00:43:25,359 --> 00:43:28,560
，所以是的，我们将

1139
00:43:28,560 --> 00:43:28,960
首先

1140
00:43:28,960 --> 00:43:32,000
再次查看它，所以我们 开车然后它

1141
00:43:32,000 --> 00:43:33,760
会转动突然你会看到一个

1142
00:43:33,760 --> 00:43:34,240
鬼

1143
00:43:34,240 --> 00:43:38,880
他们出现嗯

1144
00:43:38,880 --> 00:43:41,920
这是因为模型

1145
00:43:41,920 --> 00:43:43,599
实际上并不知道会发生什么它只能

1146
00:43:43,599 --> 00:43:44,240


1147
00:43:44,240 --> 00:43:47,440
根据它之前

1148
00:43:47,440 --> 00:43:49,520
在模型中学习的经验来尝试猜测并且

1149
00:43:49,520 --> 00:43:51,119
有很多人

1150
00:43:51,119 --> 00:43:52,079
在数据集中四处走动，

1151
00:43:52,079 --> 00:43:54,880
所以有可能有人

1152
00:43:54,880 --> 00:43:56,079
会走在那里，

1153
00:43:56,079 --> 00:43:58,720
所以它可能会想象

1154
00:43:58,720 --> 00:44:00,480
有人在那里，

1155
00:44:00,480 --> 00:44:04,319
然后也许如果我们转到下一张幻灯片，

1156
00:44:04,319 --> 00:44:07,520
嗯，这也是一个动画，

1157
00:44:07,520 --> 00:44:09,280
所以在这里你可以看到例如如何

1158
00:44:09,280 --> 00:44:12,160
这些假想的样本有偏差

1159
00:44:12,160 --> 00:44:13,760
，这也是我们需要

1160
00:44:13,760 --> 00:44:16,319
这种抽样的原因，所以不同的

1161
00:44:16,319 --> 00:44:18,240
抽样和规划树有

1162
00:44:18,240 --> 00:44:20,640
四种不同的结果，所以你会看到

1163
00:44:20,640 --> 00:44:22,880
给定相同的起始位置和

1164
00:44:22,880 --> 00:44:24,240
obs

1165
00:44:24,240 --> 00:44:26,720
模型了解到，左转可能会

1166
00:44:26,720 --> 00:44:28,319
产生不同的结果，具体取决于

1167
00:44:28,319 --> 00:44:29,040
它在

1168
00:44:29,040 --> 00:44:30,800
哪里，我们将它戴

1169
00:44:30,800 --> 00:44:33,200
在空中，例如右上角，

1170
00:44:33,200 --> 00:44:35,440
然后机器人想象它在

1171
00:44:35,440 --> 00:44:36,400
过道的尽头，

1172
00:44:36,400 --> 00:44:38,640
而在 底部两个它

1173
00:44:38,640 --> 00:44:40,480
想象它在过道上所以它只是

1174
00:44:40,480 --> 00:44:42,000
想象一些

1175
00:44:42,000 --> 00:44:44,880
东西在架子上

1176
00:44:45,520 --> 00:44:49,119
然后这里是我们如何评估

1177
00:44:49,119 --> 00:44:50,400
政策

1178
00:44:50,400 --> 00:44:52,640
所以我们通常提供三个

1179
00:44:52,640 --> 00:44:54,160
可能的政策左转第四和

1180
00:44:54,160 --> 00:44:55,040
右转

1181
00:44:55,040 --> 00:44:56,480
然后你可以想象所有 这些

1182
00:44:56,480 --> 00:44:59,839
事情将在环境中进行

1183
00:44:59,839 --> 00:45:05,440
，然后与之前类似，您可以

1184
00:45:05,440 --> 00:45:08,480
计算 g 并选择最有可能

1185
00:45:08,480 --> 00:45:09,760


1186
00:45:09,760 --> 00:45:14,960
将您带到您喜欢的序列的

1187
00:45:16,839 --> 00:45:18,720
那个，嗯，

1188
00:45:18,720 --> 00:45:21,839
是的，所以我们

1189
00:45:21,839 --> 00:45:22,880
模型的

1190
00:45:22,880 --> 00:45:26,480


1191
00:45:26,480 --> 00:45:29,040
好处是您可以，嗯，因为 因为它是一个

1192
00:45:29,040 --> 00:45:30,560
神经网络，你可以将

1193
00:45:30,560 --> 00:45:33,359
多种类型的观察放入你的

1194
00:45:33,359 --> 00:45:35,200
后验模型中，你可以

1195
00:45:35,200 --> 00:45:37,920
以各种方式融合它们，所以你可以在这里看到

1196
00:45:37,920 --> 00:45:38,800


1197
00:45:38,800 --> 00:45:42,079
类似于相机 fe  eds 机器人

1198
00:45:42,079 --> 00:45:43,920
还将学习效果，例如

1199
00:45:43,920 --> 00:45:47,359
在较轻的扫描中，它还将

1200
00:45:47,359 --> 00:45:49,280
学习对雷达扫描中速度箱的影响

1201
00:45:49,280 --> 00:45:50,160


1202
00:45:50,160 --> 00:45:53,599
，这当然会给您的

1203
00:45:53,599 --> 00:45:55,599
计划带来额外的稳健性，

1204
00:45:55,599 --> 00:45:56,720
因为您

1205
00:45:56,720 --> 00:46:00,560
现在可以对多种模式

1206
00:46:00,560 --> 00:46:04,640
进行推理然后也许 在下一张幻灯片

1207
00:46:04,640 --> 00:46:06,720
中，当然

1208
00:46:06,720 --> 00:46:07,839
，

1209
00:46:07,839 --> 00:46:10,240
使用机器人以这种方式进行机器人控制仍然存在一些限制。

1210
00:46:10,240 --> 00:46:11,440


1211
00:46:11,440 --> 00:46:15,280
首先，我们的机器人

1212
00:46:15,280 --> 00:46:19,040
在时间上是极其短视的，

1213
00:46:19,040 --> 00:46:22,240
它只能学会预测

1214
00:46:22,240 --> 00:46:24,240
我们提供的序列的长度

1215
00:46:24,240 --> 00:46:26,400
训练

1216
00:46:26,400 --> 00:46:29,040
，而且你推出的时间越长，

1217
00:46:29,040 --> 00:46:30,240
你的搜索树越大，

1218
00:46:30,240 --> 00:46:31,680


1219
00:46:31,680 --> 00:46:33,680


1220
00:46:33,680 --> 00:46:37,040
你将达到的计算限制就越多，所以

1221
00:46:37,040 --> 00:46:39,280
这也是我们现在正在

1222
00:46:39,280 --> 00:46:42,800
积极研究的一个

1223
00:46:42,800 --> 00:46:46,160
领域，那么目前我们的模型仍然

1224
00:46:46,160 --> 00:46:48,240
需要我们预先记录数据集，

1225
00:46:48,240 --> 00:46:49,520
所以

1226
00:46:49,520 --> 00:46:51,200
我们的模型要求我们

1227
00:46:51,200 --> 00:46:52,640
自己开车，然后

1228
00:46:52,640 --> 00:46:55,520
适应模型，所以还有一个

1229
00:46:55,520 --> 00:46:55,920


1230
00:46:55,920 --> 00:46:58,800
点我们目前正在研究，

1231
00:46:58,800 --> 00:46:59,440
然后

1232
00:46:59,440 --> 00:47:02,160
将我们的模型绑定到这个 目前

1233
00:47:02,160 --> 00:47:03,760
真的不知道如何探索，

1234
00:47:03,760 --> 00:47:07,119
虽然可能有一种

1235
00:47:07,119 --> 00:47:08,720


1236
00:47:08,720 --> 00:47:11,920
基于自由能原理的明智探索方式，因为您的

1237
00:47:11,920 --> 00:47:15,760
移动不确定性可以被烘焙，

1238
00:47:15,839 --> 00:47:18,240
我想我不知道您是否还有

1239
00:47:18,240 --> 00:47:21,439
更多幻灯片，实际上现在

1240
00:47:21,520 --> 00:47:24,640
没有甜点或者也许 非常棒的问题很疯狂，

1241
00:47:24,640 --> 00:47:26,480


1242
00:47:26,480 --> 00:47:30,079
你可以取消分享

1243
00:47:30,079 --> 00:47:33,280
，我们可以问一些问题，所以我

1244
00:47:33,280 --> 00:47:35,280
写了一堆东西，还有

1245
00:47:35,280 --> 00:47:36,800
任何正在

1246
00:47:36,800 --> 00:47:40,160
观看现场直播的人请问一些问题

1247
00:47:40,160 --> 00:47:43,280
，尽管如此精彩的演示和

1248
00:47:43,280 --> 00:47:47,040
令人敬畏的非常有启发性的视频

1249
00:47:47,040 --> 00:47:48,800
希望让我们觉得让我们发笑

1250
00:47:48,800 --> 00:47:50,480
当它

1251
00:47:50,480 --> 00:47:52,319
偷工减料时，可能只是一个开始的

1252
00:47:52,319 --> 00:47:53,599
问题，

1253
00:47:53,599 --> 00:47:56,720
嗯，是什么

1254
00:47:56,720 --> 00:47:59,839
让你以这种方式研究这个主题

1255
00:47:59,839 --> 00:48:02,480
，你来自主动

1256
00:48:02,480 --> 00:48:03,520
推理并将

1257
00:48:03,520 --> 00:48:06,160
机器人技术视为一个有趣的应用程序，

1258
00:48:06,160 --> 00:48:06,559


1259
00:48:06,559 --> 00:48:08,559
或者你在 机器人学，

1260
00:48:08,559 --> 00:48:10,240
然后发现主动推理是

1261
00:48:10,240 --> 00:48:13,040
一个有用的模型，

1262
00:48:13,359 --> 00:48:16,400
是的，所以基本上我们在

1263
00:48:16,400 --> 00:48:20,480
机器人学领域和学习报告领域

1264
00:48:20,480 --> 00:48:24,960
我们正在努力构建

1265
00:48:24,960 --> 00:48:26,480
更好的低维状态

1266
00:48:26,480 --> 00:48:28,160
表示

1267
00:48:28,160 --> 00:48:31,760
以输入强化学习

1268
00:48:31,760 --> 00:48:34,319
算法假设这是我们最初的

1269
00:48:34,319 --> 00:48:34,960
想法，

1270
00:48:34,960 --> 00:48:38,400
所以只是构建表示

1271
00:48:38,400 --> 00:48:41,040
或更好的强化学习，

1272
00:48:41,040 --> 00:48:43,040
现在我们偶然发现了

1273
00:48:43,040 --> 00:48:45,200
主动推理框架，它

1274
00:48:45,200 --> 00:48:47,440
基本上不仅给了我们一个

1275
00:48:47,440 --> 00:48:49,839


1276
00:48:50,559 --> 00:48:54,319
建立退化

1277
00:48:54,319 --> 00:48:55,200
模型的方法，因为

1278
00:48:55,200 --> 00:48:58,960
基本上我们发现了自己，

1279
00:48:58,960 --> 00:49:01,920
假设

1280
00:49:01,920 --> 00:49:04,000
我们基本上已经在这样做的自由能，

1281
00:49:04,000 --> 00:49:07,119
但我们看到它也在

1282
00:49:07,119 --> 00:49:09,839
相同的数学框架中为我们提供了一种

1283
00:49:09,839 --> 00:49:11,680
如何投影的方法 这些东西到

1284
00:49:11,680 --> 00:49:13,760
未来，并用于规划，

1285
00:49:13,760 --> 00:49:16,720
从而解决歧义，也

1286
00:49:16,720 --> 00:49:17,440
用于对

1287
00:49:17,440 --> 00:49:20,240
新颖性和所有这些在 rl

1288
00:49:20,240 --> 00:49:22,400
中基本上缺乏的好属性进行评分，

1289
00:49:22,400 --> 00:49:25,599
这就是为什么我们基本上

1290
00:49:25,599 --> 00:49:26,800
开始

1291
00:49:26,800 --> 00:49:29,520
深入研究这个数学框架

1292
00:49:29,520 --> 00:49:30,880


1293
00:49:30,880 --> 00:49:33,040
来阅读所有论文 打电话

1294
00:49:33,040 --> 00:49:34,079
，看看

1295
00:49:34,079 --> 00:49:36,480
所有的目的是如何联系在一起的，

1296
00:49:36,480 --> 00:49:37,680
看看这

1297
00:49:37,680 --> 00:49:40,559
是否仍然有效 rk 如果你没有

1298
00:49:40,559 --> 00:49:41,359


1299
00:49:41,359 --> 00:49:44,000
你的状态空间定义了提示，

1300
00:49:44,000 --> 00:49:45,440
但你只是从数据中学习它，

1301
00:49:45,440 --> 00:49:47,599
所以这就是你开始这项

1302
00:49:47,599 --> 00:49:48,880
工作的方式，这

1303
00:49:48,880 --> 00:49:52,160
几乎就是我们目前所处的位置，

1304
00:49:52,160 --> 00:49:56,799
并且仍在进一步调查它

1305
00:49:56,960 --> 00:49:59,119
我的第二个

1306
00:49:59,119 --> 00:50:00,000
问题是，

1307
00:50:00,000 --> 00:50:02,640


1308
00:50:02,640 --> 00:50:04,240


1309
00:50:04,240 --> 00:50:06,720


1310
00:50:06,720 --> 00:50:08,319


1311
00:50:08,319 --> 00:50:09,920
如果您之前回答过强化学习或其他机器学习框架的主动推理，您会描述哪些差异或优势

1312
00:50:09,920 --> 00:50:11,599
，或者您是否想添加任何其他

1313
00:50:11,599 --> 00:50:16,000
想法，是的，我认为

1314
00:50:16,000 --> 00:50:18,410
我认为好的部分是

1315
00:50:18,410 --> 00:50:21,040
[音乐]

1316
00:50:21,040 --> 00:50:24,480
你自动获得

1317
00:50:24,480 --> 00:50:27,200
解决

1318
00:50:27,200 --> 00:50:28,640
歧义和

1319
00:50:28,640 --> 00:50:32,480
潜在探索的好属性，如果你也

1320
00:50:32,480 --> 00:50:34,800
估计你的参数的后验分布，

1321
00:50:34,800 --> 00:50:36,640


1322
00:50:36,640 --> 00:50:40,559
所以这些是非常有趣的属性，

1323
00:50:40,559 --> 00:50:44,160
呃数学上但是它仍然是

1324
00:50:44,160 --> 00:50:46,319
嗯它仍然存在 与实际的差距，

1325
00:50:46,319 --> 00:50:47,280


1326
00:50:47,280 --> 00:50:50,480


1327
00:50:50,480 --> 00:50:52,480
如果

1328
00:50:52,480 --> 00:50:55,119
你没有退化的m  odel

1329
00:50:55,119 --> 00:50:57,760
uh 预定义的假设

1330
00:50:57,760 --> 00:50:59,119
仍然存在一些挑战，

1331
00:50:59,119 --> 00:51:01,760
但至少理论上这是

1332
00:51:01,760 --> 00:51:03,040
非常吸引人的，

1333
00:51:03,040 --> 00:51:05,920
嗯，但我认为如果你

1334
00:51:05,920 --> 00:51:07,920
看看我们在内部引用的 url 端发生了什么

1335
00:51:07,920 --> 00:51:09,040
，

1336
00:51:09,040 --> 00:51:12,079
那么就没有那么大了

1337
00:51:12,079 --> 00:51:13,119


1338
00:51:13,119 --> 00:51:15,359
我认为两个轮子之间的差距是因为你得到

1339
00:51:15,359 --> 00:51:17,760
了他们

1340
00:51:17,760 --> 00:51:18,800


1341
00:51:18,800 --> 00:51:21,040
在强化学习中试图提出的所有好奇心奖励，如果你

1342
00:51:21,040 --> 00:51:22,720


1343
00:51:22,720 --> 00:51:24,400
用这种梦想家的方法来看看像尼日尔霍夫纳这样的基于模型的东西，

1344
00:51:24,400 --> 00:51:26,319
那么一切都是

1345
00:51:26,319 --> 00:51:27,520


1346
00:51:27,520 --> 00:51:30,240
相似的 收敛

1347
00:51:30,240 --> 00:51:32,079
到建立一个你的世界模型

1348
00:51:32,079 --> 00:51:34,240
并获得更高的样本效率

1349
00:51:34,240 --> 00:51:35,839
是一个好主意，在那里进行一些计划似乎是一个好主意

1350
00:51:35,839 --> 00:51:37,119


1351
00:51:37,119 --> 00:51:39,520
，也许有一些计划并且有一些

1352
00:51:39,520 --> 00:51:40,160
获得

1353
00:51:40,160 --> 00:51:43,280
好奇心，所以你会看到

1354
00:51:43,280 --> 00:51:46,160
很多 许多不同的独立

1355
00:51:46,160 --> 00:51:47,599
研究轨道，

1356
00:51:47,599 --> 00:51:51,520
我们都沿着相同的路线汇合，

1357
00:51:51,520 --> 00:51:54,240
我认为主动推理如此吸引人的地方

1358
00:51:54,240 --> 00:51:56,240
在于，

1359
00:51:56,240 --> 00:51:58,319
它基本上从一个 pr 将所有这些整合在一起

1360
00:51:58,319 --> 00:51:59,520
inciple

1361
00:51:59,520 --> 00:52:02,640
这使它成为一个非常好的

1362
00:52:02,640 --> 00:52:03,599


1363
00:52:03,599 --> 00:52:06,800
框架，我认为可以在臭氧上添加任何东西

1364
00:52:06,800 --> 00:52:08,480


1365
00:52:08,480 --> 00:52:10,480
哦，是的，在蒂姆提到

1366
00:52:10,480 --> 00:52:11,920
我之前我已经在思考

1367
00:52:11,920 --> 00:52:12,160


1368
00:52:12,160 --> 00:52:15,680
忍者的工作，所以我的意思是

1369
00:52:15,680 --> 00:52:17,680
如果你看看他的模型 我认为

1370
00:52:17,680 --> 00:52:19,440
这目前

1371
00:52:19,440 --> 00:52:21,119
几乎是最先进的和基于移动的

1372
00:52:21,119 --> 00:52:22,880
rl，然后

1373
00:52:22,880 --> 00:52:24,960
你会发现他们正在

1374
00:52:24,960 --> 00:52:27,359
构建的模型与

1375
00:52:27,359 --> 00:52:29,599
我们正在构建的模型或其他活跃的

1376
00:52:29,599 --> 00:52:31,760
基础设施正在构建的模型非常相似，

1377
00:52:31,760 --> 00:52:34,640
所以是的，我的意思是所有这些都是有道理的

1378
00:52:34,640 --> 00:52:36,160
这些

1379
00:52:36,160 --> 00:52:38,880
方法集中在一个想法的单一 id

1380
00:52:38,880 --> 00:52:41,680
上，

1381
00:52:42,160 --> 00:52:44,800
是的，非常有趣，比如计划

1382
00:52:44,800 --> 00:52:47,359
梦想和梦想或想象，这样你

1383
00:52:47,359 --> 00:52:48,160
就可以

1384
00:52:48,160 --> 00:52:51,119
适当地抽样，为什么把它作为模型的第二

1385
00:52:51,119 --> 00:52:52,800
层，或者必须

1386
00:52:52,800 --> 00:52:53,760


1387
00:52:53,760 --> 00:52:56,800
以一种特别的方式激励它 为什么不把

1388
00:52:56,800 --> 00:52:58,880
它作为模型的基础，所以这是

1389
00:52:58,880 --> 00:53:00,160
一个非常好的

1390
00:53:00,160 --> 00:53:03,440
观点，所以聊天中的院长

1391
00:53:03,440 --> 00:53:06,000
问作者是否听说过

1392
00:53:06,000 --> 00:53:07,599
传教士和食人族

1393
00:53:07,599 --> 00:53:10,720
游戏斜线问题，它正在移动

1394
00:53:10,720 --> 00:53:13,200
两种 mutua  lly 不兼容的

1395
00:53:13,200 --> 00:53:14,880
代理

1396
00:53:14,880 --> 00:53:17,680
在河流的两侧来回走动，如果他们

1397
00:53:17,680 --> 00:53:18,480
听说过这个或

1398
00:53:18,480 --> 00:53:21,119
想到任何类似的案例

1399
00:53:21,119 --> 00:53:24,640
，你是否看到任何应用程序

1400
00:53:26,960 --> 00:53:28,960
是的，我之前没有听说过这个游戏

1401
00:53:28,960 --> 00:53:30,000
，我认为

1402
00:53:30,000 --> 00:53:32,000
它可能类似于 就像

1403
00:53:32,000 --> 00:53:33,440
带着一只鸡

1404
00:53:33,440 --> 00:53:34,720
狐狸和一只

1405
00:53:34,720 --> 00:53:36,559
山羊过河 或者什么 是的 是什么 是

1406
00:53:36,559 --> 00:53:38,400
的 就像动物版本 有

1407
00:53:38,400 --> 00:53:39,839
各种各样的版本，但是

1408
00:53:39,839 --> 00:53:41,200
与不同

1409
00:53:41,200 --> 00:53:43,119
种类的不相容的代理来回走动，你

1410
00:53:43,119 --> 00:53:44,079
需要

1411
00:53:44,079 --> 00:53:46,559
去 在你上山之前向左走，

1412
00:53:46,559 --> 00:53:48,079
但它的设置有点

1413
00:53:48,079 --> 00:53:49,520
不同，所以这让

1414
00:53:49,520 --> 00:53:52,000


1415
00:53:52,559 --> 00:53:54,880


1416
00:53:54,880 --> 00:53:57,920


1417
00:53:57,920 --> 00:53:59,520
你想到了什么 在一个

1418
00:53:59,520 --> 00:54:00,960
环境中，

1419
00:54:00,960 --> 00:54:04,240
也许会收集

1420
00:54:04,240 --> 00:54:06,960


1421
00:54:06,960 --> 00:54:08,480


1422
00:54:08,480 --> 00:54:11,119


1423
00:54:11,119 --> 00:54:12,400


1424
00:54:12,400 --> 00:54:14,880


1425
00:54:14,880 --> 00:54:16,000


1426
00:54:16,000 --> 00:54:17,920
一些数据 观察你可以得到的结果，

1427
00:54:17,920 --> 00:54:19,200


1428
00:54:19,200 --> 00:54:22,559
所以我认为你实际上

1429
00:54:22,559 --> 00:54:25,599
可以以这种方式对其进行形式化，然后

1430
00:54:25,599 --> 00:54:28,559
在其上运行一个活跃的仪器模拟

1431
00:54:28,559 --> 00:54:29,359


1432
00:54:29,359 --> 00:54:33,280
，看看会发生什么，

1433
00:54:33,280 --> 00:54:36,880
这样我们就不感兴趣了，因为

1434
00:54:36,880 --> 00:54:39,280
在我们的案例中，我们主要感兴趣的是

1435
00:54:39,280 --> 00:54:40,319
如果您的

1436
00:54:40,319 --> 00:54:42,240
观察维度如此之高

1437
00:54:42,240 --> 00:54:43,359
以至于您甚至无法

1438
00:54:43,359 --> 00:54:46,480
开始考虑

1439
00:54:46,480 --> 00:54:49,520
写出联合模型，那么

1440
00:54:49,520 --> 00:54:50,559
您唯一能做的

1441
00:54:50,559 --> 00:54:53,119
就是与您的环境交互并

1442
00:54:53,119 --> 00:54:53,920


1443
00:54:53,920 --> 00:54:56,960
尝试从数据中学习它

1444
00:54:56,960 --> 00:55:01,040


1445
00:55:01,040 --> 00:55:05,280
对主动推理问题

1446
00:55:05,280 --> 00:55:08,640
的不同看法 另一个问题是

1447
00:55:08,640 --> 00:55:11,839
你们都

1448
00:55:11,839 --> 00:55:12,160
在

1449
00:55:12,160 --> 00:55:15,680
用物理代理实时部署这些

1450
00:55:15,680 --> 00:55:18,720


1451
00:55:18,720 --> 00:55:20,160


1452
00:55:20,160 --> 00:55:23,200


1453
00:55:23,200 --> 00:55:25,040
模型 有点像把所有东西都放在

1454
00:55:25,040 --> 00:55:26,799
一个盒子里，并且确切地知道什么

1455
00:55:26,799 --> 00:55:27,839


1456
00:55:27,839 --> 00:55:30,319
会影响到我不

1457
00:55:30,319 --> 00:55:32,400
知道一些灰尘可能会进入机器人的具身世界

1458
00:55:32,400 --> 00:55:32,720
或者

1459
00:55:32,720 --> 00:55:36,079
我看到一个人走过，所以

1460
00:55:36,079 --> 00:55:39,119
当你实际部署时会发生什么

1461
00:55:39,119 --> 00:55:41,359
，以及模型如何处理

1462
00:55:41,359 --> 00:55:43,680


1463
00:55:43,839 --> 00:55:46,400
对我来说这实际上是我最喜欢的东西，

1464
00:55:46,400 --> 00:55:47,280
我们首先

1465
00:55:47,280 --> 00:55:49,440
玩了很多山地车

1466
00:55:49,440 --> 00:55:50,480
和赛车

1467
00:55:50,480 --> 00:55:52,640
但是 对我个人来说，第一件事实际上是一个真正的

1468
00:55:52,640 --> 00:55:54,319
障碍，就是

1469
00:55:54,319 --> 00:55:56,240
将它部署在一个真正的机器人上，你

1470
00:55:56,240 --> 00:55:58,079
突然有所有这些

1471
00:55:58,079 --> 00:56:00,160
硬件限制，比如你可以

1472
00:56:00,160 --> 00:56:01,520
没有无限的内存你

1473
00:56:01,520 --> 00:56:03,839
没有服务器强大的计算能力

1474
00:56:03,839 --> 00:56:07,599
，你们都必须 你必须是的

1475
00:56:07,599 --> 00:56:10,480
，例如我认为蒂姆和我

1476
00:56:10,480 --> 00:56:12,160
花了很多时间来制作一个演示

1477
00:56:12,160 --> 00:56:12,880
工作

1478
00:56:12,880 --> 00:56:15,839
，我们可以在其中实时推出它，

1479
00:56:15,839 --> 00:56:16,319
并且

1480
00:56:16,319 --> 00:56:18,000
只是在实际电源上做

1481
00:56:18,000 --> 00:56:19,920
一些像主动推理这样复杂的事情的硬件限制

1482
00:56:19,920 --> 00:56:20,880


1483
00:56:20,880 --> 00:56:23,520
约束机器人本身就是

1484
00:56:23,520 --> 00:56:24,480
另一个

1485
00:56:24,480 --> 00:56:29,040
挑战，是的，所以我想

1486
00:56:29,040 --> 00:56:32,480
，如果问题是，

1487
00:56:32,480 --> 00:56:34,960
呃，你从真实系统中得到什么，

1488
00:56:34,960 --> 00:56:36,160


1489
00:56:36,160 --> 00:56:38,240
我认为答案是很多挫折和痛苦，

1490
00:56:38,240 --> 00:56:39,119


1491
00:56:39,119 --> 00:56:41,520
但我 同样，如果我们然后如果它不起作用，

1492
00:56:41,520 --> 00:56:43,040
那么

1493
00:56:43,040 --> 00:56:46,079
感激之情是满意度要

1494
00:56:46,079 --> 00:56:46,480
高得多，

1495
00:56:46,480 --> 00:56:49,760
所以我仍然记得臭氧和我

1496
00:56:49,760 --> 00:56:52,079
在实验室里欢呼，因为我们给了

1497
00:56:52,079 --> 00:56:54,400
机器人一个喜欢的状态，就像

1498
00:56:54,400 --> 00:56:56,240
在麦芽酒的中心一样

1499
00:56:56,240 --> 00:56:58,799
它实际上是沿着麦酒移动

1500
00:56:58,799 --> 00:57:00,240
，然后在最后

1501
00:57:00,240 --> 00:57:02,640
他们决定嗯，这不是

1502
00:57:02,640 --> 00:57:04,720
动物的中心，它只是做了一个 360

1503
00:57:04,720 --> 00:57:05,440
度转弯

1504
00:57:05,440 --> 00:57:07,119
并开始往回开，我们

1505
00:57:07,119 --> 00:57:09,920
就像哦，这太棒了，

1506
00:57:09,920 --> 00:57:12,480
所以我认为有一个 很多痛苦

1507
00:57:12,480 --> 00:57:14,640
挫折 让它发挥作用 但是一旦有

1508
00:57:14,640 --> 00:57:16,720
东西出来 然后

1509
00:57:16,720 --> 00:57:18,799
满足感

1510
00:57:18,799 --> 00:57:20,799
比看到山地车时要高得多

1511
00:57:20,799 --> 00:57:22,640


1512
00:57:22,640 --> 00:57:25,119


1513
00:57:25,119 --> 00:57:26,000


1514
00:57:26,000 --> 00:57:28,000


1515
00:57:28,000 --> 00:57:29,920


1516
00:57:29,920 --> 00:57:33,359
软件实现的很多比较，但

1517
00:57:33,359 --> 00:57:35,280
也许这甚至会将它提升

1518
00:57:35,280 --> 00:57:36,720
到一个新的水平，

1519
00:57:36,720 --> 00:57:39,359
所以你反复谈论的另一件事

1520
00:57:39,359 --> 00:57:40,480


1521
00:57:40,480 --> 00:57:43,280
可能甚至在每个示例中实际上都是在

1522
00:57:43,280 --> 00:57:44,720
训练 mod  el

1523
00:57:44,720 --> 00:57:48,079
仅来自少数几个人类案例，例如

1524
00:57:48,079 --> 00:57:49,520
您驾驶汽车，

1525
00:57:49,520 --> 00:57:51,440
您让人们玩山地车

1526
00:57:51,440 --> 00:57:52,640
游戏，那么

1527
00:57:52,640 --> 00:57:55,119
那里到底发生了什么以及

1528
00:57:55,119 --> 00:57:56,000
模型

1529
00:57:56,000 --> 00:57:58,000
如何不适合

1530
00:57:58,000 --> 00:57:59,760
您展示的少数轨迹，

1531
00:57:59,760 --> 00:58:01,760
或者不只是说嘿，您只给了 我

1532
00:58:01,760 --> 00:58:03,200
三个

1533
00:58:03,200 --> 00:58:05,040
这三个完全不同的

1534
00:58:05,040 --> 00:58:07,440
轨迹是怎么回事，比如

1535
00:58:07,440 --> 00:58:09,680
当你提供一些人类例子时，模型中究竟正在学习或更新什么

1536
00:58:09,680 --> 00:58:13,759


1537
00:58:17,119 --> 00:58:18,400
我想然后我们会回答

1538
00:58:18,400 --> 00:58:23,839
这个

1539
00:58:24,720 --> 00:58:27,839
是的，我认为过度拟合是呃

1540
00:58:27,839 --> 00:58:32,000
是 显然是一个问题，

1541
00:58:32,000 --> 00:58:34,240
无论您做什么，您都

1542
00:58:34,240 --> 00:58:36,319
受到您提供给模型的数据的限制，

1543
00:58:36,319 --> 00:58:38,079


1544
00:58:38,079 --> 00:58:39,040


1545
00:58:39,040 --> 00:58:42,160
因此除了发现的内容之外，它无法真正学习任何其他内容

1546
00:58:42,160 --> 00:58:44,240
，这也是我们

1547
00:58:44,240 --> 00:58:46,160
在 最后一张幻灯片显然

1548
00:58:46,160 --> 00:58:47,839
是我们当前工作的一个严重限制，

1549
00:58:47,839 --> 00:58:51,359
但是

1550
00:58:51,359 --> 00:58:54,640
当有一个真正的机器人参与时，没有其他方法

1551
00:58:54,640 --> 00:58:55,920


1552
00:58:55,920 --> 00:58:58,640
可以开始说，所以这是

1553
00:58:58,640 --> 00:59:01,040
更容易开始的方法，所以这是主要的 你是

1554
00:59:01,040 --> 00:59:03,359
司机，但目前我们实际上

1555
00:59:03,359 --> 00:59:05,280
是在模拟和

1556
00:59:05,280 --> 00:59:06,720
真正的机器人上工作，看看

1557
00:59:06,720 --> 00:59:09,280
我们真的可以让这些系统决定如何

1558
00:59:09,280 --> 00:59:11,040


1559
00:59:11,040 --> 00:59:14,400
收集他们自己的经验，嗯，有

1560
00:59:14,400 --> 00:59:14,720


1561
00:59:14,720 --> 00:59:16,880
什么值得学习的，因为这

1562
00:59:16,880 --> 00:59:18,240
实际上是其中之一

1563
00:59:18,240 --> 00:59:21,280
到你之前的一个

1564
00:59:21,280 --> 00:59:22,000
问题的捷径

1565
00:59:22,000 --> 00:59:24,559
主动入口能给你带来什么好处

1566
00:59:24,559 --> 00:59:26,000
，它实际上

1567
00:59:26,000 --> 00:59:27,839
可以处理这些事情，

1568
00:59:27,839 --> 00:59:29,760
比如我的机器人需要收集

1569
00:59:29,760 --> 00:59:31,359
自己的经验你会做什么，

1570
00:59:31,359 --> 00:59:32,880
总是一样的，或者

1571
00:59:32,880 --> 00:59:35,359
探索者或这类东西，所以

1572
00:59:35,359 --> 00:59:36,480
这些确实是

1573
00:59:36,480 --> 00:59:39,359
一些活跃的研究领域，但是

1574
00:59:39,359 --> 00:59:40,640


1575
00:59:40,640 --> 00:59:43,359
回到过度拟合问题，所以

1576
00:59:43,359 --> 00:59:44,000


1577
00:59:44,000 --> 00:59:45,599
减轻过度拟合的一件事是，即使在系统

1578
00:59:45,599 --> 00:59:47,040
中你也有所有这些随机变量的事实

1579
00:59:47,040 --> 00:59:47,680


1580
00:59:47,680 --> 00:59:49,839
它 变成样本

1581
00:59:49,839 --> 00:59:50,720
状态

1582
00:59:50,720 --> 00:59:53,760
，这使它变得更多，但

1583
00:59:53,760 --> 00:59:56,559
它不像分类器那样

1584
00:59:56,559 --> 00:59:57,440
总是

1585
00:59:57,440 --> 00:59:59,200
适合测试假设那里总是

1586
00:59:59,200 --> 01:00:00,960
有某种

1587
01:00:00,960 --> 01:00:05,040
噪音，但你是装备 嗯

1588
01:00:05,040 --> 01:00:07,839
，从某种意义上说，数据过度拟合了

1589
01:00:07,839 --> 01:00:10,079
，因为它无法

1590
01:00:10,079 --> 01:00:13,839
预测它以前显然没有见过的场景，

1591
01:00:13,839 --> 01:00:14,880


1592
01:00:14,880 --> 01:00:17,760
但是

1593
01:00:17,760 --> 01:00:19,599
拥有这个，嗯，

1594
01:00:19,599 --> 01:00:21,839
这个预期的能量公式的好处之一就是

1595
01:00:21,839 --> 01:00:23,680
你实际上完成了

1596
01:00:23,680 --> 01:00:27,520
嗯，嗯，你打算

1597
01:00:27,520 --> 01:00:30,160
用这个熵术语，这

1598
01:00:30,160 --> 01:00:31,680
基本上意味着，

1599
01:00:31,680 --> 01:00:34,799
如果你

1600
01:00:34,799 --> 01:00:37,200
在模型没有训练过的某个空间中提前计划，那么

1601
01:00:37,200 --> 01:00:38,559
通常

1602
01:00:38,559 --> 01:00:41,040
你会有更多的变化，一些

1603
01:00:41,040 --> 01:00:42,000
更高的熵

1604
01:00:42,000 --> 01:00:44,400
或那个区域，因为通常你的

1605
01:00:44,400 --> 01:00:45,680
观察变得

1606
01:00:45,680 --> 01:00:49,520
非常糟糕或非常模糊或

1607
01:00:49,520 --> 01:00:52,880
不分布，因此从

1608
01:00:52,880 --> 01:00:53,440
某种意义上说，

1609
01:00:53,440 --> 01:00:56,079
该模型对此具有一定的鲁棒性，

1610
01:00:56,079 --> 01:00:57,680
并且

1611
01:00:57,680 --> 01:01:01,359
如果您随后部署策略或

1612
01:01:01,359 --> 01:01:03,920
进行计划，它也会尝试

1613
01:01:03,920 --> 01:01:05,760
保留

1614
01:01:05,760 --> 01:01:07,760
靠近模型到模型受到约束的制度的地方，

1615
01:01:07,760 --> 01:01:09,760
因为在那里

1616
01:01:09,760 --> 01:01:10,000
你

1617
01:01:10,000 --> 01:01:12,640
基本上得到了更好的预测，

1618
01:01:12,640 --> 01:01:13,359
所以

1619
01:01:13,359 --> 01:01:16,240
在某种意义上，这也减轻了

1620
01:01:16,240 --> 01:01:17,040


1621
01:01:17,040 --> 01:01:22,160
问题，我还想补充

1622
01:01:22,240 --> 01:01:26,079
一点，b 是的，我们可以

1623
01:01:26,079 --> 01:01:28,720
像我们所做的那样使用很少的 uh 部署，

1624
01:01:28,720 --> 01:01:29,599
因为实际上

1625
01:01:29,599 --> 01:01:32,480
如果你让人类进行部署，

1626
01:01:32,480 --> 01:01:32,880
你就可

1627
01:01:32,880 --> 01:01:34,559
以为代理解决探索问题，

1628
01:01:34,559 --> 01:01:36,079
你已经

1629
01:01:36,079 --> 01:01:39,119
很好地覆盖了

1630
01:01:39,119 --> 01:01:41,599
你得到的相关可行状态空间

1631
01:01:41,599 --> 01:01:43,920
对于赛车手来说，

1632
01:01:43,920 --> 01:01:45,920
如果你让一个随机代理

1633
01:01:45,920 --> 01:01:47,119
四处探索

1634
01:01:47,119 --> 01:01:49,839
，你一天的 99 天仍然只是草

1635
01:01:49,839 --> 01:01:50,720
，机器人会

1636
01:01:50,720 --> 01:01:53,839
老化，不会对道路一无所知，所以通过

1637
01:01:53,839 --> 01:01:54,640


1638
01:01:54,640 --> 01:01:56,880
让人类推导出它，你知道这

1639
01:01:56,880 --> 01:01:57,760
就是道路，

1640
01:01:57,760 --> 01:01:59,039
显然这 很重要，

1641
01:01:59,039 --> 01:02:02,799
因为在我的每一次观察中

1642
01:02:02,799 --> 01:02:05,119
，几乎让我想到了两种方式

1643
01:02:05,119 --> 01:02:06,240
，我们看到

1644
01:02:06,240 --> 01:02:08,240
这些大型模型是由一种导师训练的，

1645
01:02:08,240 --> 01:02:09,520


1646
01:02:09,520 --> 01:02:11,359
比如一个人说你知道这是

1647
01:02:11,359 --> 01:02:12,880
你想要取样的第一个地方

1648
01:02:12,880 --> 01:02:14,720
这是你第一次

1649
01:02:14,720 --> 01:02:17,280
驾驶的方式，驾驶教练并排

1650
01:02:17,280 --> 01:02:18,000


1651
01:02:18,000 --> 01:02:19,680
，然后是退化的

1652
01:02:19,680 --> 01:02:21,680
对抗方法

1653
01:02:21,680 --> 01:02:24,319
，这几乎是相反的，就像

1654
01:02:24,319 --> 01:02:26,160
我们将通过

1655
01:02:26,160 --> 01:02:29,520
模型最混乱 获取可能的数据

1656
01:02:29,520 --> 01:02:31,680
，所以有点像

1657
01:02:31,680 --> 01:02:33,359
胡萝卜和大棒或杆子上的推力，

1658
01:02:33,359 --> 01:02:34,240


1659
01:02:34,240 --> 01:02:37,039
这些模型来自他们两个，可能是一个，

1660
01:02:37,039 --> 01:02:37,520
也可能是

1661
01:02:37,520 --> 01:02:40,319
两个，他们弄清楚如何

1662
01:02:40,319 --> 01:02:41,599
在剃须刀的边缘

1663
01:02:41,599 --> 01:02:44,960
，然后在赛车示例中 嗯，

1664
01:02:44,960 --> 01:02:47,119
它是在偷工减料，这让

1665
01:02:47,119 --> 01:02:48,720
我对

1666
01:02:48,720 --> 01:02:50,960
自动驾驶汽车感到好奇，你说

1667
01:02:50,960 --> 01:02:52,880
好吧，目标是留在路上

1668
01:02:52,880 --> 01:02:55,280
并快速到达那里，但有时

1669
01:02:55,280 --> 01:02:56,559
快速到达那里

1670
01:02:56,559 --> 01:02:59,440
会优先考虑，然后

1671
01:02:59,440 --> 01:03:01,680
突然间你 重新离开道路，也许

1672
01:03:01,680 --> 01:03:03,520
现在你的车被毁了或类似的东西

1673
01:03:03,520 --> 01:03:05,119
，所以

1674
01:03:05,119 --> 01:03:07,280
如果要部署这些，

1675
01:03:07,280 --> 01:03:08,640
我们怎么会知道用

1676
01:03:08,640 --> 01:03:11,920
什么样的偏好来

1677
01:03:11,920 --> 01:03:16,799
实例化模型，

1678
01:03:16,799 --> 01:03:18,720
是的，这是一个非常好的点

1679
01:03:18,720 --> 01:03:20,000
，因为

1680
01:03:20,000 --> 01:03:24,079
嗯 理论上，主动入口可能看起来有多好

1681
01:03:24,079 --> 01:03:27,440
，我认为

1682
01:03:27,440 --> 01:03:29,839
它不是自治代理的灵丹妙药，

1683
01:03:29,839 --> 01:03:31,039


1684
01:03:31,039 --> 01:03:33,839
因为很多礼貌

1685
01:03:33,839 --> 01:03:35,520
仍然在于你

1686
01:03:35,520 --> 01:03:37,839
如何提供它，就像

1687
01:03:37,839 --> 01:03:39,039
首选的

1688
01:03:39,039 --> 01:03:42,079
先验一样 d 分配，这

1689
01:03:42,079 --> 01:03:45,839
在现实世界的系统中至关重要。

1690
01:03:45,839 --> 01:03:49,520
它

1691
01:03:49,520 --> 01:03:51,599
类似于奖励 基本上它

1692
01:03:51,599 --> 01:03:53,680
比你知道的标量奖励提供

1693
01:03:53,680 --> 01:03:54,559


1694
01:03:54,559 --> 01:03:56,799


1695
01:03:56,799 --> 01:03:58,319


1696
01:03:58,319 --> 01:04:01,359


1697
01:04:01,359 --> 01:04:05,200
更多信息 捷径 嗯

1698
01:04:05,200 --> 01:04:07,440
，作为实验的设计者，你得到了你之前没有想到的首选状态，假设

1699
01:04:07,440 --> 01:04:07,680


1700
01:04:07,680 --> 01:04:09,760


1701
01:04:09,760 --> 01:04:10,720


1702
01:04:10,720 --> 01:04:12,960
它基本上与强化学习有相同的问题，

1703
01:04:12,960 --> 01:04:14,240


1704
01:04:14,240 --> 01:04:17,039
所以我不认为它是

1705
01:04:17,039 --> 01:04:17,680


1706
01:04:17,680 --> 01:04:21,280
解决问题的灵丹妙药 自治 嗯，但至少它有

1707
01:04:21,280 --> 01:04:22,000
一些

1708
01:04:22,000 --> 01:04:27,680
嗯它有一些 um

1709
01:04:27,680 --> 01:04:29,680
燃烧旋钮，你可以你

1710
01:04:29,680 --> 01:04:30,880
可以使用

1711
01:04:30,880 --> 01:04:33,760
，至少可以避免某些情况，例如避免

1712
01:04:33,760 --> 01:04:34,799
这些模棱两可的

1713
01:04:34,799 --> 01:04:38,720
模棱两可状态，或者至少让它

1714
01:04:38,720 --> 01:04:42,079
首先正确学习模型，

1715
01:04:42,079 --> 01:04:44,960
这样它就有一些不错的 属性，但它

1716
01:04:44,960 --> 01:04:45,280
不是

1717
01:04:45,280 --> 01:04:47,760
解决自治

1718
01:04:47,760 --> 01:04:50,480
系统的灵丹妙药 我认为

1719
01:04:51,119 --> 01:04:53,680
可以在臭氧上添加任何东西 我认为

1720
01:04:53,680 --> 01:04:55,200
蒂姆说得很好

1721
01:04:55,200 --> 01:04:57,839


1722
01:04:57,839 --> 01:04:58,559


1723
01:04:58,559 --> 01:05:01,920


1724
01:05:01,920 --> 01:05:03,440
g

1725
01:05:03,440 --> 01:05:06,160
靶场

1726
01:05:06,160 --> 01:05:07,200
我们至少可以

1727
01:05:07,200 --> 01:05:10,240
探索它的第一个应用 嗯，这些用

1728
01:05:10,240 --> 01:05:11,200
例与人们

1729
01:05:11,200 --> 01:05:13,520
一直在更

1730
01:05:13,520 --> 01:05:14,640
广泛

1731
01:05:14,640 --> 01:05:17,680
地讨论的自动驾驶汽车的用例相同，或者可能

1732
01:05:17,680 --> 01:05:18,319


1733
01:05:18,319 --> 01:05:20,400
存在某种分工，主动

1734
01:05:20,400 --> 01:05:21,760
推理将专门化 就像在

1735
01:05:21,760 --> 01:05:22,000
那些

1736
01:05:22,000 --> 01:05:24,960
模棱两可的场景中一样，或者我只是

1737
01:05:24,960 --> 01:05:27,760
对此感到好奇，

1738
01:05:35,359 --> 01:05:38,160
所以是的，我还在

1739
01:05:38,160 --> 01:05:39,039
思考，但

1740
01:05:39,039 --> 01:05:42,160
就像我们那里一样，我认为

1741
01:05:42,160 --> 01:05:43,839
我们真正瞄准的下一个应用

1742
01:05:43,839 --> 01:05:46,960
程序仍然是受限导航

1743
01:05:46,960 --> 01:05:49,440
，然后例如仓库

1744
01:05:49,440 --> 01:05:53,200
呃计划失误的影响

1745
01:05:53,200 --> 01:05:56,480
仍然相当有限，所以实际上我们实验室的情况更

1746
01:05:56,480 --> 01:05:57,680
现实的版本

1747
01:05:57,680 --> 01:05:59,200


1748
01:05:59,200 --> 01:06:02,079
也许这也是

1749
01:06:02,079 --> 01:06:05,200
我们目前仍在走的轨迹，

1750
01:06:05,200 --> 01:06:07,119
所以我认为我们仍然相信

1751
01:06:07,119 --> 01:06:08,480


1752
01:06:08,480 --> 01:06:10,480
开发自主主动入口

1753
01:06:10,480 --> 01:06:11,599
代理有一些价值

1754
01:06:11,599 --> 01:06:14,640
对于这种更像行业的设置

1755
01:06:14,640 --> 01:06:15,440
，您

1756
01:06:15,440 --> 01:06:17,920
至少可以将其与公众分开

1757
01:06:17,920 --> 01:06:18,480


1758
01:06:18,480 --> 01:06:20,880
，而且您还可以拥有一定

1759
01:06:20,880 --> 01:06:24,160
程度的 c 环境控制

1760
01:06:24,400 --> 01:06:27,520
是的，我认为我认为您

1761
01:06:27,520 --> 01:06:27,920


1762
01:06:27,920 --> 01:06:31,200
类似于缓解学习中的相同问题，

1763
01:06:31,200 --> 01:06:33,599
基本上是

1764
01:06:33,599 --> 01:06:35,200
您在让系统

1765
01:06:35,200 --> 01:06:37,200
随机选择动作或立即选择任何动作之前

1766
01:06:37,200 --> 01:06:39,440


1767
01:06:39,440 --> 01:06:41,200
，至少在您的环境中 作为一个

1768
01:06:41,200 --> 01:06:42,960
人，

1769
01:06:42,960 --> 01:06:46,400
你可以让系统捷径并说好的，

1770
01:06:46,400 --> 01:06:48,559
你想开车进入这个机架

1771
01:06:48,559 --> 01:06:50,160
，这不是一个好主意，所以

1772
01:06:50,160 --> 01:06:52,640
你至少有一些方法来

1773
01:06:52,640 --> 01:06:54,640
定义一些规则，以将其保持在

1774
01:06:54,640 --> 01:06:56,480
某个安全范围内，比如说

1775
01:06:56,480 --> 01:06:59,599
，在这个范围内 边界它可以

1776
01:06:59,599 --> 01:07:01,680
例如

1777
01:07:01,680 --> 01:07:04,160
自动移动

1778
01:07:04,160 --> 01:07:05,920


1779
01:07:05,920 --> 01:07:08,319


1780
01:07:08,319 --> 01:07:09,039


1781
01:07:09,039 --> 01:07:12,640
，但是如果你

1782
01:07:12,640 --> 01:07:14,319
在一些麦芽酒中开车并且有人刚刚

1783
01:07:14,319 --> 01:07:16,160
从盒子中间掉下来，那么你可能会拥有更好的主动推理代理属性

1784
01:07:16,160 --> 01:07:17,280
空气

1785
01:07:17,280 --> 01:07:19,920
它不会吓坏，

1786
01:07:19,920 --> 01:07:20,960
因为 slam 地图

1787
01:07:20,960 --> 01:07:24,240
是呃它不再

1788
01:07:24,240 --> 01:07:26,319
符合

1789
01:07:26,319 --> 01:07:27,920
例如机器人的编程方式，但我们只会

1790
01:07:27,920 --> 01:07:28,240


1791
01:07:28,240 --> 01:07:31,119
说好吧，这是另一个 cas  e要么它

1792
01:07:31,119 --> 01:07:33,200
以前经历过这种情况，并且

1793
01:07:33,200 --> 01:07:33,520


1794
01:07:33,520 --> 01:07:36,319
在他的世界模型中，它有一个如何处理这部分的想法，我

1795
01:07:36,319 --> 01:07:36,880


1796
01:07:36,880 --> 01:07:38,799
会很感兴趣并开始

1797
01:07:38,799 --> 01:07:40,960
了解这些新闻信息，

1798
01:07:40,960 --> 01:07:43,359
所以我认为这些是

1799
01:07:43,359 --> 01:07:44,000
你

1800
01:07:44,000 --> 01:07:47,280
在这个代理中拥有的很好的属性，你 有点绕过

1801
01:07:47,280 --> 01:07:50,960
所有的，嗯，它太贪心了，

1802
01:07:50,960 --> 01:07:53,760
无法实现它的偏好，因为你

1803
01:07:53,760 --> 01:07:54,480


1804
01:07:54,480 --> 01:07:57,440
通过

1805
01:07:57,440 --> 01:07:58,400
安装

1806
01:07:58,400 --> 01:08:02,880
这个基于系统的系统来捷径这些情况，这

1807
01:08:02,880 --> 01:08:06,000
限制了

1808
01:08:06,000 --> 01:08:09,039
游戏中动作的选择，

1809
01:08:09,039 --> 01:08:10,720
感谢 回答这里

1810
01:08:10,720 --> 01:08:13,920
是聊天中的一个问题，因为代码

1811
01:08:13,920 --> 01:08:15,039
没有公开

1812
01:08:15,039 --> 01:08:17,198
，你会说坚持

1813
01:08:17,198 --> 01:08:18,158
你在论文中写的内容

1814
01:08:18,158 --> 01:08:20,319
就足以重现你的结果，

1815
01:08:20,319 --> 01:08:22,719
或者你在设计和训练模型时使用了任何进一步的技巧

1816
01:08:22,719 --> 01:08:26,560


1817
01:08:29,040 --> 01:08:30,799
你是在接受艺术吗？ 对不起

1818
01:08:30,799 --> 01:08:32,880
，蒂姆先去吧，

1819
01:08:32,880 --> 01:08:34,799
是的，我认为连同

1820
01:08:34,799 --> 01:08:36,238
附录一起应该就

1821
01:08:36,238 --> 01:08:38,880
足够了，你认为进展顺利吗？

1822
01:08:38,880 --> 01:08:39,679
我

1823
01:08:39,679 --> 01:08:41,279
认为我们有一些经验

1824
01:08:41,279 --> 01:08:43,279
，我三 ed来帮助那些

1825
01:08:43,279 --> 01:08:43,759


1826
01:08:43,759 --> 01:08:47,839
试图复制我们的结果的人，嗯，

1827
01:08:47,839 --> 01:08:50,799
我认为他们我们有一些计划技巧，这样的

1828
01:08:50,799 --> 01:08:51,679
计划

1829
01:08:51,679 --> 01:08:54,158
并不容易

1830
01:08:54,158 --> 01:08:55,359
复制，但是

1831
01:08:55,359 --> 01:08:58,399


1832
01:08:58,399 --> 01:09:01,439
我们解释了架构的模型预测部分，我

1833
01:09:01,439 --> 01:09:04,080
在附录中非常详细，所以 我

1834
01:09:04,080 --> 01:09:05,198
认为

1835
01:09:05,198 --> 01:09:06,960
，我们不会做任何额外的技巧，

1836
01:09:06,960 --> 01:09:09,040
例如在

1837
01:09:09,040 --> 01:09:12,479
数据处理或我们的损失条款上，所以

1838
01:09:12,479 --> 01:09:14,158
这应该很容易模仿，但我认为

1839
01:09:14,158 --> 01:09:15,520


1840
01:09:15,520 --> 01:09:17,600
计划涉及更多，因为我们有时

1841
01:09:17,600 --> 01:09:19,920
自己很难复制

1842
01:09:19,920 --> 01:09:22,080
它，

1843
01:09:22,319 --> 01:09:26,080
计划很难是的

1844
01:09:26,080 --> 01:09:29,120
嗯，好吧，如果其他人

1845
01:09:29,120 --> 01:09:31,040
在实时聊天中有问题，他们可以输入，

1846
01:09:31,040 --> 01:09:32,960
嗯，我认为在山地车示例中

1847
01:09:32,960 --> 01:09:34,319
真正令人着迷的另一篇文章

1848
01:09:34,319 --> 01:09:36,880
至少是

1849
01:09:36,880 --> 01:09:38,238
你如何

1850
01:09:38,238 --> 01:09:41,359
谈论噪音，让以前

1851
01:09:41,359 --> 01:09:44,479
不合理的政策成为

1852
01:09:44,479 --> 01:09:47,520
可能，就像我们看到的那样

1853
01:09:47,520 --> 01:09:48,238


1854
01:09:48,238 --> 01:09:51,279
当有噪音时，轨迹的更广泛传播

1855
01:09:51,279 --> 01:09:54,800
嗯，它是

1856
01:09:54,800 --> 01:09:57,760
如何实时集成的，或者噪音如何

1857
01:09:57,760 --> 01:09:58,640


1858
01:09:58,640 --> 01:10:03,040
小这如何

1859
01:10:03,040 --> 01:10:04,960
改变模型

1860
01:10:04,960 --> 01:10:08,320
对它可以去哪里以及它应

1861
01:10:11,199 --> 01:10:13,600
该做什么的理解是的，所以在多车示例

1862
01:10:13,600 --> 01:10:16,000
中，基本上有两个噪音源让我们

1863
01:10:16,000 --> 01:10:16,880
说一个是

1864
01:10:16,880 --> 01:10:19,760
关于你观察到的噪音，

1865
01:10:19,760 --> 01:10:21,120
所以你 得到

1866
01:10:21,120 --> 01:10:23,760
你位置的恼人估计，

1867
01:10:23,760 --> 01:10:24,960
所以

1868
01:10:24,960 --> 01:10:28,080
这通常不是那么大，

1869
01:10:28,080 --> 01:10:30,320
因为是的，你需要有

1870
01:10:30,320 --> 01:10:32,960
足够的信噪比才能

1871
01:10:32,960 --> 01:10:36,480
学习任何东西让我们说嗯，

1872
01:10:36,480 --> 01:10:39,600
但第二部分

1873
01:10:39,600 --> 01:10:42,560
是你的代理是从零

1874
01:10:42,560 --> 01:10:44,000
速度开始还是

1875
01:10:44,000 --> 01:10:46,640
以 随机速度，这些

1876
01:10:46,640 --> 01:10:47,280
基本上是

1877
01:10:47,280 --> 01:10:50,400
两个单独训练的 um 模型，

1878
01:10:50,400 --> 01:10:53,280
所以要么你有一个代理总是

1879
01:10:53,280 --> 01:10:54,080


1880
01:10:54,080 --> 01:10:56,400
以零初始速度开始，然后

1881
01:10:56,400 --> 01:10:58,719
基本上模型知道

1882
01:10:58,719 --> 01:11:01,920
um 初始观察 uh 的

1883
01:11:01,920 --> 01:11:03,760
速度为零，它基本上

1884
01:11:03,760 --> 01:11:06,400
知道如何正确

1885
01:11:06,400 --> 01:11:08,560
预测 从第一次观察开始，

1886
01:11:08,560 --> 01:11:09,520


1887
01:11:09,520 --> 01:11:11,199
假设你训练代理

1888
01:11:11,199 --> 01:11:12,560
不断

1889
01:11:12,560 --> 01:11:14,800
具有随机速度的模型，那么它

1890
01:11:14,800 --> 01:11:17,440
基本上从第一次观察中学习是的

1891
01:11:17,440 --> 01:11:19,920
仍然有很多选择

1892
01:11:19,920 --> 01:11:21,600
取决于我的速度，

1893
01:11:21,600 --> 01:11:24,640
并且更多的观察得到你

1894
01:11:24,640 --> 01:11:26,640
看到模型是如何

1895
01:11:26,640 --> 01:11:28,880
回升的，这现在是我的速度

1896
01:11:28,880 --> 01:11:29,920
，从那时起

1897
01:11:29,920 --> 01:11:32,960
你会看到广泛的

1898
01:11:32,960 --> 01:11:34,719
选项是如何崩溃

1899
01:11:34,719 --> 01:11:38,800
到最多的 最有可能

1900
01:11:39,440 --> 01:11:41,760
的那个或儿子的任何东西我只是

1901
01:11:41,760 --> 01:11:43,760
也在考虑例如在

1902
01:11:43,760 --> 01:11:47,199
我们给的机器人规划示例

1903
01:11:47,199 --> 01:11:49,679
中你也看到了这种传播但

1904
01:11:49,679 --> 01:11:50,560


1905
01:11:50,560 --> 01:11:53,840
更多的是因为模型了解到

1906
01:11:53,840 --> 01:11:54,800
在

1907
01:11:54,800 --> 01:11:57,840
不同的相似状态下价值

1908
01:11:57,840 --> 01:11:59,360
不同的结果 是可能的，所以它

1909
01:11:59,360 --> 01:12:01,520
会尝试

1910
01:12:01,520 --> 01:12:03,760
使高斯和潜在速度

1911
01:12:03,760 --> 01:12:05,679
更宽一些，这样如果你从中采样，

1912
01:12:05,679 --> 01:12:06,239


1913
01:12:06,239 --> 01:12:08,480
你可能会得到稍微不同的

1914
01:12:08,480 --> 01:12:09,679
样本值

1915
01:12:09,679 --> 01:12:11,360
，然后会产生

1916
01:12:11,360 --> 01:12:13,120


1917
01:12:13,120 --> 01:12:16,000
你想要可视化的不同结果，所以这也是 因此，

1918
01:12:16,000 --> 01:12:17,120
即使

1919
01:12:17,120 --> 01:12:18,960


1920
01:12:18,960 --> 01:12:20,560
您最初为重新参数化

1921
01:12:20,560 --> 01:12:21,520
技巧采样的标准法线

1922
01:12:21,520 --> 01:12:24,560
与标准法线非常相似，但

1923
01:12:24,560 --> 01:12:26,800
模型可以学习膨胀或放气

1924
01:12:26,800 --> 01:12:30,480
这个 di 分布，以便您获得

1925
01:12:30,480 --> 01:12:33,520
更广泛的覆盖范围

1926
01:12:33,520 --> 01:12:35,360
，例如您在

1927
01:12:35,360 --> 01:12:37,199
导航示例中也看到的

1928
01:12:37,199 --> 01:12:39,840
基本上是模型，因为我们

1929
01:12:39,840 --> 01:12:40,320


1930
01:12:40,320 --> 01:12:43,760
在非常短的时间子序列上训练它，

1931
01:12:43,760 --> 01:12:44,239
就像

1932
01:12:44,239 --> 01:12:47,360
我认为实时的一两秒，

1933
01:12:47,360 --> 01:12:52,159
所以它不是 能够在更长的时间

1934
01:12:52,159 --> 01:12:54,640
内做出非常一致的预测

1935
01:12:54,640 --> 01:12:56,320


1936
01:12:56,320 --> 01:12:59,440
uh 帧，并且考虑

1937
01:12:59,440 --> 01:13:01,040


1938
01:13:01,040 --> 01:13:03,920
到实验室中的每个 ale 看起来都非常相似的事实，它学习

1939
01:13:03,920 --> 01:13:05,760
了一般结构，就像

1940
01:13:05,760 --> 01:13:07,520
左右有残骸

1941
01:13:07,520 --> 01:13:09,280
，可能有盒子或

1942
01:13:09,280 --> 01:13:12,480
呃 你看到那种盒子或里面

1943
01:13:12,480 --> 01:13:14,560
的东西实际上在

1944
01:13:14,560 --> 01:13:16,880
架子上有点模糊

1945
01:13:16,880 --> 01:13:20,239
，有点褐色，呃黑色，但

1946
01:13:20,239 --> 01:13:23,360
没有真正的你真的

1947
01:13:23,360 --> 01:13:25,440
不能识别那个残骸中的东西

1948
01:13:25,440 --> 01:13:27,040


1949
01:13:27,040 --> 01:13:30,000
所以它基本上没有空间意识

1950
01:13:30,000 --> 01:13:30,400


1951
01:13:30,400 --> 01:13:33,360


1952
01:13:33,360 --> 01:13:35,040
我在残骸的什么地方我在最后还是在开始

1953
01:13:35,040 --> 01:13:36,000
或在中间

1954
01:13:36,000 --> 01:13:38,000
它不知道这就是为什么你看到如果

1955
01:13:38,000 --> 01:13:39,199
你说好的

1956
01:13:39,199 --> 01:13:42,719
右转 持续一段时间

1957
01:13:42,719 --> 01:13:44,800
，然后它要么预测我

1958
01:13:44,800 --> 01:13:46,000
在中间，所以

1959
01:13:46,000 --> 01:13:48,640
接下来如果我转 360 度，它仍然会

1960
01:13:48,640 --> 01:13:49,280
在我之后喝啤酒，

1961
01:13:49,280 --> 01:13:50,960
或者我在最后，所以如果我

1962
01:13:50,960 --> 01:13:52,640
转身，我会看到一个 墙，

1963
01:13:52,640 --> 01:13:55,840
嗯，所以它基本上没有

1964
01:13:55,840 --> 01:13:59,120
关于它在哪里的一致知识

1965
01:13:59,120 --> 01:14:02,159
，所以这基本上

1966
01:14:02,159 --> 01:14:05,360
是在分布中模拟这种噪音

1967
01:14:05,360 --> 01:14:07,760
，如果你画

1968
01:14:07,760 --> 01:14:09,679
一条不同的轨迹，它要么

1969
01:14:09,679 --> 01:14:10,400
认为

1970
01:14:10,400 --> 01:14:13,280
它在墙上，要么 它正对着

1971
01:14:13,280 --> 01:14:15,360
另一种麦芽酒，或者有一个人经过，

1972
01:14:15,360 --> 01:14:16,560
所以我看到一些

1973
01:14:16,560 --> 01:14:19,679
阴暗的类似人的结构，所以所有

1974
01:14:19,679 --> 01:14:21,520
这些东西都被

1975
01:14:21,520 --> 01:14:25,120
建模为

1976
01:14:25,120 --> 01:14:27,840
你的分布中的那种呃是的噪音，

1977
01:14:27,840 --> 01:14:28,239


1978
01:14:28,239 --> 01:14:32,000
似乎在那里

1979
01:14:32,000 --> 01:14:35,040
发生 感觉嗯，什么可能

1980
01:14:35,040 --> 01:14:37,600
对长期计划有帮助或需要，

1981
01:14:37,600 --> 01:14:38,159


1982
01:14:38,159 --> 01:14:40,840
因为你拥有的树有

1983
01:14:40,840 --> 01:14:43,280
多个，嗯，

1984
01:14:43,280 --> 01:14:46,159
我猜是分叉或它们所代表的任何东西，

1985
01:14:46,159 --> 01:14:46,880


1986
01:14:46,880 --> 01:14:48,640
这非常有趣，你如何拥有一棵

1987
01:14:48,640 --> 01:14:50,400
非常充实的树

1988
01:14:50,400 --> 01:14:51,920
，然后你展示了一种 你是如何

1989
01:14:51,920 --> 01:14:54,560
复发的 sed 进行修剪以进行

1990
01:14:54,560 --> 01:14:56,000
策略选择，

1991
01:14:56,000 --> 01:14:59,760
因此正如您所建议的那样，以指数方式

1992
01:14:59,760 --> 01:15:03,199
扩展计算

1993
01:15:03,199 --> 01:15:05,920
可能有帮助或如何

1994
01:15:05,920 --> 01:15:06,640


1995
01:15:06,640 --> 01:15:10,560
使用合理的硬件实现长期规划

1996
01:15:10,560 --> 01:15:14,400
是的，所以这里的关键是

1997
01:15:14,400 --> 01:15:16,000
我认为的分层模型，那就是

1998
01:15:16,000 --> 01:15:17,120


1999
01:15:17,120 --> 01:15:20,560
我们现在正在努力推动的

2000
01:15:20,560 --> 01:15:24,480
基本上是你给

2001
01:15:24,480 --> 01:15:27,280
你的模型，就像我们现在交易的那样，你

2002
01:15:27,280 --> 01:15:28,320
基本上把

2003
01:15:28,320 --> 01:15:31,440
一个新模型放在上面，现在因为

2004
01:15:31,440 --> 01:15:34,159
观察没有得到，呃没有

2005
01:15:34,159 --> 01:15:35,360
得到像素，

2006
01:15:35,360 --> 01:15:37,280
但是它 从这个模型中获取状态样本，

2007
01:15:37,280 --> 01:15:38,880


2008
01:15:38,880 --> 01:15:41,440
现在的时间步长不是

2009
01:15:41,440 --> 01:15:42,480


2010
01:15:42,480 --> 01:15:44,640
预测下一个时间步长，而是喜欢

2011
01:15:44,640 --> 01:15:46,800
在头部预测 10 次或 20 次，

2012
01:15:46,800 --> 01:15:49,520
或者任何你想要

2013
01:15:49,520 --> 01:15:51,440
的基本情况

2014
01:15:51,440 --> 01:15:53,199
，一旦你到了那个点 那么

2015
01:15:53,199 --> 01:15:55,199
你基本上有一个可以计划的系统，

2016
01:15:55,199 --> 01:15:58,560
如果你计划了十个时间步，

2017
01:15:58,560 --> 01:16:00,480
你实际上是为较低级别的模型计划了 100 个时间步

2018
01:16:00,480 --> 01:16:02,480
，所以

2019
01:16:02,480 --> 01:16:05,520
这样你就可以继续课程评分，

2020
01:16:05,520 --> 01:16:08,560
你只需要探索

2021
01:16:08,560 --> 01:16:11,360
一个 fe  w 策略在每个级别，然后

2022
01:16:11,360 --> 01:16:13,120


2023
01:16:13,120 --> 01:16:15,840
再次向下您只需预测

2024
01:16:15,840 --> 01:16:17,360
会发生的一秒钟，

2025
01:16:17,360 --> 01:16:19,440
因为另一个计划是由

2026
01:16:19,440 --> 01:16:20,560
顶部的模型制定的

2027
01:16:20,560 --> 01:16:23,840
，因此您可以轻松

2028
01:16:23,840 --> 01:16:27,360
绕过并降低

2029
01:16:27,360 --> 01:16:31,760
复杂性 关于规划程序，

2030
01:16:31,760 --> 01:16:34,080
它让我想起了很多驾驶在哪里

2031
01:16:34,080 --> 01:16:35,199
会好在

2032
01:16:35,199 --> 01:16:38,320
五个街道右转所以

2033
01:16:38,320 --> 01:16:39,960
你不会

2034
01:16:39,960 --> 01:16:43,120
提前右转好

2035
01:16:43,120 --> 01:16:45,440
一二三四现在我应该

2036
01:16:45,440 --> 01:16:46,400
准备好

2037
01:16:46,400 --> 01:16:49,520
嗯什么 关于符号信息，

2038
01:16:49,520 --> 01:16:51,360
例如过道是否有颜色

2039
01:16:51,360 --> 01:16:52,560
渐变，或者

2040
01:16:52,560 --> 01:16:55,679
如果它有一个点，两个点，三个点，

2041
01:16:55,679 --> 01:16:59,280
是否可以以无人监督的方式学习？

2042
01:16:59,280 --> 01:17:02,640
嗯，该像素级模型中的一个符号，

2043
01:17:02,640 --> 01:17:03,199


2044
01:17:03,199 --> 01:17:05,520
或者是分层模型

2045
01:17:05,520 --> 01:17:08,320
可以发挥作用的地方

2046
01:17:08,480 --> 01:17:11,040
吗？ 我认为目前的问题

2047
01:17:11,040 --> 01:17:11,719
在于我们的

2048
01:17:11,719 --> 01:17:14,560
架构方面，我们的模型无法

2049
01:17:14,560 --> 01:17:15,600


2050
01:17:15,600 --> 01:17:19,440
捕获非常类似于

2051
01:17:19,440 --> 01:17:22,800
环境的低级细节，因为

2052
01:17:22,800 --> 01:17:25,360
我们基于 va 方法，然后

2053
01:17:25,360 --> 01:17:26,400


2054
01:17:26,400 --> 01:17:28,159
是我们使用的均方误差目标 r

2055
01:17:28,159 --> 01:17:30,800
重建和波浪样本

2056
01:17:30,800 --> 01:17:33,360
已经抑制了例如

2057
01:17:33,360 --> 01:17:34,640
识别

2058
01:17:34,640 --> 01:17:38,159
输入中的点嗯，

2059
01:17:38,159 --> 01:17:40,000
也许实际上我不知道

2060
01:17:40,000 --> 01:17:41,600
关于它的 10 件事我认为颜色

2061
01:17:41,600 --> 01:17:42,960
渐变

2062
01:17:42,960 --> 01:17:46,400
就像模型可能会学习，如果给定

2063
01:17:46,400 --> 01:17:49,520
足够的数据和激励

2064
01:17:49,520 --> 01:17:52,080
是的，所以我 认为这种方法存在许多

2065
01:17:52,080 --> 01:17:53,600
问题

2066
01:17:53,600 --> 01:17:56,239
，因为

2067
01:17:56,239 --> 01:17:57,120


2068
01:17:57,120 --> 01:18:00,159
我们现在在像素空间中进行预测，

2069
01:18:00,159 --> 01:18:02,239


2070
01:18:02,239 --> 01:18:05,199
比如说你计算可能性的方式

2071
01:18:05,199 --> 01:18:06,320


2072
01:18:06,320 --> 01:18:09,040
，你评估可能性，然后

2073
01:18:09,040 --> 01:18:10,800
计算

2074
01:18:10,800 --> 01:18:13,280
重建误差 意味着

2075
01:18:13,280 --> 01:18:14,239


2076
01:18:14,239 --> 01:18:16,159
您希望每个像素

2077
01:18:16,159 --> 01:18:17,760


2078
01:18:17,760 --> 01:18:20,719
平均独立预测非常正确，这意味着

2079
01:18:20,719 --> 01:18:22,000
如果您有非常

2080
01:18:22,000 --> 01:18:25,760
细粒度的细节，它很容易

2081
01:18:25,760 --> 01:18:29,679
忽略这一点，您也

2082
01:18:29,679 --> 01:18:32,320
有复杂性术语，基本上说

2083
01:18:32,320 --> 01:18:34,080
好的，我希望

2084
01:18:34,080 --> 01:18:37,120
有最简单的表示

2085
01:18:37,120 --> 01:18:38,080


2086
01:18:38,080 --> 01:18:39,600
重建重建，但这基本上

2087
01:18:39,600 --> 01:18:42,239
也意味着

2088
01:18:42,239 --> 01:18:45,360
取决于你对 restr 施加的

2089
01:18:45,360 --> 01:18:46,960
压力

2090
01:18:46,960 --> 01:18:49,440
icting 复杂性，

2091
01:18:49,440 --> 01:18:51,600
您将实际编码的信息越少，

2092
01:18:51,600 --> 01:18:54,400
并且基本上您

2093
01:18:54,400 --> 01:18:56,400
的重建将变得越模糊，因此

2094
01:18:56,400 --> 01:18:58,080
它与您的床非常相似，

2095
01:18:58,080 --> 01:19:00,400
即 uh 与

2096
01:19:00,400 --> 01:19:01,840
您拥有更好的参数的行为非常相似，该参数可以

2097
01:19:01,840 --> 01:19:02,320
使

2098
01:19:02,320 --> 01:19:05,040
您放多少重量失谐 关于

2099
01:19:05,040 --> 01:19:05,520
gal

2100
01:19:05,520 --> 01:19:07,280
散度项与

2101
01:19:07,280 --> 01:19:09,760
重建项

2102
01:19:09,760 --> 01:19:12,480
，这也

2103
01:19:12,480 --> 01:19:13,360
对模型将

2104
01:19:13,360 --> 01:19:15,840
实际放入状态表示

2105
01:19:15,840 --> 01:19:17,679
的内容产生影响，哪些细节

2106
01:19:17,679 --> 01:19:20,719
将被忽略，

2107
01:19:20,719 --> 01:19:23,040
所以是的，我认为很多这些事情

2108
01:19:23,040 --> 01:19:24,640
对于 现在直接使用模型

2109
01:19:24,640 --> 01:19:27,760
，因为我们

2110
01:19:27,760 --> 01:19:28,239
构建

2111
01:19:28,239 --> 01:19:31,839
轻量级模型和参数化模型的

2112
01:19:32,719 --> 01:19:37,360


2113
01:19:37,360 --> 01:19:40,800


2114
01:19:40,800 --> 01:19:42,719


2115
01:19:42,719 --> 01:19:43,840


2116
01:19:43,840 --> 01:19:46,960


2117
01:19:46,960 --> 01:19:48,719
方式非常有趣 谁对此

2118
01:19:48,719 --> 01:19:50,480
感到好奇并想

2119
01:19:50,480 --> 01:19:53,360
在接下来的几年中

2120
01:19:53,360 --> 01:19:55,759
关注

2121
01:19:59,360 --> 01:20:01,600
是的，我的意思是我们在活跃的时候有很多喜欢

2122
01:20:01,600 --> 01:20:03,600
我认为

2123
01:20:03,600 --> 01:20:05,679
当我们刚开始的时候没有

2124
01:20:05,679 --> 01:20:07,440
太多关于如何进行主动

2125
01:20:07,440 --> 01:20:08,320
推理的信息，所以我们

2126
01:20:08,320 --> 01:20:10,880
不得不通过

2127
01:20:10,880 --> 01:20:12,960
很多尝试和失败来解决这个问题，

2128
01:20:12,960 --> 01:20:15,199
但现在我认为即使在这个

2129
01:20:15,199 --> 01:20:17,120
模型流中 是关于主动推理的一些

2130
01:20:17,120 --> 01:20:18,880
很酷的信息和可访问的

2131
01:20:18,880 --> 01:20:21,440
信息，

2132
01:20:21,440 --> 01:20:25,040
所以如果你想建立这样的模型，我的意思是具体实施

2133
01:20:25,040 --> 01:20:25,600
明智的

2134
01:20:25,600 --> 01:20:29,120
，

2135
01:20:29,120 --> 01:20:31,520
我认为

2136
01:20:31,520 --> 01:20:32,639
rl

2137
01:20:32,639 --> 01:20:36,239
和主动推理中的当前技术状态我学到的主动

2138
01:20:36,239 --> 01:20:37,120
推理

2139
01:20:37,120 --> 01:20:40,080
都非常相似，

2140
01:20:40,400 --> 01:20:44,159
是的，我同意

2141
01:20:44,159 --> 01:20:46,960
因此，如果您现在查看 ryan smith 的教程，那么很多关于主动影响

2142
01:20:46,960 --> 01:20:47,840


2143
01:20:47,840 --> 01:20:49,920
信息的可访问性

2144
01:20:49,920 --> 01:20:51,520
已经发生了变化

2145
01:20:51,520 --> 01:20:54,239


2146
01:20:54,239 --> 01:20:56,000
，例如，

2147
01:20:56,000 --> 01:20:58,639
您的一个视频中也广泛介绍了该教程，

2148
01:20:58,639 --> 01:20:59,520


2149
01:20:59,520 --> 01:21:01,679
所以我认为它真的

2150
01:21:01,679 --> 01:21:03,679
知道 进入

2151
01:21:03,679 --> 01:21:06,639
呃酒吧只是为了了解理论

2152
01:21:06,639 --> 01:21:07,840
以及一切如何

2153
01:21:07,840 --> 01:21:10,239
运作或应该如何运作，并玩

2154
01:21:10,239 --> 01:21:11,760


2155
01:21:11,760 --> 01:21:14,159
一些你可以获得的小玩具示例和模拟

2156
01:21:14,159 --> 01:21:16,080


2157
01:21:16,080 --> 01:21:18,159
关于这件事的作用以及

2158
01:21:18,159 --> 01:21:19,199
它如何

2159
01:21:19,199 --> 01:21:22,080
为深度学习部分工作的见解让我们说

2160
01:21:22,080 --> 01:21:23,520
建立这些模型

2161
01:21:23,520 --> 01:21:26,480
然后可能需要去的资源

2162
01:21:26,480 --> 01:21:27,199
就像

2163
01:21:27,199 --> 01:21:29,840
关于变分自动

2164
01:21:29,840 --> 01:21:31,840
编码器的教程我认为这些

2165
01:21:31,840 --> 01:21:34,639
是深层的东西

2166
01:21:34,639 --> 01:21:35,600


2167
01:21:35,600 --> 01:21:38,320
与

2168
01:21:38,320 --> 01:21:38,960


2169
01:21:38,960 --> 01:21:41,760
我们在这里讨论的主动推理工作最相关的学习，如果您可以构建一个

2170
01:21:41,760 --> 01:21:43,360
变分自动编码器

2171
01:21:43,360 --> 01:21:45,600
并且您知道主动推理是如何工作的，

2172
01:21:45,600 --> 01:21:46,880
并且您将两者

2173
01:21:46,880 --> 01:21:48,239
与我们论文中的一些细节放在一起，

2174
01:21:48,239 --> 01:21:50,800
例如我认为应该

2175
01:21:50,800 --> 01:21:53,040
非常简单地进入

2176
01:21:53,040 --> 01:21:57,120
第一个工作示例，为我们的实验室冷静

2177
01:21:57,120 --> 01:22:00,159
任何结束的想法甚至

2178
01:22:00,159 --> 01:22:03,199
问题，或者

2179
01:22:03,199 --> 01:22:06,239
只是让人们在

2180
01:22:06,239 --> 01:22:08,560
做梦时思考，

2181
01:22:08,560 --> 01:22:11,840
为行动做准备，

2182
01:22:13,600 --> 01:22:18,800
嗯，是的，也许我只想

2183
01:22:18,800 --> 01:22:20,719
继续一点 蒂姆早些时候说过

2184
01:22:20,719 --> 01:22:22,159


2185
01:22:22,159 --> 01:22:23,280
，例如，如果您想构建

2186
01:22:23,280 --> 01:22:26,000
分层模型

2187
01:22:26,000 --> 01:22:27,920
，则不必

2188
01:22:27,920 --> 01:22:29,280
在我们实验的主动推理模型之上构建主动推理模型

2189
01:22:29,280 --> 01:22:30,159


2190
01:22:30,159 --> 01:22:32,159
我们做了一些

2191
01:22:32,159 --> 01:22:33,760
初步实验

2192
01:22:33,760 --> 01:22:35,840
，例如仅使用我们的主动

2193
01:22:35,840 --> 01:22:37,520
推理

2194
01:22:37,520 --> 01:22:40,080
模型作为 slam 算法的动态模型，

2195
01:22:40,080 --> 01:22:41,760
然后您还已经获得了

2196
01:22:41,760 --> 01:22:45,120
分层建模和

2197
01:22:45,120 --> 01:22:48,239
一些长期收益，所以

2198
01:22:48,239 --> 01:22:50,560
也许这也很有趣，

2199
01:22:50,560 --> 01:22:52,239
想一想如何 这个

2200
01:22:52,239 --> 01:22:54,400
活跃的基础设施适合

2201
01:22:54,400 --> 01:22:57,040
现有的技术，

2202
01:22:57,040 --> 01:23:00,080
是的，所以我认为

2203
01:23:00,080 --> 01:23:03,360
臭氧想说的是，在

2204
01:23:03,360 --> 01:23:04,320
这种情况下，我们

2205
01:23:04,320 --> 01:23:06,800
使用这些深度神经网络来

2206
01:23:06,800 --> 01:23:08,000
比较眼睛，

2207
01:23:08,000 --> 01:23:11,679
这个过渡模型可能是模型和

2208
01:23:11,679 --> 01:23:15,120
后验模型，但你不应该

2209
01:23:15,120 --> 01:23:18,239
总是自动恢复到

2210
01:23:18,239 --> 01:23:20,159
这些学习技术，所以这些

2211
01:23:20,159 --> 01:23:22,400
现在非常流行并且

2212
01:23:22,400 --> 01:23:26,960
非常酷但是在某些情况下，

2213
01:23:26,960 --> 01:23:29,120
如果你知道你的环境可能就足够了，

2214
01:23:29,120 --> 01:23:30,560
那么

2215
01:23:30,560 --> 01:23:32,159
是的，如果你不应该费心学习

2216
01:23:32,159 --> 01:23:33,679
状态空间模型 你知道状态

2217
01:23:33,679 --> 01:23:34,719
空间模型，

2218
01:23:34,719 --> 01:23:37,840
是的，使用它，嗯，我知道我们

2219
01:23:37,840 --> 01:23:40,159
在这里使用了山地车示例，这将

2220
01:23:40,159 --> 01:23:42,239
是一个很好的例子，

2221
01:23:42,239 --> 01:23:45,520
为什么我们不应该只是 使用呃深度

2222
01:23:45,520 --> 01:23:47,120
学习方法，这基本上

2223
01:23:47,120 --> 01:23:48,560
就像一个

2224
01:23:48,560 --> 01:23:50,719
原理证明，让我们让一些简单的

2225
01:23:50,719 --> 01:23:51,920
例子工作，

2226
01:23:51,920 --> 01:23:54,080
但我认为如果你

2227
01:23:54,080 --> 01:23:55,280
喜欢这些真正的

2228
01:23:55,280 --> 01:23:58,239
高维观察，你

2229
01:23:58,239 --> 01:23:58,560
没有，

2230
01:23:58,560 --> 01:24:00,239
你没有 线索如何表征

2231
01:24:00,239 --> 01:24:02,400
您的基于空间的模式，但这并不是说

2232
01:24:02,400 --> 01:24:03,760
这

2233
01:24:03,760 --> 01:24:06,639
是默认的方式，

2234
01:24:06,639 --> 01:24:08,800
我们也喜欢

2235
01:24:08,800 --> 01:24:12,080
不断发展，特别是如果你

2236
01:24:12,080 --> 01:24:14,400
转向这些分层模型，

2237
01:24:14,400 --> 01:24:16,880
那么我们有点像 看看我们如何

2238
01:24:16,880 --> 01:24:19,760


2239
01:24:19,760 --> 01:24:23,600
在顶部制作一种更离散的样式 um 段落状态空间模型

2240
01:24:23,600 --> 01:24:27,199
，我们基本上

2241
01:24:27,199 --> 01:24:30,800
尝试将整个 um 状态空间放入

2242
01:24:30,800 --> 01:24:31,760
离散的

2243
01:24:31,760 --> 01:24:33,280
部分，然后像你一样拥有一个简单的

2244
01:24:33,280 --> 01:24:35,120
过渡模型，

2245
01:24:35,120 --> 01:24:36,960
你自己给出了例子 danielle

2246
01:24:36,960 --> 01:24:38,639
如果您考虑

2247
01:24:38,639 --> 01:24:40,719
自己导航，您不会

2248
01:24:40,719 --> 01:24:42,080
考虑预测

2249
01:24:42,080 --> 01:24:45,679
所有房屋的所有像素，呃，或者

2250
01:24:45,679 --> 01:24:48,239
您只是想我需要不时

2251
01:24:48,239 --> 01:24:50,400
向前走第二条街

2252
01:24:50,400 --> 01:24:52,639
到 le 所以你基本上

2253
01:24:52,639 --> 01:24:55,679
把整个连续状态空间分成

2254
01:24:55,679 --> 01:24:56,239
一些

2255
01:24:56,239 --> 01:24:59,280
相关的部分，然后你的过渡

2256
01:24:59,280 --> 01:24:59,679
模型

2257
01:24:59,679 --> 01:25:02,719
也变得像一个非常简单的

2258
01:25:02,719 --> 01:25:04,239
矩阵，具有过渡

2259
01:25:04,239 --> 01:25:06,400
概率，嗯，

2260
01:25:06,400 --> 01:25:09,440
所以我认为未来是勃起

2261
01:25:09,440 --> 01:25:10,239
模型

2262
01:25:10,239 --> 01:25:13,280
，未来是混合的

2263
01:25:13,280 --> 01:25:16,480
一些学习的部分，但也有

2264
01:25:16,480 --> 01:25:19,679
一些非常离散的，直观

2265
01:25:19,679 --> 01:25:23,520
可理解的部分，只有

2266
01:25:23,520 --> 01:25:26,320
两点，嗯，一个

2267
01:25:26,320 --> 01:25:27,760
总是吸引我主动

2268
01:25:27,760 --> 01:25:28,719
推理的东西是

2269
01:25:28,719 --> 01:25:31,520
它的推理条件和

2270
01:25:31,520 --> 01:25:32,560
动作，

2271
01:25:32,560 --> 01:25:35,760
所以你不会去那个 4k

2272
01:25:35,760 --> 01:25:37,760
谷歌街景 即使你有一个作为输出数据的生成模型，每个房子是

2273
01:25:37,760 --> 01:25:38,800
什么样子的

2274
01:25:38,800 --> 01:25:41,280
，当这是输入数据时，

2275
01:25:41,280 --> 01:25:42,800


2276
01:25:42,800 --> 01:25:44,480


2277
01:25:44,480 --> 01:25:45,920
如此主动推理是一种非常有

2278
01:25:45,920 --> 01:25:48,000
原则的方法，可以减少

2279
01:25:48,000 --> 01:25:49,199
你预测

2280
01:25:49,199 --> 01:25:51,840
的东西，我的肘部应该以哪种方式移动

2281
01:25:51,840 --> 01:25:52,239
不是

2282
01:25:52,239 --> 01:25:53,920
当我的肘部移动时像素会是什么样子，

2283
01:25:53,920 --> 01:25:56,000
这可能只

2284
01:25:56,000 --> 01:25:58,320
需要千兆字节的数据，但如果它

2285
01:25:58,320 --> 01:25:59,360
只是减少

2286
01:25:59,360 --> 01:26:02,239
到状态空间 它更容易

2287
01:26:02,239 --> 01:26:03,120
学习，这就是为什么

2288
01:26:03,120 --> 01:26:06,239


2289
01:26:06,239 --> 01:26:07,360
你的论文如此有趣的贡献

2290
01:26:07,360 --> 01:26:10,000
是在

2291
01:26:10,000 --> 01:26:11,120


2292
01:26:11,120 --> 01:26:13,360
高分辨率、实时和

2293
01:26:13,360 --> 01:26:14,480
异构

2294
01:26:14,480 --> 01:26:16,800
传感器的背景下实际学习状态空间，然后

2295
01:26:16,800 --> 01:26:17,920


2296
01:26:17,920 --> 01:26:20,480
我们在 实验室，在

2297
01:26:20,480 --> 01:26:21,760
这些讨论

2298
01:26:21,760 --> 01:26:24,239
中，有哲学讨论

2299
01:26:24,239 --> 01:26:25,600
地图和领域

2300
01:26:25,600 --> 01:26:27,679
，谁是真正的积极推理

2301
01:26:27,679 --> 01:26:29,760
代理，它是一切，尘埃

2302
01:26:29,760 --> 01:26:31,840
粒子，细菌，你所知道的世界是这样建造的

2303
01:26:31,840 --> 01:26:32,960


2304
01:26:32,960 --> 01:26:34,960
，然后有这种

2305
01:26:34,960 --> 01:26:36,480
工程方法

2306
01:26:36,480 --> 01:26:38,719
，你有你的偏好

2307
01:26:38,719 --> 01:26:40,400
你想看到机器人工作

2308
01:26:40,400 --> 01:26:42,560
，然后你可以修补和拼凑任何

2309
01:26:42,560 --> 01:26:44,800


2310
01:26:44,800 --> 01:26:47,120
让你满意的东西，它减少了你

2311
01:26:47,120 --> 01:26:48,960
在执行你试图执行的任务时的不确定性

2312
01:26:48,960 --> 01:26:51,760
，所以它有点

2313
01:26:51,760 --> 01:26:53,360
回避，但

2314
01:26:53,360 --> 01:26:55,280
它以一种实际上回避了这些问题的方式

2315
01:26:55,280 --> 01:26:56,960
带给

2316
01:26:56,960 --> 01:26:58,880
我们更高层次的理解，

2317
01:26:58,880 --> 01:27:00,239
因为我知道

2318
01:27:00,239 --> 01:27:04,000
很多听众在机器上没有那么先进

2319
01:27:04,000 --> 01:27:06,480
学习将受到启发，

2320
01:27:06,480 --> 01:27:07,199
并

2321
01:27:07,199 --> 01:27:09,360
根据您今天带来的内容产生定性的想法，

2322
01:27:09,360 --> 01:27:10,800


2323
01:27:10,800 --> 01:27:13,760
因此再次感谢这次精彩的

2324
01:27:13,760 --> 01:27:15,600
演示和对话

2325
01:27:15,600 --> 01:27:17,920
，我们将永远感谢

2326
01:27:17,920 --> 01:27:21,040
在适当的时候听到任何后续跟进，

2327
01:27:21,040 --> 01:27:23,520
是的，谢谢丹尼尔让我们进行了

2328
01:27:23,520 --> 01:27:25,199
非常愉快的讨论

2329
01:27:25,199 --> 01:27:30,520
好吧，和平再见，

2330
01:27:30,520 --> 01:27:33,520
再见，再见

