1
00:00:02,940 --> 00:00:05,939
외부

2
00:00:17,359 --> 00:00:20,520
이것은 활성 추론 연구소입니다.

3
00:00:20,520 --> 00:00:22,400


4
00:00:22,400 --> 00:00:27,240
2022년 11월 15일이며 모델 스트림 7.1

5
00:00:27,240 --> 00:00:30,960
에 있습니다

6
00:00:30,960 --> 00:00:33,840
. 이산 상태 공간에서 활성 추론을 위한 Python 패키지인 Pi mdp에 대해 논의

7
00:00:33,840 --> 00:00:37,500
할 것입니다. 모두 인사를 한 다음

8
00:00:37,500 --> 00:00:41,520
Connor에게 전달하겠습니다.  프레젠테이션

9
00:00:41,520 --> 00:00:43,860
후 프레젠테이션을

10
00:00:43,860 --> 00:00:46,920
위해 몇 가지 토론을 할 것입니다. Pi mdp

11
00:00:46,920 --> 00:00:49,140
스크립트를 살펴보고 라이브 채팅에 나오는 질문을 받습니다.

12
00:00:49,140 --> 00:00:52,500


13
00:00:52,500 --> 00:00:54,660
오늘 참여해 주신 저자

14
00:00:54,660 --> 00:00:57,180
와 Jacob에게 감사 인사를 전하며 시작하겠습니다.

15
00:00:57,180 --> 00:01:00,360
그래서 저는 Daniel입니다. 저는

16
00:01:00,360 --> 00:01:02,399
캘리포니아에 있는 연구원이고

17
00:01:02,399 --> 00:01:05,220
pi mdp에 대해 조금 더 배우고

18
00:01:05,220 --> 00:01:07,560
활성 추론이 어떻게 적용되는지 확인하게

19
00:01:07,560 --> 00:01:11,460
되어 정말 기쁩니다. jakub으로 넘어가겠습니다.

20
00:01:11,460 --> 00:01:14,220
안녕하세요 여러분 저는 yakub입니다.

21
00:01:14,220 --> 00:01:18,020
영국에 있는 학생이고 또한

22
00:01:18,020 --> 00:01:22,200
학부모에 대해 더 많이 듣고 최근

23
00:01:22,200 --> 00:01:25,320
어 개발 및 향후 개발 계획에 대해 논의하게 되어 매우 기쁩니다.

24
00:01:25,320 --> 00:01:30,500
Daphne에게 전달하겠습니다.

25
00:01:30,500 --> 00:01:33,180
안녕하세요 저는 Daphne입니다.

26
00:01:33,180 --> 00:01:36,659
저는 여기 런던에서 일하고 있습니다.

27
00:01:36,659 --> 00:01:39,780
p 내 Mas에 Connor와 함께 한 일에 대한 많은

28
00:01:39,780 --> 00:01:42,000
ter의 논문과

29
00:01:42,000 --> 00:01:43,380
그 이후로 우리가 해온 작업입니다.

30
00:01:43,380 --> 00:01:44,939
그래서

31
00:01:44,939 --> 00:01:46,680
음 정말

32
00:01:46,680 --> 00:01:50,159
정말 좋은 패키지라고 생각하고

33
00:01:50,159 --> 00:01:53,899
사람들이 더 훌륭하게 사용하기 시작하게 되어 기쁩니다.

34
00:01:55,020 --> 00:01:57,540


35
00:01:57,540 --> 00:02:00,360


36
00:02:00,360 --> 00:02:02,700
어웨이 굿 감사합니다 초대해주셔서 감사합니다

37
00:02:02,700 --> 00:02:05,700
어 우리가 음 정리해서 다행

38
00:02:05,700 --> 00:02:07,799
입니다 생방송을 할 수 있는 좋은 기회

39
00:02:07,799 --> 00:02:10,020
같아서 지금 몇 번 왔는데

40
00:02:10,020 --> 00:02:12,660
항상 돌아오는 게 좋아서

41
00:02:12,660 --> 00:02:14,640
안 해요  내 소개 슬라이드가

42
00:02:14,640 --> 00:02:16,860
있으므로 내가 누구인지에 대한 간단한 문장을 말할 것입니다.

43
00:02:16,860 --> 00:02:19,920
그래서 저는 Connor입니다. 저는 독일

44
00:02:19,920 --> 00:02:23,160
의 플러그

45
00:02:23,160 --> 00:02:25,020
동물 행동 연구소

46
00:02:25,020 --> 00:02:28,020
와 콘스탄스에서 생물학 박사 학위를 받는 학생입니다. 제 작업의 대부분

47
00:02:28,020 --> 00:02:30,120
은  집단 동물 행동과 같은 집단 행동에 적용하는

48
00:02:30,120 --> 00:02:33,360
인지 과학 및 복잡한 시스템에 대한 베이지안 렌즈의 능동적 추론과 종류를

49
00:02:33,360 --> 00:02:35,099
적용

50
00:02:35,099 --> 00:02:37,379
하는

51
00:02:37,379 --> 00:02:39,959


52
00:02:39,959 --> 00:02:41,940
것에 대해 이야기하지만 오늘은 이 Prime DP 패키지를 개발하고 있는 제 부업 박사 프로젝트 중 하나에 대해 이야기하겠습니다.

53
00:02:41,940 --> 00:02:43,620


54
00:02:43,620 --> 00:02:45,840


55
00:02:45,840 --> 00:02:47,220
였다  능동적 추론 커뮤니티

56
00:02:47,220 --> 00:02:49,739
의 여러 사람들과 공동 작업을 하는 그룹의 노력

57
00:02:49,739 --> 00:02:51,420


58
00:02:51,420 --> 00:02:52,200


59
00:02:52,200 --> 00:02:55,260
음 그래 그럼

60
00:02:55,260 --> 00:02:58,080
패키지가

61
00:02:58,080 --> 00:03:00,239
실제로 한동안 나왔다는

62
00:03:00,239 --> 00:03:02,519
논문을 살펴보고 올해 초에 나온 논문을 보자

63
00:03:02,519 --> 00:03:04,800
음 그리고 그것은 단지  나는

64
00:03:04,800 --> 00:03:06,599
primevp가

65
00:03:06,599 --> 00:03:08,280
우리

66
00:03:08,280 --> 00:03:09,599
가 논문을 발표했지만

67
00:03:09,599 --> 00:03:12,300
확실히 사용 가능한 독립 실행형 패키지와 같기는 하지만 계속 진행 중인 작업이라는 점을 강조하는 것으로 시작하고 싶습니다.

68
00:03:12,300 --> 00:03:15,239
계속해서 개발할 것이 많고

69
00:03:15,239 --> 00:03:16,440
프레젠테이션이 끝날 무렵에 이에

70
00:03:16,440 --> 00:03:18,000
대해 이야기하겠습니다.  진행 중인 개발 중 일부

71
00:03:18,000 --> 00:03:19,620


72
00:03:19,620 --> 00:03:21,959
는 제 생각에 정말

73
00:03:21,959 --> 00:03:23,700


74
00:03:23,700 --> 00:03:26,459
흥미롭고 패키지의 사용과 확장성을 공개할 것입니다.

75
00:03:26,459 --> 00:03:27,900
감사합니다.

76
00:03:27,900 --> 00:03:30,360
기본적으로 이것은 활성

77
00:03:30,360 --> 00:03:33,000
추론 연구소 팟캐스트 또는 라이브

78
00:03:33,000 --> 00:03:35,640
스트림이므로 저는  동기를 부여하는 데 너무 많은 시간을 소비해야 합니다.

79
00:03:35,640 --> 00:03:37,379
활성 추론은 생각하지

80
00:03:37,379 --> 00:03:40,799
않지만 간단히 말해서 파이 MVP

81
00:03:40,799 --> 00:03:43,379
패키지는 음을

82
00:03:43,379 --> 00:03:45,299
시뮬레이션

83
00:03:45,299 --> 00:03:46,980


84
00:03:46,980 --> 00:03:49,739
하고 개별적으로 활성 추론 프로세스를 실행하기 위한 Python 패키지입니다.  상태 공간

85
00:03:49,739 --> 00:03:51,599
및 이산 상태 공간 사례는 매우

86
00:03:51,599 --> 00:03:53,879
잘 연구된

87
00:03:53,879 --> 00:03:55,560
사례이며 매우 잘 특성화되어 있으며 이산 의사 결정 및 계획과

88
00:03:55,560 --> 00:03:57,360
같은 의사 결정 모델에서 매우 인기가

89
00:03:57,360 --> 00:03:58,980


90
00:03:58,980 --> 00:04:01,620


91
00:04:01,620 --> 00:04:03,659
있으며 모델로서 신경 과학에서 많은 응용 프로그램을 보았습니다.

92
00:04:03,659 --> 00:04:05,159


93
00:04:05,159 --> 00:04:07,019


94
00:04:07,019 --> 00:04:10,700
예를 들어 인간이나 다른 동물의 불연속적인 의사 결정 행동과 같은 것입니다

95
00:04:11,819 --> 00:04:14,580
음. 프레젠테이션에 대한 약간의 개요를 제공할 것이므로 먼저

96
00:04:14,580 --> 00:04:17,040


97
00:04:17,040 --> 00:04:19,738


98
00:04:19,738 --> 00:04:21,839
primvp에서 작업한 사람들의 팀을 소개하고

99
00:04:21,839 --> 00:04:23,699
우리는 다음의 저자입니다.  하지만

100
00:04:23,699 --> 00:04:26,699
실제 효과적인 팀은 그보다 훨씬 더 커집니다.

101
00:04:26,699 --> 00:04:27,840


102
00:04:27,840 --> 00:04:29,460


103
00:04:29,460 --> 00:04:31,020


104
00:04:31,020 --> 00:04:32,940
실제로 논문의 공동 저자가 아니더라도 그것을 개발하거나 사용하고 자신의 방식으로 기여하는 사람들이 많기 때문입니다.

105
00:04:32,940 --> 00:04:34,380


106
00:04:34,380 --> 00:04:35,820


107
00:04:35,820 --> 00:04:38,940
패키지에 대한 동기

108
00:04:38,940 --> 00:04:40,680
불연속 상태 공간에서의 능동적 추론에 대한 간략한 개요를 제공할

109
00:04:40,680 --> 00:04:44,580
것이지만 앞서 언급했듯이 Palm DP에 대해 토론

110
00:04:44,580 --> 00:04:47,340
하기에 정말 좋은 장소라고 생각합니다.

111
00:04:47,340 --> 00:04:48,960


112
00:04:48,960 --> 00:04:50,639


113
00:04:50,639 --> 00:04:53,220
능동적 추론이 무엇인지에 대해 너무 깊이 논의할 필요가

114
00:04:53,220 --> 00:04:54,720
없다고 생각합니다. 그러면

115
00:04:54,720 --> 00:04:58,080
연못 DP의 깊이에 대해 더 자세히 알아보기 위해 시간을 절약할 수 있습니다.

116
00:04:58,080 --> 00:04:59,400
음 다음과 같은 능동적 추론 에이전트를 시뮬레이션하는 기존 접근 방식에 대해 이야기하겠습니다.

117
00:04:59,400 --> 00:05:00,960


118
00:05:00,960 --> 00:05:03,240
즉, Matlab에서

119
00:05:03,240 --> 00:05:05,400
SPM을 사용하고

120
00:05:05,400 --> 00:05:08,400
Prime DP를 SPM과 비교 및 ​​대조하고

121
00:05:08,400 --> 00:05:10,440
Prime

122
00:05:10,440 --> 00:05:12,479
DB

123
00:05:12,479 --> 00:05:15,139
가 SPM의 기원 측면에서 어디에서 왔는지 이해하는 데 도움이

124
00:05:15,139 --> 00:05:17,160
되므로 몇 가지 기능에 대해 이야기하겠습니다.

125
00:05:17,160 --> 00:05:18,840
주요 DP 및 해당 일반

126
00:05:18,840 --> 00:05:20,820
패키지 구조

127
00:05:20,820 --> 00:05:22,860
의 몇 가지 사용

128
00:05:22,860 --> 00:05:24,660
예를 살펴보고

129
00:05:24,660 --> 00:05:27,600
시뮬레이션된 에이전트 동작의 출력과

130
00:05:27,600 --> 00:05:29,520
그와 함께 제공되는 코드

131
00:05:29,520 --> 00:05:31,440
를 보여줌으로써 Pi mdp의 일반적인 흐름이 무엇인지 보여줍니다.

132
00:05:31,440 --> 00:05:35,400
처럼

133
00:05:35,400 --> 00:05:36,960
보이고 마지막에 몇 가지

134
00:05:36,960 --> 00:05:39,060
향후 방향과 진행 중인

135
00:05:39,060 --> 00:05:42,060
음 활동적인 가지에 대해 논의할 것입니다. 소나무 DP

136
00:05:42,060 --> 00:05:44,220
의 지속적인 개발 노력이

137
00:05:44,220 --> 00:05:47,400
시간 EP를 매우 흥미롭고 확장 가능하게 만들 것이라고 생각합니다

138
00:05:47,400 --> 00:05:48,600


139
00:05:48,600 --> 00:05:50,880
음 모든 종류의  새로운 사용 사례에

140
00:05:50,880 --> 00:05:53,699
대해 정말 기대가 됩니다.

141
00:05:53,699 --> 00:05:56,300
다니엘이 말했듯이 언제라도

142
00:05:56,300 --> 00:05:59,400
누군가

143
00:05:59,400 --> 00:06:00,960
음하고 싶지만 설명을 위한 질문이 있으면

144
00:06:00,960 --> 00:06:02,759
언제든지 알려주세요. 그러면

145
00:06:02,759 --> 00:06:04,199
몇 가지 사항에 대해 이야기할 수 있습니다.

146
00:06:04,199 --> 00:06:05,940
더 오래

147
00:06:05,940 --> 00:06:08,639
어 알겠습니다. 그래서 팀을 소개하는 것으로 시작하겠습니다.

148
00:06:08,639 --> 00:06:11,039
그래서 그들은 종이 에디션의 공동 저자입니다.

149
00:06:11,039 --> 00:06:13,440
제게는 Baron millage

150
00:06:13,440 --> 00:06:15,900
Daphne이 오늘 여기 있는 우리를 만들었습니다. uh

151
00:06:15,900 --> 00:06:18,419
Brennan Klein Carl friston Ian 사촌

152
00:06:18,419 --> 00:06:21,360
과 Alexander chance so Carl  그리고 Ian은

153
00:06:21,360 --> 00:06:24,360
제 공동 박사 감독관

154
00:06:24,360 --> 00:06:27,020
이고 음 Carl은 Matlab에서 능동적 추론

155
00:06:27,020 --> 00:06:30,660
의 mdp 또는 이산 상태 공간 공식의 최초 창시자입니다.

156
00:06:30,660 --> 00:06:32,520


157
00:06:32,520 --> 00:06:34,080


158
00:06:34,080 --> 00:06:36,000
그래서

159
00:06:36,000 --> 00:06:38,280
여기에서 우리 작업에 대한 그의 승인 스탬프를 받는 것이 좋습니다.

160
00:06:38,280 --> 00:06:41,220
그리고 그는 일종의  그것에 대한 코사인 그리고

161
00:06:41,220 --> 00:06:43,680


162
00:06:43,680 --> 00:06:45,840
여기 있는 모든 사람이 패키지에 얼마나 중요한지 강조하는 것이 중요하다고 생각합니다.

163
00:06:45,840 --> 00:06:48,000
실제로 나만 한 것이 아니라

164
00:06:48,000 --> 00:06:50,699
실제

165
00:06:50,699 --> 00:06:52,080
소프트웨어 개발의 대부분을 추측하지만

166
00:06:52,080 --> 00:06:53,840
주요 DP의 초기 단계는 실제로 대화였습니다.

167
00:06:53,840 --> 00:06:56,639
Brennan과

168
00:06:56,639 --> 00:07:00,000
Alec은 2019년 또는 그 이전

169
00:07:00,000 --> 00:07:02,460
에 능동적 추론을 수행하는 Python 패키지의 필요성에 대해 이야기했고

170
00:07:02,460 --> 00:07:04,680


171
00:07:04,680 --> 00:07:05,819
아마 다른 사람들도

172
00:07:05,819 --> 00:07:07,440
그 시기에 비슷한 대화를 나누었

173
00:07:07,440 --> 00:07:10,080


174
00:07:10,080 --> 00:07:11,880
을 것이라고 생각합니다.  그리 길지 않은 시간에 이것을 구축할 수 있었습니다.

175
00:07:11,880 --> 00:07:14,699
제

176
00:07:14,699 --> 00:07:16,979
말은 2년 이상을 의미하고

177
00:07:16,979 --> 00:07:18,660
제가 풀타임으로 작업했다면 아마도 더 빨리 완료될 수 있었을 것입니다.

178
00:07:18,660 --> 00:07:21,360
하지만 음

179
00:07:21,360 --> 00:07:23,099


180
00:07:23,099 --> 00:07:25,319
진행 상황을 보는 것이 정말 재미있었습니다  그리고 Daphne이

181
00:07:25,319 --> 00:07:27,599
말했듯이 그녀는 실제로 자신의 석사 논문에서 음 활성 Pi mdp

182
00:07:27,599 --> 00:07:30,240
를 실제로 사용한 최초의 사람 중 한 명

183
00:07:30,240 --> 00:07:32,520


184
00:07:32,520 --> 00:07:34,380
이며 그뿐만 아니라 소나무 다발을 가진 다중 에이전트 집단 행동

185
00:07:34,380 --> 00:07:35,880
과 같은 매우 야심 찬 응용 프로그램에서도 사용했습니다.

186
00:07:35,880 --> 00:07:38,340


187
00:07:38,340 --> 00:07:40,380
DP 에이전트는

188
00:07:40,380 --> 00:07:42,960
서로 상호 작용하여 일종의

189
00:07:42,960 --> 00:07:45,060
의견 Dynamics 및 Echo Chambers와

190
00:07:45,060 --> 00:07:46,680
소셜 네트워크를 시뮬레이션합니다. 정말 흥미

191
00:07:46,680 --> 00:07:49,139


192
00:07:49,139 --> 00:07:51,660
진진해서 그녀와 함께 작업하게 되어

193
00:07:51,660 --> 00:07:53,400
정말 기뻤습니다.  또한 Daphne은 pi mdp 활성 추론 커뮤니티의 선구자이자 Baron

194
00:07:53,400 --> 00:07:55,199
의 아주 좋은 예와 같기 때문에 이것의 일부입니다

195
00:07:55,199 --> 00:07:57,960


196
00:07:57,960 --> 00:07:59,819


197
00:07:59,819 --> 00:08:02,819
. Alec과 Baron은 비활성보다 정교한 메시지 전달 기술

198
00:08:02,819 --> 00:08:04,680
을 개발하는 데 많은 작업을 수행했습니다.

199
00:08:04,680 --> 00:08:06,360


200
00:08:06,360 --> 00:08:09,120
Pym DP에서의 추론

201
00:08:09,120 --> 00:08:11,880
과 uh Baron은

202
00:08:11,880 --> 00:08:15,120
제가 논문을 작성하는 데 정말 중요했습니다.

203
00:08:15,120 --> 00:08:16,860
음, 그는 글쓰기와

204
00:08:16,860 --> 00:08:19,919
개념화에

205
00:08:19,919 --> 00:08:22,020
뛰어났고 후속 표현 및 능동적 추론에 대한 자신의 작업 중 일부에서 실제로 primevp를 사용했습니다.

206
00:08:22,020 --> 00:08:24,360


207
00:08:24,360 --> 00:08:27,060
멋지네요

208
00:08:27,060 --> 00:08:27,599


209
00:08:27,599 --> 00:08:30,240
좋아요 동기부여

210
00:08:30,240 --> 00:08:32,159


211
00:08:32,159 --> 00:08:35,159
가 여기 있는 모든 사람들이 제가 잘 알고 있는 가장 큰 것 중 하나는

212
00:08:35,159 --> 00:08:37,700


213
00:08:37,700 --> 00:08:40,380


214
00:08:40,380 --> 00:08:42,000
지난 10년 동안, 특히 지난

215
00:08:42,000 --> 00:08:43,979
5년 동안 능동적 추론에 대한 인기와 관심이 훨씬 더

216
00:08:43,979 --> 00:08:46,140
많다는 것입니다.

217
00:08:46,140 --> 00:08:48,300


218
00:08:48,300 --> 00:08:49,860
사람들

219
00:08:49,860 --> 00:08:52,080
이

220
00:08:52,080 --> 00:08:53,700
무엇보다 먼저 교육학적 관점

221
00:08:53,700 --> 00:08:54,959
과  자신의

222
00:08:54,959 --> 00:08:57,420
연구나 산업 응용 프로그램에 적용하거나 능동적 추론

223
00:08:57,420 --> 00:08:59,339
으로 실제로 하고 싶은 모든 일에 적용

224
00:08:59,339 --> 00:09:02,060


225
00:09:02,100 --> 00:09:04,320
음 그리고

226
00:09:04,320 --> 00:09:05,880


227
00:09:05,880 --> 00:09:07,320


228
00:09:07,320 --> 00:09:08,880
더 이상 신경과학뿐만 아니라

229
00:09:08,880 --> 00:09:10,680
기계 학습 데이터 과학

230
00:09:10,680 --> 00:09:12,899
엔지니어링과 같은 특정 커뮤니티의 능동적 추론에 특히 많은 관심이 있습니다. 네트워크 과학 심지어

231
00:09:12,899 --> 00:09:14,580
소프트웨어 개발  소프트웨어 엔지니어

232
00:09:14,580 --> 00:09:17,820
와 많은 관심 있는 Fields

233
00:09:17,820 --> 00:09:20,700
음 가장 지배적인 어 언어는

234
00:09:20,700 --> 00:09:23,880
Python입니다. 그래서 제가

235
00:09:23,880 --> 00:09:25,200
들은 것은 사람들이 능동적 추론에 대해 배우기 위해 와서

236
00:09:25,200 --> 00:09:26,880


237
00:09:26,880 --> 00:09:28,500
Python이나 r 또는 무언가에 대한 배경 지식이 있다는 것입니다.

238
00:09:28,500 --> 00:09:29,880
Matlab을

239
00:09:29,880 --> 00:09:31,680


240
00:09:31,680 --> 00:09:34,560


241
00:09:34,560 --> 00:09:37,740
모르거나 Matlab 코드를 구문 분석하는 데 어려움을 겪기 때문에 진입 장벽이

242
00:09:37,740 --> 00:09:39,959
있습니다. 특히

243
00:09:39,959 --> 00:09:42,540
배열이 아닌 프로그래밍

244
00:09:42,540 --> 00:09:44,339
프레임 워크와 같은 경우  그들은

245
00:09:44,339 --> 00:09:47,459
uh JavaScript 또는 무언가를 사용하는 프런트 엔드 웹 개발자이며

246
00:09:47,459 --> 00:09:48,899


247
00:09:48,899 --> 00:09:50,220
실제로 큰 다차원과 같은 것에 익숙하지 않습니다.

248
00:09:50,220 --> 00:09:52,920
배열 프로그래밍

249
00:09:52,920 --> 00:09:55,200
음, 능동적 추론을 수행하는 파이썬 패키지를 구체적으로 만드는 또 다른 동기였습니다.

250
00:09:55,200 --> 00:09:57,180


251
00:09:57,180 --> 00:10:01,019


252
00:10:01,019 --> 00:10:03,720
음, 마지막으로

253
00:10:03,720 --> 00:10:06,360
파이썬에 있기 때문에 다른 생태계

254
00:10:06,360 --> 00:10:08,940
와 대화할 수 있는 생태계를 만들고

255
00:10:08,940 --> 00:10:12,060
있으므로 이상적으로는 primevp

256
00:10:12,060 --> 00:10:14,459
가 진행되지 않습니다.  Pi mdp만 사용하는 스크립트

257
00:10:14,459 --> 00:10:16,860
에서 사용하기 위해

258
00:10:16,860 --> 00:10:19,500
다른 소프트웨어 패키지와 함께 사용할 예정

259
00:10:19,500 --> 00:10:20,760
입니다. 그 중 일부는 인공

260
00:10:20,760 --> 00:10:23,040
지능이나 네트워크 과학 또는 관련된 모든

261
00:10:23,040 --> 00:10:24,420
종류의 프레임워크와 관련

262
00:10:24,420 --> 00:10:26,640
이 있으므로 이제 플러그 앤

263
00:10:26,640 --> 00:10:29,220
piondp 에이전트와 함께 플레이하고 예를 들어 강화 학습을

264
00:10:29,220 --> 00:10:31,080
위한 개방형 AI 체육관과 같은 환경에 배치

265
00:10:31,080 --> 00:10:33,000


266
00:10:33,000 --> 00:10:36,600
하고 이제 다양한 애플리케이션에서 능동적 추론으로 작업할 수 있습니다.

267
00:10:36,600 --> 00:10:39,000


268
00:10:39,000 --> 00:10:40,380


269
00:10:40,380 --> 00:10:43,019


270
00:10:43,019 --> 00:10:44,579


271
00:10:44,579 --> 00:10:46,860


272
00:10:46,860 --> 00:10:49,140
특정 항목을 위해 매우 잘 구축된 다양한 패키지가

273
00:10:49,140 --> 00:10:51,540
이제 Python에 있으므로 함께 사용할 수 있습니다.

274
00:10:51,540 --> 00:10:54,240
w  다른 모든

275
00:10:54,240 --> 00:10:57,079
Python 패키지는

276
00:10:58,079 --> 00:11:00,480
음 좋습니다. 이제 능동적 추론에 대한 간략한 소개이므로 능동적

277
00:11:00,480 --> 00:11:02,519
추론의 기본

278
00:11:02,519 --> 00:11:05,640
패러다임

279
00:11:05,640 --> 00:11:07,500
은 환경에 내장된 에이전트를 고려하는

280
00:11:07,500 --> 00:11:08,700


281
00:11:08,700 --> 00:11:11,519


282
00:11:11,519 --> 00:11:15,540


283
00:11:15,540 --> 00:11:18,540
것입니다.

284
00:11:18,540 --> 00:11:20,880
환경이 정보를 제공한다고 생각

285
00:11:20,880 --> 00:11:22,560
하면 감각 운동 변환

286
00:11:22,560 --> 00:11:24,300
을 수행한 다음 활동적인 유아를 수행합니다

287
00:11:24,300 --> 00:11:26,279


288
00:11:26,279 --> 00:11:28,980
음은 추론

289
00:11:28,980 --> 00:11:31,320
또는 불확실성 처리 문제가

290
00:11:31,320 --> 00:11:33,959
인식 또는

291
00:11:33,959 --> 00:11:36,000
상태 추정 또는 신념

292
00:11:36,000 --> 00:11:38,519
업데이트와 같은 것을 특징 짓는다는 사실을 강조합니다.

293
00:11:38,519 --> 00:11:40,500
능동적 추론 부분이 작용하는 행동으로서

294
00:11:40,500 --> 00:11:42,300
에이전트는 자유 에너지

295
00:11:42,300 --> 00:11:44,640


296
00:11:44,640 --> 00:11:46,320


297
00:11:46,320 --> 00:11:50,700
라는 놀라움에 묶인 이 음을 최소화함으로써 세상에 숨겨진 상태에 대한 믿음을 업데이트할 뿐만 아니라

298
00:11:50,700 --> 00:11:52,620


299
00:11:52,620 --> 00:11:55,380
이러한 종류의 햄 홀시안

300
00:11:55,380 --> 00:11:58,500
추론으로서의 인식에 대한 아이디어

301
00:11:58,500 --> 00:12:01,920
는 또한 당신이 놀라움

302
00:12:01,920 --> 00:12:05,279
이나  행동을 선택하는 데 놀라움을 금치

303
00:12:05,279 --> 00:12:09,120
못하므로 행동을 추론하는 것은

304
00:12:09,120 --> 00:12:11,459
또 다른 종류의 추론

305
00:12:11,459 --> 00:12:13,740
문제가 되므로 행동의 정책 또는 시퀀스는

306
00:12:13,740 --> 00:12:15,839
잠재 변수

307
00:12:15,839 --> 00:12:18,120
또는 숨겨진 상태로 간주되고 이에

308
00:12:18,120 --> 00:12:21,000
대해 추론

309
00:12:21,000 --> 00:12:22,980
하고 인식 행동 코인의 양면을 캐스팅하여 추론합니다.

310
00:12:22,980 --> 00:12:25,200
놀라운 최소화의 예로서

311
00:12:25,200 --> 00:12:27,899
이벤트는

312
00:12:27,899 --> 00:12:29,120


313
00:12:29,120 --> 00:12:32,940
의도적이고 호기심 많은 행동을 표시하는 에이전트이며

314
00:12:32,940 --> 00:12:35,519


315
00:12:35,519 --> 00:12:37,320
활성 추론에 대해서는 아무것도 없는 것과 같습니다. 즉,

316
00:12:37,320 --> 00:12:39,660
이산 상태 공간 또는 생성

317
00:12:39,660 --> 00:12:42,720
의 특정 유형 또는

318
00:12:42,720 --> 00:12:44,519
클래스인 Pi MVP를 사용해야 함을 의미합니다.  활성 추론을 위한 모델

319
00:12:44,519 --> 00:12:45,600


320
00:12:45,600 --> 00:12:49,320
이지만 음, Palm DP 이산 상태

321
00:12:49,320 --> 00:12:51,720
공간 생성 모델은

322
00:12:51,720 --> 00:12:53,279
활성 보험과 함께 작업하기

323
00:12:53,279 --> 00:12:54,899
가

324
00:12:54,899 --> 00:12:57,600
정말 쉽습니다. 여기서 보여주고 있는 이러한 많은 양은 팜 DPS를 다룰 때 계산하기가 매우 쉽기 때문입니다.

325
00:12:57,600 --> 00:12:59,040


326
00:12:59,040 --> 00:13:00,660
또는 부분적으로 관찰된 마크업

327
00:13:00,660 --> 00:13:02,820
결정 프로세스이므로 잠시 후

328
00:13:02,820 --> 00:13:04,800
모든 수학에 대해 알아

329
00:13:04,800 --> 00:13:06,600
보겠습니다.  t는 활성 추론 에이전트 및 환경의 기본 패러다임입니다.

330
00:13:06,600 --> 00:13:08,820


331
00:13:08,820 --> 00:13:11,100
놀람을 최소화하여 인식과 행동을 모두 놀람을 최소화하려고 합니다.

332
00:13:11,100 --> 00:13:13,440


333
00:13:13,440 --> 00:13:15,600


334
00:13:15,600 --> 00:13:17,100
음

335
00:13:17,100 --> 00:13:20,040
, 활성 추론 및 이산 상태 공간에 대한 보다 심층적인

336
00:13:20,040 --> 00:13:22,079
수학적 검토를 위해,

337
00:13:22,079 --> 00:13:24,660
즉

338
00:13:24,660 --> 00:13:26,399
이러한 부분적으로 관찰된 Markov 결정

339
00:13:26,399 --> 00:13:28,860
프로세스를 사용합니다.  저는

340
00:13:28,860 --> 00:13:31,620


341
00:13:31,620 --> 00:13:34,440
Lance Thomas Noor Sebastian victorita와 Carl이 저술한 의학 심리학 저널(Journal of Medical Psychology)에서 탁월한 이 논문을 읽는

342
00:13:34,440 --> 00:13:38,040


343
00:13:38,040 --> 00:13:40,680
것을 추천합니다. 이것은

344
00:13:40,680 --> 00:13:42,899
우리가 가장 유사한 형식에서 시작하는 활성 추론을 위한 업데이트 방정식에 도달하는 방법에 대한 형식적 기반에서 정말 훌륭한 설명입니다.

345
00:13:42,899 --> 00:13:44,459


346
00:13:44,459 --> 00:13:46,440


347
00:13:46,440 --> 00:13:48,660
범주형

348
00:13:48,660 --> 00:13:50,639


349
00:13:50,639 --> 00:13:53,040
및 디리클레 분포의 처리와 우리가 보관하고 있는 버전의 소나무 DP 논문

350
00:13:53,040 --> 00:13:55,380


351
00:13:55,380 --> 00:13:58,079
에는 이와 유사한 종류의 수학을 많이 수행하는 많은 부록이

352
00:13:58,079 --> 00:14:00,779
있으므로 사람들에게 참조할 수도 있습니다.

353
00:14:00,779 --> 00:14:02,720


354
00:14:02,720 --> 00:14:05,220


355
00:14:05,220 --> 00:14:06,899


356
00:14:06,899 --> 00:14:10,440
어, Pym DP에서 에이전트의 두뇌의 빵과 버터를 형성하는 모델은

357
00:14:10,440 --> 00:14:13,139
본질적으로 Centr입니다.

358
00:14:13,139 --> 00:14:14,760


359
00:14:14,760 --> 00:14:16,800


360
00:14:16,800 --> 00:14:19,139
에이전트가

361
00:14:19,139 --> 00:14:21,180
자신의 세계가 어떻게 작동하는지, 환경이 어떻게 작동하는지에

362
00:14:21,180 --> 00:14:22,980
대한 사양인 생성 모델을 작성하는 능동적 추론에 대해

363
00:14:22,980 --> 00:14:24,839
um 환경

364
00:14:24,839 --> 00:14:27,540
이 세계의 역학처럼 자신에게 어떻게 영향을 미친

365
00:14:27,540 --> 00:14:29,639


366
00:14:29,639 --> 00:14:31,920
다고 믿습니까?  State Dynamics는 또한

367
00:14:31,920 --> 00:14:34,139


368
00:14:34,139 --> 00:14:36,240
우리가 생성 모델이라고 부르는 것 또는

369
00:14:36,240 --> 00:14:38,519
일부 사람들이 그렇게 부르는 세계 모델로 인코딩된 관찰을 야기합니다

370
00:14:38,519 --> 00:14:39,839


371
00:14:39,839 --> 00:14:43,199
. Pine DP

372
00:14:43,199 --> 00:14:44,820


373
00:14:44,820 --> 00:14:45,959
에서는 부분적으로 관찰된

374
00:14:45,959 --> 00:14:48,600
Markov 결정 프로세스라고 하는 매우 특정한 종류의 모델 성별만 처리합니다.  이것은 불확실성 하에서

375
00:14:48,600 --> 00:14:50,279
순차적 의사 결정 및 계획의 고전적인 모델입니다.

376
00:14:50,279 --> 00:14:52,380


377
00:14:52,380 --> 00:14:54,180
능동적 추론에 고유하지 않습니다.

378
00:14:54,180 --> 00:14:57,480
사람들은 고전적인

379
00:14:57,480 --> 00:14:59,160
강화 학습 및 모든 종류의

380
00:14:59,160 --> 00:15:01,620
의사 결정 문제

381
00:15:01,620 --> 00:15:03,480
에 Palm DP 모델을 사용

382
00:15:03,480 --> 00:15:05,279
합니다.

383
00:15:05,279 --> 00:15:07,440
현재

384
00:15:07,440 --> 00:15:09,060
상태는 이전 시간 상태의 작업에만 의존

385
00:15:09,060 --> 00:15:10,740
하므로 그것이 정의입니다.

386
00:15:10,740 --> 00:15:12,420


387
00:15:12,420 --> 00:15:14,339


388
00:15:14,339 --> 00:15:15,800
예를 들어 비마코비안

389
00:15:15,800 --> 00:15:18,120
프로세스는 과거로 더 거슬러 올라가는 장기 또는 더 깊은 시간 종속성이 있는 프로세스와 같은 것을 가지지 않는 것과 같은 얕은 시간 종속성을

390
00:15:18,120 --> 00:15:20,279
갖습니다.

391
00:15:20,279 --> 00:15:21,899


392
00:15:21,899 --> 00:15:23,579


393
00:15:23,579 --> 00:15:25,680
팜 DPS는 종종  하지만 항상

394
00:15:25,680 --> 00:15:27,720
불연속 상태 공간과

395
00:15:27,720 --> 00:15:29,940
불연속 시간을 공식화하는 것은 아닙니다.

396
00:15:29,940 --> 00:15:32,760
palmdp라는 단어는

397
00:15:32,760 --> 00:15:35,160
이러한 다항 또는 범주

398
00:15:35,160 --> 00:15:37,500
분포여야 함을 의미하지만

399
00:15:37,500 --> 00:15:39,240
Palm DPS와 활성 영향에 대해 이야기

400
00:15:39,240 --> 00:15:40,980
할 때 거의 항상 이러한 불연속 분포에 대해 이야기

401
00:15:40,980 --> 00:15:43,760


402
00:15:43,800 --> 00:15:45,899
합니다.  기본적으로

403
00:15:45,899 --> 00:15:47,940
한 번에 K개의 개별 상태 중 하나에만 있을 수 있고 다음 번에는 K개의 개별

404
00:15:47,940 --> 00:15:50,279
상태 중 하나로만 진행할 수

405
00:15:50,279 --> 00:15:52,260
있으므로

406
00:15:52,260 --> 00:15:53,699
모든 것이 개별적이지만

407
00:15:53,699 --> 00:15:55,920
본질적

408
00:15:55,920 --> 00:15:57,240
으로 이산적이어야 하는 이러한 Markov 결정 프로세스에는

409
00:15:57,240 --> 00:15:59,040
아무것도 없습니다.  그것은

410
00:15:59,040 --> 00:16:00,420


411
00:16:00,420 --> 00:16:02,820
사람들이

412
00:16:02,820 --> 00:16:04,139


413
00:16:04,139 --> 00:16:05,699


414
00:16:05,699 --> 00:16:08,279
Palm DP라는 단어를 볼 때 종종 만드는 중요한 종류의 융합이기 때문에 언급할 가치가 있다고 생각합니다.  능동적 추론을 위해 이 이산적인 Palm DP 생성 모델을 사용하기로 결정한 이유는

415
00:16:08,279 --> 00:16:11,040


416
00:16:11,040 --> 00:16:12,899


417
00:16:12,899 --> 00:16:15,899
순차적인 의사

418
00:16:15,899 --> 00:16:18,060
결정 및 계획에 적용할 뿐만 아니라

419
00:16:18,060 --> 00:16:20,339


420
00:16:20,339 --> 00:16:24,240
2010년부터 2011년까지

421
00:16:24,240 --> 00:16:26,760
pom DPS를

422
00:16:26,760 --> 00:16:28,079
의사 결정 테스트를 위한 생성 모델이므로 이러한 모델로

423
00:16:28,079 --> 00:16:30,540
능동적 추론을 수행하기 위한 모든 수학

424
00:16:30,540 --> 00:16:32,699
이 이미 완료되었으므로 이를 실제로 코딩하기 위해

425
00:16:32,699 --> 00:16:34,860
새로운 수학이나 이론을 발명할 필요가 없었

426
00:16:34,860 --> 00:16:36,720
습니다.

427
00:16:36,720 --> 00:16:38,339


428
00:16:38,339 --> 00:16:41,040
약 10년 동안

429
00:16:41,040 --> 00:16:44,100
우리의 삶을 더 쉽게 만들었습니다. 개발할 때

430
00:16:44,100 --> 00:16:46,320
음 이제 팜 DPS의 주요 구성 요소에 대해 자세히 살펴보겠습니다.

431
00:16:46,320 --> 00:16:48,899


432
00:16:48,899 --> 00:16:51,480


433
00:16:51,480 --> 00:16:54,360
여기서는 4개의 주요 구성 요소만 나열했지만 관심 있는

434
00:16:54,360 --> 00:16:55,980
사람이 있으면 논의할 수 있는 다른 구성 요소가

435
00:16:55,980 --> 00:16:58,560
있지만  본질적으로

436
00:16:58,560 --> 00:17:01,199
맨 위에 있는 이 줄

437
00:17:01,199 --> 00:17:02,820


438
00:17:02,820 --> 00:17:05,099


439
00:17:05,099 --> 00:17:08,640
은 Into the Fut에서 숨겨진 상태 및 관찰 o에 대한 공동 분포 측면에서 생성 모델에 대한 설명입니다.  ure

440
00:17:08,640 --> 00:17:11,939
so uh

441
00:17:11,939 --> 00:17:13,500
이 생성 모델의 마코비안 특성 때문에 작성할 수 있습니다.

442
00:17:13,500 --> 00:17:15,000


443
00:17:15,000 --> 00:17:16,619
음 이

444
00:17:16,619 --> 00:17:20,339
인수분해된 기본 곱과

445
00:17:20,339 --> 00:17:22,559


446
00:17:22,559 --> 00:17:24,179
시간에 따라 인수분해되는 우도의 합동 분포입니다.

447
00:17:24,179 --> 00:17:25,740


448
00:17:25,740 --> 00:17:27,839


449
00:17:27,839 --> 00:17:29,640
지금 당장 수학을 이해하는 것은 중요하지 않지만

450
00:17:29,640 --> 00:17:31,440
잠시 후 회로도에 매핑할 주요 구성 요소

451
00:17:31,440 --> 00:17:34,320


452
00:17:34,320 --> 00:17:36,360
는 숨겨진 상태가 관찰 모델 또는 우도 매핑이라는 것으로 인코딩하는 관찰을 유발하는 방법에 대한 에이전트의 믿음입니다.

453
00:17:36,360 --> 00:17:38,940


454
00:17:38,940 --> 00:17:40,440


455
00:17:40,440 --> 00:17:42,539


456
00:17:42,539 --> 00:17:45,360
종종 a 행렬 또는 a 배열이라고 부르므로 이것은

457
00:17:45,360 --> 00:17:47,820


458
00:17:47,820 --> 00:17:50,460
현재 시간에 숨겨진 상태가 현재 시간에 어떻게 영향을 미치

459
00:17:50,460 --> 00:17:52,559
거나 관찰을 발생시키는지에 대한

460
00:17:52,559 --> 00:17:54,000


461
00:17:54,000 --> 00:17:56,340


462
00:17:56,340 --> 00:17:58,860


463
00:17:58,860 --> 00:18:02,039
확률적 표현입니다.

464
00:18:02,039 --> 00:18:03,960
한

465
00:18:03,960 --> 00:18:05,640
번에 숨겨진 상태가 다음 시간에 숨겨진 상태와 어떻게 관련되는지에 대한 에이전트의 믿음

466
00:18:05,640 --> 00:18:08,100
그래서 이 맵

467
00:18:08,100 --> 00:18:09,960
은 에이전트가 사용하는 것입니다.

468
00:18:09,960 --> 00:18:12,539


469
00:18:12,539 --> 00:18:14,940
이런 일이 발생하거나 그런 일이 발생하면 세상이 어떻게 진화할지 예측하고

470
00:18:14,940 --> 00:18:17,100


471
00:18:17,100 --> 00:18:19,080


472
00:18:19,080 --> 00:18:22,080
, 내가 어제 있었던 과거의 경험적 사전 경험이나 일종의 메시지를 전달하기

473
00:18:22,080 --> 00:18:24,720
위해 이제

474
00:18:24,720 --> 00:18:26,400
세상이 어떻게 진화하는지에 대한 내 믿음을 받아야 합니다.  때때로 그것은

475
00:18:26,400 --> 00:18:28,860
모두 B 어레이 또는 B 매트릭스로 인코딩되며,

476
00:18:28,860 --> 00:18:31,679
이 마지막 두 개는

477
00:18:31,679 --> 00:18:33,600
일종의 어 우선 순위입니다.

478
00:18:33,600 --> 00:18:35,700
그 중 첫 번째는 매우

479
00:18:35,700 --> 00:18:38,880
중요한 C 어레이 또는 C

480
00:18:38,880 --> 00:18:41,340
벡터라고 하는 에이전트의 사전

481
00:18:41,340 --> 00:18:43,679
신념을 인코딩

482
00:18:43,679 --> 00:18:46,260
합니다.  그리고 우리

483
00:18:46,260 --> 00:18:47,520
가 처음에 말했듯이 능동적 추론은

484
00:18:47,520 --> 00:18:49,980
행동과 인식을 모두 추론 문제로 던지는 것에 관한

485
00:18:49,980 --> 00:18:51,660


486
00:18:51,660 --> 00:18:54,900
것이므로 프레임워크 종류로서의 능동적 추론

487
00:18:54,900 --> 00:18:56,880
은 보상 대신 말로 보상

488
00:18:56,880 --> 00:18:58,500
기능과 강화 학습

489
00:18:58,500 --> 00:19:00,480
의 고전적인 패러다임을 뒤집습니다.

490
00:19:00,480 --> 00:19:02,700
기능은 에이전트에게

491
00:19:02,700 --> 00:19:04,559


492
00:19:04,559 --> 00:19:07,140
미래에 이런 종류의 데이터를 보게 될 것이라는 일종의 낙관적인 믿음을 부여한

493
00:19:07,140 --> 00:19:09,120
다음 resp로 추론을 수행함으로써

494
00:19:09,120 --> 00:19:10,980


495
00:19:10,980 --> 00:19:13,200
사전 믿음이 있는 생성 모델에 에이전트는

496
00:19:13,200 --> 00:19:14,820


497
00:19:14,820 --> 00:19:16,919


498
00:19:16,919 --> 00:19:19,140
사전에 일치하는 관찰을 검색하는 것처럼 보일

499
00:19:19,140 --> 00:19:21,419
것이므로 능동적 추론은

500
00:19:21,419 --> 00:19:23,340
에이전트가 내가 믿는 자기 충족 예언의 프로세스라는 아이디어와 일치합니다.

501
00:19:23,340 --> 00:19:25,919
m 특정 관찰을 볼 가능성이 어느

502
00:19:25,919 --> 00:19:27,840


503
00:19:27,840 --> 00:19:30,780
정도 있으며

504
00:19:30,780 --> 00:19:32,580
생성 모델에 대한 이러한 편향이 있는 정책에 대한 추론을 수행함으로써 에이전트

505
00:19:32,580 --> 00:19:34,740
는 자신

506
00:19:34,740 --> 00:19:37,799
의 이전 선호도 또는 이러한 Pro

507
00:19:37,799 --> 00:19:40,020
관찰에 대한 이러한 사전 신념을 실제로 실현

508
00:19:40,020 --> 00:19:42,660
하게 될 것입니다.  C 벡터

509
00:19:42,660 --> 00:19:44,880
와 C 벡터는 기본적

510
00:19:44,880 --> 00:19:48,000
으로 보상 함수의 베이지안 변환

511
00:19:48,000 --> 00:19:49,340
으로 생각할 수 있으며 실제로

512
00:19:49,340 --> 00:19:51,600
C

513
00:19:51,600 --> 00:19:53,220
벡터 두 보상과 강화

514
00:19:53,220 --> 00:19:55,080
학습의 항목을 정확히 연관시킬 수 있지만 우리는 그것에 들어갈 필요가 없습니다.

515
00:19:55,080 --> 00:19:57,000
지금은

516
00:19:57,000 --> 00:20:00,000
누군가가 관심이 있다면 문서를 공유할 수 있고 마지막

517
00:20:00,000 --> 00:20:01,919
으로 숨겨진 상태에 대한 사전

518
00:20:01,919 --> 00:20:04,200
이 있으며 이것은 단순히

519
00:20:04,200 --> 00:20:07,559
사전 리가 무엇인지에 대한 에이전트의 믿음입니다.  시뮬레이션

520
00:20:07,559 --> 00:20:09,539
의 첫 번째 단계에서 각 숨겨진 상태의 가능성

521
00:20:09,539 --> 00:20:11,820
이 있으므로

522
00:20:11,820 --> 00:20:14,160
능동적 추론에서 실제로 필요한 것은

523
00:20:14,160 --> 00:20:15,900
아니지만 종종

524
00:20:15,900 --> 00:20:18,299
에이전트를 시뮬레이션할 때 시작 시간과 종료 시간이 있는 유한한 시간적 지평선을 사용합니다.

525
00:20:18,299 --> 00:20:20,039


526
00:20:20,039 --> 00:20:23,280
따라서

527
00:20:23,280 --> 00:20:25,200
유한한 임시 지평선이 있는

528
00:20:25,200 --> 00:20:27,240
경우 기본적으로 시간 단계 1에서

529
00:20:27,240 --> 00:20:29,100
세상이 어떻게 생겼는지에 대한 이전 믿음을 연결해야

530
00:20:29,100 --> 00:20:31,740
하고 그 이전 믿음

531
00:20:31,740 --> 00:20:34,940
이 이 d d 벡터에 인코딩되어

532
00:20:34,940 --> 00:20:38,460
직관적으로 스케치할 수 있음을 의미

533
00:20:38,460 --> 00:20:41,039
합니다.  Palm DP 생성 모델은

534
00:20:41,039 --> 00:20:43,799
베이지안 그래프로서 노드가

535
00:20:43,799 --> 00:20:45,720
서로 의존하는 경우 이러한 화살표로 가장자리로 연결

536
00:20:45,720 --> 00:20:47,280
되므로 이 빨간색 노드

537
00:20:47,280 --> 00:20:48,660
는

538
00:20:48,660 --> 00:20:51,720
시간이 지남에 따라 서로 전환되는 숨겨진 상태를 나타내고

539
00:20:51,720 --> 00:20:53,700
파란색 노드

540
00:20:53,700 --> 00:20:56,340
는 에이전트의 신념을 나타냅니다.  숨겨진 상태

541
00:20:56,340 --> 00:20:58,320
에서 관측값이 생성되는 방법에 대한

542
00:20:58,320 --> 00:21:00,299
것이므로 이는

543
00:21:00,299 --> 00:21:02,760
Palm DP의 그래픽 표현일

544
00:21:02,760 --> 00:21:05,580
뿐이며 매트릭스는 우리가 말했듯이

545
00:21:05,580 --> 00:21:07,020
에이전트의 신념을 인코딩합니다.  d

546
00:21:07,020 --> 00:21:09,120
노드는 언제든지 파란색 노드를 생성

547
00:21:09,120 --> 00:21:11,280
하므로 일반적으로 이

548
00:21:11,280 --> 00:21:13,740
행렬이 시간 불변이라고 가정하므로 그들은

549
00:21:13,740 --> 00:21:15,539
이 관찰 매핑

550
00:21:15,539 --> 00:21:18,120
자체가 적어도 대부분의 Palm DPS에서 만든 가정보다 시간에 의존하지 않는다고 믿습니다.

551
00:21:18,120 --> 00:21:19,980


552
00:21:19,980 --> 00:21:21,840


553
00:21:21,840 --> 00:21:25,860
또한 에이전트

554
00:21:25,860 --> 00:21:27,299


555
00:21:27,299 --> 00:21:30,179
는 세계의 전환 역학

556
00:21:30,179 --> 00:21:32,940
이 시간 T에서 시간 T 빼기 1 두

557
00:21:32,940 --> 00:21:35,159
상태를 시간 10에

558
00:21:35,159 --> 00:21:38,280
가져온 다음 정책 선택 또는 조치

559
00:21:38,280 --> 00:21:41,760
가 비활성 추론에서 작동하는 방식에 대한 시불변 신념이 있습니다.

560
00:21:41,760 --> 00:21:43,559
프레임 작업을 제어된

561
00:21:43,559 --> 00:21:46,980
전환으로 수행하므로 B  매트릭스는

562
00:21:46,980 --> 00:21:49,020
단순히 어제의 세상이 어떻게 보여야 하는지를 말하는

563
00:21:49,020 --> 00:21:50,520
것이

564
00:21:50,520 --> 00:21:52,919
아니라

565
00:21:52,919 --> 00:21:55,320
어제의 상황과

566
00:21:55,320 --> 00:21:57,720
내가 이 행동을 T-1 시간에 취했다는 사실을 고려할 때 지금은 어떻게 보여야 하는지를 말

567
00:21:57,720 --> 00:21:59,820
하므로 B 매트릭스는

568
00:21:59,820 --> 00:22:01,559
과거 상태뿐만 아니라

569
00:22:01,559 --> 00:22:04,320
이전 조치에 따라 정책 Pi가

570
00:22:04,320 --> 00:22:07,140


571
00:22:07,140 --> 00:22:10,020
해당 조치에 대한 신념 또는 분포로 작용하므로 조치

572
00:22:10,020 --> 00:22:11,880
가 전환 및 tra에 직접 영향을 미칩니다.

573
00:22:11,880 --> 00:22:13,320
nsitions는 상태에 영향을 미치

574
00:22:13,320 --> 00:22:14,520
므로 그것이 우리

575
00:22:14,520 --> 00:22:18,059
가 많은 손바닥 DP 시나리오에서 행동에 대해 생각하는 방식이며

576
00:22:18,059 --> 00:22:20,760
행동은 Pi는 일련

577
00:22:20,760 --> 00:22:23,520
의 행동 또는 행동 모음

578
00:22:23,520 --> 00:22:26,039
이며 결정

579
00:22:26,039 --> 00:22:28,380
하는 예상 자유 에너지라고하는 중요한 목적 함수를 갖습니다.

580
00:22:28,380 --> 00:22:31,080


581
00:22:31,080 --> 00:22:33,299


582
00:22:33,299 --> 00:22:35,820
예상되는 자유 에너지를 최소화함으로써 우리

583
00:22:35,820 --> 00:22:37,860
는 정책에 대한 믿음을 최적화하고

584
00:22:37,860 --> 00:22:39,659
예상되는 자유 에너지 자체는

585
00:22:39,659 --> 00:22:41,280
생성 모델의 함수입니다. 이 편향된 사전 믿음

586
00:22:41,280 --> 00:22:43,500
을 포함하는 세상에 대한 믿음

587
00:22:43,500 --> 00:22:45,539


588
00:22:45,539 --> 00:22:47,580
당신이 기대하는 관찰

589
00:22:47,580 --> 00:22:50,220
따라서 일종의 보상 기능

590
00:22:50,220 --> 00:22:52,919
이 이 예상 자유 에너지를 통해 정책 선택에 들어가는

591
00:22:52,919 --> 00:22:54,240
것을 볼 수 있습니다. 그래서 우리는

592
00:22:54,240 --> 00:22:57,000
여전히 이 모든 것을 추론 문제의 한 형태라고 부를 수 있습니다

593
00:22:57,000 --> 00:22:58,559


594
00:22:58,559 --> 00:23:00,780


595
00:23:00,780 --> 00:23:03,600
.  그렇게 함으로써 우리는

596
00:23:03,600 --> 00:23:05,640


597
00:23:05,640 --> 00:23:08,400
실제로

598
00:23:08,400 --> 00:23:10,500
행동을 생성하고 세상을 변화시키기 위해 샘플링하는 정책에 대한 분포를 추론

599
00:23:10,500 --> 00:23:12,539
합니다.  d 그런 다음 내가 말했듯이 D 벡터는

600
00:23:12,539 --> 00:23:14,340
기본적으로 초기 숨겨진 상태 분포에 대한 사전입니다.

601
00:23:14,340 --> 00:23:17,959


602
00:23:18,179 --> 00:23:19,260


603
00:23:19,260 --> 00:23:22,679
음 그래 요약하자면 palmdp

604
00:23:22,679 --> 00:23:24,120
활성 추론 모델을 구축

605
00:23:24,120 --> 00:23:26,700
하려면 어 당신은

606
00:23:26,700 --> 00:23:29,460
이 a b c와 D를 기록하거나 인코딩해야 하며

607
00:23:29,460 --> 00:23:30,900
다른 사전이 있습니다.  e 벡터라고 하는 사전 정책에 대해 이야기

608
00:23:30,900 --> 00:23:33,000


609
00:23:33,000 --> 00:23:34,980
할 수 있지만

610
00:23:34,980 --> 00:23:37,200
지금은 능동적 추론에서 대부분의 어려운

611
00:23:37,200 --> 00:23:39,780


612
00:23:39,780 --> 00:23:41,039
작업을 이러한 항목을 기록하는 것으로 구성되어

613
00:23:41,039 --> 00:23:43,620
에이전트가 세상에 대해 믿는 것을 실제로 인코딩하는 것으로 생각할

614
00:23:43,620 --> 00:23:46,320
수 있습니다.  그것은

615
00:23:46,320 --> 00:23:48,120
um에 존재하고 이러한 범주 이산 분포의 경우 이러한 것들은

616
00:23:48,120 --> 00:23:50,520


617
00:23:50,520 --> 00:23:53,159
결국 행렬과 벡터처럼 보입니다.

618
00:23:53,159 --> 00:23:54,900
모든 것이 범주 분포이기 때문에

619
00:23:54,900 --> 00:23:57,059
당신

620
00:23:57,059 --> 00:23:59,100
은 연속적인 무한 차원

621
00:23:59,100 --> 00:24:01,200
공간을 다루지 않습니다.

622
00:24:01,200 --> 00:24:02,940


623
00:24:02,940 --> 00:24:05,340
4 x 4 매트릭스 또는 5 x 5

624
00:24:05,340 --> 00:24:07,260
매트릭스와 같은 항목의 수 예,

625
00:24:07,260 --> 00:24:10,980
우리가 예를 들기 전에 생각합니다. 그래서 Matlab py

626
00:24:10,980 --> 00:24:12,299
와 같은 다음 부분에 대해 이야기하겠습니다.

627
00:24:12,299 --> 00:24:14,760
thon

628
00:24:14,760 --> 00:24:17,340
음 변증법 우리가 그것에 대해 이동하기 전에

629
00:24:17,340 --> 00:24:19,200
하지만 외국 질문이 있으면 잠시 멈춰야할까요

630
00:24:19,200 --> 00:24:21,780


631
00:24:21,780 --> 00:24:25,080
예 감사합니다

632
00:24:25,080 --> 00:24:28,020
Daphne 또는 Jakob 당신은 어떤 생각이나 반성을 제공하고 싶습니까

633
00:24:28,020 --> 00:24:31,879


634
00:24:35,000 --> 00:24:37,020
? 내가

635
00:24:37,020 --> 00:24:38,340
항상 약간 혼란스러워했던 한 가지가 있습니다.  이전 기본 설정의 매개 변수화에 있는

636
00:24:38,340 --> 00:24:40,620
문제를 지금 해결하는 것이 좋을 수 있습니다.

637
00:24:40,620 --> 00:24:42,360


638
00:24:42,360 --> 00:24:43,980


639
00:24:43,980 --> 00:24:47,640


640
00:24:47,640 --> 00:24:49,980
초기화할 때

641
00:24:49,980 --> 00:24:52,760


642
00:24:52,799 --> 00:24:55,679
1보다 큰 um 정수가 1보다

643
00:24:55,679 --> 00:24:57,900
크거나 같지만 다음과 같이 수행하는 이유를 정확히 설명할 수

644
00:24:57,900 --> 00:25:00,299
있습니까?  소프트 최대값은 나중에

645
00:25:00,299 --> 00:25:02,039
실제로

646
00:25:02,039 --> 00:25:04,559
우리가 이러한 확률에 대한 선호도를 정의하지 않는 이유와 같은

647
00:25:04,559 --> 00:25:05,820


648
00:25:05,820 --> 00:25:08,460
추론을 사용할 때 좋습니다.

649
00:25:08,460 --> 00:25:13,380
좋은 점이며 일반적으로 Matlab과 Python 구현 모두에서 그렇게 언급하는 것이 좋습니다.

650
00:25:13,620 --> 00:25:15,960


651
00:25:15,960 --> 00:25:17,940


652
00:25:17,940 --> 00:25:22,559
Pi mdp 우리는

653
00:25:22,559 --> 00:25:24,659
c

654
00:25:24,659 --> 00:25:27,299
Vector를 확률로 인코딩하는 대신 c Vector를 인코딩할 때 동일한 작업을 수행하기로 결정했습니다.

655
00:25:27,299 --> 00:25:29,039


656
00:25:29,039 --> 00:25:31,260
적는 것은 C 벡터의 로그

657
00:25:31,260 --> 00:25:33,840


658
00:25:33,840 --> 00:25:36,419
이므로 상대 로그 확률

659
00:25:36,419 --> 00:25:40,080
로 기록하고 확률로 직접 기록하는 것보다 잠재적으로 더

660
00:25:40,080 --> 00:25:41,580
음

661
00:25:41,580 --> 00:25:44,340
더 직관적인 매개변수화

662
00:25:44,340 --> 00:25:46,080


663
00:25:46,080 --> 00:25:49,620
가 가능한 이유는 확률의 로그가 다음과 같기 때문

664
00:25:49,620 --> 00:25:51,840
입니다.  실제 보상과 비슷

665
00:25:51,840 --> 00:25:54,299
하므로 이 생성 모델로 돌아가면

666
00:25:54,299 --> 00:25:56,220


667
00:25:56,220 --> 00:25:59,039
예상되는 자유 에너지가 자유 에너지가 되는

668
00:25:59,039 --> 00:26:01,559
것은 사실

669
00:26:01,559 --> 00:26:02,220
음

670
00:26:02,220 --> 00:26:04,559
그리고 자유 에너지는

671
00:26:04,559 --> 00:26:06,960
일종의 KL 다이버전스입니다. 그것은 자연적으로 로그 형식의 비트로 인코딩됩니다.

672
00:26:06,960 --> 00:26:08,820


673
00:26:08,820 --> 00:26:10,320


674
00:26:10,320 --> 00:26:13,620
따라서

675
00:26:13,620 --> 00:26:17,820
로그 공간의 측면에서 이전처럼 기록

676
00:26:17,820 --> 00:26:21,059


677
00:26:21,059 --> 00:26:24,059
하는 경우 이전 기본 설정에서 로그 단위

678
00:26:24,059 --> 00:26:26,400
의 수를 변경하면 예상되는 여유 공간의 변화와 더 선형적으로 관련되어 있음을 알

679
00:26:26,400 --> 00:26:28,380
수 있습니다.

680
00:26:28,380 --> 00:26:30,080
그 관찰로 이어지는 정책에 대한 에너지

681
00:26:30,080 --> 00:26:32,220
반면

682
00:26:32,220 --> 00:26:35,760
확률 공간 측면에서

683
00:26:35,760 --> 00:26:37,980
사전에 작성하는 경우 예상되는

684
00:26:37,980 --> 00:26:39,779
자유 에너지의 결과 변화는 무언가를 변경하는 것입니다.  확률 공간에서 g는

685
00:26:39,779 --> 00:26:43,320


686
00:26:43,320 --> 00:26:45,120
선형적이지 않을 것입니다. 비선형적

687
00:26:45,120 --> 00:26:45,900


688
00:26:45,900 --> 00:26:48,659
변화가 될 것입니다. 따라서 보상을 로그 확률로

689
00:26:48,659 --> 00:26:49,919


690
00:26:49,919 --> 00:26:53,100
생각하면 하나의 추가 로그 단위

691
00:26:53,100 --> 00:26:55,919
또는 하나의 자연 로그와 같은 것, 하나의 Nat 또는

692
00:26:55,919 --> 00:26:59,279
다른 것보다 조금 더 가치 있는 것입니다.  사물 1과 사물 2를 보는 것 사이

693
00:26:59,279 --> 00:27:00,960
의 예상되는 자유 에너지 차이 측면에서 실제로 반영될 것입니다.

694
00:27:00,960 --> 00:27:02,460


695
00:27:02,460 --> 00:27:04,799


696
00:27:04,799 --> 00:27:06,480
반면 우리

697
00:27:06,480 --> 00:27:08,340
가

698
00:27:08,340 --> 00:27:10,020
예상 자유 에너지 차이가 ​​선형적이

699
00:27:10,020 --> 00:27:12,299
지 않기 때문에 직관적이지 않을 확률 측면에서 이 두 가지를 인코딩한다면

700
00:27:12,299 --> 00:27:13,740


701
00:27:13,740 --> 00:27:16,080
음 그래서 그것은

702
00:27:16,080 --> 00:27:18,659
우리가 로그 공간에서 무언가를 인코딩하기로 결정한 이유에 대한 빠른 이유와

703
00:27:18,659 --> 00:27:21,179
같지만

704
00:27:21,179 --> 00:27:23,039
어떤 방법으로든 수학적으로 필요한 것은 없습니다. 확률

705
00:27:23,039 --> 00:27:24,240


706
00:27:24,240 --> 00:27:26,580
의 관점에서 사전을 쉽게 작성할 수 있습니다.

707
00:27:26,580 --> 00:27:29,039


708
00:27:29,039 --> 00:27:30,779
더 많은 보상을 해주세요

709
00:27:30,779 --> 00:27:32,460
정말

710
00:27:32,460 --> 00:27:36,200
예 이해가 많이 되네요

711
00:27:36,200 --> 00:27:39,860
감사합니다 제이콥

712
00:27:40,140 --> 00:27:43,260
예 음

713
00:27:43,260 --> 00:27:44,880


714
00:27:44,880 --> 00:27:49,860
음 실제가 되기 위해 AMB 행렬이나 텐서에 대한 심장 요구 사항이 있는지 궁금

715
00:27:49,860 --> 00:27:53,039
합니다

716
00:27:53,039 --> 00:27:56,279
범주형 행렬로 인코딩되거나

717
00:27:56,279 --> 00:27:58,020
행렬의 함수

718
00:27:58,020 --> 00:28:00,840
와 에이전트가 그것을 사용

719
00:28:00,840 --> 00:28:03,000
하여 관찰에서 숨겨진 상태를 추론하는 방식에 대해 생각하기 때문에

720
00:28:03,000 --> 00:28:05,340


721
00:28:05,340 --> 00:28:07,980
고차원 상태 공간을 신경망과 같은 것으로 인코딩할 수 있을지 생각하고 있습니다.

722
00:28:07,980 --> 00:28:09,720


723
00:28:09,720 --> 00:28:11,460


724
00:28:11,460 --> 00:28:14,279
이러한 확률적

725
00:28:14,279 --> 00:28:17,279
표현을 근사화할 수 있는 네트워크는 어 관찰과 숨겨진 상태 사이

726
00:28:17,279 --> 00:28:20,039
의 관계 유형을 나타내는 것을 배울

727
00:28:20,039 --> 00:28:23,400


728
00:28:23,400 --> 00:28:25,460


729
00:28:25,500 --> 00:28:29,460


730
00:28:29,460 --> 00:28:32,460
수 있습니다 음 예 확실히 예 그래서 기본적으로 죄송하지만 예

731
00:28:32,460 --> 00:28:34,080
기본적으로 그것이 가능할 것이라고 생각

732
00:28:34,080 --> 00:28:36,779
하는지 여부와 제가  Matlab에

733
00:28:36,779 --> 00:28:39,179


734
00:28:39,179 --> 00:28:41,880
비해 Python의 장점을 얻을 수 있을 것이라고 확신하는 Python 구현과 같은 느낌

735
00:28:41,880 --> 00:28:43,980
이 듭니다. 어

736
00:28:43,980 --> 00:28:46,799
또한 다른 라이브러리와 데이터 과학 내에서 상호 운용성을 제공합니다.

737
00:28:46,799 --> 00:28:51,919


738
00:28:51,919 --> 00:28:54,659
예, 좋은 점입니다.

739
00:28:54,659 --> 00:28:56,880
그래서

740
00:28:56,880 --> 00:28:59,159
처음에 우리가  Palm DPS에 대해 이야기

741
00:28:59,159 --> 00:29:01,020
했지만 Palm DPS에 대해서는 아무 것도 없습니다

742
00:29:01,020 --> 00:29:02,520


743
00:29:02,520 --> 00:29:05,279
.  EP에서 정의하는 주요

744
00:29:05,279 --> 00:29:06,600


745
00:29:06,600 --> 00:29:09,419
사항은 에이전트

746
00:29:09,419 --> 00:29:11,820
가 파란색 노드만 볼 수 있도록 부분적으로 관찰 가능

747
00:29:11,820 --> 00:29:14,100
하고 Markovian 프로세스이므로 Hidden State

748
00:29:14,100 --> 00:29:16,080
의 메모리에 일시적인 얕음이

749
00:29:16,080 --> 00:29:18,000
있지만 a와 b를 대체할 수 있다는 것입니다.

750
00:29:18,000 --> 00:29:21,240
모든 종류의 매개변수화

751
00:29:21,240 --> 00:29:23,279
를 사용하면 적절한 우도

752
00:29:23,279 --> 00:29:26,159
함수여야 합니다. 그래서

753
00:29:26,159 --> 00:29:28,080
음 적절한 우도 속성과 같이

754
00:29:28,080 --> 00:29:29,940


755
00:29:29,940 --> 00:29:32,820
있어야 합니다. 다변량 가우시안 또는 코시 분포 또는 베르누이 분포 또는 어가 될 수 없다는 것을 의미하는 것은 없습니다.

756
00:29:32,820 --> 00:29:35,159


757
00:29:35,159 --> 00:29:38,279
예, 모든 종류의

758
00:29:38,279 --> 00:29:41,220
지수 가족 또는

759
00:29:41,220 --> 00:29:43,440


760
00:29:43,440 --> 00:29:46,140
사람들이 강화 학습에서 자주 사용하는 매개변수화된 신경망과 같은 것은

761
00:29:46,140 --> 00:29:47,399


762
00:29:47,399 --> 00:29:49,200


763
00:29:49,200 --> 00:29:51,720


764
00:29:51,720 --> 00:29:53,820
시간 T에서 시간 상태를 취하고 상태로 이동한다고 말하는 많은 신경망으로 역학 모델을 매개변수화하는 것과 같습니다.

765
00:29:53,820 --> 00:29:56,340
시간 t에 1을 더한 시간에 그것에

766
00:29:56,340 --> 00:29:58,799
어려움이 있는 이유는 단순히

767
00:29:58,799 --> 00:30:00,899


768
00:30:00,899 --> 00:30:03,000


769
00:30:03,000 --> 00:30:06,059
일단 당신이 머무르면 예상되는 자유 에너지와 같은 것을 계산하는 방법이 불분명하기 때문입니다.  rt

770
00:30:06,059 --> 00:30:07,320


771
00:30:07,320 --> 00:30:10,020
는 잘 작동하지 않는 분포로 이동

772
00:30:10,020 --> 00:30:12,539
하므로 이

773
00:30:12,539 --> 00:30:14,580
프레임워크가 개별

774
00:30:14,580 --> 00:30:17,220
범주형 상태 버전에서 개발된 많은 이유는

775
00:30:17,220 --> 00:30:19,260


776
00:30:19,260 --> 00:30:21,299
누군가가 슬롯

777
00:30:21,299 --> 00:30:23,880
머신을 플레이하거나 왼쪽 또는 오른쪽으로 이동하기로 결정하는 것과 같은 저차원 작업을 모델링하기 때문만은 아닙니다

778
00:30:23,880 --> 00:30:27,240
.  a y 미로에서 이러한

779
00:30:27,240 --> 00:30:29,279
이산 분포를 사용하여 한 가지

780
00:30:29,279 --> 00:30:30,720
행동에 대한 좋은 설명을 제공하는

781
00:30:30,720 --> 00:30:32,640
것이 쉽지만 문자 그대로

782
00:30:32,640 --> 00:30:34,980
수학적 다루기 쉬운 이유는 예상되는 자유 에너지에 따라

783
00:30:34,980 --> 00:30:37,080
항상 닫힌 형태의 솔루션이 있는 것은 아닙니다.

784
00:30:37,080 --> 00:30:38,820


785
00:30:38,820 --> 00:30:40,559


786
00:30:40,559 --> 00:30:42,899


787
00:30:42,899 --> 00:30:45,000
예를 들어 Magnus

788
00:30:45,000 --> 00:30:48,480
cudall은 선형 동적 시스템

789
00:30:48,480 --> 00:30:50,760
에서 예상되는 자유 에너지를 계산하는 엔트로피에 대한 논문을 가지고

790
00:30:50,760 --> 00:30:52,559
있습니다. 기본적으로

791
00:30:52,559 --> 00:30:54,360
모든 A와 B는

792
00:30:54,360 --> 00:30:57,059
가우시안으로 표시되므로

793
00:30:57,059 --> 00:30:59,940
선형 제어 가능이라고 부릅니다.  동적 시스템

794
00:30:59,940 --> 00:31:01,260
이며 동작이 B 매트릭스에 미치는 영향에 대해 몇 가지 가정도 해야 합니다.

795
00:31:01,260 --> 00:31:03,120


796
00:31:03,120 --> 00:31:05,039
이것은 더 이상 행렬이 아닙니다.

797
00:31:05,039 --> 00:31:07,100
연속

798
00:31:07,100 --> 00:31:10,080
가우시안에 더 가깝습니다. 그리고 그들은 정보

799
00:31:10,080 --> 00:31:11,880
를 얻는 것과 같이 예상되는 자유 에너지로 얻을 수 있는 일반적인 항이

800
00:31:11,880 --> 00:31:13,559


801
00:31:13,559 --> 00:31:15,720


802
00:31:15,720 --> 00:31:17,760
우리가 범주형 분포를 사용할 때 얻을 수 있는 많은 흥미로운 것들을 발견합니다.

803
00:31:17,760 --> 00:31:19,740


804
00:31:19,740 --> 00:31:21,659
우리가 가우시안을 사용할 때 용어는 실제로 사라지므로 일반적으로 범주형을 사용하여

805
00:31:21,659 --> 00:31:23,520
얻을 수 있는

806
00:31:23,520 --> 00:31:26,580
정보 획득 탐색 또는 정보

807
00:31:26,580 --> 00:31:28,260
탐색 용어와 같은 멋진 용어를 실제로 얻지

808
00:31:28,260 --> 00:31:30,720
못하지만 신경망을 사용하는

809
00:31:30,720 --> 00:31:32,460
경우 여전히 사용할 수 있는 것과 같은 다른 방법이

810
00:31:32,460 --> 00:31:34,080


811
00:31:34,080 --> 00:31:36,600
있습니다.  예상되는 자유 에너지를 계산하기 위한 샘플링 방식과 같은 것들

812
00:31:36,600 --> 00:31:39,240


813
00:31:39,240 --> 00:31:40,919
음 기본적으로 가능한 많은 궤적을 샘플링하는 것과 같은 곳에서

814
00:31:40,919 --> 00:31:42,600


815
00:31:42,600 --> 00:31:44,820


816
00:31:44,820 --> 00:31:46,679
예상되는 자유 에너지를 계산하기 위해 몬테카를로 스타일과 같은 샘플을 사용할 수

817
00:31:46,679 --> 00:31:48,179


818
00:31:48,179 --> 00:31:50,039


819
00:31:50,039 --> 00:31:52,620
있고 크기 조정과 같은 작업을 수행한 많은 그룹이 있습니다.  심층 신경망에 대한 능동적 추론

820
00:31:52,620 --> 00:31:54,539
그들은 그런 종류

821
00:31:54,539 --> 00:31:56,340
의 접근 방식을 사용했습니다. Alec 기회 종이

822
00:31:56,340 --> 00:31:57,960
Scout scaling 활성 추론  ence는

823
00:31:57,960 --> 00:31:59,820


824
00:31:59,820 --> 00:32:02,940
Tim 언어 그룹과 같은 많은 일을 합니다

825
00:32:02,940 --> 00:32:04,620
음 저는 제가 생각하는 사람을 떠나고

826
00:32:04,620 --> 00:32:07,080
싶지 않으며 분명히 많은

827
00:32:07,080 --> 00:32:08,700
North Vegeta가

828
00:32:08,700 --> 00:32:11,220
심층 신경망으로 많은 적극적인 추론을 수행했습니다.

829
00:32:11,220 --> 00:32:12,720
많은

830
00:32:12,720 --> 00:32:13,919
사람들이 실제로

831
00:32:13,919 --> 00:32:15,480
신경망을 유지하기 위해 활성 추론을 적용하려고 시도하는 것처럼 바이러스가 우리를 발견했습니다.

832
00:32:15,480 --> 00:32:17,460
그들은 기본적으로 Pi MVP에서 수행되는 방식과 다른

833
00:32:17,460 --> 00:32:18,960
예상 자유 에너지를 계산하는 방법을 찾아야 합니다.

834
00:32:18,960 --> 00:32:21,240


835
00:32:21,240 --> 00:32:23,279
왜냐하면 Pine BP에서

836
00:32:23,279 --> 00:32:25,200
예상되는 자유 에너지를 정확히 계산할 수 있습니다.

837
00:32:25,200 --> 00:32:27,360
결국

838
00:32:27,360 --> 00:32:29,159
행렬 벡터 곱의 묶음이 되고

839
00:32:29,159 --> 00:32:30,179
합계가

840
00:32:30,179 --> 00:32:31,919
되므로

841
00:32:31,919 --> 00:32:34,020
더 복잡한 분포를 사용할

842
00:32:34,020 --> 00:32:36,480
때 더 어려워지지만 결코 불가능하지는 않습니다.

843
00:32:36,480 --> 00:32:37,100


844
00:32:37,100 --> 00:32:39,539


845
00:32:39,539 --> 00:32:40,980
어떤 종류의 근사치를 가지고

846
00:32:40,980 --> 00:32:43,380
있지만 사람들이 하이브리드 모델이라고 부르는 것을 포함하는 것을 피할 수 있는 방법이 있다고 생각합니다.

847
00:32:43,380 --> 00:32:45,899


848
00:32:45,899 --> 00:32:48,539


849
00:32:48,539 --> 00:32:50,159


850
00:32:50,159 --> 00:32:53,100


851
00:32:53,100 --> 00:32:54,960
일부 상위 계층과 같은 손바닥 DP로 이동한 다음

852
00:32:54,960 --> 00:32:56,640
이산 범주 공간과 같은 압수된 DP 공간에서

853
00:32:56,640 --> 00:32:58,260


854
00:32:58,260 --> 00:33:00,059
예상 자유 에너지 및 자유 에너지

855
00:33:00,059 --> 00:33:03,000
를 계속 계산할 수 있지만 여전히

856
00:33:03,000 --> 00:33:04,620
고차원 신경망과 같은 낮은 수준에서

857
00:33:04,620 --> 00:33:07,260
데이터를 투사할 수 있습니다.

858
00:33:07,260 --> 00:33:09,720
이 저차원 공간

859
00:33:09,720 --> 00:33:11,820


860
00:33:11,820 --> 00:33:13,620
으로

861
00:33:13,620 --> 00:33:15,600
모든 것이 정확하지만 신경망

862
00:33:15,600 --> 00:33:16,740
의 우수한

863
00:33:16,740 --> 00:33:19,140
차원 감소 및 기능

864
00:33:19,140 --> 00:33:20,880
추출 속성을 활용

865
00:33:20,880 --> 00:33:22,500
하여 먼저 관찰을 전처리하는 것과 같은 이 저차원 Palm DP 공간에서 모든 efe 활성 추론을 수행할 수 있습니다.

866
00:33:22,500 --> 00:33:24,419
그것은

867
00:33:24,419 --> 00:33:26,340


868
00:33:26,340 --> 00:33:28,679


869
00:33:28,679 --> 00:33:30,600


870
00:33:30,600 --> 00:33:32,580
기본적으로 모든 Pi mdp Auto를

871
00:33:32,580 --> 00:33:34,080
미분 가능하게 만드는 것과 관련된 첫 번째 단계에서 약간의 진전을 이루었기 때문에 끝에서 이야기할 것입니다.

872
00:33:34,080 --> 00:33:36,120


873
00:33:36,120 --> 00:33:38,700
모델

874
00:33:38,700 --> 00:33:41,640
네, 굉장하지만 좋은 질문입니다.

875
00:33:41,640 --> 00:33:45,059
저는 이것이 생성 모델의 신체 계획과 같다고 생각합니다.

876
00:33:45,059 --> 00:33:48,779


877
00:33:48,779 --> 00:33:51,059
오늘은 내일 안테나가 되거나

878
00:33:51,059 --> 00:33:53,580
지연되면 더 길어지거나 두꺼워

879
00:33:53,580 --> 00:33:56,159
집니다. 모델의 다른 부분을 교체하고 구성하는 방법에는 여러 가지가 있습니다.

880
00:33:56,159 --> 00:33:58,440


881
00:33:58,440 --> 00:34:00,600
덕분에

882
00:34:00,600 --> 00:34:01,860
멋진 작업을

883
00:34:01,860 --> 00:34:03,059


884
00:34:03,059 --> 00:34:04,980
계속할 수 있습니다.

885
00:34:04,980 --> 00:34:07,260


886
00:34:07,260 --> 00:34:08,820


887
00:34:08,820 --> 00:34:10,020
현재 통화 중인 모든 사람

888
00:34:10,020 --> 00:34:11,820
이 원래 수행된 방식에 익숙하다고 확신하는 활성 추론 연구

889
00:34:11,820 --> 00:34:15,540
는 기본적으로 어 Carl

890
00:34:15,540 --> 00:34:17,760
friston과 몇몇 다른 사람들

891
00:34:17,760 --> 00:34:20,879
이 SPM 패키지의 일부인 Matlab 스크립트를 작성했습니다.

892
00:34:20,879 --> 00:34:22,440


893
00:34:22,440 --> 00:34:24,780
데이터 분석 및

894
00:34:24,780 --> 00:34:26,940
통계 테스트

895
00:34:26,940 --> 00:34:29,159
그리고 Dem 또는

896
00:34:29,159 --> 00:34:31,139
동적 기대 최대화라는 하위 패키지

897
00:34:31,139 --> 00:34:33,000
가 있습니다. 이는

898
00:34:33,000 --> 00:34:34,859
지속적인 능동 추론을 포함한 능동 추론

899
00:34:34,859 --> 00:34:36,599
뿐만 아니라 일반화된 필터링

900
00:34:36,599 --> 00:34:39,300
과 마찬가지로 경험적 데이터에서 비선형 상태 공간 모델을 피팅

901
00:34:39,300 --> 00:34:41,879


902
00:34:41,879 --> 00:34:43,679
하는 데 사용됩니다.  대부분의 기능에 SPM 밑줄 Mt가 접두사로 붙는 모든 종류의

903
00:34:43,679 --> 00:34:46,800
개별 활성 추론 도구 상자

904
00:34:46,800 --> 00:34:48,599
가 있습니다.

905
00:34:48,599 --> 00:34:52,199
mdp 따라서

906
00:34:52,199 --> 00:34:53,879
기본적으로 Pine MVP가 대부분 수행하는 모든 작업을 수행하는 주요 기능은

907
00:34:53,879 --> 00:34:56,399


908
00:34:56,399 --> 00:34:58,740
SPM mdp vbx라는 기능을 포함하는 것

909
00:34:58,740 --> 00:35:02,339


910
00:35:02,339 --> 00:35:04,080


911
00:35:04,080 --> 00:35:06,420


912
00:35:06,420 --> 00:35:07,980
입니다.

913
00:35:07,980 --> 00:35:09,599
하나의 함수가 본질적으로

914
00:35:09,599 --> 00:35:12,420
활성 추론 및 학습을 수행하고

915
00:35:12,420 --> 00:35:14,460
하나의 호출로 전달되는 모든 메시지를 수행

916
00:35:14,460 --> 00:35:16,440


917
00:35:16,440 --> 00:35:18,839
하기 때문에 하나의 함수를 구현합니다. mdp

918
00:35:18,839 --> 00:35:21,000
를 전달한 다음 일종의 Black  Box

919
00:35:21,000 --> 00:35:23,339
way는 모든 신념 업데이트

920
00:35:23,339 --> 00:35:25,140
와 행동의 이력, 우아함에도 불구하고

921
00:35:25,140 --> 00:35:28,079
필요한 모든 것을 제공합니다.

922
00:35:28,079 --> 00:35:30,599


923
00:35:30,599 --> 00:35:33,000
그것은 유용성과 실제로 얼마나 강력한지와 같습니다.

924
00:35:33,000 --> 00:35:35,760


925
00:35:35,760 --> 00:35:37,260


926
00:35:37,260 --> 00:35:38,579
많은 작업

927
00:35:38,579 --> 00:35:40,859
이 문제는 단일

928
00:35:40,859 --> 00:35:42,960
기능일 뿐 모듈이 많지 않기 때문에 활성 추론 프로세스의

929
00:35:42,960 --> 00:35:45,300
다양한 하위 계산을 유연하게 구성하기가 매우 어렵기

930
00:35:45,300 --> 00:35:47,220


931
00:35:47,220 --> 00:35:49,200
때문에 맞춤형 작업을 원하는 경우

932
00:35:49,200 --> 00:35:50,700


933
00:35:50,700 --> 00:35:53,280
능동적 추론 응용 프로그램에 들어가

934
00:35:53,280 --> 00:35:55,859
숨겨진 상태 추론을 수행하기 전에 a 행렬

935
00:35:55,859 --> 00:35:57,300
의 매개변수를 업데이트하고 싶고

936
00:35:57,300 --> 00:35:58,859


937
00:35:58,859 --> 00:36:01,260
이 특정 방식

938
00:36:01,260 --> 00:36:05,119
으로 수행하고 싶습니다. SPM mdp vbx에서는 그렇게 하기가 매우 어렵기 때문에

939
00:36:05,119 --> 00:36:07,380
자주 보는 것입니다.

940
00:36:07,380 --> 00:36:09,720
내가 하고 있던 특정 일에 대한 약간의 전문가 접두사

941
00:36:09,720 --> 00:36:11,220


942
00:36:11,220 --> 00:36:13,140
를 가진 이 함수의 5가지 다른 버전을 가지게

943
00:36:13,140 --> 00:36:15,960


944
00:36:15,960 --> 00:36:18,480
되었고, 그 다음에

945
00:36:18,480 --> 00:36:21,119
는 어 종류가 아닌 것과 같이 끝납니다.

946
00:36:21,119 --> 00:36:22,500


947
00:36:22,500 --> 00:36:24,060
많은 상용구 코드

948
00:36:24,060 --> 00:36:26,400
를 만들고 있기 때문에 효율적입니다. 그러면 프로젝트에서 탐색하려는

949
00:36:26,400 --> 00:36:27,900
특정 작은 버전의 활성

950
00:36:27,900 --> 00:36:29,460
추론을 수행하는

951
00:36:29,460 --> 00:36:32,220


952
00:36:32,220 --> 00:36:34,680
기능이 하나 있으므로 Matlab 내에서도 이 기능 하나를

953
00:36:34,680 --> 00:36:36,839
모듈화하면 이렇게 할 수 있습니다.  기본적으로

954
00:36:36,839 --> 00:36:38,579
훨씬 더 유연하게 만들고 코드

955
00:36:38,579 --> 00:36:41,099
복사 및 붙여넣기를 많이 절약할 수

956
00:36:41,099 --> 00:36:43,280
있습니다

957
00:36:43,500 --> 00:36:45,420
음 또 다른 문제는 추론 및

958
00:36:45,420 --> 00:36:46,980
정책 선택이 고정되어 비교할 수

959
00:36:46,980 --> 00:36:48,839
없다는 것입니다  e 그리고 서로 다른

960
00:36:48,839 --> 00:36:51,060
메시지 전달 접근 방식 및 작업

961
00:36:51,060 --> 00:36:52,740
선택 루틴을 대조하므로

962
00:36:52,740 --> 00:36:56,099
SPM vbx에서 수행되는 한 가지 방법이 있습니다. 이를 한계 메시지 전달이라고 합니다.

963
00:36:56,099 --> 00:36:58,440


964
00:36:58,440 --> 00:37:01,079
그래서 Pi MVP에서는 메시지 전달 알고리즘을 변경하면 어떻게 되는지 비교하기 어렵습니다.

965
00:37:01,079 --> 00:37:02,339


966
00:37:02,339 --> 00:37:05,700


967
00:37:05,700 --> 00:37:07,800
우리는

968
00:37:07,800 --> 00:37:09,599


969
00:37:09,599 --> 00:37:12,000
지금 나란히 비교할 수 있는 두 개의 메시지 전달 알고리즘을 가지고 있습니다. 미래에 더 많은 것을 추가할 수 있기를 희망합니다.

970
00:37:12,000 --> 00:37:13,680


971
00:37:13,680 --> 00:37:16,920
이것은 단지 모듈식 일 뿐이고 처음

972
00:37:16,920 --> 00:37:18,119
에 이야기했던 것 때문에 매우 쉽습니다.

973
00:37:18,119 --> 00:37:21,000


974
00:37:21,000 --> 00:37:22,859
이것이 Matlab에 있기 때문에 강화 학습 개방형 AI 체육관과

975
00:37:22,859 --> 00:37:25,140
같은 다른 프레임워크와 합성하기가 더 어렵고

976
00:37:25,140 --> 00:37:27,839


977
00:37:27,839 --> 00:37:29,099


978
00:37:29,099 --> 00:37:32,339
intensorflow 흐름 또는 Pi 고문 잭과 같은 심층 신경망이 있으므로

979
00:37:32,339 --> 00:37:34,380
Matlab에 있다는 사실은

980
00:37:34,380 --> 00:37:36,660
이미 물론 사람들이 제한되어 있습니다.  Julia에서 Matlab, Python으로 이동

981
00:37:36,660 --> 00:37:39,420
하는 것과 같은 크로스 언어 크로스 플랫폼 um 코드와 같은 작업을 수행하는 방법을 찾았

982
00:37:39,420 --> 00:37:41,700


983
00:37:41,700 --> 00:37:44,400


984
00:37:44,400 --> 00:37:46,980
지만

985
00:37:46,980 --> 00:37:49,440
훨씬 더 무겁습니다.

986
00:37:49,440 --> 00:37:52,440
그런 다음

987
00:37:52,440 --> 00:37:55,619
Matlab과 Python의 장단점에

988
00:37:55,619 --> 00:37:57,420
대해 설명하겠습니다. Matlab에 대해 제가 좋아하는 것 중 하나는

989
00:37:57,420 --> 00:37:59,339


990
00:37:59,339 --> 00:38:01,680
배열 프로그래밍을 시작하기가 매우 쉽다는 것입니다. 멋진 편집기

991
00:38:01,680 --> 00:38:04,200
가 많이 있습니다.  지난 해

992
00:38:04,200 --> 00:38:06,839
전산 정신과

993
00:38:06,839 --> 00:38:09,720
과정에서 이 튜토리얼을 제공했을 때도

994
00:38:09,720 --> 00:38:11,400


995
00:38:11,400 --> 00:38:13,740
대부분의 튜토리얼

996
00:38:13,740 --> 00:38:16,260
이

997
00:38:16,260 --> 00:38:18,420
여전히 Matlab을 사용하고 있었기

998
00:38:18,420 --> 00:38:20,700
때문에 역사와

999
00:38:20,700 --> 00:38:22,440


1000
00:38:22,440 --> 00:38:24,780
신경 과학 및 정신 물리학 작업에 적합한 패키지

1001
00:38:24,780 --> 00:38:26,280
의 수

1002
00:38:26,280 --> 00:38:30,000
는 거의 모멘텀 또는 레거시 이점과 같은 이점이

1003
00:38:30,000 --> 00:38:32,099
있지만 물론 독점과 같은 문제가 있습니다.

1004
00:38:32,099 --> 00:38:33,480
이것이 지불해야 할 가장 큰 비용이라고 생각합니다.

1005
00:38:33,480 --> 00:38:35,520


1006
00:38:35,520 --> 00:38:38,339
편도 또는  Matlab을 사용하는 또 다른 방법은

1007
00:38:38,339 --> 00:38:40,800
커뮤니티 기반

1008
00:38:40,800 --> 00:38:43,020
개발이 많지 않다는 것입니다.

1009
00:38:43,020 --> 00:38:44,880
즉, 파일 교환과

1010
00:38:44,880 --> 00:38:47,400
같은 것이 있지만 Python과 같은 수준은 아닙니다.  d 그런 다음

1011
00:38:47,400 --> 00:38:49,740
파이썬 종류는 Matlab과 경쟁할 수 있습니다.

1012
00:38:49,740 --> 00:38:51,420
왜냐하면 그것은 numpy 형식의 배열 프로그래밍을 가지고 있기 때문

1013
00:38:51,420 --> 00:38:53,700
입니다. 물론 그것은 오픈 소스입니다.

1014
00:38:53,700 --> 00:38:55,680


1015
00:38:55,680 --> 00:38:57,660
음

1016
00:38:57,660 --> 00:39:00,960
학문 분야뿐만 아니라

1017
00:39:00,960 --> 00:39:02,940
많은 상업적 응용 프로그램에 걸쳐 널리 채택되었고

1018
00:39:02,940 --> 00:39:05,099
많은 커뮤니티가 주도했습니다.

1019
00:39:05,099 --> 00:39:08,940
Pi VP와 같은 패키지 형태의 개발

1020
00:39:08,940 --> 00:39:11,280
음 하지만 한 가지 단점은 적어도 저에게는

1021
00:39:11,280 --> 00:39:12,839


1022
00:39:12,839 --> 00:39:14,520
Matlab을 시작하는 것이 Matlab과

1023
00:39:14,520 --> 00:39:17,460
마찬가지로 음 시작

1024
00:39:17,460 --> 00:39:19,079
하기가 쉽지 않았다는

1025
00:39:19,079 --> 00:39:20,280
것입니다.  가상

1026
00:39:20,280 --> 00:39:21,540
환경에 대해 배우고 파이썬 사용을 시작하기 전에 더 많은 프로그래밍에 대해 배우는 것을 좋아해야 합니다.

1027
00:39:21,540 --> 00:39:24,440


1028
00:39:24,440 --> 00:39:27,060


1029
00:39:27,060 --> 00:39:29,040
그래서

1030
00:39:29,040 --> 00:39:30,780
Matlab이 실제로

1031
00:39:30,780 --> 00:39:32,520


1032
00:39:32,520 --> 00:39:33,960
Matlab을 구입하고

1033
00:39:33,960 --> 00:39:36,960
실제로 프로그래밍을 수행하는 사이의 시간과 같은 교육 도구로 여전히 유용한 이유 중 하나라고 생각합니다.  는 꽤 짧습니다.

1034
00:39:36,960 --> 00:39:39,660


1035
00:39:39,660 --> 00:39:43,440
음, 예 패키지 이름은

1036
00:39:43,440 --> 00:39:46,020
uh 이 인프라에 적극적으로 GitHub

1037
00:39:46,020 --> 00:39:48,839
조직에 있습니다. Pi MVP라고 하며

1038
00:39:48,839 --> 00:39:50,700
insta를 pip할 수 있습니다.

1039
00:39:50,700 --> 00:39:52,380
가상 환경이나 Python의 기본

1040
00:39:52,380 --> 00:39:55,140
설치

1041
00:39:55,140 --> 00:39:57,540
와 같을 것입니다. 그런

1042
00:39:57,540 --> 00:40:00,720
다음 piondp가 설치되면 기본적으로 에이전트 모듈과 같은

1043
00:40:00,720 --> 00:40:03,599
모든 다른 하위 패키지 또는 하위 모듈을 유연한 모듈식 방식으로 가져오고 사용할 수 있습니다.

1044
00:40:03,599 --> 00:40:05,640


1045
00:40:05,640 --> 00:40:07,560


1046
00:40:07,560 --> 00:40:09,660
에이전트 클래스를 구현한 다음

1047
00:40:09,660 --> 00:40:11,579
실제로 활성 추론 에이전트와 독립적인 추론

1048
00:40:11,579 --> 00:40:13,619
, 제어 및 학습과 같은 다양한 모듈이 있으며

1049
00:40:13,619 --> 00:40:15,119


1050
00:40:15,119 --> 00:40:16,440


1051
00:40:16,440 --> 00:40:19,200
숨겨진 상태 추론을 위한 메시지 전달을 수행하거나

1052
00:40:19,200 --> 00:40:21,119


1053
00:40:21,119 --> 00:40:22,320


1054
00:40:22,320 --> 00:40:24,839
가능한 정책에 대한 예상 자유 에너지를 계산하거나

1055
00:40:24,839 --> 00:40:27,119
모든 것을 구성할 수 있도록 매개변수에 대한 업데이트를 계산

1056
00:40:27,119 --> 00:40:29,640
하고 유연하게

1057
00:40:29,640 --> 00:40:31,800
일종의 프랑켄슈타인

1058
00:40:31,800 --> 00:40:33,839
활성 추론 에이전트를 원하는 맞춤형 방식으로 구성하여 일종의 프랑켄슈타인 활성 추론 에이전트를 만들 수 있습니다.

1059
00:40:33,839 --> 00:40:36,060


1060
00:40:36,060 --> 00:40:38,099


1061
00:40:38,099 --> 00:40:41,160


1062
00:40:41,160 --> 00:40:43,260


1063
00:40:43,260 --> 00:40:45,060
생성 모델과 이러한 개별 배열의 형식을 지정

1064
00:40:45,060 --> 00:40:47,640


1065
00:40:47,640 --> 00:40:49,680
하고 에이전트의 두뇌에 연결하고

1066
00:40:49,680 --> 00:40:52,020


1067
00:40:52,020 --> 00:40:54,119
맨 아래에 있는 이 두 줄로 거의 캡슐화되도록 에이전트를 인스턴스화합니다.

1068
00:40:54,119 --> 00:40:57,000
Pine BP에서 에이전트를 가져온

1069
00:40:57,000 --> 00:40:59,400


1070
00:40:59,400 --> 00:41:02,220
다음 ABC와 D를 연결하여 에이전트를 빌드하면 숨겨진 상태

1071
00:41:02,220 --> 00:41:04,619
를 수행하는 데 사용할 수 있는 이 에이전트 개체가

1072
00:41:04,619 --> 00:41:06,420
생깁니다.

1073
00:41:06,420 --> 00:41:08,099


1074
00:41:08,099 --> 00:41:10,560
에이전트가 정책

1075
00:41:10,560 --> 00:41:12,240
의 예상 자유 에너지를 내부적으로 계산하는 에이전트

1076
00:41:12,240 --> 00:41:14,760
인 첫 번째 상태 추론 정책과 같은 방법을 통한 추론을 통해

1077
00:41:14,760 --> 00:41:17,400
최종적으로 작업을 샘플링할 수 있으므로 이

1078
00:41:17,400 --> 00:41:19,260
세 라인은 모든 활성 추론의 주요 플레이어 유형입니다.

1079
00:41:19,260 --> 00:41:21,359
루프

1080
00:41:21,359 --> 00:41:24,660
상태 추론 정책 추론

1081
00:41:24,660 --> 00:41:26,820
그런 다음 동작을 선택하고

1082
00:41:26,820 --> 00:41:30,320
시간이 지남에 따라 루프에 연결

1083
00:41:30,359 --> 00:41:32,339
하여 능동적 추론

1084
00:41:32,339 --> 00:41:35,460
프로세스를 인스턴스화

1085
00:41:35,460 --> 00:41:37,079
하고 동작 인식

1086
00:41:37,079 --> 00:41:39,300
루프의 순환성이 관찰되는 에이전트에 대한 입력과 함께 작용합니다.

1087
00:41:39,300 --> 00:41:41,880
그리고

1088
00:41:41,880 --> 00:41:43,500


1089
00:41:43,500 --> 00:41:45,960
차트가 해당 작업인 작업 선택의 출력과

1090
00:41:45,960 --> 00:41:48,000
물론 마지막 작업을 사용

1091
00:41:48,000 --> 00:41:50,640
하여 새로운 관찰을 가져와야 합니다.  t

1092
00:41:50,640 --> 00:41:53,520
당신은 행동을 어떤 환경에 연결함으로써 할 수

1093
00:41:53,520 --> 00:41:55,980
있습니다. 이것은 또한

1094
00:41:55,980 --> 00:41:57,480
종종

1095
00:41:57,480 --> 00:41:59,400
생성 프로세스라고 불리는 활성 추론

1096
00:41:59,400 --> 00:42:00,960
문헌에도 있습니다.

1097
00:42:00,960 --> 00:42:03,119
그래서 이것은 당신이 보게 될

1098
00:42:03,119 --> 00:42:04,680
고전적인 행동 인식 그룹의 종류입니다.

1099
00:42:04,680 --> 00:42:06,480
활성 추론

1100
00:42:06,480 --> 00:42:08,640
에이전트를 제정했으며 이것은 활성 추론에만 고유하지도 않습니다.

1101
00:42:08,640 --> 00:42:10,320
이것은

1102
00:42:10,320 --> 00:42:12,119
강화 학습 문제가

1103
00:42:12,119 --> 00:42:14,880
일반적으로 프레임되는 방식이므로 개방형 AI Jam

1104
00:42:14,880 --> 00:42:17,040
이 매우 유사한

1105
00:42:17,040 --> 00:42:20,339
음 제어 흐름을 사용하는 것처럼 우리는

1106
00:42:20,339 --> 00:42:24,020
음 예 감각 모터

1107
00:42:24,440 --> 00:42:27,359
루프와 비슷합니다.  다음

1108
00:42:27,359 --> 00:42:30,359
은 에이전트가 생성 모델을 설정하는 가져오기와 같은 작업을 수행하는 예

1109
00:42:30,359 --> 00:42:31,980
입니다.

1110
00:42:31,980 --> 00:42:33,720
가장 어려운 부분이므로

1111
00:42:33,720 --> 00:42:36,420
점 점 뒤에 생략

1112
00:42:36,420 --> 00:42:37,500
부호를 넣었지만 실제로 대부분의 코드

1113
00:42:37,500 --> 00:42:38,640
가 발생하는 곳은 생성 모델을 구축하는 것입니다.

1114
00:42:38,640 --> 00:42:41,220


1115
00:42:41,220 --> 00:42:43,020


1116
00:42:43,020 --> 00:42:45,599
저장된 Pi mdp 환경 중 하나로 가져올 수 있는 환경을 구축

1117
00:42:45,599 --> 00:42:47,820
하거나

1118
00:42:47,820 --> 00:42:50,040
개방형 AI 체육관에서 가져올 수 있거나 할 수 있습니다.  d는

1119
00:42:50,040 --> 00:42:51,660
자신만의 환경을 생성하여 에이전트가 상호

1120
00:42:51,660 --> 00:42:53,940


1121
00:42:53,940 --> 00:42:55,920
작용하는 세계에서 세계가 어떻게 작동하는지 실제로 설명하는 코드가 될 수 있도록 합니다.

1122
00:42:55,920 --> 00:42:57,900


1123
00:42:57,900 --> 00:43:01,319
그런 다음 바로 거기에 있는 몇 줄의 코드로 활성 추론의 시간 단계를 구현할 수 있습니다.

1124
00:43:01,319 --> 00:43:02,940


1125
00:43:02,940 --> 00:43:05,339
그것은

1126
00:43:05,339 --> 00:43:07,740
모두 8에서 15와 같은 마지막 줄과

1127
00:43:07,740 --> 00:43:09,240
같을 것입니다.

1128
00:43:09,240 --> 00:43:10,560


1129
00:43:10,560 --> 00:43:14,000
시간이 지남에 따라 루프 내에서 래핑될 것입니다.

1130
00:43:14,640 --> 00:43:16,500
음 예 이것은 이와 같은 더 많은 예일 뿐입니다

1131
00:43:16,500 --> 00:43:19,260
.

1132
00:43:19,260 --> 00:43:20,880
이 예에서 우리는 활성 상태로 실행하지도 않습니다.

1133
00:43:20,880 --> 00:43:22,920
추론하지만 우리는

1134
00:43:22,920 --> 00:43:25,079


1135
00:43:25,079 --> 00:43:28,380
숨은 상태 추론을 수행하기 위해 Algos 하위 모듈의 메시지 전달 알고리즘 중 하나를 사용

1136
00:43:28,380 --> 00:43:31,020


1137
00:43:31,020 --> 00:43:33,240


1138
00:43:33,240 --> 00:43:36,660


1139
00:43:36,660 --> 00:43:39,240
하고 있습니다.  그런 다음

1140
00:43:39,240 --> 00:43:42,420


1141
00:43:42,420 --> 00:43:43,619
은닉 상태 추론 중에 에이전트가 수행할 수 있는 작업에 대한 가상 업데이트와 같은 작업을 수행하고 Q 또는 은닉 상태에

1142
00:43:43,619 --> 00:43:47,099
대한 믿음을 최적화

1143
00:43:47,099 --> 00:43:49,380


1144
00:43:49,380 --> 00:43:50,520
할 수 있으므로 이것은 실제로

1145
00:43:50,520 --> 00:43:53,160
연못 DP를 j에 사용할 수 있는 방법의 예입니다.  숨겨진 Markov 모델에 대한 일반 추론을

1146
00:43:53,160 --> 00:43:55,380
수행해야

1147
00:43:55,380 --> 00:43:58,020
합니다. 활성 추론

1148
00:43:58,020 --> 00:44:00,900
루프 내에서 사용할 필요조차 없습니다. 우리가 제공한 특정 알고리즘을 사용하여 숨겨진 Markov 모델에 대한 통계적 추론과 같은 작업을 수행하는 데 사용할 수 있습니다.

1149
00:44:00,900 --> 00:44:02,520


1150
00:44:02,520 --> 00:44:04,440


1151
00:44:04,440 --> 00:44:06,720


1152
00:44:06,720 --> 00:44:08,280
SPM에 대해 이야기한 장점 중 하나는

1153
00:44:08,280 --> 00:44:10,560


1154
00:44:10,560 --> 00:44:12,180
맞춤형 활성 추론

1155
00:44:12,180 --> 00:44:14,400
프로세스를 생성

1156
00:44:14,400 --> 00:44:16,200
할 수 있다는 것입니다. 에이전트 클래스에 대한 추가 인수와

1157
00:44:16,200 --> 00:44:18,300
같은 많은

1158
00:44:18,300 --> 00:44:21,000
보상 기능 또는 예상되는 무료 기능의 다른 부분을 켜고 끌

1159
00:44:21,000 --> 00:44:23,819
수 있습니다.  예를

1160
00:44:23,819 --> 00:44:26,339
들어 이 에이전트에서 에이전트

1161
00:44:26,339 --> 00:44:28,619


1162
00:44:28,619 --> 00:44:30,540
는 행동 선택의 보상

1163
00:44:30,540 --> 00:44:32,819
C 벡터 구동 구성 요소인 기대 효용을 통합하지

1164
00:44:32,819 --> 00:44:35,240
않지만 에이전트는 상태

1165
00:44:35,240 --> 00:44:37,800
정보 이득과 매개 변수 정보

1166
00:44:37,800 --> 00:44:39,480
게임의 다른 두 구성 요소를 사용합니다.

1167
00:44:39,480 --> 00:44:42,119
예상되는 자유 에너지이므로 다양한 방식으로 작동하지

1168
00:44:42,119 --> 00:44:43,500
않는 맞춤형 능동 추론 에이전트를 생성할 수 있는 많은 방법이 있습니다.

1169
00:44:43,500 --> 00:44:45,619


1170
00:44:45,619 --> 00:44:47,940


1171
00:44:47,940 --> 00:44:49,800


1172
00:44:49,800 --> 00:44:53,300
당신이 제공하는 이러한 종류의 어 키워드 인수에 대해

1173
00:44:54,060 --> 00:44:55,500
음

1174
00:44:55,500 --> 00:44:57,660
예 여기에는

1175
00:44:57,660 --> 00:44:58,920


1176
00:44:58,920 --> 00:45:00,780
숨겨진 상태 추론을 수행하기 위해 활성 추론 에이전트를 사용

1177
00:45:00,780 --> 00:45:03,060
하고 전혀 작업을 수행하지 않으므로 에이전트

1178
00:45:03,060 --> 00:45:04,980
가 업데이트하는 숨겨진 상태만 추론하는 것과 같은 더 많은 예가 있습니다.

1179
00:45:04,980 --> 00:45:07,200
행렬에

1180
00:45:07,200 --> 00:45:08,700
대한 신념과

1181
00:45:08,700 --> 00:45:11,099
D 벡터 또는 초기 은닉 상태

1182
00:45:11,099 --> 00:45:12,960
에 대한 신념을 업데이트하므로 이

1183
00:45:12,960 --> 00:45:14,640
모든 라인을 유연하게 조합

1184
00:45:14,640 --> 00:45:16,380
하고 원하는 작업을 수행하는 에이전트를 생성

1185
00:45:16,380 --> 00:45:17,940
할 수 있습니다. 행동할 필요도 없습니다.

1186
00:45:17,940 --> 00:45:19,940
세계에서 기술적으로

1187
00:45:19,940 --> 00:45:22,140
괜찮으니 이제

1188
00:45:22,140 --> 00:45:25,859
작동 중인 소나무 DP의 몇 가지 예를 보여

1189
00:45:25,859 --> 00:45:28,800
드리겠습니다 음 그래서 이것은 고전적인

1190
00:45:28,800 --> 00:45:31,020
능동적 추론 논문입니다 제가

1191
00:45:31,020 --> 00:45:33,660
가장 좋아하는 논문 중 하나였습니다 음

1192
00:45:33,660 --> 00:45:35,160
장면 구성 및 능동적

1193
00:45:35,160 --> 00:45:37,319
추론이라고 하는 것 같습니다  에이전트가 수행해야 하는 작업을 설명하고

1194
00:45:37,319 --> 00:45:39,839


1195
00:45:39,839 --> 00:45:41,640
있으며

1196
00:45:41,640 --> 00:45:44,160
정신물리학

1197
00:45:44,160 --> 00:45:45,960


1198
00:45:45,960 --> 00:45:48,780
테스트에서 실제로 인간 데이터를 모델링하는 데 사용되었습니다.

1199
00:45:48,780 --> 00:45:51,359
그 안에 특정 이미지가 있고

1200
00:45:51,359 --> 00:45:53,579
총 4개의 사분면이 있고 그 중

1201
00:45:53,579 --> 00:45:56,579
두 개는 관심 있는 이미지를

1202
00:45:56,579 --> 00:45:59,460
가지고 있습니다. 이 경우 두 이미지

1203
00:45:59,460 --> 00:46:02,640
가 새와 고양이 이미지

1204
00:46:02,640 --> 00:46:05,579
이고 그것은 벼룩 장면의 예

1205
00:46:05,579 --> 00:46:07,380
이므로 아시아인은 기본적으로 또는  인간

1206
00:46:07,380 --> 00:46:09,960


1207
00:46:09,960 --> 00:46:12,300
은 두 이미지의 조합으로 간단하게 정의된 잠재 장면

1208
00:46:12,300 --> 00:46:15,540
을 순서대로 분류한 다음 장면을 분류해야

1209
00:46:15,540 --> 00:46:16,859
하므로 기본적으로 분류

1210
00:46:16,859 --> 00:46:20,040
분류 작업이지만 에이전트는

1211
00:46:20,040 --> 00:46:22,740


1212
00:46:22,740 --> 00:46:24,599
그 범주가 무엇인지 알기 전에 일련의 단서를 발견하여 우발적으로 응시해야 합니다.

1213
00:46:24,599 --> 00:46:27,720
또는 그 장면이 무엇인지 그래서

1214
00:46:27,720 --> 00:46:29,940


1215
00:46:29,940 --> 00:46:31,380
우리 모두가 알고 있고

1216
00:46:31,380 --> 00:46:33,660


1217
00:46:33,660 --> 00:46:36,180
적극적으로 샘플링하여 세계의 숨겨진 상태를 밝히려고 하는 능동적 추론에 대해 좋아하는 인식적 구성 요소를 결합

1218
00:46:36,180 --> 00:46:38,400
하므로 이 경우

1219
00:46:38,400 --> 00:46:39,720
그들은 시선을 다른 곳으로 이동하여 세계를 샘플링합니다.

1220
00:46:39,720 --> 00:46:41,760
사분면에서 그 뒤에 무엇이 있는지 밝혀낸

1221
00:46:41,760 --> 00:46:44,760
다음 세상에 대해 배운 내용을

1222
00:46:44,760 --> 00:46:47,280
기반으로 진정한 범주가 무엇인지 실제로 선택합니다.

1223
00:46:47,280 --> 00:46:49,020


1224
00:46:49,020 --> 00:46:50,160


1225
00:46:50,160 --> 00:46:51,780


1226
00:46:51,780 --> 00:46:55,140
올바르게 분류하는 것과 관련된 약간의 보상

1227
00:46:55,140 --> 00:46:57,180
이 있기 때문에 효용을 극대화하려고 합니다. 이것은

1228
00:46:57,180 --> 00:46:58,740
Matlab에서 원래 수행된 예제이고 방금

1229
00:46:58,740 --> 00:47:01,020
pi mdp에서 다시 구현한 것입니다.

1230
00:47:01,020 --> 00:47:03,300
이것은

1231
00:47:03,300 --> 00:47:05,400
이제 장면이

1232
00:47:05,400 --> 00:47:07,800
음 피드 장면인 또 다른 예입니다.  신호는

1233
00:47:07,800 --> 00:47:09,780
이 예에서 아래쪽 2개 사분면에

1234
00:47:09,780 --> 00:47:12,359
있으므로 에이전트는 다른 사분면을 둘러봐야

1235
00:47:12,359 --> 00:47:14,099
합니다. 마침내

1236
00:47:14,099 --> 00:47:15,839
괜찮다는 것을 알게

1237
00:47:15,839 --> 00:47:17,700
됩니다. 왼쪽 하단의 오른쪽 하단 씨앗에 새가 있으므로 이것이

1238
00:47:17,700 --> 00:47:20,880
피드 장면이어야 합니다

1239
00:47:20,880 --> 00:47:22,980
음 그리고 그냥  어

1240
00:47:22,980 --> 00:47:24,359


1241
00:47:24,359 --> 00:47:25,740
, 코드가 어떻게 생겼는지와 같은 활성 추론에서 실제로 어떻게 보이는지에 대한 예를 보여주기

1242
00:47:25,740 --> 00:47:27,780


1243
00:47:27,780 --> 00:47:29,160
위해 이것에 대해 가장 먼저 할 일은 a b c'

1244
00:47:29,160 --> 00:47:31,140
를 다시 던지는 에이전트를 설정하는 것입니다.

1245
00:47:31,140 --> 00:47:33,720
이 경우 s와 D

1246
00:47:33,720 --> 00:47:35,760


1247
00:47:35,760 --> 00:47:36,960


1248
00:47:36,960 --> 00:47:38,640
는 Matlab에서 사용되는 것과 동일한 한계 메시지 전달이라는 특정 메시지 전달 알고리즘을 사용

1249
00:47:38,640 --> 00:47:42,180
했습니다. 정책 깊이와 일종의 추론 수평선을 설정합니다

1250
00:47:42,180 --> 00:47:43,680


1251
00:47:43,680 --> 00:47:45,420
.  얼마나 많은 과거

1252
00:47:45,420 --> 00:47:48,119
관찰을

1253
00:47:48,119 --> 00:47:50,700
고려한 다음 환경을 설정하는지와 같은 메모리

1254
00:47:50,700 --> 00:47:52,980


1255
00:47:52,980 --> 00:47:55,500
입니다. 이것은 이 경우 에이전트가 상호 작용할 외부 세계와

1256
00:47:55,500 --> 00:47:57,420
같습니다. 저는 그것을 장면

1257
00:47:57,420 --> 00:47:59,520
구성 환경이라고 부릅니다

1258
00:47:59,520 --> 00:48:01,920
.  에이전트는 눈

1259
00:48:01,920 --> 00:48:03,300
을 특정 위치로 이동

1260
00:48:03,300 --> 00:48:06,180
한 다음 에이전트가 다음에 무엇을 볼지 결정합니다. 에이전트

1261
00:48:06,180 --> 00:48:07,980
가 보기로

1262
00:48:07,980 --> 00:48:09,720
결정한 사분면 뒤에 무엇이 있는지 알 수 있습니다.

1263
00:48:09,720 --> 00:48:13,200


1264
00:48:13,200 --> 00:48:14,819


1265
00:48:14,819 --> 00:48:16,619
에이전트

1266
00:48:16,619 --> 00:48:18,780
와 환경

1267
00:48:18,780 --> 00:48:21,900
을 인식한 다음 일반적으로 하는

1268
00:48:21,900 --> 00:48:24,300


1269
00:48:24,300 --> 00:48:26,880


1270
00:48:26,880 --> 00:48:29,760
일은 openai 체육관에서 빌린 관습

1271
00:48:29,760 --> 00:48:32,220


1272
00:48:32,220 --> 00:48:33,960
인 환경을 재설정하여 초기 초기 관찰에 들어가는 것입니다.

1273
00:48:33,960 --> 00:48:36,240
초기 관찰을

1274
00:48:36,240 --> 00:48:37,619
제거한 다음 관찰 인덱스

1275
00:48:37,619 --> 00:48:39,359


1276
00:48:39,359 --> 00:48:41,819
사이에 매핑이 있는 목록이나 사전을 만드는 것이 종종 유용합니다.

1277
00:48:41,819 --> 00:48:43,800
이것은

1278
00:48:43,800 --> 00:48:46,319
0 사이의 정수와 같

1279
00:48:46,319 --> 00:48:48,420
으며 얼마나 많은 관측값이 있는지 그리고

1280
00:48:48,420 --> 00:48:49,619
그것들이 실제로

1281
00:48:49,619 --> 00:48:51,720
의미론적으로 대응하는 것이므로 이것은

1282
00:48:51,720 --> 00:48:54,000
모든 Palm

1283
00:48:54,000 --> 00:48:56,700
DP와 환경이

1284
00:48:56,700 --> 00:48:59,220
뱉어낼 것이기 때문에 좋아하는 매우 일반적인 방법입니다.

1285
00:48:59,220 --> 00:49:00,780
이 모든 것은 불연속 인덱스와 비슷하지만

1286
00:49:00,780 --> 00:49:02,700


1287
00:49:02,700 --> 00:49:04,980


1288
00:49:04,980 --> 00:49:07,920


1289
00:49:07,920 --> 00:49:09,740


1290
00:49:09,740 --> 00:49:14,160
새 이미지를

1291
00:49:14,160 --> 00:49:18,420
보거나 범주 1과 범주 2

1292
00:49:18,420 --> 00:49:20,579
를 선택하는 것과 같은 의미 있는 특정 인덱스를 의미론적으로 매핑하는 데 사용할 수 있는 이러한 목록을 갖는 것이 유용합니다.  기본적

1293
00:49:20,579 --> 00:49:23,400


1294
00:49:23,400 --> 00:49:25,260


1295
00:49:25,260 --> 00:49:27,240
으로 은닉 상태

1296
00:49:27,240 --> 00:49:29,460
추정 및 정책 추론으로 구성된 능동적 추론을 수행하는 루프를 시간에 따라 작성

1297
00:49:29,460 --> 00:49:32,700
하면 작업을 샘플링한

1298
00:49:32,700 --> 00:49:34,680
다음 환경으로 피드백되어

1299
00:49:34,680 --> 00:49:37,079
또 다른

1300
00:49:37,079 --> 00:49:38,819
관찰을 생성한 다음

1301
00:49:38,819 --> 00:49:39,900
시간이 지남에 따라 발생합니다.  전체적인 행동

1302
00:49:39,900 --> 00:49:41,339
인식은

1303
00:49:41,339 --> 00:49:44,339
그래서 이것은

1304
00:49:44,339 --> 00:49:45,720
음 예 그래서

1305
00:49:45,720 --> 00:49:48,119
그것이 얼마나 짧은 것처럼 보이는지 믿을 수 없을 정도로 간단

1306
00:49:48,119 --> 00:49:49,920
하지만 나는 약간 광택이 있습니다

1307
00:49:49,920 --> 00:49:51,359
나중에 이야기할 것, 즉

1308
00:49:51,359 --> 00:49:53,880
앞에서 언급한

1309
00:49:53,880 --> 00:49:55,619
것처럼 가장 어려운 부분은

1310
00:49:55,619 --> 00:49:57,720
실제로 이러한 일이 발생하기 전에 수행

1311
00:49:57,720 --> 00:49:59,520
됩니다. 즉, a b

1312
00:49:59,520 --> 00:50:02,760
c와 D를 기록하는 것입니다.

1313
00:50:02,760 --> 00:50:05,460


1314
00:50:05,460 --> 00:50:06,839
활성 추론의 집중적이고 복잡한 부분은 실제로

1315
00:50:06,839 --> 00:50:08,640


1316
00:50:08,640 --> 00:50:10,680
생성 모델을 작성한 후 생성 모델을 작성

1317
00:50:10,680 --> 00:50:12,780
하고 나머지는 기본적으로 시계와 같습니다

1318
00:50:12,780 --> 00:50:15,060
. 에이전트를 환경에 연결

1319
00:50:15,060 --> 00:50:17,160
한 다음 5

1320
00:50:17,160 --> 00:50:19,560
~6줄 정도 실행하면 됩니다.  실제로 구현

1321
00:50:19,560 --> 00:50:20,819
하는 것이 가장 어려운 부분

1322
00:50:20,819 --> 00:50:22,560
은 처음에 a b c와 D

1323
00:50:22,560 --> 00:50:24,799


1324
00:50:25,260 --> 00:50:27,119
를 기록하는

1325
00:50:27,119 --> 00:50:28,079
것입니다.

1326
00:50:28,079 --> 00:50:31,740
음 제가 일종의 팀원을 스테로이드로 부르는 또 다른 예를 보여 드리겠습니다. 그래서

1327
00:50:31,740 --> 00:50:33,960
고전적인 teamaze 작업에서

1328
00:50:33,960 --> 00:50:35,579
음 원래 무엇을 잊어버렸는지  종이

1329
00:50:35,579 --> 00:50:36,900
는 하지만 한동안 활동적인 추론 문헌에서 매우 인기가 있었던 것입니다.

1330
00:50:36,900 --> 00:50:37,980


1331
00:50:37,980 --> 00:50:39,599


1332
00:50:39,599 --> 00:50:41,460
어, Carl이

1333
00:50:41,460 --> 00:50:44,700
아마도 2015년 또는 그 이전에 생각해

1334
00:50:44,700 --> 00:50:48,119
냈다고 생각합니다.  환경에서

1335
00:50:48,119 --> 00:50:51,180
보상 또는 처벌의 두 가지 잠재적인 소스를 방문

1336
00:50:51,180 --> 00:50:53,160
해야

1337
00:50:53,160 --> 00:50:55,619
하며 이 팀원의 어느 팔에 보상이 포함되어 있는지 알지 못하므로 어느 팔에 보상이 있고 어느 팔에 보상이 없는지

1338
00:50:55,619 --> 00:50:58,020


1339
00:50:58,020 --> 00:51:00,300
알기 전에 먼저 큐를 방문해야 합니다.

1340
00:51:00,300 --> 00:51:02,700


1341
00:51:02,700 --> 00:51:04,559
보상이나 부정적인 자극과 같은 충격과 같은

1342
00:51:04,559 --> 00:51:07,200
것입니다

1343
00:51:07,200 --> 00:51:09,660
. 팀원을 공간적으로 확장하여

1344
00:51:09,660 --> 00:51:12,119
에이전트가 이제 일련의 큐를 방문해야 합니다.

1345
00:51:12,119 --> 00:51:14,819
각 큐는 최종 큐

1346
00:51:14,819 --> 00:51:17,099
를 파악하기 위해 다음 큐브의 위치를 ​​나타냅니다

1347
00:51:17,099 --> 00:51:19,559
.  이것은 치즈 대 충격의 위치일 뿐이

1348
00:51:19,559 --> 00:51:22,619


1349
00:51:22,619 --> 00:51:24,359
므로 이것은

1350
00:51:24,359 --> 00:51:26,520
에이전트가 먼저 q1로 이동

1351
00:51:26,520 --> 00:51:28,200
한 다음 Q2가 어디에 있는지 알고 치즈가 어디에 있는지 아는 또 다른 예입니다.

1352
00:51:28,200 --> 00:51:30,300


1353
00:51:30,300 --> 00:51:32,099


1354
00:51:32,099 --> 00:51:34,740


1355
00:51:34,740 --> 00:51:37,020


1356
00:51:37,020 --> 00:51:38,940
치즈의 최종 어 위치까지 루트를 계획하기 위해 해야 할 일은

1357
00:51:38,940 --> 00:51:41,280
다음 q에 도달하는 것입니다. 그러면 다음

1358
00:51:41,280 --> 00:51:43,880
큐가 어디에 있는지 밝혀지고 마침내 보상의 숨겨진 위치가 어디에 있는지 밝혀

1359
00:51:43,880 --> 00:51:47,099
집니다.

1360
00:51:47,099 --> 00:51:49,440
당신은 일종의

1361
00:51:49,440 --> 00:51:53,040
인식적 가치나 호기심을 사용하여

1362
00:51:53,040 --> 00:51:56,160
일시적으로 얕은 동물이

1363
00:51:56,160 --> 00:51:58,800


1364
00:51:58,800 --> 00:52:00,839
um 먼 보상 또는 무언가

1365
00:52:00,839 --> 00:52:03,300
에 도달할

1366
00:52:03,300 --> 00:52:05,640


1367
00:52:05,640 --> 00:52:07,500
수 있는 방법을 계획

1368
00:52:07,500 --> 00:52:09,059
할 수 있도록 허용합니다.  그것은 Pine DP에서처럼 보일 것입니다.

1369
00:52:09,059 --> 00:52:10,500
기본적으로 정확히

1370
00:52:10,500 --> 00:52:12,660
똑같아 보입니다. 단지 환경

1371
00:52:12,660 --> 00:52:14,579
과 생성 모델이 다르지만

1372
00:52:14,579 --> 00:52:16,859
코드의 일반적인 흐름은

1373
00:52:16,859 --> 00:52:21,619
항상 이런 종류의 고전적인 파이프

1374
00:52:21,839 --> 00:52:24,059
라인을 가지고 있습니다.  능동적 추론

1375
00:52:24,059 --> 00:52:25,619


1376
00:52:25,619 --> 00:52:28,260
에서 가장 큰 혼란의 원인은

1377
00:52:28,260 --> 00:52:29,880


1378
00:52:29,880 --> 00:52:31,500
가장 어려운 부분이 생성 모델

1379
00:52:31,500 --> 00:52:34,319
이라는 것입니다. 세상에 대한 에이전트의

1380
00:52:34,319 --> 00:52:36,599
믿음을 인코딩하는 데 복잡성이 옵니다.

1381
00:52:36,599 --> 00:52:38,280
그래서

1382
00:52:38,280 --> 00:52:40,079
어떻게 적어야 할까요?  심층

1383
00:52:40,079 --> 00:52:41,460


1384
00:52:41,460 --> 00:52:44,099


1385
00:52:44,099 --> 00:52:47,960
신경망 또는 감독되지 않은 학습과 같은 패러다임에서 B와 C와 D

1386
00:52:47,960 --> 00:52:50,280
는 최신을 기록할 필요가 없습니다

1387
00:52:50,280 --> 00:52:51,740
.

1388
00:52:51,740 --> 00:52:54,540
신경망은

1389
00:52:54,540 --> 00:52:57,000
부하와 부하를 관찰하여 모델을 학습합니다 o  f 데이터

1390
00:52:57,000 --> 00:52:59,040
이므로 샘플 효율성이 떨어지지만 처음부터 많이 인코딩할 필요가 없으므로

1391
00:52:59,040 --> 00:53:01,319


1392
00:53:01,319 --> 00:53:03,119


1393
00:53:03,119 --> 00:53:06,359


1394
00:53:06,359 --> 00:53:08,220
모델 3과

1395
00:53:08,220 --> 00:53:10,140
더 깊은 신경망을 사용하는 모델 기반 접근 방식 사이의 더 큰 차이와 일치

1396
00:53:10,140 --> 00:53:12,619
합니다.  많은 비선형 함수 근사값을 결합하여 모델을 작성해야

1397
00:53:12,619 --> 00:53:15,420
하는 통계적 복잡성을 샘플에 효과적으로 발행한

1398
00:53:15,420 --> 00:53:17,220


1399
00:53:17,220 --> 00:53:19,380


1400
00:53:19,380 --> 00:53:22,140


1401
00:53:22,140 --> 00:53:24,240
다음

1402
00:53:24,240 --> 00:53:25,619
에이전트가 데이터로 충격을 가함으로써 에이전트가 세계에 대해 가지고 있는 믿음을 학습하는

1403
00:53:25,619 --> 00:53:27,480
것만으로도 동일한 작업

1404
00:53:27,480 --> 00:53:29,339
이 수행됩니다.

1405
00:53:29,339 --> 00:53:32,579
능동적 추론에서 DQ 학습과 같은 심층 강화 학습

1406
00:53:32,579 --> 00:53:35,160
에이전트는 수십억 개의 데이터 벡터와 같이

1407
00:53:35,160 --> 00:53:36,300
훈련할 필요가 없다는 점에서 훨씬 더 샘플 효율적

1408
00:53:36,300 --> 00:53:40,740


1409
00:53:40,740 --> 00:53:42,240
이지만 다른 한편

1410
00:53:42,240 --> 00:53:44,040
으로는 모델러로서 더 많은 투자

1411
00:53:44,040 --> 00:53:45,900
가 있습니다.

1412
00:53:45,900 --> 00:53:48,359
세계에 대한 에이전트의 신념이 무엇인지 명시적으로 작성하려면

1413
00:53:48,359 --> 00:53:49,920


1414
00:53:49,920 --> 00:53:53,220
컨볼루션 레이어와 같은 일반적인 항목

1415
00:53:53,220 --> 00:53:55,200
과 일부 리뷰 등을 장비하지 마십시오.  암탉

1416
00:53:55,200 --> 00:53:57,119
이 실제로 손으로 코딩해야 한다는 것을 배우게 하십시오.

1417
00:53:57,119 --> 00:53:59,400
그래서 저는 이것이 세계

1418
00:53:59,400 --> 00:54:01,800


1419
00:54:01,800 --> 00:54:03,059


1420
00:54:03,059 --> 00:54:04,859
의 베이지안 일반

1421
00:54:04,859 --> 00:54:07,020
생성 모델을 실제로 인코딩하는 모델 기반 강화 학습과

1422
00:54:07,020 --> 00:54:08,940
일종의 더 많은 모델 프리 또는 데이터 기반

1423
00:54:08,940 --> 00:54:11,099
접근 방식 사이의 가장 큰 차이점 중 하나라고 생각합니다.  그런 이분법이 아니라

1424
00:54:11,099 --> 00:54:12,660
두 가지를 결합하는 방법이 있습니다.

1425
00:54:12,660 --> 00:54:14,099


1426
00:54:14,099 --> 00:54:16,980


1427
00:54:16,980 --> 00:54:18,720
예를

1428
00:54:18,720 --> 00:54:21,780
들어 제가 몇 슬라이드 전에 보여드린 이 장면 구성 데모에서 아주 구체적으로

1429
00:54:21,780 --> 00:54:23,460
보여주는 것입니다.

1430
00:54:23,460 --> 00:54:25,940


1431
00:54:25,940 --> 00:54:28,680
하나가 더 많은 코드를

1432
00:54:28,680 --> 00:54:31,440
사용하는 코드의

1433
00:54:31,440 --> 00:54:34,559
경우 통계적 복잡성 또는 얼마나

1434
00:54:34,559 --> 00:54:36,660
많은 정보가 포함되어 있는지에 대한 프록시로 코드 줄의 양을 사용할 수 있으므로

1435
00:54:36,660 --> 00:54:38,339
활성 추론 루프를 실행하는 시뮬레이션 자체

1436
00:54:38,339 --> 00:54:40,140
는 다음과 같이 15줄의 코드

1437
00:54:40,140 --> 00:54:42,300
와 같았습니다.  그들과 그 코드

1438
00:54:42,300 --> 00:54:44,220
자체는 이미 매우 일반적이며

1439
00:54:44,220 --> 00:54:46,319


1440
00:54:46,319 --> 00:54:48,359
생성 모델 자체

1441
00:54:48,359 --> 00:54:49,920
를 작성하는 장면 구성 데모

1442
00:54:49,920 --> 00:54:51,119
에만 국한되지 않습니다.  여기

1443
00:54:51,119 --> 00:54:53,520
에서 해당 작업과 관련된 모든 정보가

1444
00:54:53,520 --> 00:54:55,980
인코딩됩니다. 예를 들어 전체 활성 추론

1445
00:54:55,980 --> 00:54:58,260


1446
00:54:58,260 --> 00:55:00,540


1447
00:55:00,540 --> 00:55:02,520


1448
00:55:02,520 --> 00:55:05,460
을 실행하는 것보다 이미 훨씬 더 많은 코드와 같은 장면 구성 데모에 대한 관찰 매핑에 대한 믿음을 행렬을 만든 방법을 살펴봅니다.

1449
00:55:05,460 --> 00:55:07,859


1450
00:55:07,859 --> 00:55:09,540
시뮬레이션을 통해 이미 알 수 있는 엄청난 양의

1451
00:55:09,540 --> 00:55:11,220
코드

1452
00:55:11,220 --> 00:55:13,200
와 마찬가지로 생성 모델에 적용되는 많은 가정과

1453
00:55:13,200 --> 00:55:15,119
정보가 있으며 능동적

1454
00:55:15,119 --> 00:55:16,559
추론의 대부분

1455
00:55:16,559 --> 00:55:18,480
의 무거운 작업은

1456
00:55:18,480 --> 00:55:21,260
실제로 여기에서 비롯됩니다

1457
00:55:21,300 --> 00:55:22,559
음 예 그래서 저는

1458
00:55:22,559 --> 00:55:24,300


1459
00:55:24,300 --> 00:55:26,640


1460
00:55:26,640 --> 00:55:28,440


1461
00:55:28,440 --> 00:55:30,599
불연속 상태 공간에서 활성 추론 모델로 작업을 시작하려는 사람

1462
00:55:30,599 --> 00:55:32,220
이 머리를 감싸야 하는 정말 중요한

1463
00:55:32,220 --> 00:55:34,559
것은 모델이 대부분

1464
00:55:34,559 --> 00:55:36,420
의 작업을 수행한다는 것입니다.  예상되는 자유

1465
00:55:36,420 --> 00:55:38,040
에너지 예

1466
00:55:38,040 --> 00:55:39,660
는 많은

1467
00:55:39,660 --> 00:55:41,880
장점이 있지만 능동적 추론의 대부분의 힘을 가진 매우 흥미로운 목적 함수입니다.

1468
00:55:41,880 --> 00:55:44,700
세계

1469
00:55:44,700 --> 00:55:46,740
에 대한 에이전트의 신념이 무엇인지 적어

1470
00:55:46,740 --> 00:55:48,300
놓은 다음 일단 그것을

1471
00:55:48,300 --> 00:55:50,520
가지면 나머지 모든 종류는

1472
00:55:50,520 --> 00:55:52,980
당신을 위해 작동합니다. 왜냐하면 pi NDB 코드는 매우 일반적이기 때문입니다.

1473
00:55:52,980 --> 00:55:55,440
일반적이지 않은

1474
00:55:55,440 --> 00:55:56,880
것은 당신이

1475
00:55:56,880 --> 00:55:59,000
세상

1476
00:55:59,400 --> 00:56:01,680
음 그래 이제 마무리하는 중이

1477
00:56:01,680 --> 00:56:03,960
야 아마도 우리는 잠시 그 ​​부분에

1478
00:56:03,960 --> 00:56:05,460
대해 생각해야 할 것입니다. 그렇지 않다면

1479
00:56:05,460 --> 00:56:08,579
이것에 대해 생각이나 의견 또는 질문이 있는 사람이

1480
00:56:08,579 --> 00:56:12,359
있습니까? 계속해서 Daphne이나 Jacob을 마무리할 수 있습니다.

1481
00:56:12,359 --> 00:56:16,460
아니면 물어보겠습니다.  하나

1482
00:56:21,300 --> 00:56:23,520
는 질문이 없습니다

1483
00:56:23,520 --> 00:56:25,680


1484
00:56:25,680 --> 00:56:28,079
. 에이전트의 생성 모델의 사양을 강조

1485
00:56:28,079 --> 00:56:29,099


1486
00:56:29,099 --> 00:56:31,680
하셨고 동전의 다른 면은

1487
00:56:31,680 --> 00:56:34,740
어떻습니까? 생성 프로세스를 지정하는

1488
00:56:34,740 --> 00:56:37,680
방법은 에이전트의 환경을 지정하는 방법입니다.

1489
00:56:37,680 --> 00:56:40,399


1490
00:56:40,440 --> 00:56:41,880
좋은 질문입니다.

1491
00:56:41,880 --> 00:56:44,520
기본적으로 제가 생성 모델에 대해 말한 모든

1492
00:56:44,520 --> 00:56:46,680


1493
00:56:46,680 --> 00:56:48,540
것은 에이전트의 흥미로운 행동을 제외하고 생성 프로세스에도 적용됩니다. 제 말은 생성

1494
00:56:48,540 --> 00:56:50,099
프로세스를

1495
00:56:50,099 --> 00:56:53,520


1496
00:56:53,520 --> 00:56:55,500
생각할 수 있다는 뜻입니다

1497
00:56:55,500 --> 00:56:57,059
.

1498
00:56:57,059 --> 00:56:58,200


1499
00:56:58,200 --> 00:57:00,059
병목 현상이

1500
00:57:00,059 --> 00:57:01,920
생성 모델이라고 생각합니다.

1501
00:57:01,920 --> 00:57:04,140
정말 복잡한 생성 프로세스를 생성하면

1502
00:57:04,140 --> 00:57:05,819
모든

1503
00:57:05,819 --> 00:57:08,579
종류의 멋진 비선형 역학이 있는 정말 복잡한 환경

1504
00:57:08,579 --> 00:57:10,319
이지만 에이전트의 세계 모델은 슈퍼

1505
00:57:10,319 --> 00:57:12,420
슈퍼입니다.  간단

1506
00:57:12,420 --> 00:57:14,400
해서 켜거나 끄는 전등 스위치가 있다고 믿으면 그러한 간단한 에이전트에서

1507
00:57:14,400 --> 00:57:16,440


1508
00:57:16,440 --> 00:57:18,839
얻을 수 있는 가능한 행동

1509
00:57:18,839 --> 00:57:22,200


1510
00:57:22,200 --> 00:57:23,880
은 생성 모델의 복잡성에 의해 제한

1511
00:57:23,880 --> 00:57:28,020
되므로 매우 복잡한

1512
00:57:28,020 --> 00:57:29,760
생성 모델은 매우 간단한 생성 모델이 될 것입니다.  복잡한 생성 프로세스에 포함되더라도 여전히

1513
00:57:29,760 --> 00:57:33,000
매우 흥미로운 행동을 보여주지는 못하지만

1514
00:57:33,000 --> 00:57:34,619
복잡한

1515
00:57:34,619 --> 00:57:37,079
생성 프로세스와 복잡한 생성 모델이 모두 있을 때 가장 풍부한

1516
00:57:37,079 --> 00:57:38,700
역학이 분명히 발생할

1517
00:57:38,700 --> 00:57:40,500


1518
00:57:40,500 --> 00:57:44,040


1519
00:57:44,040 --> 00:57:46,920


1520
00:57:46,920 --> 00:57:48,660
것입니다.

1521
00:57:48,660 --> 00:57:50,760
여기에 있는 첫 번째 줄은 생성 프로세스

1522
00:57:50,760 --> 00:57:52,319
를 생성하는 데 많은 작업과 일치할 수

1523
00:57:52,319 --> 00:57:54,900


1524
00:57:54,900 --> 00:57:56,760
있으며 이 경우에는 일입니다.  인식 그리드

1525
00:57:56,760 --> 00:57:58,319
세계 환경

1526
00:57:58,319 --> 00:58:00,660
은 에이전트가 대기열 위치에 있을 때

1527
00:58:00,660 --> 00:58:03,000


1528
00:58:03,000 --> 00:58:04,920
이와 같은 대기열 ID를 보여 주는 일련의 규칙에 불과합니다. 비교적

1529
00:58:04,920 --> 00:58:06,359
간단

1530
00:58:06,359 --> 00:58:08,760
하지만 생각해 볼 흥미로운 한 가지가

1531
00:58:08,760 --> 00:58:10,920
있습니다. Daniel이 생각한 것처럼 확신합니다.

1532
00:58:10,920 --> 00:58:13,260
이것에 관해서는

1533
00:58:13,260 --> 00:58:15,000
능동적 추론에 대한 당신의 작업을 알고

1534
00:58:15,000 --> 00:58:17,099
있고 집합적 행동은

1535
00:58:17,099 --> 00:58:18,960
다중 에이전트 행동에 대한 흥미로운 점

1536
00:58:18,960 --> 00:58:21,300
입니다. 이 경우 생성

1537
00:58:21,300 --> 00:58:25,020
프로세스는 다른 에이전트의 작업

1538
00:58:25,020 --> 00:58:26,819
이므로 생성 프로세스 내 생성

1539
00:58:26,819 --> 00:58:28,980
프로세스는 실제로

1540
00:58:28,980 --> 00:58:31,020
또 다른 활성 추론 에이전트의 출력은 Daphne과 제가 할 때 씨름해야 했던

1541
00:58:31,020 --> 00:58:32,819
것 중 가장 복잡한 것 중 하나입니다.

1542
00:58:32,819 --> 00:58:34,500


1543
00:58:34,500 --> 00:58:36,720


1544
00:58:36,720 --> 00:58:38,339


1545
00:58:38,339 --> 00:58:40,500


1546
00:58:40,500 --> 00:58:43,140


1547
00:58:43,140 --> 00:58:45,119
그 맥락에서 생성 프로세스는

1548
00:58:45,119 --> 00:58:47,880


1549
00:58:47,880 --> 00:58:49,980
프로세스 자체가

1550
00:58:49,980 --> 00:58:51,660
다른 활성 추론 에이전트로 구성되어 있기 때문에 조금 더 어렵습니다.

1551
00:58:51,660 --> 00:58:54,780
다시 작동하여 해당 코드의 제어 흐름이

1552
00:58:54,780 --> 00:58:55,980
조금 다르게 보일 것입니다.

1553
00:58:55,980 --> 00:58:57,420
여기서 루프를 통해

1554
00:58:57,420 --> 00:59:00,599
모든 에이전트가 작업을 가져온

1555
00:59:00,599 --> 00:59:02,400
다음 해당 작업을 사용

1556
00:59:02,400 --> 00:59:03,720
하여 다른 모든 에이전트에 대한 관찰을 매개변수화해야 합니다.

1557
00:59:03,720 --> 00:59:05,760
일반적으로

1558
00:59:05,760 --> 00:59:08,099
다중 에이전트 시뮬레이션

1559
00:59:08,099 --> 00:59:10,440
에 대한 일반적인 설명이지만 다른 에이전트를 모델링하려는 에이전트

1560
00:59:10,440 --> 00:59:12,240
에 대해 생각할 때 특히 흥미롭습니다.

1561
00:59:12,240 --> 00:59:14,400


1562
00:59:14,400 --> 00:59:16,740
왜냐하면 거의 모든 활성

1563
00:59:16,740 --> 00:59:18,119
추론 에이전트는

1564
00:59:18,119 --> 00:59:20,400
세계가 작동하는 방식에 대한 빈약한 모델을 가질 것이기 때문입니다.

1565
00:59:20,400 --> 00:59:23,819


1566
00:59:23,819 --> 00:59:25,500
상호 작용하는 활성

1567
00:59:25,500 --> 00:59:27,000
추론 에이전트의 묶음이므로

1568
00:59:27,000 --> 00:59:29,819
모든 에이전트

1569
00:59:29,819 --> 00:59:31,500
가

1570
00:59:31,500 --> 00:59:33,660


1571
00:59:33,660 --> 00:59:35,460
무한 재귀 깊이와 같이

1572
00:59:35,460 --> 00:59:37,859
자체 생성 모델에서 시뮬레이션할 수 있기를 원하지 않는 한 각 에이전트에 보다 단순화된 생성 모델을 반드시 장착해야

1573
00:59:37,859 --> 00:59:39,480
합니다.  다른 모든 에이전트의 생성 모델입니다.

1574
00:59:39,480 --> 00:59:41,940
예, 그게 다중 에이전트 사례

1575
00:59:41,940 --> 00:59:43,020
에 대한 접선의 일종이라는 뜻입니다.

1576
00:59:43,020 --> 00:59:44,460
하지만 제 생각에는

1577
00:59:44,460 --> 00:59:46,619


1578
00:59:46,619 --> 00:59:49,140


1579
00:59:49,140 --> 00:59:51,119


1580
00:59:51,119 --> 00:59:52,680
생성 모델 복잡성과

1581
00:59:52,680 --> 00:59:54,480
생성 프로세스 복잡성 사이의 긴장과

1582
00:59:54,480 --> 00:59:56,579
이들이 서로의 행동을 어떻게 상호 제한하는지

1583
00:59:56,579 --> 00:59:59,480


1584
01:00:02,400 --> 01:00:04,799
에 대해 생각하는 것은 흥미롭고 흥미로운

1585
01:00:04,799 --> 01:00:06,540
복합성입니다.  생각

1586
01:00:06,540 --> 01:00:09,720
은 일종의 신나는 일이므로 앞으로

1587
01:00:09,720 --> 01:00:11,099
프라임 DP와 함께 하고 싶은 일의 목록이

1588
01:00:11,099 --> 01:00:13,500


1589
01:00:13,500 --> 01:00:15,480
있습니다 음

1590
01:00:15,480 --> 01:00:16,980
그냥 살펴보고 가장 중요하다고 생각하는 몇 가지에 대해 이야기하겠습니다

1591
01:00:16,980 --> 01:00:19,319
중요한 것은 Pine DP

1592
01:00:19,319 --> 01:00:21,299
모델을 경험적 데이터에 맞추는 것이므로

1593
01:00:21,299 --> 01:00:23,160


1594
01:00:23,160 --> 01:00:24,960


1595
01:00:24,960 --> 01:00:26,460
실제로

1596
01:00:26,460 --> 01:00:30,299
행동 모델(종종 인간 행동)을 만드는 데 관심이 있는 전산 정신의학 커뮤니티

1597
01:00:30,299 --> 01:00:32,520


1598
01:00:32,520 --> 01:00:34,740
의 사람들과 많이 교류했습니다.

1599
01:00:34,740 --> 01:00:37,020
현재 소나무 DP의 가장 큰 한계

1600
01:00:37,020 --> 01:00:40,319
는 사람들이 pi mdp를 사용

1601
01:00:40,319 --> 01:00:42,900


1602
01:00:42,900 --> 01:00:44,819


1603
01:00:44,819 --> 01:00:47,220
하여 S에서 할 수 있는 작업을 수행하는 인간 대상과 같은 활성 추론 매개변수를 추론할 수 없다는 것입니다.

1604
01:00:47,220 --> 01:00:48,540
지금은 PM이지만 불행히도

1605
01:00:48,540 --> 01:00:51,540
Pion VP에서는 그렇게 할 수 없습니다. 그래서 이것은

1606
01:00:51,540 --> 01:00:53,339
우선순위 목록에서 정말 높은 것과 같습니다. 이것이

1607
01:00:53,339 --> 01:00:55,020
기본 P가 실제로 Pi mdp 모델을 맞추는 데 관심이

1608
01:00:55,020 --> 01:00:58,440
있는 커뮤니티를 위해 SPM에 대한 경쟁력을 갖추는 데 도움이 될 것이라고 생각

1609
01:00:58,440 --> 01:00:59,640


1610
01:00:59,640 --> 01:01:02,640
합니다.  그래서 이것들

1611
01:01:02,640 --> 01:01:03,780
은 전산 정신 의학과 같은 좀 더 경험

1612
01:01:03,780 --> 01:01:05,040
적인 과학 분야와 같습니다.

1613
01:01:05,040 --> 01:01:08,040


1614
01:01:08,040 --> 01:01:10,440
음 다른 것들은

1615
01:01:10,440 --> 01:01:12,059
실제로 병목 현상이 되는 건물 A 및 B 매트릭스와 관련된 모든 코드가 생성 모델을 실제로 생성하고 구성하기 위한 더 나은 인터페이스가 필요하다고 생각합니다.

1616
01:01:12,059 --> 01:01:13,859


1617
01:01:13,859 --> 01:01:17,460


1618
01:01:17,460 --> 01:01:19,559


1619
01:01:19,559 --> 01:01:21,180


1620
01:01:21,180 --> 01:01:23,280
능동적 추론을 하려는 사람은 대부분 복잡하고 너그러운 모델을

1621
01:01:23,280 --> 01:01:25,319
위해 이러한 배열을 구성하는

1622
01:01:25,319 --> 01:01:27,839
것이 정말

1623
01:01:27,839 --> 01:01:29,280
골칫거리일 수 있기 때문에 이 이상한 다차원 인덱싱을 모두 수행해야 합니다.

1624
01:01:29,280 --> 01:01:31,680


1625
01:01:31,680 --> 01:01:33,000


1626
01:01:33,000 --> 01:01:34,920


1627
01:01:34,920 --> 01:01:37,079


1628
01:01:37,079 --> 01:01:39,180


1629
01:01:39,180 --> 01:01:41,160
에 해당하는 추가 차원의 수가 다른 거대한 다차원 배열을 만들어야 합니다.  세상

1630
01:01:41,160 --> 01:01:42,720
에서 일어날

1631
01:01:42,720 --> 01:01:44,460
수 있는 이 모든 우발 사태는 변수 간의

1632
01:01:44,460 --> 01:01:47,339
모든 관계를 인코딩해야 하는 거대한 조회 테이블이 됩니다.

1633
01:01:47,339 --> 01:01:49,680


1634
01:01:49,680 --> 01:01:51,480
그래서 제 생각에는 이것이

1635
01:01:51,480 --> 01:01:52,859
야심찬 프로젝트일 수 있지만 사용자

1636
01:01:52,859 --> 01:01:55,619
와 같은 종류의 UI를 실제로 생성하는 방법이 있을 수 있습니다.

1637
01:01:55,619 --> 01:01:58,440


1638
01:01:58,440 --> 01:02:00,540


1639
01:02:00,540 --> 01:02:02,579
예를 들어

1640
01:02:02,579 --> 01:02:04,200
이 변수가 해당 변수에 영향을 주기를 원하는지 등의 일련

1641
01:02:04,200 --> 01:02:05,760
의

1642
01:02:05,760 --> 01:02:08,339
질문

1643
01:02:08,339 --> 01:02:10,440


1644
01:02:10,440 --> 01:02:12,180
을 함으로써 생성 모델을 구축하는 데 도움이 되는 인터페이스입니다.

1645
01:02:12,180 --> 01:02:13,740
매트릭스 스케치

1646
01:02:13,740 --> 01:02:15,900
창의 실제 구조는 세계의 다양한 우발 상황에 대한 일련의 예 아니오

1647
01:02:15,900 --> 01:02:17,160
질문에

1648
01:02:17,160 --> 01:02:19,740


1649
01:02:19,740 --> 01:02:21,900
이르기

1650
01:02:21,900 --> 01:02:24,119
까지 우리가 이미 수행

1651
01:02:24,119 --> 01:02:26,099
한 몇 가지 예가 있는 것처럼 openai 체육관과 인터페이스하는 것입니다.

1652
01:02:26,099 --> 01:02:28,079


1653
01:02:28,079 --> 01:02:31,020
아직 깃허브에 적극적으로 인프라에 올려본 적은 없지만

1654
01:02:31,020 --> 01:02:32,880
이건 공개된 부분

1655
01:02:32,880 --> 01:02:35,160
인데 굉장히 뻔하고

1656
01:02:35,160 --> 01:02:37,500
쉽게 할 수 있는 일 같아요.  왜냐하면 우리는

1657
01:02:37,500 --> 01:02:40,020
환경 클래스

1658
01:02:40,020 --> 01:02:42,240
를 마치 체육관 환경인 것처럼 기반으로 작성했기 때문에

1659
01:02:42,240 --> 01:02:43,859
일단 그렇게 하면

1660
01:02:43,859 --> 01:02:45,780
활성 추론 에이전트를 계층 모델

1661
01:02:45,780 --> 01:02:46,920
의 모든 종류의 강화 학습

1662
01:02:46,920 --> 01:02:48,000
알고리즘과 비교할 수 있게 될

1663
01:02:48,000 --> 01:02:51,780
것이기 때문에 큰 문제입니다.

1664
01:02:51,780 --> 01:02:54,140
음 기본적으로

1665
01:02:54,140 --> 01:02:56,099
계층적으로 활성화된 추론 에이전트

1666
01:02:56,099 --> 01:02:58,559
를 서로 쌓을 수 있습니다. 예를 들어

1667
01:02:58,559 --> 01:03:00,119


1668
01:03:00,119 --> 01:03:02,579
활성 추론 에이전트

1669
01:03:02,579 --> 01:03:05,160
를 계층적 사물에 쌓음으로써 얻을 수 있는 많은 시간적 깊이가 있습니다. 예를 들어, 한

1670
01:03:05,160 --> 01:03:07,680
시간 규모의 추론과 계획이

1671
01:03:07,680 --> 01:03:10,200
더 느린 규모에서 일어나는 것과 같습니다.

1672
01:03:10,200 --> 01:03:12,420
서브 빠른 시간 척도보다 느리고

1673
01:03:12,420 --> 01:03:14,520


1674
01:03:14,520 --> 01:03:16,140


1675
01:03:16,140 --> 01:03:19,020
b 및 d 배열 업데이트를 수행할 수 있도록 매개변수 학습을 시연하는 더 많은 데모가 필요합니다.

1676
01:03:19,020 --> 01:03:21,299
지금까지 C를 업데이트할 수 없다고 생각합니다.

1677
01:03:21,299 --> 01:03:22,740
이것이 Daniel이 제게 언급한 내용

1678
01:03:22,740 --> 01:03:25,140
이라는 것을 압니다.

1679
01:03:25,140 --> 01:03:26,700
활성 추론 연구소의 사람들은 일반적으로

1680
01:03:26,700 --> 01:03:28,079


1681
01:03:28,079 --> 01:03:29,640


1682
01:03:29,640 --> 01:03:31,200
생성 모델 매개변수에 대한 신념을 기본적

1683
01:03:31,200 --> 01:03:32,460
으로 업데이트하는 데 관심이 있습니다.  능동적 추론

1684
01:03:32,460 --> 01:03:34,319


1685
01:03:34,319 --> 01:03:36,000
하에서 계획의 최신 버전인 정교한 추론

1686
01:03:36,000 --> 01:03:37,440


1687
01:03:37,440 --> 01:03:40,200
과 같이 흥미롭고 약간의

1688
01:03:40,200 --> 01:03:42,480
계산상의 이점이

1689
01:03:42,480 --> 01:03:43,799
있으며 정교한 추론과 함께

1690
01:03:43,799 --> 01:03:45,839
사람들

1691
01:03:45,839 --> 01:03:47,700
이 개발한 이 일은 심층 강화에서 처리해야 했습니다.

1692
01:03:47,700 --> 01:03:49,140


1693
01:03:49,140 --> 01:03:51,720


1694
01:03:51,720 --> 01:03:53,460
폭발적인 조합 정책 공간을 길들이는 방법에 대해 잠시 학습합니다. 따라서

1695
01:03:53,460 --> 01:03:56,280
시간이 지남에 따라 심층적인 계획을 수행할 때

1696
01:03:56,280 --> 01:03:58,200
정책의

1697
01:03:58,200 --> 01:04:01,020
수는 계획하는 시간 단계의 수에 따라 기하급수적이므로

1698
01:04:01,020 --> 01:04:03,720
이를 처리하기 위한 다양한 기술

1699
01:04:03,720 --> 01:04:05,339
이 있습니다.

1700
01:04:05,339 --> 01:04:07,200


1701
01:04:07,200 --> 01:04:09,380
Teofio Champions와 같은 일부 사람들과 다른 사람들이 이미

1702
01:04:09,380 --> 01:04:11,640


1703
01:04:11,640 --> 01:04:14,700
팜 DPS의 자체 구현을 구현

1704
01:04:14,700 --> 01:04:17,040


1705
01:04:17,040 --> 01:04:19,079
하기 시작했다고 생각하는 Monte Carlo 트리 검색과 같은 것입니다.

1706
01:04:19,079 --> 01:04:21,059
지금 작업 중이므로

1707
01:04:21,059 --> 01:04:23,339
Pi mdp 모델을 경험적 데이터에

1708
01:04:23,339 --> 01:04:25,980
맞추는 중이므로 Dimitri markovic과 제가 함께 작업한 분기가

1709
01:04:25,980 --> 01:04:27,420
있습니다.

1710
01:04:27,420 --> 01:04:29,579
우리는

1711
01:04:29,579 --> 01:04:31,680
기본적으로 pione p 및 Jax에 대한 백엔드를 작성했습니다.

1712
01:04:31,680 --> 01:04:35,160
이를 통해

1713
01:04:35,160 --> 01:04:37,319


1714
01:04:37,319 --> 01:04:39,420
numpyro와 같은 여러 통계적 확률 추론 기술을 사용하여

1715
01:04:39,420 --> 01:04:42,480


1716
01:04:42,480 --> 01:04:44,819
유사한 데이터에서 Pi mdp 에이전트의 매개변수를 반전하거나 추론할 수 있습니다.

1717
01:04:44,819 --> 01:04:47,280
인간 참여자로부터 수집된 인스턴스 컴퓨팅

1718
01:04:47,280 --> 01:04:49,920
이지만 Jacks에서도 백엔드라는 사실

1719
01:04:49,920 --> 01:04:52,440
은 Pi mdp가

1720
01:04:52,440 --> 01:04:54,299
이제 완전히 자동 미분 가능

1721
01:04:54,299 --> 01:04:56,460
하다는 것을 의미하므로 파이 VP의 매트릭스 레이어 전에 심층 신경망 레이어를 쌓을 수 있음을 의미합니다.

1722
01:04:56,460 --> 01:04:59,400


1723
01:04:59,400 --> 01:05:01,799


1724
01:05:01,799 --> 01:05:03,420
에이전트 그리고 당신은 파이 VP 에이전트

1725
01:05:03,420 --> 01:05:05,460


1726
01:05:05,460 --> 01:05:07,500


1727
01:05:07,500 --> 01:05:09,660
에 연결된 신경망의 매개변수를 자동으로 훈련

1728
01:05:09,660 --> 01:05:11,880


1729
01:05:11,880 --> 01:05:14,280
시키기 위해 변형 자유 에너지 또는 다른

1730
01:05:14,280 --> 01:05:16,260
목적 함수와 같은 것을 사용할 수 있습니다.

1731
01:05:16,260 --> 01:05:18,720
이는 심층 신경망을 다양한 구성 요소에 연결하여

1732
01:05:18,720 --> 01:05:20,700


1733
01:05:20,700 --> 01:05:22,680
파이오네 P를 훨씬 더 높은

1734
01:05:22,680 --> 01:05:25,640
차원의 상태 공간으로 확장할 수 있기 때문에 큰 이점과 같습니다.

1735
01:05:25,640 --> 01:05:28,260


1736
01:05:28,260 --> 01:05:31,020
o  f 당신이 그것을 설명하는 에이전트의 몸

1737
01:05:31,020 --> 01:05:33,119
Daniel

1738
01:05:33,119 --> 01:05:34,619
음 그래서 우리는 원래

1739
01:05:34,619 --> 01:05:36,359
경험적 데이터의 피팅을 할 수 있도록

1740
01:05:36,359 --> 01:05:38,700
하기 위해 이것을 했습니다.

1741
01:05:38,700 --> 01:05:41,280


1742
01:05:41,280 --> 01:05:43,619


1743
01:05:43,619 --> 01:05:45,559
딥 러닝

1744
01:05:45,559 --> 01:05:48,119
모델을 업데이트하는 것이 정말 흥미진진하다고 생각합니다.

1745
01:05:48,119 --> 01:05:51,299
그래서 거의 완료된 것 같습니다. 제 말

1746
01:05:51,299 --> 01:05:53,579
은 우리가 실제로 그렇게 하는 노트북을 세우는 데 매우 가까워졌다는

1747
01:05:53,579 --> 01:05:55,559


1748
01:05:55,559 --> 01:05:57,180
것입니다. Jack's Branch 요원을 보면 지금은

1749
01:05:57,180 --> 01:05:58,980
그다지 체계적이지 않지만 그 내용입니다.

1750
01:05:58,980 --> 01:06:01,680
지금 거기에 있으며

1751
01:06:01,680 --> 01:06:04,799
또 다른 것을 구현했습니다. Sajid도 아니고 저는

1752
01:06:04,799 --> 01:06:07,020
실제로

1753
01:06:07,020 --> 01:06:09,480
그녀의 종이 능동적 추론에서 일부 환경을

1754
01:06:09,480 --> 01:06:11,339
비교하여 구현했습니다. 우리는

1755
01:06:11,339 --> 01:06:15,180
실제로

1756
01:06:15,180 --> 01:06:16,980
얼어붙은 호수 환경

1757
01:06:16,980 --> 01:06:19,380
과 같은 openai 체육관에서 파이 MVP로 수행했습니다.  B 매트릭스

1758
01:06:19,380 --> 01:06:20,640
학습을 시뮬레이트

1759
01:06:20,640 --> 01:06:21,839
하는 것 음, 그것은

1760
01:06:21,839 --> 01:06:24,599
우리가 그것을 한 것과 같은 것입니다. 그리고 그것을

1761
01:06:24,599 --> 01:06:26,520
업로드하는 것을 좋아해야 합니다.

1762
01:06:26,520 --> 01:06:28,079
아니면 짧은 논문을 쓰세요

1763
01:06:28,079 --> 01:06:29,700
그 이유는 탐색된 다양한 덩굴손과 같은 것이 많기 때문

1764
01:06:29,700 --> 01:06:31,200


1765
01:06:31,200 --> 01:06:33,359
입니다.

1766
01:06:33,359 --> 01:06:34,799
앞으로 나아가고 실제로

1767
01:06:34,799 --> 01:06:37,500
소나무 BP 보고서에 올려 놓는 문제입니다.

1768
01:06:37,500 --> 01:06:39,359
음 예, 그리고

1769
01:06:39,359 --> 01:06:42,000
시간을 내서 다른 일을 하고 싶지만  나는 단지

1770
01:06:42,000 --> 01:06:43,799
하지 않았지만 처음에

1771
01:06:43,799 --> 01:06:44,940
말했듯이 이것은 매우

1772
01:06:44,940 --> 01:06:47,039
협력적인 노력이었습니다. 그래서 나는 또한

1773
01:06:47,039 --> 01:06:48,660


1774
01:06:48,660 --> 01:06:50,700
음 반드시 이 모든 것을 하는 것과 같은 사람이 되고

1775
01:06:50,700 --> 01:06:52,380


1776
01:06:52,380 --> 01:06:54,180
싶지는 않습니다.  패키지의 개발은

1777
01:06:54,180 --> 01:06:55,680
서로 다른 사람들이

1778
01:06:55,680 --> 01:06:57,480
서로 다른 것을 주도

1779
01:06:57,480 --> 01:06:58,980
하고 자신의 방식으로 개발하는

1780
01:06:58,980 --> 01:07:00,480
것이므로 저도 일반적으로

1781
01:07:00,480 --> 01:07:03,059
권장하고 싶은 모든 종류의 관심있는

1782
01:07:03,059 --> 01:07:04,140
사람들이 개발에 참여하는 것입니다.

1783
01:07:04,140 --> 01:07:05,520


1784
01:07:05,520 --> 01:07:08,339
Brennan이 여기에 있다고 생각하지 않지만

1785
01:07:08,339 --> 01:07:11,000
Brennan Klein은

1786
01:07:11,000 --> 01:07:12,839


1787
01:07:12,839 --> 01:07:13,920
박사후 연구원이자

1788
01:07:13,920 --> 01:07:15,240
네트워크 과학 연구소의 Northeastern University의 연구 과학자이기도 합니다.

1789
01:07:15,240 --> 01:07:17,880
그는 이러한 Pi

1790
01:07:17,880 --> 01:07:20,339
mdp 펠로우십을 시작하여

1791
01:07:20,339 --> 01:07:21,960
N  ortheastern 나는 Templeton

1792
01:07:21,960 --> 01:07:24,420
재단이 사람들이

1793
01:07:24,420 --> 01:07:26,400
Pine MVP 개발 또는 주요 DP

1794
01:07:26,400 --> 01:07:28,619
인접 프로젝트에 자금을 지원한다고 생각합니다. 첫 번째

1795
01:07:28,619 --> 01:07:30,839
신청 라운드는 끝났지만 이것이

1796
01:07:30,839 --> 01:07:32,099


1797
01:07:32,099 --> 01:07:33,839
광고할 수 있는 좋은 기회

1798
01:07:33,839 --> 01:07:35,339
가 될 것이라고 생각합니다.

1799
01:07:35,339 --> 01:07:38,000
여름의 또 다른 코호트이므로 이것은

1800
01:07:38,000 --> 01:07:40,680
겉보기에 진행 중인 자금 조달원의 일종이므로

1801
01:07:40,680 --> 01:07:42,359
다른 사람들

1802
01:07:42,359 --> 01:07:45,180
이 Pine VP를 자신의 방향으로 밀어붙이는

1803
01:07:45,180 --> 01:07:47,339


1804
01:07:47,339 --> 01:07:48,839
것을 보는 것이 좋습니다.

1805
01:07:48,839 --> 01:07:52,319
의

1806
01:07:52,319 --> 01:07:54,299
음 오 예 그리고 난 그냥 자동 문서를 만드는 데 정말 좋은

1807
01:07:54,299 --> 01:07:56,359


1808
01:07:57,240 --> 01:08:00,180
docs 웹 사이트 읽기에서 음 환자로 끝낼 것입니다.

1809
01:08:00,180 --> 01:08:01,740


1810
01:08:01,740 --> 01:08:03,960
그래서 우리는

1811
01:08:03,960 --> 01:08:05,460
거기에 많은 데모가 있습니다. 우리는 다른

1812
01:08:05,460 --> 01:08:07,440
자습서

1813
01:08:07,440 --> 01:08:09,539
가 있습니다. 음 우리는 또 다른 새로운 데모가 있습니다.

1814
01:08:09,539 --> 01:08:11,160


1815
01:08:11,160 --> 01:08:13,140


1816
01:08:13,140 --> 01:08:15,480


1817
01:08:15,480 --> 01:08:17,939
Ryan Smith와

1818
01:08:17,939 --> 01:08:20,040
Christopher white 및 Carl fursten의

1819
01:08:20,040 --> 01:08:20,819
아빠의 데모를 기반으로 하는 불연속 범주형 모델에서 자유 에너지의 변화를 계산하는 것에 관한 여기에 나열되지 않았습니다.

1820
01:08:20,819 --> 01:08:23,698
어 어 능동적 추론에 대한 큰 튜토리얼 문서와 달리

1821
01:08:23,698 --> 01:08:26,100


1822
01:08:26,100 --> 01:08:28,319
그 문서의 데모 중 하나를 다시 구현

1823
01:08:28,319 --> 01:08:31,020
했으며 이제 문서에도 있습니다

1824
01:08:31,020 --> 01:08:33,060
음 예 그래서

1825
01:08:33,060 --> 01:08:35,100
collab에서 모든 데모 노트북을 열고 단계별로 살펴볼

1826
01:08:35,100 --> 01:08:36,960
수 있습니다 음 그리고 그들은  실제로 사용하기 위해 컴퓨터에

1827
01:08:36,960 --> 01:08:38,880
Python을 설치할 필요가 없습니다

1828
01:08:38,880 --> 01:08:40,198


1829
01:08:40,198 --> 01:08:42,600
. collab에서 링크를 열고 코드를 단계별로

1830
01:08:42,600 --> 01:08:44,460
실행하고 자신만의

1831
01:08:44,460 --> 01:08:46,259
활성 추론 에이전트를 빌드하는 것처럼

1832
01:08:46,259 --> 01:08:48,238
교육학에 유용하므로

1833
01:08:48,238 --> 01:08:49,259
제가 언급한 이유입니다.  이제 막 시작

1834
01:08:49,259 --> 01:08:50,880


1835
01:08:50,880 --> 01:08:54,238
하는 경우 문서로 이동하는 것이 좋습니다.

1836
01:08:54,238 --> 01:08:56,698
예 음 경청해 주셔서 감사합니다.

1837
01:08:56,698 --> 01:08:59,640
어, 저

1838
01:08:59,640 --> 01:09:01,799
에게 말할 기회를 주셔서 감사합니다.

1839
01:09:01,799 --> 01:09:05,640
언제나처럼 여기에 있어서 좋았고 제 생각에는  예

1840
01:09:05,640 --> 01:09:07,620
, 다음 라이브 스트림을 위해 맨 아래에 나열했습니다.

1841
01:09:07,620 --> 01:09:08,939


1842
01:09:08,939 --> 01:09:10,738
일부 데모 노트북을 검토할 수

1843
01:09:10,738 --> 01:09:12,660
있지만 시간이 있으면 지금 검토할 수도 있습니다.

1844
01:09:12,660 --> 01:09:14,279
먼저 토론을 한 다음 시간이

1845
01:09:14,279 --> 01:09:15,179
있는지 확인

1846
01:09:15,179 --> 01:09:17,880


1847
01:09:17,880 --> 01:09:21,540
하겠습니다. 감사합니다.

1848
01:09:21,540 --> 01:09:25,140
Daphne과 Jacob의 몇 가지 질문에 답변하겠습니다

1849
01:09:25,140 --> 01:09:28,140
. 실시간 채팅에서 몇 가지 질문을 한 다음 문서

1850
01:09:28,140 --> 01:09:31,738


1851
01:09:31,738 --> 01:09:34,920
읽기에서 하나 또는 몇 가지 예를 공유할 수

1852
01:09:34,920 --> 01:09:36,479


1853
01:09:36,479 --> 01:09:40,140
있으며 해부학 및 생리학이 무엇인지 구조적으로 볼 수 있습니다.

1854
01:09:40,140 --> 01:09:42,899
노트북이므로 먼저

1855
01:09:42,899 --> 01:09:46,080
Daphne 또는 Jacob의

1856
01:09:46,080 --> 01:09:49,339
생각이나 질문이 있습니다.

1857
01:09:52,679 --> 01:09:56,120
예 예 가능합니다.

1858
01:09:56,400 --> 01:09:58,620
um Jacks 구현에 대해 궁금한

1859
01:09:58,620 --> 01:10:00,300


1860
01:10:00,300 --> 01:10:03,660
점이 있습니다

1861
01:10:03,660 --> 01:10:07,400
. 생성 프로세스를

1862
01:10:07,500 --> 01:10:11,160
정의하는 데 필요한 요구 사항이 있는지 아니면

1863
01:10:11,160 --> 01:10:13,140


1864
01:10:13,140 --> 01:10:14,820
그런 다음 우리가 실험 데이터

1865
01:10:14,820 --> 01:10:16,199
에 맞추는 생성 모델 그리고 이것은

1866
01:10:16,199 --> 01:10:18,840


1867
01:10:18,840 --> 01:10:21,780


1868
01:10:21,780 --> 01:10:24,179
모델러로서

1869
01:10:24,179 --> 01:10:27,000
실제로 우리 자신을 정의할 수 있는 자유가 없지만

1870
01:10:27,000 --> 01:10:28,699


1871
01:10:28,699 --> 01:10:31,159
배포하고

1872
01:10:31,159 --> 01:10:34,739


1873
01:10:34,739 --> 01:10:37,080


1874
01:10:37,080 --> 01:10:39,780
카테고리 또는

1875
01:10:39,780 --> 01:10:42,500
이산

1876
01:10:42,600 --> 01:10:45,360
데이터가 들어오는 온라인 설정과 같이 이미

1877
01:10:45,360 --> 01:10:46,920


1878
01:10:46,920 --> 01:10:48,960
존재

1879
01:10:48,960 --> 01:10:51,360
하는 일반적인 프로세스에서 이러한 에이전트를 교육합니다.  음 측면에 있는 좋은 질문

1880
01:10:51,360 --> 01:10:54,659
은 심층 신경망이 연결된 계획 BP 에이전트가

1881
01:10:54,659 --> 01:10:56,159


1882
01:10:56,159 --> 01:10:59,580


1883
01:10:59,580 --> 01:11:01,320
있고 배포된 환경에서 훈련하고 싶었기 때문에 마치 외부와 같다고

1884
01:11:01,320 --> 01:11:03,179
가정해 보겠습니다. 에이전트라고 가정해 보겠습니다.

1885
01:11:03,179 --> 01:11:04,739
그것은 주식 시장에서 거래되거나

1886
01:11:04,739 --> 01:11:06,300


1887
01:11:06,300 --> 01:11:09,060
암호화폐처럼 구매하기 위해 내기를 거는 것과 같은

1888
01:11:09,060 --> 01:11:09,960
것

1889
01:11:09,960 --> 01:11:12,659
입니다. 이 경우 생성 프로세스를 통해 기울기를 전달할 필요가 없는 그러한 종류의 데이터에 대해 심층 신경망을 훈련하는 것과 같은 방식으로 말합시다.

1890
01:11:12,659 --> 01:11:14,280


1891
01:11:14,280 --> 01:11:16,320


1892
01:11:16,320 --> 01:11:18,120
물론

1893
01:11:18,120 --> 01:11:20,159
당신은 당신이 주식 시장에서 거래하고 있다는 것에 접근할 수 없습니다

1894
01:11:20,159 --> 01:11:22,320
. 그런 의미에서 그래디언트

1895
01:11:22,320 --> 01:11:24,420
를 통과

1896
01:11:24,420 --> 01:11:27,300
하거나 자동으로 미분할 수 있는 생성 프로세스를 작성하는 데 대한 요구 사항이 없습니다.

1897
01:11:27,300 --> 01:11:30,060


1898
01:11:30,060 --> 01:11:32,820
원하는 경우가 하나 있습니다.

1899
01:11:32,820 --> 01:11:34,739


1900
01:11:34,739 --> 01:11:37,980
종종 실증적으로

1901
01:11:37,980 --> 01:11:40,800
Pine DP 모델을 데이터에

1902
01:11:40,800 --> 01:11:43,020
맞추는 경우 종종 하고 싶은 한 가지는

1903
01:11:43,020 --> 01:11:45,000
기본적으로 모델 t

1904
01:11:45,000 --> 01:11:47,219
에 맞는 인간 참가자의 행동 및 관찰 기록이 있는 것과 같은 많은 것을 갖는 것입니다.

1905
01:11:47,219 --> 01:11:49,679


1906
01:11:49,679 --> 01:11:52,140
그는 참가자의 관찰된 행동을 가장 잘 설명하는 파이 VP 에이전트의 매개변수이며,

1907
01:11:52,140 --> 01:11:54,360


1908
01:11:54,360 --> 01:11:55,920


1909
01:11:55,920 --> 01:11:57,120
당신은

1910
01:11:57,120 --> 01:11:59,219
이

1911
01:11:59,219 --> 01:12:00,480
사람이 관찰 시퀀스를 볼 것이라고 결정한 실험자이기 때문에

1912
01:12:00,480 --> 01:12:02,400
관찰을 알고 있으므로 미분 가능 없이 모든 것을 수행할 수 있습니다.

1913
01:12:02,400 --> 01:12:04,380


1914
01:12:04,380 --> 01:12:07,380
생성 프로세스 또는 환경

1915
01:12:07,380 --> 01:12:09,000
이지만 Bayesian

1916
01:12:09,000 --> 01:12:10,860
추론에는 사후 예측 검사와 같은 것이

1917
01:12:10,860 --> 01:12:12,960
있습니다. 여기에서 좋아요라고 말하면

1918
01:12:12,960 --> 01:12:16,620


1919
01:12:16,620 --> 01:12:18,840
파이오네 P 에이전트의 매개변수에 대한 내 추론이 주어지고

1920
01:12:18,840 --> 01:12:20,520


1921
01:12:20,520 --> 01:12:23,100
이 에이전트의 예상되는 동작을 롤아웃하고 싶습니다.

1922
01:12:23,100 --> 01:12:25,560
이 에이전트의 매개변수가 무엇인지에 대한 내 최선

1923
01:12:25,560 --> 01:12:27,840
의 추측이 주어지면

1924
01:12:27,840 --> 01:12:29,640
사후 예측 밀도와 같이 호출됩니다.

1925
01:12:29,640 --> 01:12:32,400
여기서

1926
01:12:32,400 --> 01:12:34,500
에이전트의 매개변수에 대한 내 사후 추정치가

1927
01:12:34,500 --> 01:12:37,080


1928
01:12:37,080 --> 01:12:39,480
이러한 사후 매개변수 하에서 미래에 어떻게 보일지

1929
01:12:39,480 --> 01:12:42,840
말하고 그것을 다음에서 수행하는 것입니다.  Jax를 백엔드로 사용

1930
01:12:42,840 --> 01:12:45,420
하는 확률적 추론 프레임워크인

1931
01:12:45,420 --> 01:12:47,699


1932
01:12:47,699 --> 01:12:49,800
numpyro를 사용하면 생성

1933
01:12:49,800 --> 01:12:52,679
자동 미분 가능 프로세스

1934
01:12:52,679 --> 01:12:54,659
이기도 하지만 이 경우 제어된 작업 환경에 있는 것과 같은 실험 데이터에 인간의 행동을 맞추는 경우이기 때문에

1935
01:12:54,659 --> 01:12:56,400
이러한 생성 프로세스를 작성하는

1936
01:12:56,400 --> 01:12:58,020
것이 쉬울 것이라고 기대합니다.

1937
01:12:58,020 --> 01:13:01,199


1938
01:13:01,199 --> 01:13:02,820


1939
01:13:02,820 --> 01:13:05,159


1940
01:13:05,159 --> 01:13:07,739


1941
01:13:07,739 --> 01:13:10,320
C 벡터의 값과 같은 누군가의 매개 변수를 맞추려고 시도

1942
01:13:10,320 --> 01:13:12,420
하고

1943
01:13:12,420 --> 01:13:13,860
그들이 아픈 장면 구성 작업을 수행하는 경우

1944
01:13:13,860 --> 01:13:15,300
주변

1945
01:13:15,300 --> 01:13:17,040
을 자르는 경우 생성 프로세스를 작성할 수

1946
01:13:17,040 --> 01:13:18,840
있습니다.

1947
01:13:18,840 --> 01:13:21,480


1948
01:13:21,480 --> 01:13:22,739
그들은 당신과 상호 작용하고 있습니다. 모델링을

1949
01:13:22,739 --> 01:13:24,659
수행할 때 Jax에서도 작성할 수

1950
01:13:24,659 --> 01:13:26,460
있으므로

1951
01:13:26,460 --> 01:13:28,620
이러한 사후 예측 검사를 수행할 때

1952
01:13:28,620 --> 01:13:30,300
Jacks에서도 작성

1953
01:13:30,300 --> 01:13:31,620
되고 배포된 설정에서 해당 수량을 계산할 수 있음을 알 수 있습니다.

1954
01:13:31,620 --> 01:13:33,900


1955
01:13:33,900 --> 01:13:35,460


1956
01:13:35,460 --> 01:13:37,140


1957
01:13:37,140 --> 01:13:39,179


1958
01:13:39,179 --> 01:13:41,219
환경이 실제로 어떻게 작동하는지 모르기 때문에 앞으로 어떤 종류의 사후 예측 검사도 할 수 없을 것입니다.  ht

1959
01:13:41,219 --> 01:13:43,080
그래서 당신은 그것이

1960
01:13:43,080 --> 01:13:44,940
당신이 처음에 하려고 시도한 것이 아닐 수도

1961
01:13:44,940 --> 01:13:47,520


1962
01:13:47,520 --> 01:13:48,540
있지만 음, 그래서 모델이 그들이 가지고 있는

1963
01:13:48,540 --> 01:13:52,020
것과 같은 방식으로 미분할 수 있는 한 본질적으로 당신을

1964
01:13:52,020 --> 01:13:54,000


1965
01:13:54,000 --> 01:13:55,140
방해하는 것은 아무것도 없습니다.  심층 신경망

1966
01:13:55,140 --> 01:13:56,219


1967
01:13:56,219 --> 01:13:57,659


1968
01:13:57,659 --> 01:13:58,980


1969
01:13:58,980 --> 01:14:01,940
세계의 규칙이 어떻게 작동

1970
01:14:02,640 --> 01:14:04,199


1971
01:14:04,199 --> 01:14:06,900
하는지 모르는 환경에

1972
01:14:06,900 --> 01:14:10,620


1973
01:14:10,620 --> 01:14:13,080
그냥 던지는

1974
01:14:13,080 --> 01:14:15,239
것을 막을 수 있는 것은 없습니다.  밖에서

1975
01:14:15,239 --> 01:14:16,020


1976
01:14:16,020 --> 01:14:18,900
는 작동하거나 작동하지

1977
01:14:18,900 --> 01:14:21,600
않을 것입니다. 실패하면 실패하고

1978
01:14:21,600 --> 01:14:23,940
계산 환경은 우리

1979
01:14:23,940 --> 01:14:25,860
가 이러한 종류의 회색 지대에 존재할

1980
01:14:25,860 --> 01:14:28,260
수 있도록

1981
01:14:28,260 --> 01:14:30,719


1982
01:14:30,719 --> 01:14:33,300
합니다.

1983
01:14:33,300 --> 01:14:35,880
여전히 실행되지만 물론 우리는

1984
01:14:35,880 --> 01:14:38,300
컴퓨터 프로그램이 실행

1985
01:14:38,300 --> 01:14:42,120
되고 에이전트가 어떤 종류

1986
01:14:42,120 --> 01:14:43,100
의

1987
01:14:43,100 --> 01:14:47,520
의미 있거나 심지어 유용한 행동을

1988
01:14:47,520 --> 01:14:49,860
우리와 똑같은 이벤트로 발생시킬 수 있는 경우에 관심이 있습니다.

1989
01:14:49,860 --> 01:14:52,620


1990
01:14:52,620 --> 01:14:54,420


1991
01:14:54,420 --> 01:14:56,340
두 개의 숨겨진 상태가 있는 멍청한 모델

1992
01:14:56,340 --> 01:14:57,960


1993
01:14:57,960 --> 01:14:59,580
과 같이 일부

1994
01:14:59,580 --> 01:15:02,340
작업에서 끔찍한 일을 할 수 있는 매우 단순한 Prime DP 모델

1995
01:15:02,340 --> 01:15:05,520
을 상상할 수 있습니까?  10개

1996
01:15:05,520 --> 01:15:07,679
주식 포트폴리오와 마찬가지로 모델

1997
01:15:07,679 --> 01:15:10,739
은 적합하지 않지만

1998
01:15:10,739 --> 01:15:13,800


1999
01:15:13,800 --> 01:15:15,780
Prime DP 에이전트의 다른 끝에 큰 심층 함수 근사자를 적용한다는 약속은

2000
01:15:15,780 --> 01:15:18,179


2001
01:15:18,179 --> 01:15:20,760
좋은 생성 모델을 학습한 다음

2002
01:15:20,760 --> 01:15:22,739
여전히 더 낮은 모델과 결합할 수 있음을 의미합니다.

2003
01:15:22,739 --> 01:15:24,719


2004
01:15:24,719 --> 01:15:26,400


2005
01:15:26,400 --> 01:15:28,380
능동적 추론으로 모든 좋은 추론과 계획을 할

2006
01:15:28,380 --> 01:15:31,320
수 있는 차원 생성 모델 위로 올라가지만 심층 신경망을 사용하여 고차원 또는 보기 흉

2007
01:15:31,320 --> 01:15:33,420
하고 길들이기 힘든 관찰 및 행동

2008
01:15:33,420 --> 01:15:36,360
공간을 처리

2009
01:15:36,360 --> 01:15:39,000
할 수

2010
01:15:39,000 --> 01:15:40,800
있습니다.  딥 러닝

2011
01:15:40,800 --> 01:15:42,659
이 많은 경우에 작동하게 된

2012
01:15:42,659 --> 01:15:45,120
것과 같은 방식입니다. 이것은 주요

2013
01:15:45,120 --> 01:15:48,120
DP 모델과

2014
01:15:48,120 --> 01:15:50,940
Daphne의 모든 발언을 사용하여 수행하는 방법입니다.  또는 채팅에서 몇 가지 물어볼게

2015
01:15:50,940 --> 01:15:53,719


2016
01:15:54,540 --> 01:15:55,920
음 정말 질문이 없지만

2017
01:15:55,920 --> 01:15:57,960


2018
01:15:57,960 --> 01:16:00,000
정말 흥미롭고 생각하는 것이 정말 흥미 진진

2019
01:16:00,000 --> 01:16:02,040
하다고 생각합니다. 네 말씀하신대로

2020
01:16:02,040 --> 01:16:06,300
생성 모델을 배우는 것과 같습니다.

2021
01:16:06,300 --> 01:16:07,800
에이전트는 실제 데이터와 같은 자체 생성 모델을 학습하여

2022
01:16:07,800 --> 01:16:10,560


2023
01:16:10,560 --> 01:16:12,480
그것들이 무엇인지 파악

2024
01:16:12,480 --> 01:16:14,040


2025
01:16:14,040 --> 01:16:15,600
하고 함수

2026
01:16:15,600 --> 01:16:18,480
근사치 및 numpyro와

2027
01:16:18,480 --> 01:16:22,140
같은 것에 대해 이야기 한 것과 같은 점에서 여전히 당신과 같은 것 같습니다.

2028
01:16:22,140 --> 01:16:24,239
여전히 그 코드 기반에서처럼 작동

2029
01:16:24,239 --> 01:16:27,360
하고 마지막으로 변환

2030
01:16:27,360 --> 01:16:29,100
하거나 처음부터 시작했습니다.

2031
01:16:29,100 --> 01:16:31,320
예, 우리는 거의 처음부터 pi DCM을 시작했습니다.

2032
01:16:31,320 --> 01:16:33,659


2033
01:16:33,659 --> 01:16:35,400
실제로 IP 상태가 어떤지 잘 모르겠습니다.

2034
01:16:35,400 --> 01:16:37,260
우리가 일했기 때문입니다.

2035
01:16:37,260 --> 01:16:39,060
중첩 광산의 일부로 그것에

2036
01:16:39,060 --> 01:16:40,500
더 이상 해당 코드에 액세스할 수

2037
01:16:40,500 --> 01:16:43,260
없지만 그것은

2038
01:16:43,260 --> 01:16:46,739
우리가 작업한 변형 LaPlace와 같은 구현에 더 가깝습니다.

2039
01:16:46,739 --> 01:16:48,900


2040
01:16:48,900 --> 01:16:51,960
y 우리가 지금 하고 있는 것을 추론하려고 할 때

2041
01:16:51,960 --> 01:16:54,060
자유 에너지에 대한 경사 하강법을 수행

2042
01:16:54,060 --> 01:16:56,460


2043
01:16:56,460 --> 01:16:59,640
한다는 것은 그 대신에

2044
01:16:59,640 --> 01:17:02,400
소나무 DP 모델을 재작성하여

2045
01:17:02,400 --> 01:17:03,600


2046
01:17:03,600 --> 01:17:06,600
그라디언트를 통과할 수 있도록 할 수 있다는 것입니다.

2047
01:17:06,600 --> 01:17:09,420
그래디언트

2048
01:17:09,420 --> 01:17:11,400
를 사용한 다음 numpyro를 사용하여 변형 LaPlace뿐만 아니라 모든 종류의 피팅 루틴을 수행

2049
01:17:11,400 --> 01:17:13,020


2050
01:17:13,020 --> 01:17:16,080
할 수 있지만 numpower처럼 사용할 수 있는 mcmc를

2051
01:17:16,080 --> 01:17:18,540
사용할 수 있습니다.

2052
01:17:18,540 --> 01:17:21,440
다양한 어

2053
01:17:21,440 --> 01:17:24,179
확률적 근사 베이지안

2054
01:17:24,179 --> 01:17:25,679
추론 기술의 방대한 라이브러리가 있으므로 부엌 싱크대를 던질 수 있습니다.

2055
01:17:25,679 --> 01:17:28,380


2056
01:17:28,380 --> 01:17:31,800
프라임 DP 모델에서 numpyro 추론 기술

2057
01:17:31,800 --> 01:17:34,080
의 문제

2058
01:17:34,080 --> 01:17:36,239
는 프라임 DP 모델을 다시 작성하는 것이므로

2059
01:17:36,239 --> 01:17:38,280


2060
01:17:38,280 --> 01:17:40,440
Palm DP 매개변수와 같은

2061
01:17:40,440 --> 01:17:42,420
관찰에서 이 경우

2062
01:17:42,420 --> 01:17:45,300
에이전트의 작업이 되는 우도 함수와 같이 정의할 수 있습니다.

2063
01:17:45,300 --> 01:17:47,040


2064
01:17:47,040 --> 01:17:48,780
Jax와 친근하게 플레이할 수 있도록 하기 위해 소나무 DP 에이전트

2065
01:17:48,780 --> 01:17:51,300
의 모든 내부 기능이 추론과 같은지 확인해야 했습니다.

2066
01:17:51,300 --> 01:17:53,340


2067
01:17:53,340 --> 01:17:55,679
계획 작업 선택은

2068
01:17:55,679 --> 01:17:58,199
모두 Jacks로 작성되었으므로

2069
01:17:58,199 --> 01:18:00,000


2070
01:18:00,000 --> 01:18:03,199
우도 그래디언트와 같이 효과적으로

2071
01:18:03,199 --> 01:18:05,699
계산할 때 그래디언트를 통과할 수 있습니다. 예, 그것은 많은 의미가 있습니다. 예,

2072
01:18:05,699 --> 01:18:07,380


2073
01:18:07,380 --> 01:18:09,900
좋습니다. 라이브 채팅에서 몇 가지 질문을

2074
01:18:09,900 --> 01:18:13,140
할 것이므로 먼저

2075
01:18:13,140 --> 01:18:15,360
가장  문헌 전반에 걸친 활성 추론에 대한 설명

2076
01:18:15,360 --> 01:18:17,100


2077
01:18:17,100 --> 01:18:19,380
은 행렬의 관점에서 작성되지만 Pi mdp

2078
01:18:19,380 --> 01:18:20,880
는 텐서와 명확하게 작동

2079
01:18:20,880 --> 01:18:23,340


2080
01:18:23,340 --> 01:18:24,960


2081
01:18:24,960 --> 01:18:27,120
합니다. 방정식을 행렬

2082
01:18:27,120 --> 01:18:28,940
에서 텐서

2083
01:18:28,940 --> 01:18:31,260
로 일반화할 때 작업이 어떻게 다른지에 대한 좋은 참고 자료가 있습니까? 정말 좋은 지적입니다.

2084
01:18:31,260 --> 01:18:32,100
음 이것은 다음 중 하나입니다.  능동적 추론에 대해 처음 배울

2085
01:18:32,100 --> 01:18:33,840
때 실제로 저를 많이 실망시킨

2086
01:18:33,840 --> 01:18:35,159


2087
01:18:35,159 --> 01:18:37,340
것은 이 사람이 질문한 것을 정확히 알아차렸습니다

2088
01:18:37,340 --> 01:18:40,260
. 많은 기본

2089
01:18:40,260 --> 01:18:42,000
작업

2090
01:18:42,000 --> 01:18:42,540


2091
01:18:42,540 --> 01:18:45,960
이 마치 1

2092
01:18:45,960 --> 01:18:47,520
차원 숨겨진 상태와 1

2093
01:18:47,520 --> 01:18:50,580
차원 관찰만 있는 것처럼 작성되어 모든

2094
01:18:50,580 --> 01:18:53,159
것이  매트릭스 벡터 제품

2095
01:18:53,159 --> 01:18:54,840
과 매트릭스 수학이라고 하지만 우리가 실제로

2096
01:18:54,840 --> 01:18:57,239
하고 있는 것은 텐서 곱셈과

2097
01:18:57,239 --> 01:19:00,239
텐서 곱은 그것이

2098
01:19:00,239 --> 01:19:03,060
어떻게 작동하는지에 대한 참조의 관점에서 볼

2099
01:19:03,060 --> 01:19:05,940
때 음, 그렇습니다. 본질적으로

2100
01:19:05,940 --> 01:19:07,800
질적으로 매우 다른 것은 없습니다

2101
01:19:07,800 --> 01:19:10,260


2102
01:19:10,260 --> 01:19:12,600
. 파이오네 P에서 우리가 수행하는 이러한 텐서 연산은 기본적으로 행렬 곱셈의 합

2103
01:19:12,600 --> 01:19:15,600
을 표현하는 더 멋진 방법

2104
01:19:15,600 --> 01:19:17,880


2105
01:19:17,880 --> 01:19:20,280
이므로 수학이 있습니다.  여전히 모든

2106
01:19:20,280 --> 01:19:22,380
표준 선형 대수학은 텐서가 더 효율적인

2107
01:19:22,380 --> 01:19:24,060
표현이기 때문에 우리가 이러한 고차원

2108
01:19:24,060 --> 01:19:25,920
행렬을 나타내는 방식일 뿐입니다.

2109
01:19:25,920 --> 01:19:27,120
그래서

2110
01:19:27,120 --> 01:19:29,880
수학적으로 그것이

2111
01:19:29,880 --> 01:19:32,340
어떻게 작동하는지에 대해 배운 방식

2112
01:19:32,340 --> 01:19:34,800
은 Matlab에서 함수를 1년 동안 쳐다보는 것이었습니다.

2113
01:19:34,800 --> 01:19:37,260
방금

2114
01:19:37,260 --> 01:19:38,820
알아 냈지만 쉽지 않았고

2115
01:19:38,820 --> 01:19:41,580
지금 확실히 더 나은 옵션

2116
01:19:41,580 --> 01:19:42,900
이 있습니다

2117
01:19:42,900 --> 01:19:45,600
음 그래서 음 내가 추천 할 방망이에서 하나의 참조

2118
01:19:45,600 --> 01:19:48,719
는 음 Pi mdp의 부록 부록

2119
01:19:48,719 --> 01:19:50,460
입니다

2120
01:19:50,460 --> 01:19:52,920
uh the paper the archive paper

2121
01:19:52,920 --> 01:19:55,739
so that like that  나는 부록 a

2122
01:19:55,739 --> 01:19:57,960
또는 모든 부록에서 기본적으로 행렬을

2123
01:19:57,960 --> 01:20:01,199
다루지 않고 전체 텐서 분해 버전을 다룬다고 생각합니다.

2124
01:20:01,199 --> 01:20:03,179


2125
01:20:03,179 --> 01:20:05,100
우리는 실제로 더 높은 차원으로 인덱싱하고 있습니다.

2126
01:20:05,100 --> 01:20:09,120
제 생각에

2127
01:20:09,120 --> 01:20:11,460
음은 원래 텐서

2128
01:20:11,460 --> 01:20:13,860
제품에 대해 논의했고 텐서 인수 분해

2129
01:20:13,860 --> 01:20:16,500
는 부록에 있습니다. 능동적

2130
01:20:16,500 --> 01:20:18,540
추론 호기심과 통찰력

2131
01:20:18,540 --> 01:20:19,679


2132
01:20:19,679 --> 01:20:21,719


2133
01:20:21,719 --> 01:20:23,820
이라고 생각합니다.  종이

2134
01:20:23,820 --> 01:20:25,199
음 죄송합니다. 나온 연도가 기억나지 않습니다.

2135
01:20:25,199 --> 01:20:27,900
2017년인지 2018년

2136
01:20:27,900 --> 01:20:30,420
인지 모르지만 논문 제목이 능동적

2137
01:20:30,420 --> 01:20:32,340
추론 호기심과 통찰력이라는 것을 알고

2138
01:20:32,340 --> 01:20:34,440
있으며 부록 중 하나에서 그들은

2139
01:20:34,440 --> 01:20:38,580
실제로 전체 텐서 기반 수학을 수행하고

2140
01:20:38,580 --> 01:20:41,820
마지막으로 또 다른 좋은 참조는 teofio Champion이

2141
01:20:41,820 --> 01:20:44,640
이끄는 최근 논문입니다.

2142
01:20:44,640 --> 01:20:48,780


2143
01:20:48,780 --> 01:20:50,760
저는 이것을 잊고 싶지 않기 때문에 정말 빨리 찾으려고

2144
01:20:50,760 --> 01:20:52,739


2145
01:20:52,739 --> 01:20:55,679
노력할 것입니다. 화면 공유를

2146
01:20:55,679 --> 01:20:58,800
중지하겠습니다.  그것은 멈췄습니다

2147
01:20:58,800 --> 01:20:59,580
음

2148
01:20:59,580 --> 01:21:01,080


2149
01:21:01,080 --> 01:21:02,760


2150
01:21:02,760 --> 01:21:04,500


2151
01:21:04,500 --> 01:21:07,920


2152
01:21:07,920 --> 01:21:11,600
특히 활성 추론을 위해 텐서 수학을 수행하는 것에 대한 부록이 있는 정말 좋은 참조입니다. 특히

2153
01:21:13,260 --> 01:21:15,600
우리는 분기 시간 활성 추론에 대해서도 최근에 배웠습니다

2154
01:21:15,600 --> 01:21:18,360
w  hich

2155
01:21:18,360 --> 01:21:20,040
는 계산 복잡성에 대한 몇 가지 질문에 대해 말하고 있습니다. 네, 능동적 추론의

2156
01:21:20,040 --> 01:21:24,480
계산 복잡성

2157
01:21:26,219 --> 01:21:27,840
을 미세 조정하는

2158
01:21:27,840 --> 01:21:29,699


2159
01:21:29,699 --> 01:21:31,380


2160
01:21:31,380 --> 01:21:33,960
것에 대해 현재까지 가장 유망한 접근 방식이라고 언급해야 했습니다.

2161
01:21:33,960 --> 01:21:37,080


2162
01:21:37,080 --> 01:21:38,820


2163
01:21:38,820 --> 01:21:41,400
그래서 이것은

2164
01:21:41,400 --> 01:21:44,580
teofio의 것입니다.  Champions Mark gresh 나는

2165
01:21:44,580 --> 01:21:46,440
그의 조언자 중 한 명이고 Howard

2166
01:21:46,440 --> 01:21:49,560
Bowman 그의 다른 조언자이며 방금 게시

2167
01:21:49,560 --> 01:21:51,600
한 multimodal and multi-factor

2168
01:21:51,600 --> 01:21:53,400
branching time active inference라고 합니다.

2169
01:21:53,400 --> 01:21:55,620


2170
01:21:55,620 --> 01:21:57,000


2171
01:21:57,000 --> 01:21:59,040
Alec Chance가 부록이 기술에 정말 좋다고 말한 것 같아요.

2172
01:21:59,040 --> 01:22:01,920


2173
01:22:01,920 --> 01:22:03,780


2174
01:22:03,780 --> 01:22:05,940
능동적 추론의

2175
01:22:05,940 --> 01:22:08,699
전체 텐서 일반화 좋습니다. 좋습니다

2176
01:22:08,699 --> 01:22:09,540


2177
01:22:09,540 --> 01:22:12,239
. YouTube 실시간 채팅에 언급된 음 인용문을 모두 추가했습니다.

2178
01:22:12,239 --> 01:22:13,920


2179
01:22:13,920 --> 01:22:16,500
감사합니다. 묻겠습니다.

2180
01:22:16,500 --> 01:22:19,560


2181
01:22:19,560 --> 01:22:22,739
Jax 백엔드를 사용하는 Fausto의 다음 질문을 사용하면 pymc3를 쉽게 래핑할 수

2182
01:22:22,739 --> 01:22:24,020


2183
01:22:24,020 --> 01:22:28,800
있습니다. EG

2184
01:22:28,800 --> 01:22:32,219
는 pi MC3 모델에서 사용할 연산자로 pi mdp를 사용하도록 MC3를 적용

2185
01:22:32,219 --> 01:22:35,580
합니다.  Pi MC3 주변에 Python에 Bayesian 커뮤니티가 성장하고 있기 때문에 이것을 할 계획이 있습니까

2186
01:22:35,580 --> 01:22:37,320


2187
01:22:37,320 --> 01:22:41,880


2188
01:22:41,880 --> 01:22:43,380
? 음 정말 흥미 롭습니다.

2189
01:22:43,380 --> 01:22:46,199
실제로 Prime G3

2190
01:22:46,199 --> 01:22:48,719
에도 Jacks가 다시

2191
01:22:48,719 --> 01:22:51,600
있다는 것을 몰랐습니다. 그래서 음 잘 모르겠습니다.  솔직히 말해서

2192
01:22:51,600 --> 01:22:52,980


2193
01:22:52,980 --> 01:22:55,080


2194
01:22:55,080 --> 01:22:57,840
파이썬에서 확률적 모델링과 같은 것을 소개

2195
01:22:57,840 --> 01:23:00,300
한 것이

2196
01:23:00,300 --> 01:23:02,880
기본적으로 numpyro numpyro에서 나를 팔았던 DME Dimitri markovic을 통해서였기 때문에 잘 모르겠다는 말로 시작하겠습니다. numpyro

2197
01:23:02,880 --> 01:23:04,920
는 미래의 방식이고 numpyro

2198
01:23:04,920 --> 01:23:06,840
에는  Jack의 백 엔드와 저는

2199
01:23:06,840 --> 01:23:10,440
numpyro와 Pi MC3가 Python

2200
01:23:10,440 --> 01:23:13,199
의 확률적 추론 생태계에서 비슷한 위치를 차지한다고 생각합니다.

2201
01:23:13,199 --> 01:23:16,020


2202
01:23:16,020 --> 01:23:18,300
음

2203
01:23:18,300 --> 01:23:22,020
pi MC3에서 모델이

2204
01:23:22,020 --> 01:23:24,300
어떻게 지정되는지 모르겠습니다. numpyro에서 보이는 방식

2205
01:23:24,300 --> 01:23:26,520
과 크게 다르지 않다고 가정합니다.  모든 하위 수준 백엔드

2206
01:23:26,520 --> 01:23:29,880
는 이제 Jax로 작성되었습니다. 약속할 수는

2207
01:23:29,880 --> 01:23:31,860
없지만 pi MC3 모델을 작성할 수 있다고 가정합니다.

2208
01:23:31,860 --> 01:23:34,140


2209
01:23:34,140 --> 01:23:36,480


2210
01:23:36,480 --> 01:23:40,500


2211
01:23:40,500 --> 01:23:43,620
파이 MVP 구현  따라서

2212
01:23:43,620 --> 01:23:46,020
Pine Z3가 낮은 수준의 Jax에만 의존

2213
01:23:46,020 --> 01:23:48,600
한다면 확실히 작동할 수

2214
01:23:48,600 --> 01:23:50,699
있지만 음 저는

2215
01:23:50,699 --> 01:23:53,040
여기에 pine G3를 사용해 본 경험

2216
01:23:53,040 --> 01:23:55,320
이 있고 제가 충분히 알지 못하기 때문에 알 수도 있는 다른 사람이 있는지 모르겠습니다.

2217
01:23:55,320 --> 01:23:56,820


2218
01:23:56,820 --> 01:23:58,560
그것은

2219
01:23:58,560 --> 01:24:01,320
YMC를 조금 사용했지만 numpyro

2220
01:24:01,320 --> 01:24:03,239
와 매우 유사하다고 말했듯이 예

2221
01:24:03,239 --> 01:24:05,400
와 같다고 생각합니다. 아마도 pyro에서 통합하는 것과 같이 numpirers

2222
01:24:05,400 --> 01:24:07,560
를 사용하여

2223
01:24:07,560 --> 01:24:10,080
수행하는 것과 동일한 작업을 수행할 수 있을 것이라고 생각합니다.

2224
01:24:10,080 --> 01:24:12,480


2225
01:24:12,480 --> 01:24:15,540
파이 MC3도

2226
01:24:15,540 --> 01:24:18,360
아 멋지고 그래서 기본 음

2227
01:24:18,360 --> 01:24:19,800
백엔드는 Jax

2228
01:24:19,800 --> 01:24:21,239
는

2229
01:24:21,239 --> 01:24:25,099
음 내가 실제로

2230
01:24:25,620 --> 01:24:28,460
그렇게 하지 않았다는 것입니다.

2231
01:24:28,460 --> 01:24:31,980


2232
01:24:31,980 --> 01:24:35,219


2233
01:24:35,219 --> 01:24:37,380


2234
01:24:37,380 --> 01:24:40,980
프로그래밍 방향과

2235
01:24:40,980 --> 01:24:42,780


2236
01:24:42,780 --> 01:24:44,820
우리가 명명한 이러한 모든 패키지 및 접근 방식은

2237
01:24:44,820 --> 01:24:48,179
확률적 프로그래밍

2238
01:24:48,179 --> 01:24:51,420
이 행렬을 작성

2239
01:24:51,420 --> 01:24:54,000
하고 종이에 계산하는 것과 어떻게 다른지 그리고 능동적 추론 모델

2240
01:24:54,000 --> 01:24:56,880
을 구현하기 위한 약속이 있는 이유는 무엇입니까?

2241
01:24:56,880 --> 01:24:59,400


2242
01:24:59,400 --> 01:25:01,880
k

2243
01:25:01,880 --> 01:25:03,780
확률론적

2244
01:25:03,780 --> 01:25:05,940
프로그래밍의 가장 큰 장점은 매트릭스 곱셈이 충분한지 확인

2245
01:25:05,940 --> 01:25:08,400
하기 위해 활성 추론 에이전트를 시뮬레이션하기 위해

2246
01:25:08,400 --> 01:25:10,020
활성 추론 에이전트를 시뮬레이션하는

2247
01:25:10,020 --> 01:25:12,659


2248
01:25:12,659 --> 01:25:15,840
데 반드시 필요한 것은 아닙니다. Jax에

2249
01:25:15,840 --> 01:25:18,480
있으면 훨씬 더 확장 가능하므로

2250
01:25:18,480 --> 01:25:21,120
모든 벡터화된 작업을

2251
01:25:21,120 --> 01:25:22,980
수십

2252
01:25:22,980 --> 01:25:24,600


2253
01:25:24,600 --> 01:25:25,620


2254
01:25:25,620 --> 01:25:28,440
고도로 최적화된 JIT(적시 컴파일)

2255
01:25:28,440 --> 01:25:30,840
기능과

2256
01:25:30,840 --> 01:25:32,280
기본적으로 속도를 크게 높일 수

2257
01:25:32,280 --> 01:25:34,860
있는 잭이 있기 때문에 수천 개의 활성 추론 에이전트를 동시에 사용할 수 있지만 확률적

2258
01:25:34,860 --> 01:25:36,540
프로그래밍 각도는

2259
01:25:36,540 --> 01:25:39,060
활성 추론 프로세스를 시뮬레이션하는 데 그다지 적합하지 않습니다.

2260
01:25:39,060 --> 01:25:41,100
그것은 경험적 데이터에 대한 활성 추론 에이전트의 추론 또는 피팅 모델을 수행하기 위한 것입니다. 예를

2261
01:25:41,100 --> 01:25:43,620


2262
01:25:43,620 --> 01:25:46,860
들어

2263
01:25:46,860 --> 01:25:49,460
동물이나 사람이

2264
01:25:49,460 --> 01:25:53,040
지금 우리가 할 수 있는 일을 관찰하는 것입니다. 우리

2265
01:25:53,040 --> 01:25:55,440
는 SPM만 할 수 있지만 아직까지는 Pine VP에서는 할 수 없습니다.

2266
01:25:55,440 --> 01:25:58,080
우리는

2267
01:25:58,080 --> 01:25:59,460
누군가의 행동 시퀀스

2268
01:25:59,460 --> 01:26:02,699
를 취한 다음

2269
01:26:02,699 --> 01:26:04,260
활성 추론 모델의 최상의 매개변수를 추론할 수

2270
01:26:04,260 --> 01:26:06,239
있습니다.

2271
01:26:06,239 --> 01:26:08,100
누군가가 어떻게 결정했는지에 따라 그들의 행동을 설명합니다. 오

2272
01:26:08,100 --> 01:26:10,199
그들의 매트릭스는 이렇게 생겼어야 합니다. 또는

2273
01:26:10,199 --> 01:26:12,780
그들의 C 벡터는 누군가의 위험 민감도를

2274
01:26:12,780 --> 01:26:14,880
추론할 수 있는 것처럼 그것에 대해 이 음 정밀도를 가져야 합니다.

2275
01:26:14,880 --> 01:26:18,420


2276
01:26:18,420 --> 01:26:21,239


2277
01:26:21,239 --> 01:26:22,500


2278
01:26:22,500 --> 01:26:24,060
확률적 프로그래밍 언어에 관한

2279
01:26:24,060 --> 01:26:26,520


2280
01:26:26,520 --> 01:26:29,159


2281
01:26:29,159 --> 01:26:30,719


2282
01:26:30,719 --> 01:26:31,860
것은 Matlab 문헌에 활성 추론 모델을 맞추기 위해 실제로 잘 탐구되지 않은 다양한 방법이 너무 많다는 것입니다. 거의

2283
01:26:31,860 --> 01:26:34,679
모든 사람들

2284
01:26:34,679 --> 01:26:36,420
이 기본적으로

2285
01:26:36,420 --> 01:26:38,940
자유 에너지를 최소화하고 가우시안 근사를 사용하는 이 음 변형 Bayes 접근 방식을 사용하기 때문입니다.

2286
01:26:38,940 --> 01:26:40,800
사후의 경우

2287
01:26:40,800 --> 01:26:42,480
매우 특정한

2288
01:26:42,480 --> 01:26:45,060
유형의 변이 추론

2289
01:26:45,060 --> 01:26:48,480
이므로 numpyro 또는 아마도 Pi mt3에 다시

2290
01:26:48,480 --> 01:26:50,520
있습니다. 곧 완전히

2291
01:26:50,520 --> 01:26:52,560
구현되지는 않지만 서로 다른 장점을 가진

2292
01:26:52,560 --> 01:26:54,480
모든 종류의 확률

2293
01:26:54,480 --> 01:26:55,620
추론 기술을 던질 수 있습니다.

2294
01:26:55,620 --> 01:26:57,780
그리고

2295
01:26:57,780 --> 01:27:00,300
확률론적 추론에서 큰 것과 같은 단점

2296
01:27:00,300 --> 01:27:04,620
은 um mcmc Monte C  알로 마르코프

2297
01:27:04,620 --> 01:27:06,540
연쇄 몬테카를로 추론 대략적인 기본 및 추론에 대한 변형 접근 방식에 비해

2298
01:27:06,540 --> 01:27:09,840
mcmc를 사용하는 이점이 있는 것과 같이 덜 편향된 어 어 후방 분포를 제공

2299
01:27:09,840 --> 01:27:11,280


2300
01:27:11,280 --> 01:27:13,500


2301
01:27:13,500 --> 01:27:16,260


2302
01:27:16,260 --> 01:27:18,360
해야 합니다.

2303
01:27:18,360 --> 01:27:19,739


2304
01:27:19,739 --> 01:27:21,780


2305
01:27:21,780 --> 01:27:23,280
전산 정신의학 커뮤니티의 사람들

2306
01:27:23,280 --> 01:27:25,320
은 불만을 토로했고 그들이

2307
01:27:25,320 --> 01:27:27,120
보고 싶은 것은

2308
01:27:27,120 --> 01:27:30,440


2309
01:27:30,440 --> 01:27:33,840
Pi mdp 매개변수 또는 Palm DP 매개변수를 추론하기 위한 변이 일수

2310
01:27:33,840 --> 01:27:37,199
와 mcmc 접근 방식을 나란히 비교하는 것과 같다고 말했습니다

2311
01:27:37,199 --> 01:27:38,520
.  하나 또는 둘 또는 세

2312
01:27:38,520 --> 01:27:40,139


2313
01:27:40,139 --> 01:27:42,360


2314
01:27:42,360 --> 01:27:44,159
개의 추론 기술만 구현

2315
01:27:44,159 --> 01:27:46,020


2316
01:27:46,020 --> 01:27:47,400
되는 언어에 의해 제한

2317
01:27:47,400 --> 01:27:49,460


2318
01:27:49,460 --> 01:27:52,139


2319
01:27:52,139 --> 01:27:53,639
되어 기본적으로 이점을 누리는 것입니다.

2320
01:27:53,639 --> 01:27:55,340
사람들이 numpyro에서 작업한 모든 작업 중

2321
01:27:55,340 --> 01:27:57,780


2322
01:27:57,780 --> 01:27:59,880
이러한 모든 종류의 어 추론 방법을 구현하기 위해 수행한 작업

2323
01:27:59,880 --> 01:28:01,440
ods

2324
01:28:01,440 --> 01:28:04,440
예 굉장하고 fausta는 YMC의 기본 백엔드를 따라갔습니다.

2325
01:28:04,440 --> 01:28:05,960


2326
01:28:05,960 --> 01:28:11,040
하지만 새

2327
01:28:11,040 --> 01:28:13,620
버전은 Jax를 사용할 수 있습니다.

2328
01:28:13,620 --> 01:28:16,139


2329
01:28:16,139 --> 01:28:18,420
Pi mdp의 Jax 버전이 안정되면 pi MC3 래퍼를 작성할

2330
01:28:18,420 --> 01:28:19,739
수

2331
01:28:19,739 --> 01:28:21,659
있습니다.

2332
01:28:21,659 --> 01:28:23,639
가능하다고

2333
01:28:23,639 --> 01:28:26,880
생각하고 여유가 있다면

2334
01:28:26,880 --> 01:28:28,860
자유 에너지를 최소화하세요.

2335
01:28:28,860 --> 01:28:30,719
그러면 그렇게 할 때 놀라지 않을 것

2336
01:28:30,719 --> 01:28:31,980


2337
01:28:31,980 --> 01:28:34,260
입니다. 정말 훌륭합니다.

2338
01:28:34,260 --> 01:28:35,940
좋은 약속이군요.

2339
01:28:35,940 --> 01:28:38,760
음 Jacob이나 Daphne 또는 지금 당장 다른 질문을 할 수 있습니다.

2340
01:28:38,760 --> 01:28:41,120


2341
01:28:43,560 --> 01:28:45,600


2342
01:28:45,600 --> 01:28:47,460


2343
01:28:47,460 --> 01:28:51,780
Pi MGP의 맥락에서 메시지 전달을 여러 번 언급하셨는데요.

2344
01:28:51,780 --> 01:28:55,080
메시지 전달이란 무엇

2345
01:28:55,080 --> 01:28:58,820
이며 pi mdp에서 어떻게 사용되었습니까?

2346
01:28:58,820 --> 01:29:02,040
좋은 질문입니다. 따라서

2347
01:29:02,040 --> 01:29:04,199
일반적으로 메시지 전달은

2348
01:29:04,199 --> 01:29:07,860


2349
01:29:07,860 --> 01:29:11,219
정확한  또는 대략적인 베이지안 추론

2350
01:29:11,219 --> 01:29:13,679
음 숨겨진 상태에 대한 베이지안 추론을 수행하는 맥락에서 매우 구체적으로 만들기 위해 매우 자주 사용

2351
01:29:13,679 --> 01:29:15,420


2352
01:29:15,420 --> 01:29:17,340


2353
01:29:17,340 --> 01:29:19,860
되므로

2354
01:29:19,860 --> 01:29:21,179
활성 추론 에이전트가 수행해야

2355
01:29:21,179 --> 01:29:22,920
할 작업  어떤 관찰에 직면했을

2356
01:29:22,920 --> 01:29:25,800
때 그들은

2357
01:29:25,800 --> 01:29:28,500
하나의 메시지

2358
01:29:28,500 --> 01:29:30,900
가 감각 정보에

2359
01:29:30,900 --> 01:29:32,340
해당하고 다른 메시지

2360
01:29:32,340 --> 01:29:34,320
가 세상에 대한 이전 믿음에 해당하는 것처럼 메시지를 결합해야 할 것입니다. 그들은 현재에 대한 믿음을 최적화

2361
01:29:34,320 --> 01:29:36,440
하기 위해 이러한 메시지를 결합하는 알고리즘을 사용

2362
01:29:36,440 --> 01:29:39,179
합니다.

2363
01:29:39,179 --> 01:29:42,120
세계의 숨겨진 상태이므로 pione P에서

2364
01:29:42,120 --> 01:29:43,679
우리는

2365
01:29:43,679 --> 01:29:45,600


2366
01:29:45,600 --> 01:29:48,420
순진하거나

2367
01:29:48,420 --> 01:29:50,460
평범한 고정 소수점 반복이라고 부르는

2368
01:29:50,460 --> 01:29:52,920
것을 수행하는 매우 순진한 종류의 계산 효율적인 수행 방법을 가지고

2369
01:29:52,920 --> 01:29:54,420
있습니다.

2370
01:29:54,420 --> 01:29:56,580


2371
01:29:56,580 --> 01:29:58,860
과거의 사전 정보를 사용하여 숨겨진 상태를 적극적으로 필터링하므로

2372
01:29:58,860 --> 01:30:01,380
마지막 시간 단계

2373
01:30:01,380 --> 01:30:03,780
에서 내가 어디에 있었는지 이제 B 매트릭스가 제공되어야 하는지 말한

2374
01:30:03,780 --> 01:30:06,060
다음 기본적으로 관찰인 들어오는 감각 메시지

2375
01:30:06,060 --> 01:30:08,300
와 결합했습니다.

2376
01:30:08,300 --> 01:30:10,739


2377
01:30:10,739 --> 01:30:13,020


2378
01:30:13,020 --> 01:30:15,239
우도 행렬 a 행렬을 통과한 다음

2379
01:30:15,239 --> 01:30:16,440
이 두 메시지를 함께 결합하면

2380
01:30:16,440 --> 01:30:19,080
그 결과가 내

2381
01:30:19,080 --> 01:30:21,540
사후 분포가 됩니다.  가장 단순한 형태의 메시지 전달과 같은

2382
01:30:21,540 --> 01:30:24,000
숨겨진 상태에 대한 내 사후 또는 최선의

2383
01:30:24,000 --> 01:30:25,679


2384
01:30:25,679 --> 01:30:27,840
믿음은 매우 일시적으로

2385
01:30:27,840 --> 01:30:28,920
얕은

2386
01:30:28,920 --> 01:30:31,920
현재 증거와

2387
01:30:31,920 --> 01:30:33,600
새로운 믿음을 형성하기 전에 결합

2388
01:30:33,600 --> 01:30:35,639


2389
01:30:35,639 --> 01:30:37,620
되어 최고의 사후가

2390
01:30:37,620 --> 01:30:40,739
우도와 사전의 산물

2391
01:30:40,739 --> 01:30:41,520
음

2392
01:30:41,520 --> 01:30:43,139
, 믿음 자체가 더 복잡

2393
01:30:43,139 --> 01:30:45,480
할 때 사용되는 고급 메시지 전달 기술도

2394
01:30:45,480 --> 01:30:46,980


2395
01:30:46,980 --> 01:30:48,480
있으므로

2396
01:30:48,480 --> 01:30:49,980


2397
01:30:49,980 --> 01:30:52,199
Matlab 버전 에이전트에 있는 능동적

2398
01:30:52,199 --> 01:30:53,820
추론의 전체 구현에서

2399
01:30:53,820 --> 01:30:56,179
현재 은닉 상태는 미래의 모든 은닉 상태와 과거의 모든 은닉 상태에 대한 완전한

2400
01:30:56,179 --> 01:31:00,239
예측 및 사후 규제 유형의

2401
01:31:00,239 --> 01:31:03,000
um 텐서 또는 믿음의 입방체를 가지고

2402
01:31:03,000 --> 01:31:04,860


2403
01:31:04,860 --> 01:31:07,020


2404
01:31:07,020 --> 01:31:09,179


2405
01:31:09,179 --> 01:31:11,219
있다는 것입니다. 내가 잠재적으로 취하거나 가질 수 있는 모든 정책에 대한 추가 조건입니다.

2406
01:31:11,219 --> 01:31:12,960
과거에 촬영되었으므로

2407
01:31:12,960 --> 01:31:15,900


2408
01:31:15,900 --> 01:31:17,940
미래와 과거의 숨겨진 상태로 확장되는 믿음

2409
01:31:17,940 --> 01:31:21,060
텐서와 같은 거대한 것을 갖게 됩니다.  r 정책에 의해 분해되고 업데이트가

2410
01:31:21,060 --> 01:31:22,800
필요하다는 믿음이 있을

2411
01:31:22,800 --> 01:31:24,600
때 더 정교한 메시지 전달 기술을 사용해야 합니다. 그

2412
01:31:24,600 --> 01:31:26,580


2413
01:31:26,580 --> 01:31:28,920
중 하나는 한계

2414
01:31:28,920 --> 01:31:30,659
메시지 전달이라고 합니다.

2415
01:31:30,659 --> 01:31:32,880
변형 메시지 전달이라는 것이 있으며

2416
01:31:32,880 --> 01:31:34,199
이러한 모든 다른 메시지 전달

2417
01:31:34,199 --> 01:31:35,760
기술은 단지

2418
01:31:35,760 --> 01:31:37,800
메시지를 앞뒤로 전달하는 데 본질적으로 일관성이

2419
01:31:37,800 --> 01:31:40,320
있을 뿐만 아니라 숨겨진 상태

2420
01:31:40,320 --> 01:31:42,600
를 특징짓는 다양한 변수에 걸쳐서

2421
01:31:42,600 --> 01:31:44,159
Hidden State

2422
01:31:44,159 --> 01:31:45,500
요인

2423
01:31:45,500 --> 01:31:48,060
과 메시지 전달 알고리즘

2424
01:31:48,060 --> 01:31:49,739
은 기본적으로 여전히

2425
01:31:49,739 --> 01:31:52,380
감각 정보

2426
01:31:52,380 --> 01:31:55,199
를 이전 신념과 결합하는 데 상당하지만 그들은 단지

2427
01:31:55,199 --> 01:31:57,360
일종의

2428
01:31:57,360 --> 01:31:59,280


2429
01:31:59,280 --> 01:32:02,400
과거에 미래에 대한 믿음의 공간을 통해 더 복잡한 궤적을 나보다

2430
01:32:02,400 --> 01:32:03,960
훨씬 더 잘 설명할 수 있는 사람들이 있습니다

2431
01:32:03,960 --> 01:32:05,940
. 저는 pi mdp에서 이들 중 일부를 구현

2432
01:32:05,940 --> 01:32:09,179
했지만 사람들에게 정말 좋은 음 종이가 있다고 추천할 것입니다.

2433
01:32:09,179 --> 01:32:12,060


2434
01:32:12,060 --> 01:32:14,280
저번에 리트윗 하셨을

2435
01:32:14,280 --> 01:32:16,440
것 같은데 제이콥에 관한 내용입니다.

2436
01:32:16,440 --> 01:32:16,980


2437
01:32:16,980 --> 01:32:19,620
n 필드

2438
01:32:19,620 --> 01:32:21,719
오 예

2439
01:32:21,719 --> 01:32:24,360
음 평균 필드를 비교하는 논문과

2440
01:32:24,360 --> 01:32:27,179


2441
01:32:27,179 --> 01:32:28,679


2442
01:32:28,679 --> 01:32:30,719
평균 필드 Bethy 및

2443
01:32:30,719 --> 01:32:32,400
한계 근사

2444
01:32:32,400 --> 01:32:36,960
par Markovich kibel 및 friston 2019를 사용하여 근사 및 최상의 공기 근사 신경 메시지 전달을 비교

2445
01:32:36,960 --> 01:32:38,820
하는 논문입니다.

2446
01:32:38,820 --> 01:32:42,179


2447
01:32:42,179 --> 01:32:44,340


2448
01:32:44,340 --> 01:32:46,380
서로 다른 근사치에서 서로 다른 자유 에너지 기능이 어떻게

2449
01:32:46,380 --> 01:32:50,340
다르게 보이는지 그리고

2450
01:32:50,340 --> 01:32:54,420


2451
01:32:54,420 --> 01:32:57,800


2452
01:32:57,800 --> 01:33:03,020
2011년에서 2019년 사이의 많은 논문이 현재 Pi와 같은 패키지 및 개발 방향이라고 가정해 봅시다.

2453
01:33:03,020 --> 01:33:06,360


2454
01:33:06,360 --> 01:33:08,400
mdp

2455
01:33:08,400 --> 01:33:09,690
는

2456
01:33:09,690 --> 01:33:11,880
[음악]

2457
01:33:11,880 --> 01:33:16,139
이러한 방법을 실제로 사용하도록 촉진하고 있으며

2458
01:33:16,139 --> 01:33:18,600


2459
01:33:18,600 --> 01:33:22,560
개념적 가능성이 엄청나게 풍부합니다. 휴리스틱을 제안하고

2460
01:33:22,560 --> 01:33:27,560


2461
01:33:27,840 --> 01:33:32,880
다른 종류의 연결과 관련된 흥미로운 사용 사례를 제안했습니다.

2462
01:33:32,880 --> 01:33:33,480
음

2463
01:33:33,480 --> 01:33:36,000
,

2464
01:33:36,000 --> 01:33:40,139
이전에 언급했듯이 이러한

2465
01:33:40,139 --> 01:33:43,440
종류의 연결을  라스트 마일

2466
01:33:43,440 --> 01:33:46,340
, 그리고

2467
01:33:46,340 --> 01:33:50,480
특히 더 세분화되거나 모듈화된

2468
01:33:50,480 --> 01:33:52,440
개발

2469
01:33:52,440 --> 01:33:54,960
은

2470
01:33:54,960 --> 01:33:58,800
Under the Umbrella of t였습니다.

2471
01:33:58,800 --> 01:34:00,840


2472
01:34:00,840 --> 01:34:02,400


2473
01:34:02,400 --> 01:34:04,080


2474
01:34:04,080 --> 01:34:07,739
진정한 분산형 개방형 과학 또는

2475
01:34:07,739 --> 01:34:10,080
분산형 과학 방식

2476
01:34:10,080 --> 01:34:12,060
으로 의미 있게 공유되는 것을 막는 SPM vbx 때문에 당연히 우리는 Prime DP와

2477
01:34:12,060 --> 01:34:14,580
함께 작업하고 구축

2478
01:34:14,580 --> 01:34:17,460
하고 이에 대해 더 많이 알게 되어 매우 기뻤습니다

2479
01:34:17,460 --> 01:34:20,280
.

2480
01:34:20,280 --> 01:34:23,639
능동적 추론 에이전트의 구성 가능성

2481
01:34:23,639 --> 01:34:26,219
과 대규모 분산 방식

2482
01:34:26,219 --> 01:34:28,380
으로 작업할 수 있는 다양한 구현

2483
01:34:28,380 --> 01:34:30,840
누군가가

2484
01:34:30,840 --> 01:34:33,000
정말 흥미로운 행렬을

2485
01:34:33,000 --> 01:34:34,860
지정할 수 있음 다른 누군가가

2486
01:34:34,860 --> 01:34:37,320
흥미로운 B를 지정할 수 있음 다른 누군가가

2487
01:34:37,320 --> 01:34:39,300
이들을 함께 연결  새로운 종류의

2488
01:34:39,300 --> 01:34:40,320
에이전트는

2489
01:34:40,320 --> 01:34:42,540
다른 사람이 다르게 구현할 수

2490
01:34:42,540 --> 01:34:46,139
있으므로

2491
01:34:46,139 --> 01:34:49,139


2492
01:34:49,139 --> 01:34:51,420


2493
01:34:51,420 --> 01:34:55,139
이전에는 거의

2494
01:34:55,139 --> 01:34:57,719


2495
01:34:57,719 --> 01:35:00,000
항상 완전히 Matlab

2496
01:35:00,000 --> 01:35:03,239
또는 맞춤식

2497
01:35:03,239 --> 01:35:06,179


2498
01:35:06,179 --> 01:35:09,300
이었고 주어진 논문에 매우 맞춤화되고 적합했던 이러한 알고리즘을 개발하는 프로세스를 자연스럽게 가져옵니다.

2499
01:35:09,300 --> 01:35:13,320


2500
01:35:13,320 --> 01:35:15,840


2501
01:35:15,840 --> 01:35:18,360
현대적인 특히 파이썬 설정에 사용하려는 관련 축을 따라 반드시 적응할 필요는 없습니다.

2502
01:35:18,360 --> 01:35:22,260


2503
01:35:22,260 --> 01:35:24,480
완전히 더 동의할 수 있습니다.

2504
01:35:24,480 --> 01:35:25,800


2505
01:35:25,800 --> 01:35:28,500
그게 생각하는 좋은 방법이라는 뜻은 다른 패키지의 생태계에 존재하는 모듈식 유연한 코드를 만들고 있는 것과 같습니다.

2506
01:35:28,500 --> 01:35:30,600


2507
01:35:30,600 --> 01:35:33,260
본질적으로

2508
01:35:33,260 --> 01:35:35,580
당면한 작업의 집합적 마음

2509
01:35:35,580 --> 01:35:38,760
표현을 분해

2510
01:35:38,760 --> 01:35:40,679
하거나 다른 것입니다.  해당 표현의 일부는

2511
01:35:40,679 --> 01:35:42,420


2512
01:35:42,420 --> 01:35:45,840
메시지를 전달하거나 분산 작업자

2513
01:35:45,840 --> 01:35:47,520
의 전체 네트워크에서 진행되는 작업을 고려하지 않고도 작업할

2514
01:35:47,520 --> 01:35:50,159


2515
01:35:50,159 --> 01:35:52,739
수 있으므로 누군가가

2516
01:35:52,739 --> 01:35:54,239
더 나은 메시지 전달 알고리즘을 알고 있는 자신의 메시지를 작성한

2517
01:35:54,239 --> 01:35:56,520
다음 함께 사용할 수 있도록 슬롯에 넣을 수

2518
01:35:56,520 --> 01:35:59,219
있습니다.  파이 MVP

2519
01:35:59,219 --> 01:36:01,320
는 프라임 DP의 모든 작은 측면이 어떻게

2520
01:36:01,320 --> 01:36:04,320
작동하는지 알 필요가 없습니다. 그래서 예, 그것은

2521
01:36:04,320 --> 01:36:06,239
정말 중요합니다. 제 생각

2522
01:36:06,239 --> 01:36:08,820
에는 열린 과학과 모듈식 소프트웨어

2523
01:36:08,820 --> 01:36:10,940
개발

2524
01:36:10,940 --> 01:36:14,639
에 관한 것이 코스 마감 시간에 훌륭하다고 생각합니다.

2525
01:36:14,639 --> 01:36:17,940
물론 Jacob이나 Daphne은 어떤 발언이나

2526
01:36:17,940 --> 01:36:23,219
질문도 할 수 있습니다.  또한 애피타이저 어떤

2527
01:36:23,219 --> 01:36:26,540
종류의 모델에 대해 사람들이 열광

2528
01:36:26,540 --> 01:36:31,020
하는지 또는 다음 라이브 스트림에서 볼 수 있는 의미는 무엇입니까?

2529
01:36:31,020 --> 01:36:33,900


2530
01:36:33,900 --> 01:36:36,360
2023년 1월

2531
01:36:36,360 --> 01:36:39,920
모델 스트림 7.2

2532
01:36:41,699 --> 01:36:43,320
음 저는

2533
01:36:43,320 --> 01:36:45,719
노트북이 정말 정말 유용하다고 생각

2534
01:36:45,719 --> 01:36:48,420
하므로 기본 IMDb에서 무슨 일이 일어나고

2535
01:36:48,420 --> 01:36:50,100


2536
01:36:50,100 --> 01:36:52,020
있는지 이해하고 구축하고 모델링하려는 사람들에게 정말 훌륭한 리소스

2537
01:36:52,020 --> 01:36:53,580


2538
01:36:53,580 --> 01:36:56,460
라고 말하고 싶습니다.  A 및 B 행렬

2539
01:36:56,460 --> 01:36:58,980


2540
01:36:58,980 --> 01:37:01,139


2541
01:37:01,139 --> 01:37:02,360


2542
01:37:02,360 --> 01:37:05,340
의 지속 시간 매개변수 학습에 대해 이야기하는 노트북에 대한 확장 기능을 갖는 것이

2543
01:37:05,340 --> 01:37:08,100
정말 멋질 것이라고 생각합니다. 정말 멋질 것이라고 생각합니다.

2544
01:37:08,100 --> 01:37:11,659


2545
01:37:13,320 --> 01:37:15,360
Connor가 이야기하고 싶었던 부분이 정말 감사합니다.

2546
01:37:15,360 --> 01:37:17,219


2547
01:37:17,219 --> 01:37:19,020
예 감사합니다.  그것은

2548
01:37:19,020 --> 01:37:20,100
정말 좋은 지적입니다.

2549
01:37:20,100 --> 01:37:22,199
이것은 Daniel

2550
01:37:22,199 --> 01:37:24,000
이 이메일의 앞부분에서

2551
01:37:24,000 --> 01:37:26,639
A와 B를 업데이트하는 것이

2552
01:37:26,639 --> 01:37:28,199
지금 문서화

2553
01:37:28,199 --> 01:37:30,840
되지 않은 것과 같다고 말한 것입니다.

2554
01:37:30,840 --> 01:37:32,639


2555
01:37:32,639 --> 01:37:33,960
아직

2556
01:37:33,960 --> 01:37:36,239


2557
01:37:36,239 --> 01:37:37,679


2558
01:37:37,679 --> 01:37:39,300
고정된 수의 행과 열을 가지고

2559
01:37:39,300 --> 01:37:41,460
있으므로 몇 가지 가정을 하지만 이는 가장

2560
01:37:41,460 --> 01:37:42,960
유연한 방법과 같습니다.  에이전트는

2561
01:37:42,960 --> 01:37:45,239
스스로 b와 a 행렬을 학습하고

2562
01:37:45,239 --> 01:37:46,679
있으므로

2563
01:37:46,679 --> 01:37:48,540
음 그래 우리는 확실히 아마도

2564
01:37:48,540 --> 01:37:50,280
실제로 I가 될

2565
01:37:50,280 --> 01:37:52,260
수 있을

2566
01:37:52,260 --> 01:37:54,719


2567
01:37:54,719 --> 01:37:57,300
것입니다. 이것을 보여

2568
01:37:57,300 --> 01:37:59,639
주려고 계획했던 노트북에 추가할 수 있습니다.

2569
01:37:59,639 --> 01:38:01,920
일부 A 또는 B에서 그것에 대해 배우고 그것이

2570
01:38:01,920 --> 01:38:03,780
어떻게 작동하는지 보여줍니다

2571
01:38:03,780 --> 01:38:06,120
음 저는

2572
01:38:06,120 --> 01:38:08,360


2573
01:38:08,460 --> 01:38:12,600
결국 교과서

2574
01:38:12,600 --> 01:38:15,659
와 모든

2575
01:38:15,659 --> 01:38:19,679
논문에 대해 그 멋진 것을 사용하는 새로운 노트북을 만들 것입니다.

2576
01:38:19,679 --> 01:38:21,239


2577
01:38:21,239 --> 01:38:24,719


2578
01:38:24,719 --> 01:38:27,900
서로 다른

2579
01:38:27,900 --> 01:38:30,780
자연어 표현이

2580
01:38:30,780 --> 01:38:34,260
있기 때문입니다. 왜냐하면 그것들은 모두 공식적으로 어 공식적으로

2581
01:38:34,260 --> 01:38:37,080
연결되어 있고 모두 그렇게 렌더링될 수 있기 때문입니다. 그러면

2582
01:38:37,080 --> 01:38:40,080


2583
01:38:40,080 --> 01:38:42,239


2584
01:38:42,239 --> 01:38:45,900
모델의 접근성과 엄격함이 증가하고 서로 다른 도메인

2585
01:38:45,900 --> 01:38:48,719
을 구성하고 연결하는 데 도움이 될 것입니다.

2586
01:38:48,719 --> 01:38:51,060
환영하고

2587
01:38:51,060 --> 01:38:52,679
다양한 종류의

2588
01:38:52,679 --> 01:38:55,760
학습 및 모델링을 인식하고

2589
01:38:56,040 --> 01:38:57,840


2590
01:38:57,840 --> 01:38:59,580
모든

2591
01:38:59,580 --> 01:39:02,540
생각이나 질문을 절대적으로 jakov

2592
01:39:02,760 --> 01:39:05,880
음 이 시점에서 질문은 없지만 어

2593
01:39:05,880 --> 01:39:09,060
또한 그냥  멋진 프리젠테이션을 위해 많은 노력을 기울였습니다.

2594
01:39:09,060 --> 01:39:11,699
저는

2595
01:39:11,699 --> 01:39:14,820
모든 새로운

2596
01:39:14,820 --> 01:39:16,920
um

2597
01:39:16,920 --> 01:39:19,739
통합과 사용 사례에 대해 정말 기대하고 있습니다.

2598
01:39:19,739 --> 01:39:22,679
의심할 여지없이

2599
01:39:22,679 --> 01:39:26,159


2600
01:39:26,159 --> 01:39:30,300
생겨날 것입니다.

2601
01:39:30,300 --> 01:39:33,360
확장 가능한 능동적

2602
01:39:33,360 --> 01:39:36,659
추론 모델에 사용될 수 있으며 저는

2603
01:39:36,659 --> 01:39:40,199


2604
01:39:40,199 --> 01:39:41,540


2605
01:39:41,540 --> 01:39:44,420
primevp가 음 이러한 다양한

2606
01:39:44,420 --> 01:39:49,219
통합과 어떻게 상호 운용되는지 정말 기대됩니다.

2607
01:39:50,580 --> 01:39:54,320


2608
01:39:56,159 --> 01:39:58,940


2609
01:39:58,980 --> 01:40:03,239
Connor에게 감사합니다.

2610
01:40:03,239 --> 01:40:05,820


2611
01:40:05,820 --> 01:40:09,060
당신은 내가 다음에

2612
01:40:09,060 --> 01:40:11,699
우리가 겪을 수 있는 뼈대를 보여줄 수 있다고 말했습니다.

2613
01:40:11,699 --> 01:40:14,340
아 좋아 좋아 우리는 그것을 볼 수 있습니다

2614
01:40:14,340 --> 01:40:16,860
음 예 그것은 좋아

2615
01:40:16,860 --> 01:40:18,480
보입니다 멋져요

2616
01:40:18,480 --> 01:40:20,760
그래서

2617
01:40:20,760 --> 01:40:22,920
예 기본적으로 이것은 공동 작업 노트북

2618
01:40:22,920 --> 01:40:26,280
이므로 누구에게나 가도록 권장합니다

2619
01:40:26,280 --> 01:40:28,380
um Pine DP 튜토리얼 웹사이트와

2620
01:40:28,380 --> 01:40:30,179
Daphne과 같은 각 노트북

2621
01:40:30,179 --> 01:40:32,699
은 그들이 I'm 꽤 유용

2622
01:40:32,699 --> 01:40:34,860
하고 그들과 관련된 공동 작업 링크가 있다고 말했고

2623
01:40:34,860 --> 01:40:36,239


2624
01:40:36,239 --> 01:40:38,040
링크를 열 수 있습니다.

2625
01:40:38,040 --> 01:40:41,520
이것은 에이전트 API의 일부라고 생각

2626
01:40:41,520 --> 01:40:43,139


2627
01:40:43,139 --> 01:40:46,500
합니다. 네, 최근 전산 정신의학 과정에서 이것을 보여드린 것을 제외하고는 동일합니다.

2628
01:40:46,500 --> 01:40:48,060


2629
01:40:48,060 --> 01:40:49,679
그래서

2630
01:40:49,679 --> 01:40:51,060
조금 업데이트하여

2631
01:40:51,060 --> 01:40:53,340


2632
01:40:53,340 --> 01:40:55,980
음 다니엘과 공유할 수 있습니다. 그러면 당신은 할 수 있습니다.

2633
01:40:55,980 --> 01:40:58,080
Discord에 올리거나

2634
01:40:58,080 --> 01:40:59,460
조금 더 업데이트된

2635
01:40:59,460 --> 01:41:01,739
곳이면 여기에서

2636
01:41:01,739 --> 01:41:03,900
액세스할 수 있는 기본 항목은 여전히

2637
01:41:03,900 --> 01:41:04,980
동일한 내용을 표시

2638
01:41:04,980 --> 01:41:07,560
하지만 음 어쨌든

2639
01:41:07,560 --> 01:41:09,179
공동 작업을 열면 Google 계정이 필요합니다.

2640
01:41:09,179 --> 01:41:12,060
이것이 이것을 사용하는 데 한 가지 제한 사항입니다.

2641
01:41:12,060 --> 01:41:14,820
음 로컬 인프라에 적극적으로 설치할 수 있습니다.

2642
01:41:14,820 --> 01:41:17,219
Dash piondp

2643
01:41:17,219 --> 01:41:19,980
uh import numpy matplotlib

2644
01:41:19,980 --> 01:41:22,080
여기에 몇 가지 가져오기가 있습니다. 그리고 이 모든

2645
01:41:22,080 --> 01:41:23,880
것이 이 노트북의 정신은

2646
01:41:23,880 --> 01:41:25,380
본질적으로

2647
01:41:25,380 --> 01:41:27,480
생성 모델을 설정하는 모든 단계를 거치는 것입니다.

2648
01:41:27,480 --> 01:41:29,820


2649
01:41:29,820 --> 01:41:31,020
우리가 실제로 이야기하지 않은 숨겨진 상태 요소를 생성

2650
01:41:31,020 --> 01:41:33,360


2651
01:41:33,360 --> 01:41:35,460
하는 것은 Pi mdp의 맥락에서 분해된 표현이며

2652
01:41:35,460 --> 01:41:36,480


2653
01:41:36,480 --> 01:41:40,139
B 배열을 구축하는

2654
01:41:40,139 --> 01:41:41,940


2655
01:41:41,940 --> 01:41:43,679
것입니다.  스스로 할 수

2656
01:41:43,679 --> 01:41:45,060
있지만 이러한 각 항목에 대한 솔루션이 있는 숨겨진 셀도 있습니다.

2657
01:41:45,060 --> 01:41:47,580


2658
01:41:47,580 --> 01:41:49,139


2659
01:41:49,139 --> 01:41:51,119
능동적 추론을 실행하기 전에 이 노트북의 주요 정면은 단지

2660
01:41:51,119 --> 01:41:52,800
단계별로 진행하고 실제로

2661
01:41:52,800 --> 01:41:54,480


2662
01:41:54,480 --> 01:41:58,320
음 a b c 및 d 배열의 항목을 초기화하는

2663
01:41:58,320 --> 01:42:00,659
것입니다.  몇 가지 슬라이드가

2664
01:42:00,659 --> 01:42:02,040
이와 함께 이동하여 기본적으로

2665
01:42:02,040 --> 01:42:03,840
슬라이드와 실제 코드 사이를 이동할 수 있습니다

2666
01:42:03,840 --> 01:42:06,360


2667
01:42:06,360 --> 01:42:08,699
. 어레이와 동일합니다. 따라서

2668
01:42:08,699 --> 01:42:11,520


2669
01:42:11,520 --> 01:42:13,440
원하는 매트릭스의 모습을 표현한 다음

2670
01:42:13,440 --> 01:42:15,119
코드로 이동하여  실제로 빌드

2671
01:42:15,119 --> 01:42:17,460


2672
01:42:17,460 --> 01:42:19,020
하고 생성 모델의 각 구성 요소에 대해 순차적으로 수행합니다.

2673
01:42:19,020 --> 01:42:20,820


2674
01:42:20,820 --> 01:42:21,540
음

2675
01:42:21,540 --> 01:42:23,460
, 빌드한 후 어떻게 보이는지 볼 수 있도록 그 과정에서 구성 요소를 플로팅합니다.

2676
01:42:23,460 --> 01:42:25,920


2677
01:42:25,920 --> 01:42:29,280
그런 다음 실제로

2678
01:42:29,280 --> 01:42:31,560
어 우리는 실제로 구현합니다.

2679
01:42:31,560 --> 01:42:32,699
일반 모델을 구축한 후

2680
01:42:32,699 --> 01:42:34,080
실제로 활성

2681
01:42:34,080 --> 01:42:35,340
추론 에이전트에 연결

2682
01:42:35,340 --> 01:42:38,280
하므로 이것이 첫 번째 작업은

2683
01:42:38,280 --> 01:42:41,580
일반에 대해 분해된 a와 b를 구축하는

2684
01:42:41,580 --> 01:42:43,440
것입니다.  더

2685
01:42:43,440 --> 01:42:45,239
정교한 그리드 세계 그러나 우리는

2686
01:42:45,239 --> 01:42:47,100
실제로 그것은 입문 작업의 일종입니다.

2687
01:42:47,100 --> 01:42:48,600
그런 다음 우리는 기본적으로 팀원과 같은

2688
01:42:48,600 --> 01:42:50,940
이

2689
01:42:50,940 --> 01:42:53,219
인식적인 두 팔 밴드 작업을 위해 실제로 A, B 및 C

2690
01:42:53,219 --> 01:42:55,560


2691
01:42:55,560 --> 01:42:56,460


2692
01:42:56,460 --> 01:43:00,300
를 빌드합니다.  a 행렬

2693
01:43:00,300 --> 01:43:02,520
의 모든 작은 하위 행렬에 쓰고 있다는 것을 알고 있습니다.

2694
01:43:02,520 --> 01:43:04,679


2695
01:43:04,679 --> 01:43:06,420
그래서 내가 말했듯이 셀이 너무 많은 이유

2696
01:43:06,420 --> 01:43:07,739
는 그것이 실제로 구성하는 가장 긴 부분과 같습니다.

2697
01:43:07,739 --> 01:43:09,950


2698
01:43:09,950 --> 01:43:10,500
[음악]

2699
01:43:10,500 --> 01:43:11,100


2700
01:43:11,100 --> 01:43:13,619
음 C 벡터는 기본적으로 보상

2701
01:43:13,619 --> 01:43:15,300
함수입니다.  Daphne이

2702
01:43:15,300 --> 01:43:16,800
이전에 실제로

2703
01:43:16,800 --> 01:43:20,100
상대 로그 확률의 관점에서 인코딩

2704
01:43:20,100 --> 01:43:23,040
하고 있다고 말한 다음 마지막으로 기본적으로 프레젠테이션

2705
01:43:23,040 --> 01:43:25,320
중에 논의한 단계를 수행

2706
01:43:25,320 --> 01:43:27,980
합니다.

2707
01:43:27,980 --> 01:43:30,360
공들여 생성한 모든 A와 B

2708
01:43:30,360 --> 01:43:32,639
를 에이전트 클래스에 너무 힘들게 연결하지 않기를

2709
01:43:32,639 --> 01:43:35,340
바랍니다.  에이전트의 행동과 일이 주어진 세계가 어떻게 작동하는지에 대한 규칙인 두 개의 무장한

2710
01:43:35,340 --> 01:43:37,980
도적을 암적에게 무장하는

2711
01:43:37,980 --> 01:43:39,840
환경을 생성합니다.

2712
01:43:39,840 --> 01:43:42,719


2713
01:43:42,719 --> 01:43:45,360
ko 당신은 실제로

2714
01:43:45,360 --> 01:43:48,480
이 활성 추론 루프를 실행합니다.

2715
01:43:48,480 --> 01:43:51,900
이것은 우리가

2716
01:43:51,900 --> 01:43:53,639
시간이 지남에 따라 루프를 효과적으로 실행하여 숨겨진 상태

2717
01:43:53,639 --> 01:43:55,739
영향 정책 추론 작업

2718
01:43:55,739 --> 01:43:58,440
샘플링을 수행한 다음

2719
01:43:58,440 --> 01:44:00,480
새로운 관찰을 얻기 위해 환경을 스테핑

2720
01:44:00,480 --> 01:44:02,159
한 다음 마지막에 다음

2721
01:44:02,159 --> 01:44:03,659
과 같이 작성했습니다.

2722
01:44:03,659 --> 01:44:05,699
기본적으로 선택과 신념의 역사를 플롯할 수 있는 도우미 기능

2723
01:44:05,699 --> 01:44:07,440


2724
01:44:07,440 --> 01:44:09,300
음 그래서 맨 끝에

2725
01:44:09,300 --> 01:44:11,280
이것은 더 재미있는 실험적인 부분

2726
01:44:11,280 --> 01:44:14,280
과 같습니다.

2727
01:44:14,280 --> 01:44:16,739
어 환경의 매개변수와 에이전트 모델의 매개변수를 망칠 수 있는

2728
01:44:16,739 --> 01:44:18,420


2729
01:44:18,420 --> 01:44:20,760
다음 시작합니다.

2730
01:44:20,760 --> 01:44:22,260


2731
01:44:22,260 --> 01:44:24,000
반복적으로 실행되는

2732
01:44:24,000 --> 01:44:25,380
능동적 추론 시뮬레이션을 통해 행동이 어떻게 변화하는지 확인

2733
01:44:25,380 --> 01:44:28,020
하고 결과적인 선택 행동

2734
01:44:28,020 --> 01:44:29,699
과 믿음의 역사를 플로팅

2735
01:44:29,699 --> 01:44:31,320
하여 일반적으로 약간의

2736
01:44:31,320 --> 01:44:33,480
미리보기

2737
01:44:33,480 --> 01:44:35,040
가 됩니다.

2738
01:44:35,040 --> 01:44:36,780
여기서 우리는 실제로 에이전트

2739
01:44:36,780 --> 01:44:38,460
가 a 또는 B 매트릭스에 대한 신념을 업데이트하도록 하고

2740
01:44:38,460 --> 01:44:42,500
있습니다.

2741
01:44:42,900 --> 01:44:46,260
그리고 SPM 교과서의

2742
01:44:46,260 --> 01:44:49,500
마지막 SPM

2743
01:44:49,500 --> 01:44:52,800
메모와 실험

2744
01:44:52,800 --> 01:44:54,840
에는 때때로 100명의 참가자에 대한 여러 실험 요소

2745
01:44:54,840 --> 01:44:59,159
처럼 요약되는 놀라운 그레이스케일 매트릭스가 있습니다.

2746
01:44:59,159 --> 01:45:02,699


2747
01:45:02,699 --> 01:45:06,900
어

2748
01:45:06,900 --> 01:45:09,360


2749
01:45:09,360 --> 01:45:13,500
, 흑백

2750
01:45:13,500 --> 01:45:18,300
또는 그레이스케일 매트릭스 표현으로 어떻게 표시되는지 보는 것은 정말 흥미로울 것입니다.

2751
01:45:18,300 --> 01:45:22,800
그리고

2752
01:45:22,800 --> 01:45:25,739
그것이 우리가 논의한 이러한 주제 중 일부에 대한 시각적 느낌을 제공하는 방법

2753
01:45:25,739 --> 01:45:27,960
과

2754
01:45:27,960 --> 01:45:30,600
물론 표현은

2755
01:45:30,600 --> 01:45:33,420
매트릭스와 공식적으로 연결되어 있지만

2756
01:45:33,420 --> 01:45:36,060
때로는 두 가지

2757
01:45:36,060 --> 01:45:37,800
옵션이 있고 세계에는 10개의 상태가

2758
01:45:37,800 --> 01:45:40,560
있으며 가능성이 보인다고 말하는 경우가 있습니다.

2759
01:45:40,560 --> 01:45:42,119


2760
01:45:42,119 --> 01:45:45,300
숫자가 있는 스프레드시트

2761
01:45:45,300 --> 01:45:49,040
를 회색조

2762
01:45:49,040 --> 01:45:52,560
로 보는 것이 일종의 느낌

2763
01:45:52,560 --> 01:45:55,199
을 주고 정말 멋져 보이기 때문에

2764
01:45:55,199 --> 01:45:56,639


2765
01:45:56,639 --> 01:45:59,100
DOT 2를 위해 가질 멋진 세션처럼 보입니다.

2766
01:45:59,100 --> 01:46:01,260
네, 정말 흥미롭습니다.

2767
01:46:01,260 --> 01:46:03,360
그런 식

2768
01:46:03,360 --> 01:46:05,580
으로 내가 항상 해왔던 일이고

2769
01:46:05,580 --> 01:46:07,679


2770
01:46:07,679 --> 01:46:10,320
독서에서 그 모든 것을 배웠기 때문에 그것은 매우 중요하다고 생각합니다.  호스

2771
01:46:10,320 --> 01:46:13,619
능동적 추론과 SPM 논문

2772
01:46:13,619 --> 01:46:15,480
음 그래서 저는

2773
01:46:15,480 --> 01:46:18,659
그들에게서 시각화 기술을 아주 많이 빌

2774
01:46:18,659 --> 01:46:20,400
렸어요 음 그리고 저는 그것을 당연하게 여겼지만

2775
01:46:20,400 --> 01:46:22,139
네, 흥미롭습니다 그것은 확실히

2776
01:46:22,139 --> 01:46:24,600
갈 수 있는 유일한 방법은 아니지만 저는

2777
01:46:24,600 --> 01:46:25,980
항상 그것이 매우 직관적이라는 것을 알았습니다

2778
01:46:25,980 --> 01:46:28,560
확률을 생각하면

2779
01:46:28,560 --> 01:46:30,420
색상을 사용할 수 있습니다. 숫자가 너무 구체적이기 때문에 색상을 사용

2780
01:46:30,420 --> 01:46:32,580


2781
01:46:32,580 --> 01:46:34,199
합니다. 시각적 측면이 정말 좋아하는 회색조 색상

2782
01:46:34,199 --> 01:46:35,940
이 이것보다 가능성이 더 높다는 것을 보여줍니다.

2783
01:46:35,940 --> 01:46:37,860


2784
01:46:37,860 --> 01:46:40,080


2785
01:46:40,080 --> 01:46:42,860


2786
01:46:42,860 --> 01:46:46,020
이

2787
01:46:46,020 --> 01:46:48,179
멋진 세션

2788
01:46:48,179 --> 01:46:51,480
에 대해 정말 감사

2789
01:46:51,480 --> 01:46:54,000
하고 dot two를 위해 한 달 조금 더 후에 뵙겠습니다.

2790
01:46:54,000 --> 01:46:55,560
정말 감사합니다. Daniel과

2791
01:46:55,560 --> 01:46:57,060
모두 감사합니다. 모두 평화롭게 잘 지내세요.

2792
01:46:57,060 --> 01:46:58,260


2793
01:46:58,260 --> 01:47:01,820


