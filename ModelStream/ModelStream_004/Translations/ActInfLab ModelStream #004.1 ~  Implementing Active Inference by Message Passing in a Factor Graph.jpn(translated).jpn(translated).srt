1
00:00:00,080 --> 00:00:02,639
信号処理グループ

2
00:00:02,639 --> 00:00:04,400
なので

3
00:00:04,400 --> 00:00:05,680
、トレーニングを設計しました。

4
00:00:05,680 --> 00:00:08,080
申し訳ありませんが、実際に

5
00:00:08,080 --> 00:00:10,559
変更したのは1つだけです。再開して

6
00:00:10,559 --> 00:00:11,920


7
00:00:11,920 --> 00:00:12,960


8
00:00:12,960 --> 00:00:15,679


9
00:00:15,679 --> 00:00:18,320
いただけませんか。ご紹介いただきありがとうございます。私の名前は、バーティフライです。ア

10
00:00:18,320 --> 00:00:20,400
インドホーフェン工科大学のアインドホーフェン

11
00:00:20,400 --> 00:00:21,920
教授です。 オランダでは、

12
00:00:21,920 --> 00:00:23,840


13
00:00:23,840 --> 00:00:25,920
私は

14
00:00:25,920 --> 00:00:28,000


15
00:00:28,000 --> 00:00:30,480
信号処理グループの電気工学部門の一員になるので、

16
00:00:30,480 --> 00:00:33,600
信号処理アルゴリズムを設計しました。約

17
00:00:33,600 --> 00:00:36,320
67年前に

18
00:00:36,320 --> 00:00:38,399
、カール・フィストンの論文を初めて読みまし

19
00:00:38,399 --> 00:00:40,559


20
00:00:40,559 --> 00:00:41,760
た。

21
00:00:41,760 --> 00:00:44,160
頭脳と私はこれが信号処理にとって素晴らしいかもしれないと思った

22
00:00:44,160 --> 00:00:46,399
ので、

23
00:00:46,399 --> 00:00:49,039
それ以来、私は実際

24
00:00:49,039 --> 00:00:50,640
に私の研究室の人々と協力して、設計

25
00:00:50,640 --> 00:00:53,360
するエージェント

26
00:00:53,360 --> 00:00:56,559


27
00:00:56,559 --> 00:00:59,199
が信号処理アルゴリズムの設計プロセスを自動化することを実現しようとし

28
00:00:59,199 --> 00:01:01,120
ています。 メッセージ

29
00:01:01,120 --> 00:01:02,960
パッシングでこれを行い、今日はそれについて話したいと思い

30
00:01:02,960 --> 00:01:05,199
ます。

31
00:01:05,199 --> 00:01:06,799
ええと、

32
00:01:06,799 --> 00:01:10,400
ええと、私の名前はタイソンです。

33
00:01:10,400 --> 00:01:13,760
私は鳥の実験室のポスターです。私は博士号も

34
00:01:13,760 --> 00:01:15,280
積極的に推測しました。

35
00:01:15,280 --> 00:01:17,840
これらのプロセスを自動化する方法と

36
00:01:17,840 --> 00:01:20,080
、マイケル・コックスとラボのすべての同僚と一緒に、

37
00:01:20,080 --> 00:01:22,000
fornilabというツールボックスを

38
00:01:22,000 --> 00:01:24,400
作成

39
00:01:24,400 --> 00:01:27,600
しました。アクティブなインフラ会議のコンテキストでそれをどのように適用するかについて説明します。

40
00:01:27,600 --> 00:01:30,400


41
00:01:30,400 --> 00:01:32,560


42
00:01:32,560 --> 00:01:35,920
それでいくつかのクールなことをして、後で

43
00:01:37,439 --> 00:01:39,759
みんなこんにちは、私の名前はニトリ・

44
00:01:39,759 --> 00:01:42,640
バガフです私は大学の色相でもバイアスラボの博士課程の候補者です

45
00:01:42,640 --> 00:01:46,000


46
00:01:46,000 --> 00:01:48,000


47
00:01:48,000 --> 00:01:50,960


48
00:01:50,960 --> 00:01:52,960
アクティブな

49
00:01:52,960 --> 00:01:55,119
推論にも役立ちますが、それについては

50
00:01:55,119 --> 00:01:56,960
後で説明し

51
00:01:56,960 --> 00:01:57,920


52
00:01:57,920 --> 00:02:01,439
ますええ、私のスロットは

53
00:02:01,759 --> 00:02:04,640
クールですありがとうござい

54
00:02:05,119 --> 00:02:07,520


55
00:02:07,520 --> 00:02:10,160


56
00:02:10,160 --> 00:02:12,560


57
00:02:12,560 --> 00:02:14,000


58
00:02:14,000 --> 00:02:16,400


59
00:02:16,400 --> 00:02:18,640
ます。 スライドを共有できれば、

60
00:02:18,640 --> 00:02:20,000


61
00:02:20,000 --> 00:02:21,360


62
00:02:21,360 --> 00:02:23,040
うん、よさそうだね

63
00:02:23,040 --> 00:02:25,040


64
00:02:25,040 --> 00:02:25,840
。

65
00:02:25,840 --> 00:02:29,040
最初のスライドは、アムステルダムとの関係

66
00:02:29,040 --> 00:02:31,120
でどこにあるのか不思議に思うかもしれないので、最初のスライドは

67
00:02:31,120 --> 00:02:33,680


68
00:02:33,680 --> 00:02:34,560


69
00:02:34,560 --> 00:02:37,280
、アムステルダムの南約100km

70
00:02:37,280 --> 00:02:39,680
にある。 ベルギーの国境であり

71
00:02:39,680 --> 00:02:41,840
、ドイツからそれほど遠くない

72
00:02:41,840 --> 00:02:42,640


73
00:02:42,640 --> 00:02:44,959
ので、それは一種のハイテク都市

74
00:02:44,959 --> 00:02:46,080
フィリップスが

75
00:02:46,080 --> 00:02:48,400
始まり、右下に開い

76
00:02:48,400 --> 00:02:50,560
た中央の写真が表示さ

77
00:02:50,560 --> 00:02:53,599
れ、右上

78
00:02:53,599 --> 00:02:55,680
は私たちの

79
00:02:55,680 --> 00:02:57,519
大学のキャンパスのビューです テクノロジーの

80
00:02:57,519 --> 00:03:00,319


81
00:03:00,319 --> 00:03:02,840


82
00:03:02,840 --> 00:03:05,360


83
00:03:05,360 --> 00:03:07,760
概要は、5つを通過するグループの空中写真です。キャンパスの空中写真です。

84
00:03:07,760 --> 00:03:11,120
ここで、ポインターを共有できるかどうかを確認しましょう。

85
00:03:11,120 --> 00:03:13,440
ええと、これは電気工学の建物な

86
00:03:13,440 --> 00:03:14,959
ので、ここは

87
00:03:14,959 --> 00:03:16,239


88
00:03:16,239 --> 00:03:18,560
iosラボが短い場所です。 私たちが構築しようとし

89
00:03:18,560 --> 00:03:20,480
ているベイジアンインテリジェント自律システムの場合、

90
00:03:20,480 --> 00:03:22,959


91
00:03:22,959 --> 00:03:25,519
約3人

92
00:03:25,519 --> 00:03:28,000
のスタッフがいます。たとえば、教職員

93
00:03:28,000 --> 00:03:31,200
と現在6人のphd学生のドミトリー

94
00:03:31,200 --> 00:03:33,120
は、それらのPC学生の一人で

95
00:03:33,120 --> 00:03:35,519
あり、確率的プログラミングに興味のある人が見ている場合は、オープンポジションがあり

96
00:03:35,519 --> 00:03:37,760


97
00:03:37,760 --> 00:03:40,640
ます。 アクティブな推論を機能させる方法次に、

98
00:03:40,640 --> 00:03:43,200


99
00:03:43,200 --> 00:03:45,680
これを実行しようとしているのは、

100
00:03:45,680 --> 00:03:47,360
おそらく

101
00:03:47,360 --> 00:03:50,239
このuhフォーラムのすべての人に馴染みのある写真です。

102
00:03:50,239 --> 00:03:52,560


103
00:03:52,560 --> 00:03:53,840


104
00:03:53,840 --> 00:03:55,200
脳内で実際に起こっているのは

105
00:03:55,200 --> 00:03:57,680
、エネルギーの最小化または期待される自由

106
00:03:57,680 --> 00:03:59,120
エネルギーの最小化で

107
00:03:59,120 --> 00:04:00,560
すべて

108
00:04:00,560 --> 00:04:03,360


109
00:04:03,360 --> 00:04:05,599
を実行することだけです。これは、エンジニアにとって大きなインスピレーションです。

110
00:04:05,599 --> 00:04:08,159
基本的に、これを入れたいのです。

111
00:04:08,159 --> 00:04:10,879
iphoneまたはラズベリーパイ

112
00:04:10,879 --> 00:04:12,560
でロボットに

113
00:04:12,560 --> 00:04:14,560
自転車の乗り方を学ばせ

114
00:04:14,560 --> 00:04:16,798


115
00:04:16,798 --> 00:04:19,839
ますが、エンジニアリング目的のこのフレームワークの利点は

116
00:04:19,839 --> 00:04:22,479
、問題に対するほぼ1つの解決策である

117
00:04:22,479 --> 00:04:24,080
ため

118
00:04:24,080 --> 00:04:26,240
、それができればロボットに方法を教えることができることです。

119
00:04:26,240 --> 00:04:27,440


120
00:04:27,440 --> 00:04:30,400
エネルギー最小化を書くために、おそらく

121
00:04:30,400 --> 00:04:33,360
これを仮想現実に適用し、補聴器や自動運転車の設計アルゴリズムに適用することもできます。

122
00:04:33,360 --> 00:04:35,120


123
00:04:35,120 --> 00:04:38,160


124
00:04:38,240 --> 00:04:40,240


125
00:04:40,240 --> 00:04:41,280
たとえば

126
00:04:41,280 --> 00:04:43,360
、エンジニアリングの大きな約束や魅力

127
00:04:43,360 --> 00:04:45,840
は、それが

128
00:04:45,840 --> 00:04:48,240
常にあなたが持っているものと同じものであるということです。

129
00:04:48,240 --> 00:04:50,240
モデルを提案し、アプリケーションが何であれ、自由エネルギーを最小化する

130
00:04:50,240 --> 00:04:51,440


131
00:04:51,440 --> 00:04:53,520
ことは

132
00:04:53,520 --> 00:04:54,840
非常に

133
00:04:54,840 --> 00:04:56,400
魅力的ですが

134
00:04:56,400 --> 00:04:59,919
、エンジニアリングの問題は、この

135
00:04:59,919 --> 00:05:02,000
エネルギー

136
00:05:02,000 --> 00:05:04,560
汎関数が観測者の機能であるということです。  vationsと

137
00:05:04,560 --> 00:05:07,600
observationsはストリーミングデータであり、

138
00:05:07,600 --> 00:05:08,800


139
00:05:08,800 --> 00:05:10,560
通常は

140
00:05:10,560 --> 00:05:13,199
1ミリ秒ごとに発生する可能性があるため、時間

141
00:05:13,199 --> 00:05:14,880
変化する関数で

142
00:05:14,880 --> 00:05:17,360
あり、潜在変数の数は、

143
00:05:17,360 --> 00:05:19,919
潜在変数のスペース

144
00:05:19,919 --> 00:05:23,039
が通常非常に高いため、時間変化する非常に高

145
00:05:23,039 --> 00:05:24,639
次元の関数があり

146
00:05:24,639 --> 00:05:25,759
ます。

147
00:05:25,759 --> 00:05:27,120


148
00:05:27,120 --> 00:05:29,280
最小化したいのですが、脳

149
00:05:29,280 --> 00:05:31,360
は非常に優れています。脳

150
00:05:31,360 --> 00:05:34,880
は10の14

151
00:05:34,880 --> 00:05:38,720
シナプスの1000億ユーロの累乗です

152
00:05:38,720 --> 00:05:41,039
が、通常の

153
00:05:41,039 --> 00:05:43,120
最適化ライブラリとモデルアップまたは

154
00:05:43,120 --> 00:05:45,360
pythonはそれをカットしません。

155
00:05:45,360 --> 00:05:47,840
最小化することはできません。  matlabの1000変数の時変関数は機能し

156
00:05:47,840 --> 00:05:49,919


157
00:05:49,919 --> 00:05:51,759
ない

158
00:05:51,759 --> 00:05:55,520
ので、ここではかなり急進的なものが必要です。私たちが採用

159
00:05:55,520 --> 00:05:57,840
するアイデアは、それほど

160
00:05:57,840 --> 00:06:00,800
急進的ではありません。脳からインスピレーションを得

161
00:06:00,800 --> 00:06:03,520
て、脳

162
00:06:03,520 --> 00:06:07,039
はメッセージの受け渡しのネットワークであり、結果として得られます。

163
00:06:07,039 --> 00:06:09,360


164
00:06:09,360 --> 00:06:12,240
信号処理

165
00:06:12,240 --> 00:06:15,440
または情報理論の私自身の分野では、正確には

166
00:06:15,440 --> 00:06:17,840
これが形式化されています。

167
00:06:17,840 --> 00:06:18,880


168
00:06:18,880 --> 00:06:22,000
2001年に

169
00:06:22,000 --> 00:06:24,560
daveforneyによるグラフのコードに関する論文があります。 彼

170
00:06:24,560 --> 00:06:27,039
はそれを通常の因子グラフと呼んでいましたが、

171
00:06:27,039 --> 00:06:29,840
今日のデビッドフォーニーに敬意を表して、

172
00:06:29,840 --> 00:06:31,360
それらはフォーニースタイルのファクトリーグラフと呼ばれています。

173
00:06:31,360 --> 00:06:32,319


174
00:06:32,319 --> 00:06:33,440


175
00:06:33,440 --> 00:06:35,600
これが

176
00:06:35,600 --> 00:06:37,280
私たちが話している因子グラフの起源であり、

177
00:06:37,280 --> 00:06:39,120
数年後

178
00:06:39,120 --> 00:06:41,600
、大学のハンスアンドレイアルリガー

179
00:06:41,600 --> 00:06:43,039
シリーズ

180
00:06:43,039 --> 00:06:45,280
ええと、私はこれを

181
00:06:45,280 --> 00:06:47,840
信号処理コミュニティで人気にしました、

182
00:06:47,840 --> 00:06:51,360
そしてすでに2007年頃

183
00:06:51,360 --> 00:06:54,479
に彼の論文であなたはこれらを見る

184
00:06:54,479 --> 00:06:56,720
でしょ

185
00:06:56,720 --> 00:06:58,560


186
00:06:58,560 --> 00:07:00,080


187
00:07:00,080 --> 00:07:01,919


188
00:07:01,919 --> 00:07:04,880
うえええええええええええええええええええええええええええええええええええええええええええええええええええええええええええええええええええええええええええええええええええええええ 構造のこれ

189
00:07:04,880 --> 00:07:06,960


190
00:07:06,960 --> 00:07:08,639
は、私たちの言語でやりたいことです。

191
00:07:08,639 --> 00:07:10,800


192
00:07:10,800 --> 00:07:13,039


193
00:07:13,039 --> 00:07:14,319
神経科学コミュニティからのインスピレーションのインスピレーションからのアクティブな推論

194
00:07:14,319 --> 00:07:16,639
を組み合わせ、それ

195
00:07:16,639 --> 00:07:18,240
を信号処理や

196
00:07:18,240 --> 00:07:20,560
因子グラフに関する情報理論で知っていることと組み合わせて、

197
00:07:20,560 --> 00:07:24,639
これらのツールを使用して これを実装する

198
00:07:24,639 --> 00:07:26,560
ために、

199
00:07:26,560 --> 00:07:29,199
今日は2つのプレゼンテーションがあります。1つは

200
00:07:29,199 --> 00:07:30,479


201
00:07:30,479 --> 00:07:33,120
、forney labforneylabを通過するメッセージの実行方法に関する行からのテキストです。

202
00:07:33,120 --> 00:07:35,360
は私たちが書いたツールボックスです。

203
00:07:35,360 --> 00:07:36,800


204
00:07:36,800 --> 00:07:38,160


205
00:07:38,160 --> 00:07:40,960
名前はもちろんフォーニーを指します。

206
00:07:40,960 --> 00:07:42,720
タイは

207
00:07:42,720 --> 00:07:45,120
このツールボックスで積極的な影響を与える方法

208
00:07:45,120 --> 00:07:47,280
を示します。その後、リアクティブメッセージパッシングと呼ばれる新しいバージョンにも取り組んでおり、

209
00:07:47,280 --> 00:07:49,680


210
00:07:49,680 --> 00:07:51,520
ドミトリーがメインです。 そこにいる人と

211
00:07:51,520 --> 00:07:53,280
ディミトリも

212
00:07:53,280 --> 00:07:55,280
それについて少し話し

213
00:07:55,280 --> 00:07:57,360


214
00:07:57,360 --> 00:07:59,680
ますそれは私にとってすべてですええと私はあなたにそれを返します

215
00:07:59,680 --> 00:08:00,800


216
00:08:00,800 --> 00:08:02,960


217
00:08:02,960 --> 00:08:03,840


218
00:08:03,840 --> 00:08:06,720


219
00:08:06,720 --> 00:08:08,400


220
00:08:08,400 --> 00:08:10,720
コンテキストについては

221
00:08:10,720 --> 00:08:12,479


222
00:08:12,479 --> 00:08:14,400
、著者から、

223
00:08:14,400 --> 00:08:16,560


224
00:08:16,560 --> 00:08:18,879
あなたが提起した一般的なポイントと、

225
00:08:18,879 --> 00:08:20,960
それが実際に特定の方法でどのように適用されるかについての考察を

226
00:08:20,960 --> 00:08:22,319
聞くのは素晴らしいことです。

227
00:08:22,319 --> 00:08:24,960


228
00:08:24,960 --> 00:08:27,440
1つの統一されたアプローチの単純さと

229
00:08:27,440 --> 00:08:29,759
、進行中の最適化

230
00:08:29,759 --> 00:08:31,520
問題の課題、そして自然からインスピレーションを引き出す

231
00:08:31,520 --> 00:08:33,599
ことはとても素晴らしいこと

232
00:08:33,599 --> 00:08:35,440


233
00:08:35,440 --> 00:08:36,880


234
00:08:36,880 --> 00:08:38,719
です。

235
00:08:38,719 --> 00:08:40,640
あなたが好むプレゼンテーションのどれにでもジャンプできると思います。  d画面を共有してみて

236
00:08:40,640 --> 00:08:42,000


237
00:08:42,000 --> 00:08:44,880
、それが機能するかどうかを確認します

238
00:08:46,130 --> 00:08:49,189
[音楽]

239
00:08:53,279 --> 00:08:56,160
ウィンドウ画面を選択します画面全体

240
00:08:56,160 --> 00:08:58,800
大丈夫もっと

241
00:09:00,720 --> 00:09:02,080
実用的なストリーム今あなたは私の画面を見ることができると思います

242
00:09:02,080 --> 00:09:03,839


243
00:09:03,839 --> 00:09:05,600


244
00:09:05,600 --> 00:09:07,200
そこに行くの

245
00:09:07,200 --> 00:09:09,440
は素晴らしい

246
00:09:09,440 --> 00:09:11,920
ですね

247
00:09:11,920 --> 00:09:14,160


248
00:09:14,160 --> 00:09:15,440


249
00:09:15,440 --> 00:09:17,040


250
00:09:17,040 --> 00:09:19,040


251
00:09:19,040 --> 00:09:21,600


252
00:09:21,600 --> 00:09:23,600


253
00:09:23,600 --> 00:09:25,040


254
00:09:25,040 --> 00:09:26,880
ええと、ええと、アクティブな推論

255
00:09:26,880 --> 00:09:28,560


256
00:09:28,560 --> 00:09:30,320
のコンテキストで偽のラボでメッセージパッシングを行う方法について少し紹介し、この話に

257
00:09:30,320 --> 00:09:32,800


258
00:09:32,800 --> 00:09:34,480
少し動機を与えるために、

259
00:09:34,480 --> 00:09:37,040
これは

260
00:09:37,040 --> 00:09:39,360
私たちが興味を持っている状況の一種です その

261
00:09:39,360 --> 00:09:42,000
ため、ある種の環境が

262
00:09:42,000 --> 00:09:43,600
あり

263
00:09:43,600 --> 00:09:45,360
、その環境で実行されている環境プロセスがあり、その環境内で

264
00:09:45,360 --> 00:09:47,680


265
00:09:47,680 --> 00:09:49,760
何らかの目的を持っている、または何らかの目的のある

266
00:09:49,760 --> 00:09:53,120
タスクを実行するエージェントを開発したいと考えています。

267
00:09:53,120 --> 00:09:54,959


268
00:09:54,959 --> 00:09:56,640
d環境へのアクションとその環境の

269
00:09:56,640 --> 00:09:58,880
操作。

270
00:09:58,880 --> 00:10:02,160
観測

271
00:10:02,160 --> 00:10:04,320
を受け取り、環境プロセスで実行され

272
00:10:04,320 --> 00:10:05,519


273
00:10:05,519 --> 00:10:08,320
ている関数rtがあり、それと

274
00:10:08,320 --> 00:10:10,000


275
00:10:10,000 --> 00:10:11,760
対話するのはシミュレーションである場合もあれば、

276
00:10:11,760 --> 00:10:14,079
実際のプロセスである場合もあります。 もちろん、現実の世界

277
00:10:14,079 --> 00:10:16,640
でrtが実行されているかどうかはわかりません。どういう

278
00:10:16,640 --> 00:10:19,120


279
00:10:19,120 --> 00:10:21,680
わけか、その世界で何かを実行するエージェントを構築したい

280
00:10:21,680 --> 00:10:23,279


281
00:10:23,279 --> 00:10:26,640
ので、1970年代の

282
00:10:26,800 --> 00:10:29,360
conantとashbyからのこの論文はどこから始めますか。

283
00:10:29,360 --> 00:10:31,040


284
00:10:31,040 --> 00:10:32,480
彼らは興味深い定理を持っており、

285
00:10:32,480 --> 00:10:33,600


286
00:10:33,600 --> 00:10:36,000
システムのすべての優れたレギュレーターは

287
00:10:36,000 --> 00:10:39,040
そのシステムのモデルで

288
00:10:39,040 --> 00:10:39,920


289
00:10:39,920 --> 00:10:41,519
なければならないということです。

290
00:10:41,519 --> 00:10:43,120


291
00:10:43,120 --> 00:10:44,839
つまり

292
00:10:44,839 --> 00:10:47,839
、システムを環境を調整または操作するエージェントを構築する場合は、

293
00:10:47,839 --> 00:10:51,920
そのシステムを次の

294
00:10:51,920 --> 00:10:53,600
ようにモデル化する必要があります。 私たちが正確にモデル生成モデルを構築

295
00:10:53,600 --> 00:10:55,920
するビジネスをしているエンジニアであり、

296
00:10:55,920 --> 00:10:57,839


297
00:10:57,839 --> 00:11:00,880


298
00:11:00,880 --> 00:11:03,120
このモデル

299
00:11:03,120 --> 00:11:04,160


300
00:11:04,160 --> 00:11:05,920


301
00:11:05,920 --> 00:11:09,839
は、私たちの操作から観察がどのように続くかについての私

302
00:11:09,839 --> 00:11:12,160
たちの信念を表しています。  yの関数である関数fによって表される、

303
00:11:12,160 --> 00:11:15,839
観測値

304
00:11:15,839 --> 00:11:17,839
コントロールu

305
00:11:17,839 --> 00:11:20,560
と、観測値とコントロールの中間として機能する潜在状態の隠れ

306
00:11:20,560 --> 00:11:23,440
変数x

307
00:11:23,440 --> 00:11:25,440
も、

308
00:11:25,440 --> 00:11:29,160


309
00:11:30,160 --> 00:11:31,760


310
00:11:31,760 --> 00:11:34,000
1つのことですが

311
00:11:34,000 --> 00:11:36,160
、最終的には、観測値を実行します。

312
00:11:36,160 --> 00:11:38,640
次に、

313
00:11:38,640 --> 00:11:41,600
私たちを好ましい状態に導く制御を提案します。

314
00:11:41,600 --> 00:11:42,959
そこで

315
00:11:42,959 --> 00:11:44,880
は、自由エネルギー原理

316
00:11:44,880 --> 00:11:47,519
と能動的推論のアイデアが出てくる

317
00:11:47,519 --> 00:11:49,440
ので、

318
00:11:49,440 --> 00:11:51,360
これを見たい場合は仮説

319
00:11:51,360 --> 00:11:53,600
であり、目的のあることを行うエージェントを構築したい

320
00:11:53,600 --> 00:11:55,440
場合は、 驚きに

321
00:11:55,440 --> 00:11:58,240
縛られた自由エネルギーを最小化することで

322
00:11:58,240 --> 00:12:00,240


323
00:12:00,240 --> 00:12:02,320
それを行うことができるので、驚きを回避するエージェントを構築したいと思います。

324
00:12:02,320 --> 00:12:05,040
それによって、その環境についてベイズ推定を行うことができる

325
00:12:05,040 --> 00:12:07,600


326
00:12:07,600 --> 00:12:09,600
ので、エージェントが最適化するためのある種の自由エネルギー汎関数を構築する必要が

327
00:12:09,600 --> 00:12:11,200


328
00:12:11,200 --> 00:12:13,680


329
00:12:13,680 --> 00:12:16,720
あります。 その持続時間によって、

330
00:12:16,720 --> 00:12:19,540
アクションとコントロール

331
00:12:19,540 --> 00:12:20,959
[音楽]の推論

332
00:12:20,959 --> 00:12:23,760
と、エネルギー汎関数を、

333
00:12:23,760 --> 00:12:26,240


334
00:12:26,240 --> 00:12:28,160
私たちが持っている生成モデル

335
00:12:28,160 --> 00:12:29,600
とsの間のkl発散として定義しました。

336
00:12:29,600 --> 00:12:32,959
ここでqtを

337
00:12:32,959 --> 00:12:35,839
定義し

338
00:12:36,000 --> 00:12:38,240
、このエネルギー汎関数を最小化することで、ある種の近似的な事後分析により、観測から制御に向けて

339
00:12:38,240 --> 00:12:40,160
逆方向に推論できるようになります。これは

340
00:12:40,160 --> 00:12:44,560


341
00:12:45,360 --> 00:12:48,720
一種の一般的な考え方で

342
00:12:48,720 --> 00:12:50,320
あり

343
00:12:50,320 --> 00:12:52,480
、これを仮定した

344
00:12:52,480 --> 00:12:53,360


345
00:12:53,360 --> 00:12:55,680
ので、たとえば1つの大きなものを選択できます。

346
00:12:55,680 --> 00:12:57,760
私が作りたい選択は、どのようにモデルを選択する

347
00:12:57,760 --> 00:12:59,600
かです。どのように私は自分に役立つ方法で自分のfを選択

348
00:12:59,600 --> 00:13:01,760


349
00:13:01,760 --> 00:13:03,839
するのです

350
00:13:03,839 --> 00:13:06,399
か。また、どのように自分のキュートを選択

351
00:13:06,399 --> 00:13:08,320
するのですか。

352
00:13:08,320 --> 00:13:09,440


353
00:13:09,440 --> 00:13:13,040
推論

354
00:13:13,120 --> 00:13:14,160
と

355
00:13:14,160 --> 00:13:17,360
そのプロセスは試行錯誤のようなもので

356
00:13:17,360 --> 00:13:19,120
あり

357
00:13:19,120 --> 00:13:20,800


358
00:13:20,800 --> 00:13:22,480
、エンジニアとしてはもちろん可能な限り最高のモデルを構築したいのです

359
00:13:22,480 --> 00:13:24,959


360
00:13:24,959 --> 00:13:26,959
が、どのようにし

361
00:13:26,959 --> 00:13:28,720
て試行錯誤のプロセスをできるだけ早く進める

362
00:13:28,720 --> 00:13:30,959
ことができますか？ 私は最高のモデルをマークし

363
00:13:30,959 --> 00:13:34,199
ます。

364
00:13:34,560 --> 00:13:36,800
これがモデル

365
00:13:36,800 --> 00:13:39,199
設計サイクルのアイデアの出番です。

366
00:13:39,199 --> 00:13:41,839
これは

367
00:13:41,839 --> 00:13:43,120


368
00:13:43,120 --> 00:13:45,440
、2014年にDavid blyが作成した計算試行錯誤の論文で再び人気を博し

369
00:13:45,440 --> 00:13:47,600


370
00:13:47,600 --> 00:13:49,760
、彼はサイクルを提案しています。

371
00:13:49,760 --> 00:13:52,240
エンジニアがモデルを提案し、

372
00:13:52,240 --> 00:13:54,320
そのモデルを

373
00:13:54,320 --> 00:13:56,480


374
00:13:56,480 --> 00:13:58,079
使用して

375
00:13:58,079 --> 00:13:59,600
、データを指定して関心のある量を推測します。そのようなモデルを推測した場合は、

376
00:13:59,600 --> 00:14:01,279
それを批判し

377
00:14:01,279 --> 00:14:02,720
、評価し

378
00:14:02,720 --> 00:14:04,560
たパフォーマンスに基づいて

379
00:14:04,560 --> 00:14:07,680


380
00:14:07,680 --> 00:14:08,800
、モデルの再構築を繰り返します。

381
00:14:08,800 --> 00:14:09,839


382
00:14:09,839 --> 00:14:10,720
もう一度推測して

383
00:14:10,720 --> 00:14:12,959
、満足するまでそれがどれだけうまく機能するかを確認

384
00:14:12,959 --> 00:14:14,639


385
00:14:14,639 --> 00:14:16,959
し、実際に実際の設定でエージェントに適用できるようにします。

386
00:14:16,959 --> 00:14:19,680


387
00:14:19,680 --> 00:14:21,440
その後、

388
00:14:21,440 --> 00:14:24,079
この設計サイクルをできるだけ早く実行

389
00:14:24,079 --> 00:14:27,040


390
00:14:27,120 --> 00:14:29,279
する方法が課題になります。 私たちは柔軟になりたいと思ってい

391
00:14:29,279 --> 00:14:31,760
ます。自動

392
00:14:31,760 --> 00:14:34,000
化したいと

393
00:14:34,000 --> 00:14:35,040
思っ

394
00:14:35,040 --> 00:14:37,440
ています。モデルの提案自体は、エンジニアとしてあなたがしなければならないことです。

395
00:14:37,440 --> 00:14:38,800


396
00:14:38,800 --> 00:14:40,320


397
00:14:40,320 --> 00:14:44,079
世界がどのように機能すると信じているかを提案する必要

398
00:14:44,079 --> 00:14:45,920
がありますが、それができたら、他のすべてを行う必要があり

399
00:14:45,920 --> 00:14:48,959
ます。 自動化

400
00:14:48,959 --> 00:14:50,800
することができます確率的プログラミングによってこれらの量を推測することが

401
00:14:50,800 --> 00:14:52,480
できますモデルのパフォーマンス

402
00:14:52,480 --> 00:14:55,920
の尺度として自由エネルギーを評価することができます

403
00:14:55,920 --> 00:14:57,360


404
00:14:57,360 --> 00:14:59,040
[音楽]

405
00:14:59,040 --> 00:15:00,399
そして

406
00:15:00,399 --> 00:15:03,120
このサイクルを自動化する lは、実際

407
00:15:03,120 --> 00:15:05,360
に役立つエージェントのモデル提案を作成するための鍵

408
00:15:05,360 --> 00:15:07,519
となるため

409
00:15:07,519 --> 00:15:08,639
、これをできるだけ早く実行したい

410
00:15:08,639 --> 00:15:10,160


411
00:15:10,160 --> 00:15:11,760
ので、特定の

412
00:15:11,760 --> 00:15:14,079
方法を選択

413
00:15:14,079 --> 00:15:16,240
するのは、因数分解されたモデルを表す

414
00:15:16,240 --> 00:15:17,680
ため

415
00:15:17,680 --> 00:15:20,000
にベクトルグラフを選択する理由です。 操作を行うこと

416
00:15:20,000 --> 00:15:22,560
ができますノードを追加することができますノードを削除することができ

417
00:15:22,560 --> 00:15:24,839
ます非常に迅速に再配線でき

418
00:15:24,839 --> 00:15:26,959


419
00:15:26,959 --> 00:15:29,040
ますモデルのグラフィック表現ができたら

420
00:15:29,040 --> 00:15:31,440


421
00:15:31,440 --> 00:15:34,399
、推論を自動化するためにそのグラフにメッセージを渡す

422
00:15:34,399 --> 00:15:36,720
ことができ、ローカルの貢献によって自由エネルギーを評価することもできます

423
00:15:36,720 --> 00:15:38,839
その

424
00:15:38,839 --> 00:15:41,920
グラフは、

425
00:15:41,920 --> 00:15:43,519
グラフィック表現を選択する理由

426
00:15:43,519 --> 00:15:45,440
です。また、効果的なエージェントを設計できるようにモデルを迅速に設計したいので、メッセージパッシングを実行し

427
00:15:45,440 --> 00:15:47,440
たいの

428
00:15:47,440 --> 00:15:51,680


429
00:15:52,639 --> 00:15:54,880
です。これらのグラフ

430
00:15:54,880 --> 00:15:57,279
はどのように機能しますか。

431
00:15:57,279 --> 00:15:58,639
グラフまたはそれはどのように見える

432
00:15:58,639 --> 00:16:00,560


433
00:16:00,560 --> 00:16:03,040
ので、モデルの特定の表現を選択します。

434
00:16:03,040 --> 00:16:04,560


435
00:16:04,560 --> 00:16:06,880
これは、

436
00:16:06,880 --> 00:16:09,120
5つの変数の生成モデルがある例です。  x1

437
00:16:09,120 --> 00:16:10,959
から

438
00:16:10,959 --> 00:16:15,759
x5まで、3つの要素f a bとcが

439
00:16:15,759 --> 00:16:18,079
あります。右の図は

440
00:16:18,079 --> 00:16:20,240
、そのモデルのグラフ表示

441
00:16:20,240 --> 00:16:21,279


442
00:16:21,279 --> 00:16:23,440
です。ご覧のとおり、エッジは

443
00:16:23,440 --> 00:16:25,680
変数に

444
00:16:25,680 --> 00:16:28,560
対応し、ノードはベクトルに対応し

445
00:16:28,560 --> 00:16:31,360
、エッジはに接続されています。

446
00:16:31,360 --> 00:16:32,399


447
00:16:32,399 --> 00:16:34,560
ベクトルが引数にある

448
00:16:34,560 --> 00:16:37,040
ノード。ここでは、エッジx1とx2をうまく接続するノードfaが表示されます。これ

449
00:16:37,040 --> 00:16:39,759
は、x1とx2

450
00:16:39,759 --> 00:16:42,160


451
00:16:42,160 --> 00:16:45,519
がfbとfcで同じfaの引数で

452
00:16:46,800 --> 00:16:48,079


453
00:16:48,079 --> 00:16:50,639
あるためです。このグラフで推論を行うには、次の

454
00:16:50,639 --> 00:16:53,680
ように仮定します。

455
00:16:53,680 --> 00:16:56,480
この小さな実線の四角で示されるx5を観察し、

456
00:16:56,480 --> 00:16:58,399


457
00:16:58,399 --> 00:17:00,560


458
00:17:00,560 --> 00:17:02,800
x5が与え

459
00:17:02,800 --> 00:17:05,359


460
00:17:05,359 --> 00:17:07,199


461
00:17:07,199 --> 00:17:09,119
られた場合のx2に対する信念を

462
00:17:09,119 --> 00:17:10,959


463
00:17:10,959 --> 00:17:12,559
計算したいと思います。

464
00:17:12,559 --> 00:17:14,319
x2を受け入れ、

465
00:17:14,319 --> 00:17:16,559
すべてを統合し、

466
00:17:16,559 --> 00:17:20,640
x5を観察するというこの制約を追加します。

467
00:17:20,640 --> 00:17:23,199
大きなモデルがある

468
00:17:23,199 --> 00:17:25,599
場合、この統合は非常に

469
00:17:25,599 --> 00:17:28,319
面倒になります。これは、ここにあり

470
00:17:28,319 --> 00:17:30,480
ます。 統合する変数

471
00:17:30,480 --> 00:17:32,559


472
00:17:32,559 --> 00:17:33,520


473
00:17:33,520 --> 00:17:35,679
この部屋この統合スペース

474
00:17:35,679 --> 00:17:37,840
は、これを素朴に実行したい場合に実際に爆発し

475
00:17:37,840 --> 00:17:40,320


476
00:17:40,320 --> 00:17:43,039
ますが、これについて賢く

477
00:17:43,039 --> 00:17:45,120
すること

478
00:17:45,120 --> 00:17:47,640
ができ、それぞれの用語

479
00:17:47,640 --> 00:17:49,919
に従ってこれらの積分を再シャッフルする

480
00:17:49,919 --> 00:17:52,080


481
00:17:52,080 --> 00:17:54,480
ことができます。たとえば、

482
00:17:54,480 --> 00:17:57,600
この統合は

483
00:17:57,600 --> 00:18:00,000
x5は、x5が引数である要因が1つしかない

484
00:18:00,000 --> 00:18:01,440


485
00:18:01,440 --> 00:18:03,520
ため、分散ルールを使用し

486
00:18:03,520 --> 00:18:06,960
てこの積分を

487
00:18:07,280 --> 00:18:09,840
内部に持ち込み、これらの積分

488
00:18:09,840 --> 00:18:14,120
を管理可能な小さな部分に分割でき

489
00:18:14,320 --> 00:18:16,400
ます。これは、

490
00:18:16,400 --> 00:18:17,200


491
00:18:17,200 --> 00:18:19,919
メッセージパッシングが本質的にメッセージパッシングから発生する場所です。

492
00:18:19,919 --> 00:18:22,559
これらの統合を1つずつ解決して、

493
00:18:22,559 --> 00:18:25,520
最初にここでx x 1を統合できるようにし

494
00:18:25,520 --> 00:18:27,520
ます。

495
00:18:27,520 --> 00:18:28,559


496
00:18:28,559 --> 00:18:31,280
たとえば、

497
00:18:31,280 --> 00:18:33,840
このオレンジ色のボックス内のすべての情報を要約し、このオレンジ色のボックス

498
00:18:33,840 --> 00:18:35,919
を終了するメッセージの最初のメッセージをここに表示します。

499
00:18:35,919 --> 00:18:38,480


500
00:18:38,480 --> 00:18:40,320
下にあるので、

501
00:18:40,320 --> 00:18:43,120
積分はx5を統合し

502
00:18:43,120 --> 00:18:45,840
、2番目のメッセージを取得し、

503
00:18:45,840 --> 00:18:48,160
この2番目の

504
00:18:48,160 --> 00:18:50,559
メッセージを3番目のメッセージの計算に使用できます。

505
00:18:50,559 --> 00:18:52,880
これは、メッセージ3の計算でメッセージ2に対して持って

506
00:18:52,880 --> 00:18:56,080


507
00:18:56,080 --> 00:18:58,240
いるソリューションを使用する、ネストされたソリューションアプローチを取得する方法です。

508
00:18:58,240 --> 00:18:59,600


509
00:18:59,600 --> 00:19:01,760


510
00:19:01,760 --> 00:19:03,679
最終

511
00:19:03,679 --> 00:19:05,600
的に

512
00:19:05,600 --> 00:19:08,320
、x2のエッジでこれら2つの衝突するメッセージを乗算

513
00:19:08,320 --> 00:19:10,000
すると、

514
00:19:10,000 --> 00:19:12,480
私の比例的な信念

515
00:19:12,480 --> 00:19:14,960


516
00:19:14,960 --> 00:19:19,280
私が観察したものを与えられたx2に対する私の比例的な後部

517
00:19:21,120 --> 00:19:24,400


518
00:19:24,400 --> 00:19:27,679
特定のノードの小さな例を与えるために、これがどのように機能するかを示し

519
00:19:27,679 --> 00:19:30,320
ます。

520
00:19:30,320 --> 00:19:32,080
これは

521
00:19:32,080 --> 00:19:33,120


522
00:19:33,120 --> 00:19:34,640


523
00:19:34,640 --> 00:19:36,320


524
00:19:36,320 --> 00:19:38,400
、隣接するエッジの信念を制約するための制約として使用する等式制約ノード

525
00:19:38,400 --> 00:19:41,280
です。 等しい

526
00:19:41,280 --> 00:19:43,840
ええと、それは

527
00:19:43,840 --> 00:19:45,440
、ここで数学を実行すると、それらが従うということですえ

528
00:19:45,440 --> 00:19:46,559


529
00:19:46,559 --> 00:19:47,520
えと、

530
00:19:47,520 --> 00:19:48,880
これはノード関数がどの

531
00:19:48,880 --> 00:19:51,200
ように見えるかですので、私はそれが

532
00:19:51,200 --> 00:19:53,200
3つの変数x yとzの関数であり、z

533
00:19:53,200 --> 00:19:55,679


534
00:19:55,679 --> 00:19:58,960
をxに制約します zもyに制約

535
00:19:58,960 --> 00:20:00,000


536
00:20:00,000 --> 00:20:01,760


537
00:20:01,760 --> 00:20:03,840
するので、これら2つを同じに制約すると、xもyになる

538
00:20:03,840 --> 00:20:05,679
ので、これに基づいてメッセージを導出できるかどうかを見てみましょう。

539
00:20:05,679 --> 00:20:08,640


540
00:20:08,880 --> 00:20:09,760


541
00:20:09,760 --> 00:20:11,520
情報をこのオレンジ色のボックスに要約する場合は、

542
00:20:11,520 --> 00:20:13,360


543
00:20:13,360 --> 00:20:14,960
サブプロダクトルールを使用できます。左

544
00:20:14,960 --> 00:20:16,799
から2つのメッセージが

545
00:20:16,799 --> 00:20:18,320
あり、下の

546
00:20:18,320 --> 00:20:20,880
メッセージ1とメッセージ2から入っています。

547
00:20:20,880 --> 00:20:23,280


548
00:20:23,280 --> 00:20:24,799
これに等式ノードのノード関数を掛けて、今すぐ

549
00:20:24,799 --> 00:20:27,760
この統合を実行します。

550
00:20:27,760 --> 00:20:29,360


551
00:20:29,360 --> 00:20:31,280


552
00:20:31,280 --> 00:20:32,880
ここでこのノード関数を除算

553
00:20:32,880 --> 00:20:34,720
積分に置き換えてから、shiftingプロパティを使用して

554
00:20:34,720 --> 00:20:36,240


555
00:20:36,240 --> 00:20:37,200


556
00:20:37,200 --> 00:20:39,600
、x

557
00:20:39,600 --> 00:20:41,440
とy

558
00:20:41,440 --> 00:20:43,840
の引数をzの引数に置き換える

559
00:20:43,840 --> 00:20:47,120
ことができます。したがって、ここで基本的に行った

560
00:20:47,120 --> 00:20:49,360
ことは、このメッセージを3倍することで計算できるということです。

561
00:20:49,360 --> 00:20:51,919


562
00:20:51,919 --> 00:20:53,440
左から下から入っ

563
00:20:53,440 --> 00:20:55,280


564
00:20:55,280 --> 00:20:56,799
てくる2つのメッセージ少し目を細め、

565
00:20:56,799 --> 00:20:58,799
目を見てみると

566
00:20:58,799 --> 00:21:00,799


567
00:21:00,799 --> 00:21:03,919
、ここで比例基本法則を認識

568
00:21:03,919 --> 00:21:06,320
できるので、基本的にメッセージ3の場合はよく言うことができ

569
00:21:06,320 --> 00:21:08,000
ます。 ここで私の

570
00:21:08,000 --> 00:21:09,360
後部

571
00:21:09,360 --> 00:21:11,919
を表し、メッセージ1は私の前

572
00:21:11,919 --> 00:21:15,440
のメッセージを私の可能性に表すことができ

573
00:21:15,440 --> 00:21:17,280
、次に比例した後部

574
00:21:17,280 --> 00:21:19,520
メッセージ3があり、それから

575
00:21:19,520 --> 00:21:21,520
残りのmodに渡すことができます el

576
00:21:21,520 --> 00:21:23,200
とこのノードは、左と下からの情報を組み合わせるためにもよく使用されます。

577
00:21:23,200 --> 00:21:24,880


578
00:21:24,880 --> 00:21:28,000


579
00:21:29,120 --> 00:21:31,840


580
00:21:34,320 --> 00:21:36,480
これは、メッセージパッシングを行うための非常に簡単な紹介

581
00:21:36,480 --> 00:21:38,320


582
00:21:38,320 --> 00:21:42,240


583
00:21:42,240 --> 00:21:43,760


584
00:21:43,760 --> 00:21:46,400
です。

585
00:21:46,400 --> 00:21:49,200


586
00:21:49,200 --> 00:21:50,880
基本的に

587
00:21:50,880 --> 00:21:53,679


588
00:21:53,679 --> 00:21:55,360


589
00:21:55,360 --> 00:21:57,520
は、スケジューリングと

590
00:21:57,520 --> 00:22:00,240
このメッセージ計算を行うソフトウェア問題プログラミングスイートである偽のラボにすでに派生しているルールな

591
00:22:00,240 --> 00:22:01,760
ので、

592
00:22:01,760 --> 00:22:03,280
これらの積分を再配布

593
00:22:03,280 --> 00:22:06,240
する方法と派生する方法についてあまり考える必要はありません。

594
00:22:06,240 --> 00:22:10,400
特定のノードの更新がたくさんある

595
00:22:10,960 --> 00:22:13,280
ので、これ

596
00:22:13,280 --> 00:22:15,520
を自動化できるの

597
00:22:15,520 --> 00:22:17,280


598
00:22:17,280 --> 00:22:19,919
は、設計サイクルのその側で、

599
00:22:19,919 --> 00:22:22,320


600
00:22:23,200 --> 00:22:24,840


601
00:22:24,840 --> 00:22:27,120
これに関する他の

602
00:22:27,120 --> 00:22:28,880
質問です。これは非常に迅速に行われているためです。

603
00:22:28,880 --> 00:22:30,240
次に行うのは、例を見て

604
00:22:30,240 --> 00:22:32,320
いきたいということです。

605
00:22:32,320 --> 00:22:34,240
これは

606
00:22:34,240 --> 00:22:36,880
、人々が

607
00:22:36,880 --> 00:22:38,880
私を止めて、やあ、やったと思うような質問をする自然なポイントかもしれません。

608
00:22:38,880 --> 00:22:41,440
ここで速くする

609
00:22:41,440 --> 00:22:43,600
ために、例を見るのは良いことだと思います。

610
00:22:43,600 --> 00:22:45,280


611
00:22:45,280 --> 00:22:47,039
ライブチャットでいくつか質問があります。また

612
00:22:47,039 --> 00:22:49,120


613
00:22:49,120 --> 00:22:52,158


614
00:22:52,400 --> 00:22:54,480


615
00:22:54,480 --> 00:22:56,640
、アクティブな推論のコンテキストで実際にこれをどのように行うのでしょうか。 これ

616
00:22:56,640 --> 00:22:58,080
はベイジアンサーモスタットと呼ばれる小さな例

617
00:22:58,080 --> 00:23:00,559


618
00:23:00,559 --> 00:23:02,960
です。環境環境がある

619
00:23:02,960 --> 00:23:03,760
ため

620
00:23:03,760 --> 00:23:05,840
、

621
00:23:05,840 --> 00:23:08,000
左側に熱源があり、その周りを移動できる小さな車が

622
00:23:08,000 --> 00:23:09,600


623
00:23:09,600 --> 00:23:11,520
熱源から離れたり、に向かって移動したりできます。

624
00:23:11,520 --> 00:23:13,679
熱源は

625
00:23:13,679 --> 00:23:16,400
現在、熱源に対する相対的な

626
00:23:16,400 --> 00:23:19,120


627
00:23:19,120 --> 00:23:20,799
位置がxと呼ばれ、すべての位置に

628
00:23:20,799 --> 00:23:22,799
特定の温度

629
00:23:22,799 --> 00:23:23,679
um

630
00:23:23,679 --> 00:23:25,120
があり、特定の位置で測定される温度

631
00:23:25,120 --> 00:23:29,600
はyと呼ば

632
00:23:29,679 --> 00:23:31,600
れ、

633
00:23:31,600 --> 00:23:33,440
4

634
00:23:33,440 --> 00:23:35,440
y 4これが私たちが選んだものかどうかはわかりませんが、

635
00:23:35,440 --> 00:23:37,600


636
00:23:37,600 --> 00:23:39,360
この車を

637
00:23:39,360 --> 00:23:41,279
左右に動かして制御します。制御

638
00:23:41,279 --> 00:23:43,440
は、左右に移動する速度

639
00:23:43,440 --> 00:23:45,360
であり、uと呼ばれる

640
00:23:45,360 --> 00:23:47,520


641
00:23:47,840 --> 00:23:50,880
ので、これが私たちの環境です。  nt

642
00:23:50,880 --> 00:23:54,320
と私たちはそのためのモデルを構築したい

643
00:23:54,320 --> 00:23:56,240
ので

644
00:23:56,240 --> 00:23:57,919
、アクティブな干渉で私たちがやりたいこと

645
00:23:57,919 --> 00:23:59,760
は

646
00:23:59,760 --> 00:24:01,840


647
00:24:01,840 --> 00:24:05,039
、私たちが取得するため

648
00:24:05,039 --> 00:24:07,600


649
00:24:07,600 --> 00:24:09,679
にこの現在の時点で適用し

650
00:24:09,679 --> 00:24:12,080
なければならない制御に向かっている状態から推論したいことです 将来的に

651
00:24:12,080 --> 00:24:13,679
は

652
00:24:13,679 --> 00:24:16,000
、現在の時刻

653
00:24:16,000 --> 00:24:17,360


654
00:24:17,360 --> 00:24:18,400
tから

655
00:24:18,400 --> 00:24:21,120
ある時間範囲の大きなtまで前方に推論し

656
00:24:21,120 --> 00:24:22,880


657
00:24:22,880 --> 00:24:25,200
たいので、将来的には

658
00:24:25,200 --> 00:24:27,200
、エージェントがどのように移動

659
00:24:27,200 --> 00:24:29,120
し、そのエージェントをどこに配置するかを検討します。

660
00:24:29,120 --> 00:24:32,960
そのとき、そして最終的には

661
00:24:32,960 --> 00:24:35,760
4の温度になりたい

662
00:24:35,760 --> 00:24:37,200
と思うでしょう。

663
00:24:37,200 --> 00:24:41,520
これは、このエージェントが世界をどのように移動するかについての私たちの

664
00:24:41,520 --> 00:24:42,880


665
00:24:42,880 --> 00:24:44,320


666
00:24:44,320 --> 00:24:46,480


667
00:24:46,480 --> 00:24:48,720


668
00:24:48,720 --> 00:24:51,200
信念を表す状態空間モデルです。 特定の温度

669
00:24:51,200 --> 00:24:55,360
とおそらくすでにアクション

670
00:24:55,360 --> 00:24:56,960
um

671
00:24:56,960 --> 00:24:59,600
を作成しており

672
00:24:59,600 --> 00:25:02,159
、現在の状態xtは、追加

673
00:25:02,159 --> 00:25:03,840
することによって以前の状態とアクションに関連していると言います。

674
00:25:03,840 --> 00:25:06,559
基本的に、ここでは、

675
00:25:06,559 --> 00:25:08,320
現在の

676
00:25:08,320 --> 00:25:09,600
位置

677
00:25:09,600 --> 00:25:12,880
umに1つで追加する速度です。 時間  ステップしてから、それを

678
00:25:12,880 --> 00:25:14,640


679
00:25:14,640 --> 00:25:17,039
追加し、ガウスノイズを適用するだけで、次の位置に

680
00:25:17,039 --> 00:25:19,520


681
00:25:19,520 --> 00:25:21,279
移動します。これにより、状態遷移が発生し

682
00:25:21,279 --> 00:25:23,520
ます。これは

683
00:25:23,520 --> 00:25:25,600


684
00:25:25,600 --> 00:25:28,880
、左に移動したい、または右に4つ移動したいという義務があります。

685
00:25:28,880 --> 00:25:30,559
次に、ガウスノイズを追加して、

686
00:25:30,559 --> 00:25:33,039


687
00:25:33,039 --> 00:25:34,799
このエージェントが環境内でどのように移動

688
00:25:34,799 --> 00:25:35,919


689
00:25:35,919 --> 00:25:38,159
するかについては不確かだと言っていますが、不確実性

690
00:25:38,159 --> 00:25:40,080
を説明するためにいくつかのバリアントを追加して、

691
00:25:40,080 --> 00:25:43,760


692
00:25:43,760 --> 00:25:45,520
ここでこれを言います 垂直

693
00:25:45,520 --> 00:25:47,520
線は、私たちが観測をしている場合

694
00:25:47,520 --> 00:25:49,600
、

695
00:25:49,600 --> 00:25:52,159
または位置を持っている場合、それ

696
00:25:52,159 --> 00:25:55,840
は温度の観測に関連してい

697
00:25:55,840 --> 00:25:56,960
ます

698
00:25:56,960 --> 00:25:59,279
-1それは私が私の熱から離れるなら私が右に移動するならそれはちょうどよく言っているのは一種の大まかな推測です

699
00:25:59,279 --> 00:26:01,440


700
00:26:01,440 --> 00:26:03,200


701
00:26:03,200 --> 00:26:05,200
ソースの場合、私の温度

702
00:26:05,200 --> 00:26:06,720
は

703
00:26:06,720 --> 00:26:09,120
マイナス1の勾配で低下し

704
00:26:09,120 --> 00:26:11,200


705
00:26:11,200 --> 00:26:12,880
ます。これは、現実の世界では非常に大まかな推測です。非常に良い

706
00:26:12,880 --> 00:26:14,640
温度勾配があり、おそらく

707
00:26:14,640 --> 00:26:16,799


708
00:26:16,799 --> 00:26:19,360
非常にゆっくりと下に移動するように移動します

709
00:26:19,360 --> 00:26:21,840
が、 私たちは

710
00:26:21,840 --> 00:26:24,400
、それが何であるかを本当に知らないと言っているだけです。

711
00:26:24,400 --> 00:26:26,159
これは私たちの生成モデルであるという信念を持っていると大まかに推測し

712
00:26:26,159 --> 00:26:27,760


713
00:26:27,760 --> 00:26:29,520
ましょう。世界についての私たちの信念は、温度

714
00:26:29,520 --> 00:26:32,400
が位置とともに低下する

715
00:26:32,400 --> 00:26:33,919
と言いましょう。 それについて

716
00:26:33,919 --> 00:26:36,559
もう一度ガウスノイズを追加してみましょう。

717
00:26:36,559 --> 00:26:39,600


718
00:26:39,600 --> 00:26:41,679
これ

719
00:26:41,679 --> 00:26:43,919
を将来に拡張します。実際に

720
00:26:43,919 --> 00:26:45,760
は、将来的にはこれに従って

721
00:26:45,760 --> 00:26:48,240
環境も進化すると信じています

722
00:26:48,240 --> 00:26:50,480


723
00:26:50,480 --> 00:26:51,360
が、自分が

724
00:26:51,360 --> 00:26:53,520
どこになりたいか、これについてもいくつかのアイデア

725
00:26:53,520 --> 00:26:55,360
が

726
00:26:55,360 --> 00:26:58,720
あります。 金の先駆者がやって来て

727
00:26:58,720 --> 00:27:00,960


728
00:27:00,960 --> 00:27:03,200
、温度の将来の観測をこの望ましい温度の4前後に制限します。

729
00:27:03,200 --> 00:27:06,240


730
00:27:06,240 --> 00:27:08,080
ここで、

731
00:27:08,080 --> 00:27:11,200


732
00:27:11,200 --> 00:27:13,360
ノイズを追加して、正確に4前後にしたいのです

733
00:27:13,360 --> 00:27:15,360
が、正確である必要はありません。 しかし

734
00:27:15,360 --> 00:27:18,240


735
00:27:18,240 --> 00:27:21,360
、私は、時間tプラス1で約4になり、将来のいつかまで

736
00:27:21,360 --> 00:27:22,480


737
00:27:22,480 --> 00:27:24,080
そこに留まり続けることをかなり確信したいと思います。これ

738
00:27:24,080 --> 00:27:25,039


739
00:27:25,039 --> 00:27:28,080
で、

740
00:27:30,320 --> 00:27:33,200
再生モデル

741
00:27:33,200 --> 00:27:35,200


742
00:27:35,200 --> 00:27:37,279
ができ、エネルギー汎関数を定義できます。

743
00:27:37,279 --> 00:27:39,360
nこのグラフをメッセージで渡すことにより、エネルギー汎関数についてこれを解決し

744
00:27:39,360 --> 00:27:41,919


745
00:27:41,919 --> 00:27:44,960


746
00:27:44,960 --> 00:27:46,480


747
00:27:46,480 --> 00:27:49,360
ます。次の時間

748
00:27:49,360 --> 00:27:52,480
から次に何をしなければならないかを推測することに関心があるため、これらのメッセージを次のコントロールに

749
00:27:52,480 --> 00:27:55,279


750
00:27:55,600 --> 00:27:57,679
渡します。ここでメッセージを実行できます。

751
00:27:57,679 --> 00:27:59,600
合格すると

752
00:27:59,600 --> 00:28:02,720


753
00:28:02,720 --> 00:28:04,159
、過去から得たすべての情報を要約できるため、これは

754
00:28:04,159 --> 00:28:06,240


755
00:28:06,240 --> 00:28:07,679
エージェント

756
00:28:07,679 --> 00:28:09,600
の現在の状態の見積もりになり、将来についての私たちの信念によってバイアスがかけられ、私たち

757
00:28:09,600 --> 00:28:11,279
がどこになりたい

758
00:28:11,279 --> 00:28:12,240
か

759
00:28:12,240 --> 00:28:14,799
、そしてそれが影響を与えたり決定したりします

760
00:28:14,799 --> 00:28:17,039


761
00:28:17,039 --> 00:28:18,640
現時点

762
00:28:18,640 --> 00:28:21,520
または次回に

763
00:28:21,600 --> 00:28:24,640
どのコントロールを実行するかについては

764
00:28:24,640 --> 00:28:26,559


765
00:28:26,559 --> 00:28:28,880
、2019年からのこのペーパーで説明さ

766
00:28:28,880 --> 00:28:31,039
れてい

767
00:28:34,080 --> 00:28:35,600
ます。また、アクション知覚ループ内でそれをどのように適用するかなどもわかります。

768
00:28:35,600 --> 00:28:37,440


769
00:28:37,440 --> 00:28:40,000


770
00:28:40,000 --> 00:28:42,240


771
00:28:42,240 --> 00:28:43,520


772
00:28:43,520 --> 00:28:44,960


773
00:28:44,960 --> 00:28:46,799
状態の見積もりが変わるため、毎回これを行う必要があります。

774
00:28:46,799 --> 00:28:48,159
単語は

775
00:28:48,159 --> 00:28:49,760
アクションに応じて変わるため、毎回

776
00:28:49,760 --> 00:28:51,600
、whaの新しいアクションを再計算する必要があります。

777
00:28:51,600 --> 00:28:54,719
次のumを実行する予定ですが

778
00:28:55,120 --> 00:28:57,600
、これ

779
00:28:57,600 --> 00:28:59,360
が主なアイデアの1つです。もちろん

780
00:28:59,360 --> 00:29:01,120


781
00:29:01,120 --> 00:29:03,679
、これをすべて手作業で実行する必要は

782
00:29:03,679 --> 00:29:07,200
ないので、そのためのツールを使用したいと考えています。

783
00:29:07,679 --> 00:29:09,039


784
00:29:09,039 --> 00:29:10,960


785
00:29:10,960 --> 00:29:12,880


786
00:29:12,880 --> 00:29:15,360
次に、数式確率プログラミングツールを使用してこのumを実装する方法のデモを少し示します。

787
00:29:15,360 --> 00:29:17,520


788
00:29:17,520 --> 00:29:19,840


789
00:29:19,840 --> 00:29:22,480
小さなデモを開くことができる

790
00:29:22,480 --> 00:29:24,320
かどうかを確認してみましょう。これは実際に読みやすいので

791
00:29:24,320 --> 00:29:25,520
、もっと拡大する

792
00:29:25,520 --> 00:29:27,279


793
00:29:27,279 --> 00:29:30,640
必要があります。 もう少しズームインできます

794
00:29:32,720 --> 00:29:35,440


795
00:29:35,440 --> 00:29:37,840
ええと、サイズを変更できますえ

796
00:29:37,840 --> 00:29:39,360
えと

797
00:29:39,360 --> 00:29:41,520
、それはかなり良いです

798
00:29:41,520 --> 00:29:42,880
ああそれは完璧

799
00:29:42,880 --> 00:29:46,159
です

800
00:29:48,640 --> 00:29:52,000
それはかなり良いですうん、ありがとうございますこれはええと

801
00:29:52,000 --> 00:29:55,279


802
00:29:55,440 --> 00:29:58,080
そうです 環境自体の定義の一種な

803
00:29:58,080 --> 00:29:59,919
ので、これ

804
00:29:59,919 --> 00:30:01,279
は現実の世界です。

805
00:30:01,279 --> 00:30:03,039
この温度

806
00:30:03,039 --> 00:30:05,120
勾配は非常に優れた関数

807
00:30:05,120 --> 00:30:07,840


808
00:30:07,840 --> 00:30:09,039
であり、熱源

809
00:30:09,039 --> 00:30:10,640
で100の温度が

810
00:30:10,640 --> 00:30:12,960
あり、

811
00:30:12,960 --> 00:30:14,880
それが次のように低下

812
00:30:14,880 --> 00:30:18,410
非常に滑らかな関数です。 熱源からの位置で

813
00:30:18,410 --> 00:30:20,240
[音楽]

814
00:30:20,240 --> 00:30:21,679
そうt 彼は私たちが本当にこれを知らない現実の世界な

815
00:30:21,679 --> 00:30:23,360
ので、これは私たち

816
00:30:23,360 --> 00:30:25,279
がこの

817
00:30:25,279 --> 00:30:28,640
非常にラフなマイナス1で近似するものであり、

818
00:30:28,640 --> 00:30:31,279
それが今それでうまくいくかどうかを確認します

819
00:30:31,279 --> 00:30:33,360
これは私の素晴らしいasciiアートです

820
00:30:33,360 --> 00:30:35,600
これで、基本的に

821
00:30:35,600 --> 00:30:38,880
スライドに表示したモデルのサイズが変更されました。

822
00:30:38,880 --> 00:30:40,559


823
00:30:40,559 --> 00:30:42,960
これがモデルの定義です。

824
00:30:42,960 --> 00:30:44,480
実際には、少しズームアウトし

825
00:30:44,480 --> 00:30:45,919
て読み

826
00:30:45,919 --> 00:30:48,399
やすくする必要があるので、この権利のグラフを作成します。

827
00:30:48,399 --> 00:30:50,799
つまり、ここでは、

828
00:30:50,799 --> 00:30:53,679
観測状態の制御が

829
00:30:53,679 --> 00:30:56,720
あり

830
00:30:56,720 --> 00:30:59,200
、tから1を引いたものについての事前の信念を定義

831
00:30:59,200 --> 00:31:01,120
しているので、これから言うのはガウス分布

832
00:31:01,120 --> 00:31:05,039
であり、平均と分散が

833
00:31:05,039 --> 00:31:07,440
あり、その後

834
00:31:07,440 --> 00:31:11,039
、 ええと、1つから地平線

835
00:31:11,039 --> 00:31:12,320
まで、コントロールについての事前の信念があり

836
00:31:12,320 --> 00:31:15,840
ます。これは、基本的に

837
00:31:15,840 --> 00:31:18,240
、私が大丈夫だと言ったときに何ができるかを

838
00:31:18,240 --> 00:31:19,039
よく示して

839
00:31:19,039 --> 00:31:20,159


840
00:31:20,159 --> 00:31:22,640


841
00:31:22,640 --> 00:31:24,480


842
00:31:24,480 --> 00:31:26,159


843
00:31:26,159 --> 00:31:28,480
います。 そこにそれを置き換えて、それから

844
00:31:28,480 --> 00:31:31,279
多分いくつかの変化

845
00:31:31,279 --> 00:31:32,880
とええと

846
00:31:32,880 --> 00:31:34,960
彼 私はエージェントの位置を持っていると言いますが、

847
00:31:34,960 --> 00:31:37,600


848
00:31:37,600 --> 00:31:38,399


849
00:31:38,399 --> 00:31:39,919


850
00:31:39,919 --> 00:31:41,120


851
00:31:41,120 --> 00:31:42,880
これはいくつかの精度ガンマが追加されたこの追加のumによって私のコントロールに関連しているので、これ

852
00:31:42,880 --> 00:31:44,640
は遷移モデルです

853
00:31:44,640 --> 00:31:46,880
これは水平

854
00:31:46,880 --> 00:31:48,480
線で

855
00:31:48,480 --> 00:31:50,480
あり、これ

856
00:31:50,480 --> 00:31:52,640
は非常に

857
00:31:52,640 --> 00:31:54,399
大まかな見積もりから1を引いた観測モデルです

858
00:31:54,399 --> 00:31:56,000
温度勾配と

859
00:31:56,000 --> 00:31:58,880
現在の状態の積、および

860
00:31:58,880 --> 00:32:00,640
いくつかの精度

861
00:32:00,640 --> 00:32:03,200
保存の精度。

862
00:32:03,200 --> 00:32:06,320
これは以前の目標を表している

863
00:32:06,320 --> 00:32:09,120
ため、ここには特定の値を実際には入力していませんが、実際の統計と値のプレースホルダーがあることに注意してください

864
00:32:09,120 --> 00:32:12,320


865
00:32:12,320 --> 00:32:14,399


866
00:32:14,399 --> 00:32:16,880
。

867
00:32:16,880 --> 00:32:18,480
私のアルゴリズムの実際の導出は

868
00:32:18,480 --> 00:32:20,480
実際には統計に依存しないので、

869
00:32:20,480 --> 00:32:23,120
それ

870
00:32:23,120 --> 00:32:27,799
は後で入れることができるものな

871
00:32:28,240 --> 00:32:29,760
ので、これは私がやりたいことであり、

872
00:32:29,760 --> 00:32:31,919
自由エネルギー汎関数を構築し、偽のラボ

873
00:32:31,919 --> 00:32:33,679
は実際にはちょうどです

874
00:32:33,679 --> 00:32:36,720
基本的に4行のコード

875
00:32:36,720 --> 00:32:39,279
umなので、qの因数分解を定義するこのステレオ因数分解

876
00:32:39,279 --> 00:32:42,559
は

877
00:32:42,559 --> 00:32:44,240


878
00:32:44,240 --> 00:32:46,960


879
00:32:46,960 --> 00:32:50,640


880
00:32:50,640 --> 00:32:52,880
、en上で共同変分分布umを持つことになります。 タイヤグラフ

881
00:32:52,880 --> 00:32:54,559
私は実際にはそれを

882
00:32:54,559 --> 00:32:55,840
構造化された

883
00:32:55,840 --> 00:32:57,760
因数分解に細分化していません一部の人々は

884
00:32:57,760 --> 00:32:59,279
そのええとよく知っています

885
00:32:59,279 --> 00:33:01,440
が、私はただ大丈夫と言って

886
00:33:01,440 --> 00:33:03,039
、変分分布のこのステレオ因数分解

887
00:33:03,039 --> 00:33:05,919
を私のグラフ全体にし、

888
00:33:05,919 --> 00:33:08,640


889
00:33:08,640 --> 00:33:11,120
私が導き出すことができるコマンドは1つだけではありません

890
00:33:11,120 --> 00:33:14,080
すべてのメッセージ

891
00:33:14,080 --> 00:33:16,320
をコントロールu2に向けて伝播するメッセージパッシングアルゴリズム。これは

892
00:33:16,320 --> 00:33:18,159
、次の

893
00:33:18,159 --> 00:33:21,039
タイムステップtに1を加えたもののコントロールであり

894
00:33:21,039 --> 00:33:23,039
、自由エネルギーを評価したいので

895
00:33:23,039 --> 00:33:24,799
、同時に実行できるアルゴリズムも提供します。

896
00:33:24,799 --> 00:33:27,840


897
00:33:27,840 --> 00:33:31,439
私の自由エネルギーを評価するために

898
00:33:31,919 --> 00:33:35,279
、この行はこれ

899
00:33:35,279 --> 00:33:36,320
を

900
00:33:36,320 --> 00:33:38,320
2つのソースコードに変換し、それを私の環境にロードできます。

901
00:33:38,320 --> 00:33:41,120


902
00:33:41,200 --> 00:33:43,519
これにより、メッセージパッシングアルゴリズムが構築される

903
00:33:43,519 --> 00:33:46,480


904
00:33:46,480 --> 00:33:48,559
ため、これがメッセージを実行するコードに

905
00:33:48,559 --> 00:33:50,159
なります。 グラフを渡す

906
00:33:50,159 --> 00:33:51,200


907
00:33:51,200 --> 00:33:53,120
と、ここでは

908
00:33:53,120 --> 00:33:54,640


909
00:33:54,640 --> 00:33:57,039
、いくつかの製品ルールと、

910
00:33:57,039 --> 00:33:58,559
事前に導出

911
00:33:58,559 --> 00:34:01,279
され、fornilabとで実装された他のルールによってこれらすべてのメッセージが計算されていることがわかります。

912
00:34:01,279 --> 00:34:03,039
これらのメッセージ

913
00:34:03,039 --> 00:34:05,360
は統計に依存していることがわかります。たとえば、これは

914
00:34:05,360 --> 00:34:07,679


915
00:34:07,679 --> 00:34:09,520
以前の

916
00:34:09,520 --> 00:34:11,280
オーバーステートの平均と以前のオーバーステートの分散であり、

917
00:34:11,280 --> 00:34:13,839


918
00:34:14,079 --> 00:34:15,599


919
00:34:15,599 --> 00:34:18,000


920
00:34:18,000 --> 00:34:19,359
メッセージの受け渡しとこれを説明した方法で以前のメッセージに依存する他のメッセージが

921
00:34:19,359 --> 00:34:21,199


922
00:34:21,199 --> 00:34:23,839
あります。

923
00:34:23,839 --> 00:34:27,599
この場合は26のメッセージ

924
00:34:27,599 --> 00:34:29,918
の完全なリストを作成し、最終的には

925
00:34:29,918 --> 00:34:32,079
限界の信念に関心があるので、

926
00:34:32,079 --> 00:34:35,040
たとえば、またはコントロールについての後方の限界の信念

927
00:34:35,040 --> 00:34:36,480


928
00:34:36,480 --> 00:34:38,399
と

929
00:34:38,399 --> 00:34:40,879
、たとえば新しい信念を取得するためにメッセージを乗算することによってこれらの信念を取得します

930
00:34:40,879 --> 00:34:43,199
次のコントロールを介して、

931
00:34:43,199 --> 00:34:44,560


932
00:34:44,560 --> 00:34:48,639
メッセージ9と25

933
00:34:48,639 --> 00:34:50,719
を乗算します。また、後の信念を得るために乗算するエッジに衝突するメッセージがある、過去の紹介からこれを認識します。これ

934
00:34:50,719 --> 00:34:52,560


935
00:34:52,560 --> 00:34:54,239


936
00:34:54,239 --> 00:34:56,239


937
00:34:56,239 --> 00:34:58,400


938
00:34:58,400 --> 00:34:59,920
が、最終的に返さ

939
00:34:59,920 --> 00:35:03,720
れるものです。 興味がある

940
00:35:06,160 --> 00:35:07,760
ので、これはそのアルゴリズムの実行であり、

941
00:35:07,760 --> 00:35:08,960


942
00:35:08,960 --> 00:35:10,640


943
00:35:10,640 --> 00:35:12,160
ここでスケジュール全体を作成し

944
00:35:12,160 --> 00:35:14,800
たことに注意してください。  rsome

945
00:35:14,800 --> 00:35:17,119
は非常に長く、非常に長いスケジュールになる可能性がある

946
00:35:17,119 --> 00:35:19,599
ため、ロードして実行するのに費用がかかる可能性があります

947
00:35:19,599 --> 00:35:21,359


948
00:35:21,359 --> 00:35:22,800
。dimitriにはその解決策が

949
00:35:22,800 --> 00:35:25,359
あり、彼はすぐにそれを説明するので、

950
00:35:25,359 --> 00:35:27,520


951
00:35:27,520 --> 00:35:29,119
スケジュールの作成に非常に

952
00:35:29,119 --> 00:35:32,400
満足しています。 たくさんのええと

953
00:35:32,400 --> 00:35:34,560
、彼はええと、彼らのための解決策を見つけようとします

954
00:35:34,560 --> 00:35:36,160


955
00:35:36,160 --> 00:35:37,680
ええと、結局、

956
00:35:37,680 --> 00:35:38,800


957
00:35:38,800 --> 00:35:40,400


958
00:35:40,400 --> 00:35:41,839
それは本当にレシピを持っていないスケジュールを持っていないのに最も速いでしょうが、

959
00:35:41,839 --> 00:35:44,880


960
00:35:44,880 --> 00:35:47,440
あなたに与えられたもので料理するだけです

961
00:35:49,920 --> 00:35:51,599
だから今

962
00:35:51,599 --> 00:35:52,800
、私たちは実際にこのアルゴリズムを実行しているので、これは私たちが行動したい

963
00:35:52,800 --> 00:35:55,520
すべてのタイムステップのアクション認識ループです私

964
00:35:55,520 --> 00:35:57,599
たちは

965
00:35:57,599 --> 00:35:59,119


966
00:35:59,119 --> 00:36:01,359
実行したいエージェントからアクション

967
00:36:01,359 --> 00:36:04,240


968
00:36:04,240 --> 00:36:06,720
を呼び起こしたいです これは

969
00:36:06,720 --> 00:36:09,040


970
00:36:09,040 --> 00:36:11,200
、この場合、実際の実世界またはある種のシミュレートされた世界に向けてアクションを送信し

971
00:36:11,200 --> 00:36:13,680
ます。そこから得られるのは

972
00:36:13,680 --> 00:36:15,680
観測で

973
00:36:15,680 --> 00:36:18,079
あり、アクションの観測から

974
00:36:18,079 --> 00:36:20,640


975
00:36:20,960 --> 00:36:22,640
、新しいアクションを推測し

976
00:36:22,640 --> 00:36:24,320


977
00:36:24,320 --> 00:36:26,560
、自由エネルギーの変動を返し

978
00:36:26,560 --> 00:36:28,240


979
00:36:28,240 --> 00:36:30,160
ます。  d次に、次のステップの準備をします。

980
00:36:30,160 --> 00:36:31,920
すべてのステップ

981
00:36:31,920 --> 00:36:34,160
で、実際に実行される環境にアクションを提案します。

982
00:36:34,160 --> 00:36:35,839
新しい結果を観察し、

983
00:36:35,839 --> 00:36:37,920
新しいアクションを

984
00:36:37,920 --> 00:36:41,680
推測し、そのアクションでどれだけうまくいったかを評価し

985
00:36:41,680 --> 00:36:44,319


986
00:36:46,480 --> 00:36:48,480
ます。そうすれば、良いプロットが得られます。

987
00:36:48,480 --> 00:36:50,160
このように、

988
00:36:50,160 --> 00:36:52,480
これはエージェントの速度です。

989
00:36:52,480 --> 00:36:54,240
ゼロから開始

990
00:36:54,240 --> 00:36:56,960
し、右のumに非常に速く

991
00:36:56,960 --> 00:36:57,920


992
00:36:57,920 --> 00:36:59,920


993
00:36:59,920 --> 00:37:02,240
移動し

994
00:37:02,240 --> 00:37:05,200
、最後が多かれ少なかれ静止点に到達するまで少し戻って移動することがわかります。

995
00:37:05,200 --> 00:37:06,839


996
00:37:06,839 --> 00:37:09,680
実際にここで

997
00:37:09,680 --> 00:37:11,119
それが何をしているのかを見ることができるので、それ

998
00:37:11,119 --> 00:37:13,359
は20の温度で始まり

999
00:37:13,359 --> 00:37:15,920


1000
00:37:15,920 --> 00:37:17,760
、熱源からすぐに非常

1001
00:37:17,760 --> 00:37:20,560
に速く移動し、マークを超えて、

1002
00:37:20,560 --> 00:37:22,560
実際に戻って、

1003
00:37:22,560 --> 00:37:23,920
この望ましい温度の4の周りに落ち着きます

1004
00:37:23,920 --> 00:37:26,320


1005
00:37:26,320 --> 00:37:30,480
目標の優先順位によってエンコードされている

1006
00:37:31,839 --> 00:37:34,400
ので

1007
00:37:34,400 --> 00:37:36,480
、環境のモデルが完全ではなかったのはなぜですか？

1008
00:37:36,480 --> 00:37:39,119
マイナスマイナス1 umの非常に大まかな見積もりが

1009
00:37:39,119 --> 00:37:40,560


1010
00:37:40,560 --> 00:37:43,040
あり、現実の世界ではこの非常に

1011
00:37:43,040 --> 00:37:46,240
滑らかな親族でした このようなベルの形をした複雑な関数のd

1012
00:37:46,240 --> 00:37:47,280


1013
00:37:47,280 --> 00:37:51,680


1014
00:37:51,680 --> 00:37:54,000


1015
00:37:54,000 --> 00:37:55,599
は、環境の生成モデルが

1016
00:37:55,599 --> 00:37:57,200
完全ではなかった

1017
00:37:57,200 --> 00:37:59,520
としても、最終的には

1018
00:37:59,520 --> 00:38:01,599
少しオーバーシュートすることでその代償を払ったのですが、

1019
00:38:01,599 --> 00:38:04,880
それでも私たちは

1020
00:38:04,880 --> 00:38:06,560
4の温度で望ましい状態なので

1021
00:38:06,560 --> 00:38:07,440
、最終

1022
00:38:07,440 --> 00:38:10,720
的にはかなりうまく機能

1023
00:38:10,800 --> 00:38:12,240
しました。また

1024
00:38:12,240 --> 00:38:14,880
、エージェントの自由エネルギーも時間とともに減少する

1025
00:38:14,880 --> 00:38:16,880
ことがわかります。

1026
00:38:16,880 --> 00:38:19,680
したがって、約1000から開始するため、ここでのスケールの対数

1027
00:38:19,680 --> 00:38:22,640
は非常に減少します。 すぐに

1028
00:38:22,640 --> 00:38:24,720
合計値になりますが、

1029
00:38:24,720 --> 00:38:27,040
かなり低くなります。その後

1030
00:38:27,040 --> 00:38:29,359
、

1031
00:38:29,359 --> 00:38:32,320
予期しない変化や予期しない

1032
00:38:32,320 --> 00:38:34,079


1033
00:38:34,079 --> 00:38:36,079
驚きを引き起こすノイズが発生します。そのため、

1034
00:38:36,079 --> 00:38:38,240
ここにこれらの小さな波紋がありますが

1035
00:38:38,240 --> 00:38:39,760
、最終的には自由エネルギーを最小限に抑えています。 そして

1036
00:38:39,760 --> 00:38:41,920
それは劇的に減少している

1037
00:38:41,920 --> 00:38:43,440
ので、私たちは実際にこの自由エネルギー最小化エージェントを持っています

1038
00:38:43,440 --> 00:38:47,079


1039
00:38:47,200 --> 00:38:48,079


1040
00:38:48,079 --> 00:38:50,880
ええと、ええ、それは基本的に

1041
00:38:50,880 --> 00:38:53,200
私が持っているすべての話ですそして

1042
00:38:53,200 --> 00:38:55,759


1043
00:38:56,880 --> 00:39:00,320
素晴らしいデモはありがとうy

1044
00:39:00,320 --> 00:39:03,520
画面共有をオンにするか

1045
00:39:03,520 --> 00:39:05,040
、ライブチャットからいくつかの質問をしないか

1046
00:39:05,040 --> 00:39:07,040
、さらに入力するのに数秒

1047
00:39:07,040 --> 00:39:08,720
かかるので

1048
00:39:08,720 --> 00:39:10,160
、最初に質問に飛び込んで

1049
00:39:10,160 --> 00:39:12,320


1050
00:39:12,320 --> 00:39:14,480
、スクリーンショットを停止させてください。

1051
00:39:14,480 --> 00:39:16,640
まだスクリーンストーリーを共有しています

1052
00:39:16,640 --> 00:39:19,280
ええと、ジッシーだけが

1053
00:39:19,280 --> 00:39:21,119
表示されているので、ジッツィでもう一度スクリーン共有ボタンをクリックし

1054
00:39:21,119 --> 00:39:23,599
てください。

1055
00:39:25,440 --> 00:39:27,599
ありがとうございます。最初の

1056
00:39:27,599 --> 00:39:29,359
質問

1057
00:39:29,359 --> 00:39:31,920
はジョンからです。ジョンは、グラフの場合、因子グラフのアプローチはどのように機能するかを書いてい

1058
00:39:31,920 --> 00:39:34,320


1059
00:39:34,320 --> 00:39:36,960
ます。 構造は事前にわかっていません

1060
00:39:36,960 --> 00:39:41,079
構造学習は可能です

1061
00:39:43,040 --> 00:39:44,720
ええと、

1062
00:39:44,720 --> 00:39:46,800
それは良い質問です。

1063
00:39:46,800 --> 00:39:49,520
これらのグラフで構造学習が可能である

1064
00:39:49,520 --> 00:39:51,839


1065
00:39:52,079 --> 00:39:54,240
ため、実際には

1066
00:39:54,240 --> 00:39:55,520
まだ活発な

1067
00:39:55,520 --> 00:39:57,520
研究分野であり、できれば素晴らしいでしょう。

1068
00:39:57,520 --> 00:39:59,599


1069
00:39:59,599 --> 00:40:01,599
グラフ自体の構造学習も自動化します

1070
00:40:01,599 --> 00:40:02,880
が、そこには多くの課題がある

1071
00:40:02,880 --> 00:40:04,400
ので、このグラフ構造をどのようにパラメーター化するのです

1072
00:40:04,400 --> 00:40:07,520
か、そしてどのように行うのですか

1073
00:40:07,520 --> 00:40:08,960


1074
00:40:08,960 --> 00:40:12,560
？  ■グラフの観点からの検索スペースグラフに

1075
00:40:12,560 --> 00:40:14,240


1076
00:40:14,240 --> 00:40:15,920
ノード

1077
00:40:15,920 --> 00:40:18,160
関数が指定されていない場合、ノード関数をどのように学習しますか。

1078
00:40:18,160 --> 00:40:19,760
これらはすべて非常に難しい質問

1079
00:40:19,760 --> 00:40:21,200
であり、簡単な

1080
00:40:21,200 --> 00:40:23,040
答えが

1081
00:40:23,040 --> 00:40:24,800
ないため、次のようになります。 設計サイクル自体の

1082
00:40:24,800 --> 00:40:27,040
この実際のモデル設計ステップ

1083
00:40:27,040 --> 00:40:27,920


1084
00:40:27,920 --> 00:40:29,359


1085
00:40:29,359 --> 00:40:31,440
がまだ一種の創造的なプロセス

1086
00:40:31,440 --> 00:40:33,359
である理由モデルを考え出す必要があるエンジニアがいて

1087
00:40:33,359 --> 00:40:34,880


1088
00:40:34,880 --> 00:40:36,560
、エンジニアとして、そうでない

1089
00:40:36,560 --> 00:40:38,400
場合はそのモデルを調整する方法についても考える

1090
00:40:38,400 --> 00:40:40,240
必要があります 満足している

1091
00:40:40,240 --> 00:40:42,160
ので

1092
00:40:42,160 --> 00:40:44,400
、エージェントをうまく実行した後も自由エネルギーがまだ高い場合

1093
00:40:44,400 --> 00:40:45,760
は、モデルに何か問題があります。

1094
00:40:45,760 --> 00:40:46,720
これ

1095
00:40:46,720 --> 00:40:48,960


1096
00:40:48,960 --> 00:40:50,720
は環境を正確に表していない

1097
00:40:50,720 --> 00:40:53,599
ため、現在の状態をどのように調整するかを調整できます。

1098
00:40:53,599 --> 00:40:55,040
まだ

1099
00:40:55,040 --> 00:40:57,280
試行錯誤なので、

1100
00:40:57,280 --> 00:40:58,640
ここで改善できることがあると思います。

1101
00:40:58,640 --> 00:41:00,640
ノードを削除するかもしれません。モデルが複雑すぎるかもしれません

1102
00:41:00,640 --> 00:41:03,598


1103
00:41:04,130 --> 00:41:05,440
[音楽]

1104
00:41:05,440 --> 00:41:08,880
が、それ自体で実行されている構造は、なんとなく

1105
00:41:08,880 --> 00:41:10,800
です。  gそれは

1106
00:41:10,800 --> 00:41:12,560
また対処できるので

1107
00:41:12,560 --> 00:41:15,599
、ネストされたモデルの比較のようなumのような方法

1108
00:41:15,599 --> 00:41:17,359


1109
00:41:17,359 --> 00:41:19,280
があり、実際にグラフを作成できるような方法があります。

1110
00:41:19,280 --> 00:41:20,800
たとえば、ネストされたモデルがある場合は、

1111
00:41:20,800 --> 00:41:22,880
野蛮なディッキーの比率を計算して

1112
00:41:22,880 --> 00:41:25,440
から、 これに基づいてモデルを整理します。

1113
00:41:25,440 --> 00:41:27,440


1114
00:41:27,440 --> 00:41:29,040
複雑なモデルを見つけて、何を切り取ることができるかを確認するために

1115
00:41:29,040 --> 00:41:31,759
できることです

1116
00:41:32,480 --> 00:41:34,000
が、そのモデルに追加するのはまだ

1117
00:41:34,000 --> 00:41:35,440
難しいので、

1118
00:41:35,440 --> 00:41:37,680
うまく切り取ったら、どのように追加しますか。 私

1119
00:41:37,680 --> 00:41:39,040
は本当に知らないので、それは

1120
00:41:39,040 --> 00:41:41,200
良い質問です、そして、ええと、私は非常に簡単ではなく、

1121
00:41:41,200 --> 00:41:43,040
あなたが

1122
00:41:43,040 --> 00:41:46,319
私のガタガタから切り替えることができるので、ええ、

1123
00:41:46,800 --> 00:41:49,839
おそらく私はそれについて何かを言うことができます

1124
00:41:49,839 --> 00:41:52,960


1125
00:41:52,960 --> 00:41:55,200
味私は一般的

1126
00:41:55,200 --> 00:41:57,520
に、

1127
00:41:57,520 --> 00:41:59,520
システムまたは信号処理システム

1128
00:41:59,520 --> 00:42:00,839
を設計するときは、構造を設計する

1129
00:42:00,839 --> 00:42:03,119
必要があります。パラメータを推定する必要があり

1130
00:42:03,119 --> 00:42:05,520
ます。次に、状態が非常に速く変化することを推測する必要があります。

1131
00:42:05,520 --> 00:42:08,480


1132
00:42:08,480 --> 00:42:11,359
これにより、共通のフィルタが作成されます。これは

1133
00:42:11,359 --> 00:42:13,040
非常に重要です。

1134
00:42:13,040 --> 00:42:15,599
良い 因子グラフで知られている

1135
00:42:15,599 --> 00:42:17,920
場合、次の段階は

1136
00:42:17,920 --> 00:42:20,800
、長期的にパラメータを学習することで

1137
00:42:20,800 --> 00:42:23,200
あり、エフェクトグラフは

1138
00:42:23,200 --> 00:42:24,240


1139
00:42:24,240 --> 00:42:27,040
、生物学の次の段階でそれをかなりうまく

1140
00:42:27,040 --> 00:42:29,280
行うことができ

1141
00:42:29,280 --> 00:42:31,440


1142
00:42:31,440 --> 00:42:33,920
ます。 これは現在、数式では機能していません。

1143
00:42:33,920 --> 00:42:37,040
テストのように比較

1144
00:42:37,040 --> 00:42:39,119
できます。2つの例がある場合は

1145
00:42:39,119 --> 00:42:41,359
、自由エネルギーを比較し

1146
00:42:41,359 --> 00:42:43,119
て最適なものを選択できます

1147
00:42:43,119 --> 00:42:45,359
が、私たちはそれに取り組んでいます。これは、私

1148
00:42:45,359 --> 00:42:47,280
たちが再びリードしていることを意味します。 ええと

1149
00:42:47,280 --> 00:42:49,599
、ベイジアンモデルの縮小に関するカールのアイデアから

1150
00:42:49,599 --> 00:42:51,920
ですが、それを因子グラフに実装する方法

1151
00:42:51,920 --> 00:42:54,400
は研究プロジェクトなので、

1152
00:42:54,400 --> 00:42:55,839
私たちはそれに

1153
00:42:55,839 --> 00:42:58,160
取り組んでおり、

1154
00:42:58,160 --> 00:43:00,560
それがどこで終わるかはわかりませんが、それが私たちの目標でした

1155
00:43:00,560 --> 00:43:02,640
phdの位置が利用できるので

1156
00:43:02,640 --> 00:43:04,799


1157
00:43:05,920 --> 00:43:07,920


1158
00:43:07,920 --> 00:43:08,640
、

1159
00:43:08,640 --> 00:43:10,640
モーターカーが最適

1160
00:43:10,640 --> 00:43:13,040
な温度に到達する例に戻すこともできます。これは、1時間ごと

1161
00:43:13,040 --> 00:43:14,720
に自由エネルギーにバンプがあることに気付いた

1162
00:43:14,720 --> 00:43:16,960
場合、図面に戻っ

1163
00:43:16,960 --> 00:43:18,640
て あなたが行く

1164
00:43:18,640 --> 00:43:20,800
その地域でその車に乗っている人々に、

1165
00:43:20,800 --> 00:43:23,200
1時間ごとに何が起こるかをよく尋ねるか

1166
00:43:23,200 --> 00:43:24,960
、この他の情報源を含める必要があるかもしれません

1167
00:43:24,960 --> 00:43:28,000
が、あなたが持っていたモデル

1168
00:43:28,000 --> 00:43:30,480
は、壁紙や他の機能を部屋に含めることができるようにその仕事をします

1169
00:43:30,480 --> 00:43:32,400


1170
00:43:32,400 --> 00:43:35,040
しかし、それは一種の工学の芸術と科学

1171
00:43:35,040 --> 00:43:36,720
であり、それが

1172
00:43:36,720 --> 00:43:39,599
常に興味深い理由です。なぜなら

1173
00:43:39,599 --> 00:43:41,280
、研究では分析を終了するようなものであることが多いのです

1174
00:43:41,280 --> 00:43:42,640


1175
00:43:42,640 --> 00:43:45,200
が、実際に

1176
00:43:45,200 --> 00:43:46,240


1177
00:43:46,240 --> 00:43:48,160
はモデル全体が埋め込まれ

1178
00:43:48,160 --> 00:43:50,400
ているこのサイクルがあり、常にそれらを監視するのに役立ちます。

1179
00:43:50,400 --> 00:43:52,160


1180
00:43:52,160 --> 00:43:54,160
現在のモデルによるキャプチャを妨げているパターンは

1181
00:43:54,160 --> 00:43:56,319


1182
00:43:56,319 --> 00:43:57,839


1183
00:43:57,839 --> 00:44:00,960
、チャットからの2番目の質問

1184
00:44:00,960 --> 00:44:03,119


1185
00:44:03,119 --> 00:44:05,680
です。この例の目標温度

1186
00:44:05,680 --> 00:44:08,079
が事前に定義されていない場合、ファクターグラフのアプローチは

1187
00:44:08,079 --> 00:44:09,920
どのように機能します

1188
00:44:09,920 --> 00:44:11,440
か？ 構造学習よりも、

1189
00:44:11,440 --> 00:44:13,599
好みと目標の方向性がどのように

1190
00:44:13,599 --> 00:44:16,319


1191
00:44:16,319 --> 00:44:19,440
再び発生するのか優れた質問である

1192
00:44:19,920 --> 00:44:20,960
ため

1193
00:44:20,960 --> 00:44:22,560
、

1194
00:44:22,560 --> 00:44:24,240


1195
00:44:24,240 --> 00:44:25,359
目標

1196
00:44:25,359 --> 00:44:28,560
またはどのように目標を設定する

1197
00:44:29,680 --> 00:44:30,640
ので

1198
00:44:30,640 --> 00:44:32,560


1199
00:44:32,560 --> 00:44:34,560
、それに対する明白な答えは、

1200
00:44:34,560 --> 00:44:36,880
そのええとを定義するエンジニア

1201
00:44:36,880 --> 00:44:39,359
ですが、

1202
00:44:39,359 --> 00:44:40,319


1203
00:44:40,319 --> 00:44:42,640
推論を行い、彼の目標を設定するより高いレベルのエージェントになることも

1204
00:44:42,640 --> 00:44:44,960


1205
00:44:45,040 --> 00:44:47,599
できるので、一種の

1206
00:44:47,599 --> 00:44:49,280
カメに到達します

1207
00:44:49,280 --> 00:44:51,520
ある意味では

1208
00:44:51,520 --> 00:44:53,760
、レイヤーをレイヤーごとに

1209
00:44:53,760 --> 00:44:55,760
配置し、レイヤーをそのレイヤーの目標として設定し、他のレイヤー

1210
00:44:55,760 --> 00:44:58,560
をそのレイヤーなどの目標として設定

1211
00:44:58,560 --> 00:44:59,760


1212
00:44:59,760 --> 00:45:03,280
することができ

1213
00:45:03,280 --> 00:45:06,160


1214
00:45:06,160 --> 00:45:08,240
ます。 エリアえ

1215
00:45:08,240 --> 00:45:10,240


1216
00:45:10,240 --> 00:45:11,920
えと、最終的には

1217
00:45:11,920 --> 00:45:14,400
自由エネルギーを最小化することになります。

1218
00:45:14,400 --> 00:45:16,720
そのため、これの中心的なテーマ

1219
00:45:16,720 --> 00:45:18,720
の一種であり、自由エネルギーを最小化したいと考えて

1220
00:45:18,720 --> 00:45:19,920


1221
00:45:19,920 --> 00:45:21,760
います。知覚によってそれを行います。

1222
00:45:21,760 --> 00:45:22,880


1223
00:45:22,880 --> 00:45:26,480
目標

1224
00:45:26,480 --> 00:45:28,480
は自由エネルギーを最小化することによって推進されるべきで

1225
00:45:28,480 --> 00:45:30,240


1226
00:45:30,240 --> 00:45:32,240
あるため、エネルギーを最小化する目標を選択する必要があります。どう

1227
00:45:32,240 --> 00:45:33,680
やってそれを

1228
00:45:33,680 --> 00:45:34,800
行うのかわかりません。

1229
00:45:34,800 --> 00:45:36,640


1230
00:45:36,640 --> 00:45:38,879


1231
00:45:41,280 --> 00:45:44,640


1232
00:45:44,640 --> 00:45:47,119


1233
00:45:47,119 --> 00:45:48,560
データベース

1234
00:45:48,560 --> 00:45:50,960
または大規模なデータセットは、この

1235
00:45:50,960 --> 00:45:52,640


1236
00:45:52,640 --> 00:45:54,319
種の経験的データを処理するためにスケーリングまたはすでに統合されているもの、

1237
00:45:54,319 --> 00:45:56,160
または

1238
00:45:56,160 --> 00:45:58,319


1239
00:45:58,319 --> 00:45:59,760


1240
00:45:59,760 --> 00:46:03,119
大規模なデータセットの意味に依存すると思う

1241
00:46:03,119 --> 00:46:04,000


1242
00:46:04,000 --> 00:46:04,800
ので

1243
00:46:04,800 --> 00:46:06,640
、大規模なデータセットを聞いたときに私は通常

1244
00:46:06,640 --> 00:46:09,200
考えます

1245
00:46:09,200 --> 00:46:11,200


1246
00:46:11,200 --> 00:46:13,359


1247
00:46:13,359 --> 00:46:16,800
このツールボックスは、データに

1248
00:46:16,800 --> 00:46:18,240


1249
00:46:18,240 --> 00:46:19,359


1250
00:46:19,359 --> 00:46:20,880
多くの機能があるという意味で、動的モデリング用に特別に構築されていますが、

1251
00:46:20,880 --> 00:46:23,440
信号

1252
00:46:23,440 --> 00:46:25,359
処理であるため、データが非常に迅速に受信される可能性があり、

1253
00:46:25,359 --> 00:46:27,280


1254
00:46:27,280 --> 00:46:28,720
その方法のモデルがあります。 これらのデータ

1255
00:46:28,720 --> 00:46:30,319
は時間の経過とともに変化する

1256
00:46:30,319 --> 00:46:31,119
ため

1257
00:46:31,119 --> 00:46:33,200
、その意味では、処理を

1258
00:46:33,200 --> 00:46:35,119
すばやく実行したいので、速度が必要です。

1259
00:46:35,119 --> 00:46:37,599
これは、ボリュームでは処理せず、速度で処理することに基づいてい

1260
00:46:37,599 --> 00:46:39,599
ます。

1261
00:46:39,599 --> 00:46:41,760


1262
00:46:41,760 --> 00:46:43,839
たとえば、他の問題のプログラミング

1263
00:46:43,839 --> 00:46:47,119
ツールボックスは

1264
00:46:47,119 --> 00:46:49,359
、トーチや その正しい

1265
00:46:49,359 --> 00:46:51,599
サンプリングベースのツールボックスのようなもの

1266
00:46:51,599 --> 00:46:53,359


1267
00:46:53,359 --> 00:46:56,640


1268
00:46:56,640 --> 00:46:58,400
は、データの観点からボリュームがあり、たとえば、あなたが

1269
00:46:58,400 --> 00:47:00,880
それをやりたいiidモデルを持っている場合、すべての優れたツールボックスを称賛します

1270
00:47:00,880 --> 00:47:03,040


1271
00:47:03,040 --> 00:47:04,960
大きなデータについて話す場合は、私たちの意味でumに適合させたい

1272
00:47:04,960 --> 00:47:06,720
ので、ボリュームについて話します。その

1273
00:47:06,720 --> 00:47:08,720
ため、非常に迅速にデータが入り、

1274
00:47:08,720 --> 00:47:11,599
そのum phony lab

1275
00:47:11,599 --> 00:47:14,640
が得意ではありませんが、

1276
00:47:14,640 --> 00:47:17,760
正直なところ、反応的なメッセージです。 通過

1277
00:47:17,760 --> 00:47:19,040
は

1278
00:47:19,040 --> 00:47:21,520


1279
00:47:22,240 --> 00:47:26,319
、そのような種類のデータセットの爆弾になります。

1280
00:47:26,640 --> 00:47:31,520


1281
00:47:31,520 --> 00:47:34,079


1282
00:47:34,079 --> 00:47:36,480
アクティブな影響力のあるエージェントを構築するためにこれらのツールボックスを構築しようとしていること

1283
00:47:36,480 --> 00:47:38,640
や、これらのエージェントをアクションを実行する環境に配置するという考えもあります。

1284
00:47:38,640 --> 00:47:40,800


1285
00:47:40,800 --> 00:47:44,000
彼らは独自のデータを選択する

1286
00:47:44,000 --> 00:47:47,119
ので、固定セットデータベースの機械学習を行うの

1287
00:47:47,119 --> 00:47:49,040
に本当に優れたツールボックスを構築しようとはし

1288
00:47:49,040 --> 00:47:51,359


1289
00:47:51,359 --> 00:47:54,160


1290
00:47:54,160 --> 00:47:56,720
ません

1291
00:47:56,720 --> 00:47:58,319


1292
00:47:58,319 --> 00:48:01,119
が、適応できてアクションを実行できる動的モデルなどのモデルを構築しよう

1293
00:48:01,119 --> 00:48:03,119
とします これにより、

1294
00:48:03,119 --> 00:48:06,559
ストリーミングデータをリアルタイムで処理

1295
00:48:06,559 --> 00:48:09,359
できます。その意味で、

1296
00:48:09,359 --> 00:48:11,599
十分に長く待つと、大量のデータストリーミング

1297
00:48:11,599 --> 00:48:13,760


1298
00:48:13,760 --> 00:48:16,880
が発生しますが、それはユーザーによって生成されたか

1299
00:48:16,880 --> 00:48:19,119
、少なくともエージェント自体の影響を受け

1300
00:48:19,119 --> 00:48:21,200
ます。

1301
00:48:21,200 --> 00:48:23,839
t 環境内でデータをストリーミング

1302
00:48:23,839 --> 00:48:29,200
するだけでなく、大規模な固定データベース向けに最適化し

1303
00:48:29,200 --> 00:48:32,559


1304
00:48:32,559 --> 00:48:34,480
てみてください。これは、自律運転など

1305
00:48:34,480 --> 00:48:36,640
の時間依存のタスクがたくさんあるため

1306
00:48:36,640 --> 00:48:39,040


1307
00:48:39,040 --> 00:48:42,160
、500テラバイトのビデオがあり

1308
00:48:42,160 --> 00:48:43,839
ます。これで、最高の結果が得られます。

1309
00:48:43,839 --> 00:48:45,280


1310
00:48:45,280 --> 00:48:48,800
タイムスナップショットで可能なスコア。

1311
00:48:48,800 --> 00:48:50,400
アクティブな

1312
00:48:50,400 --> 00:48:52,319
推論エージェントを使用するたび

1313
00:48:52,319 --> 00:48:54,880
に、ループにアクションとポリシーの選択が含まれます。

1314
00:48:54,880 --> 00:48:56,480
そのため、

1315
00:48:56,480 --> 00:48:58,400
どのように対処する

1316
00:48:58,400 --> 00:49:00,319
のでしょうか。しかし、それが

1317
00:49:00,319 --> 00:49:02,640
生物学的システムからのインスピレーションがそうなる理由です。 重要

1318
00:49:02,640 --> 00:49:04,559
なのは、人々がうまくいくとき

1319
00:49:04,559 --> 00:49:06,960
、脳はこの処理能力を持っている必要が

1320
00:49:06,960 --> 00:49:09,040
あり、それが電球である

1321
00:49:09,040 --> 00:49:10,559
か、この種のシリコン

1322
00:49:10,559 --> 00:49:11,839
コンピュータである場合、これだけの

1323
00:49:11,839 --> 00:49:14,160
エネルギーを消費するというようなものです。エルゴの効率はその

1324
00:49:14,160 --> 00:49:16,640
ようなものですが、それは すでに存在するものから始めて、tにある答えを探すのではなく、

1325
00:49:16,640 --> 00:49:18,720
私たちが見慣れている種類のコンピューターに基づいて

1326
00:49:18,720 --> 00:49:20,800


1327
00:49:20,800 --> 00:49:22,800
います

1328
00:49:22,800 --> 00:49:24,160


1329
00:49:24,160 --> 00:49:26,480


1330
00:49:26,480 --> 00:49:28,800
低電力トランジスタをどのように作成

1331
00:49:28,800 --> 00:49:31,040
して脳にフィットさせるかではなく

1332
00:49:31,040 --> 00:49:31,920


1333
00:49:31,920 --> 00:49:34,559


1334
00:49:34,559 --> 00:49:37,680
、次のプレゼンテーションの準備が

1335
00:49:39,440 --> 00:49:41,599
できていると

1336
00:49:41,599 --> 00:49:45,839


1337
00:49:47,920 --> 00:49:52,400
思います。 今は見栄えが良い

1338
00:49:52,400 --> 00:49:56,800
ので、私のスライドを見ることができます。

1339
00:49:56,800 --> 00:49:59,119
はい、わかりました。こんにちは、もう一度私の名前は

1340
00:49:59,119 --> 00:50:02,000
mitri bhagavです。7月のベイジアンインプリント用の

1341
00:50:02,000 --> 00:50:04,319
この新しいリアクティブメッセージパッシング

1342
00:50:04,319 --> 00:50:06,400
ベースのフレームワークのように紹介したいと思います。これ

1343
00:50:06,400 --> 00:50:08,880
は、リアクティブmpと呼ばれて

1344
00:50:08,880 --> 00:50:11,200
います。

1345
00:50:11,200 --> 00:50:14,079
アクティブな推論のソリューションに関する将来のビジョンfornilab.jlは、

1346
00:50:14,079 --> 00:50:15,680
それが機能する成熟したフレームワークのようなもので

1347
00:50:15,680 --> 00:50:18,800
あり、リアクティブmpは

1348
00:50:18,800 --> 00:50:22,720
今のところ私たちの研究プロジェクトで

1349
00:50:22,720 --> 00:50:24,400


1350
00:50:24,400 --> 00:50:25,520


1351
00:50:25,520 --> 00:50:27,359
あり、実際にリアクティブなメッセージ

1352
00:50:27,359 --> 00:50:28,400
バスティング

1353
00:50:28,400 --> 00:50:29,839
と

1354
00:50:29,839 --> 00:50:31,920
は何かという質問から始めます。 数式と同じメッセージが

1355
00:50:31,920 --> 00:50:34,960
渡されますが

1356
00:50:34,960 --> 00:50:37,680
、リアクティブパラダイムで再実装されるため、基本的

1357
00:50:37,680 --> 00:50:39,760


1358
00:50:39,760 --> 00:50:40,960
にポルノラボの従来のアプローチの主な問題

1359
00:50:40,960 --> 00:50:43,760
は、モデルの推論を実行できるようにすること

1360
00:50:43,760 --> 00:50:45,839
です。 この

1361
00:50:45,839 --> 00:50:48,480
メッセージの影を事前に作成

1362
00:50:48,480 --> 00:50:50,720
する必要があるため、グラフを事前に分析する

1363
00:50:50,720 --> 00:50:53,119
必要があります。基本的にすべてを分析する

1364
00:50:53,119 --> 00:50:55,200
必要があり、グラフ構造を変更するたびにそれを行う必要があり

1365
00:50:55,200 --> 00:50:57,200


1366
00:50:57,200 --> 00:51:00,480
ます。グラフが大きい場合は、このグラフ分析

1367
00:51:00,480 --> 00:51:02,319
時間と シャドウの作成には多く

1368
00:51:02,319 --> 00:51:04,240
の余分な

1369
00:51:04,240 --> 00:51:07,280
時間がかかる可能性があり、大きな問題ではないかもしれませんが

1370
00:51:07,280 --> 00:51:09,200
、エンジニアとして

1371
00:51:09,200 --> 00:51:11,359


1372
00:51:11,359 --> 00:51:14,079
、パフォーマンスとこの余分な遅延

1373
00:51:14,079 --> 00:51:16,079
とシャトルの作成時間に満足するまで、多くのモデルをテストする

1374
00:51:16,079 --> 00:51:19,680
ことをお勧めします。 最後に通過するちょっとした迷惑で反応的な

1375
00:51:19,680 --> 00:51:21,520
メッセージ

1376
00:51:21,520 --> 00:51:24,400
により、この事前定義されたシャドウを排除

1377
00:51:24,400 --> 00:51:26,240
できます。また、他の多くの利点

1378
00:51:26,240 --> 00:51:30,400
と将来の研究の方向性が得

1379
00:51:30,400 --> 00:51:32,880
られるため、

1380
00:51:32,880 --> 00:51:35,839
固定シャドウを使用する代わりに、グラフをイベントのようにキャストします。

1381
00:51:35,839 --> 00:51:37,760


1382
00:51:37,760 --> 00:51:39,520
すべてが

1383
00:51:39,520 --> 00:51:41,119
隣接環境

1384
00:51:41,119 --> 00:51:43,440
に反応し、メッセージパッシング

1385
00:51:43,440 --> 00:51:45,920
ノードが着信

1386
00:51:45,920 --> 00:51:48,319
メッセージに反応し、パラメータの更新された後方

1387
00:51:48,319 --> 00:51:50,800
周辺に反応するベースのシステム

1388
00:51:50,800 --> 00:51:53,760
dモデル全体がリアクティブになると

1389
00:51:53,760 --> 00:51:56,319
、このシステムの変更に反応し

1390
00:51:56,319 --> 00:51:58,960
、基本的に必要な

1391
00:51:58,960 --> 00:52:00,800
ことを実行できるため

1392
00:52:00,800 --> 00:52:04,800


1393
00:52:04,800 --> 00:52:07,680
、自然な開始点を通過するメッセージでも、新しい更新された後

1394
00:52:07,680 --> 00:52:11,280
縁に基づいて

1395
00:52:11,280 --> 00:52:14,400
アクションを実行できます。 モデル自体が

1396
00:52:14,400 --> 00:52:18,559
データまたは事前情報の変更に反応し

1397
00:52:18,559 --> 00:52:20,319
、それに応じて後継者も変更

1398
00:52:20,319 --> 00:52:23,040
される

1399
00:52:23,040 --> 00:52:26,480
ため、ここではアクティブメッセージパッシブ実装のいくつかの追加の利点について概説しまし

1400
00:52:26,480 --> 00:52:27,760


1401
00:52:27,760 --> 00:52:29,839
た。まず、

1402
00:52:29,839 --> 00:52:32,400
生物学的妥当

1403
00:52:32,400 --> 00:52:34,480
性について概説します。

1404
00:52:34,480 --> 00:52:36,800


1405
00:52:36,800 --> 00:52:39,440


1406
00:52:39,440 --> 00:52:41,520
たとえば、脳内の

1407
00:52:41,520 --> 00:52:43,920
ニューロンを流れる情報の事前定義されたスケジューラーは、物理学などの化学によって駆動され

1408
00:52:43,920 --> 00:52:46,960
、ある意味で

1409
00:52:46,960 --> 00:52:49,200


1410
00:52:49,200 --> 00:52:52,240
は、環境の変化に絶えず適応し、

1411
00:52:52,240 --> 00:52:55,599
必要な場合にのみ反応する反応システムのようなものです

1412
00:52:55,599 --> 00:52:57,359
。 メッセージパッシングベースの

1413
00:52:57,359 --> 00:52:59,520
推論の条件では、メッセージがそうでない場合、

1414
00:52:59,520 --> 00:53:02,400
一部のメッセージのような一部のイベントでさえ反応する必要

1415
00:53:02,400 --> 00:53:05,760
がない場合があります 非常に重要

1416
00:53:05,760 --> 00:53:08,240
です。事前定義された固定のシャドウ

1417
00:53:08,240 --> 00:53:10,480


1418
00:53:10,480 --> 00:53:13,280
は、実際には必要ない場合でも、すべての計算を実行する必要があります。

1419
00:53:13,280 --> 00:53:15,040
クラフトメッセージバスティングのもう1つの大きな利点は

1420
00:53:15,040 --> 00:53:17,040


1421
00:53:17,040 --> 00:53:19,599
、非常に大きなグラフに対して非常に適切にスケーリングされる

1422
00:53:19,599 --> 00:53:22,319
ため、以前の回答のようになります。 質問

1423
00:53:22,319 --> 00:53:24,559
ええと、それは数十万のファクターノートのようにサポートします数

1424
00:53:24,559 --> 00:53:26,800
百万

1425
00:53:26,800 --> 00:53:29,040
も可能ですええと

1426
00:53:29,040 --> 00:53:30,559
、数分で例を示し

1427
00:53:30,559 --> 00:53:32,800
ますが、少しコンテキストを与えるために、この

1428
00:53:32,800 --> 00:53:35,359
プロットでは、いくつかの動くオブジェクトをモデル化

1429
00:53:35,359 --> 00:53:38,559
しました 既知のライン線形ダイナミクス

1430
00:53:38,559 --> 00:53:40,559
とアイデアは、この例ではノイズの多い観測値が与えられた場合のセダン状態を推定することでした

1431
00:53:40,559 --> 00:53:43,520


1432
00:53:43,520 --> 00:53:45,520
。5

1433
00:53:45,520 --> 00:53:47,280
万の

1434
00:53:47,280 --> 00:53:49,680
観測値を持つカルマンスムーザーを使用しました。このモデルには

1435
00:53:49,680 --> 00:53:53,280
約15万の因子ノードが含まれている

1436
00:53:53,280 --> 00:53:55,040
ため、この種のモデルでのベイズ推定

1437
00:53:55,040 --> 00:53:57,839
はサンプリングでは不可能です。 ベースの

1438
00:53:57,839 --> 00:53:59,520
推論です

1439
00:53:59,520 --> 00:54:01,200
が、リアクティブメッセージパッシングを使用すると

1440
00:54:01,200 --> 00:54:03,119


1441
00:54:03,119 --> 00:54:06,480
、自宅のmacbookラップトップで約8秒しかかから

1442
00:54:06,480 --> 00:54:09,480


1443
00:54:10,559 --> 00:54:12,720
ないため、さらに少し進んでリアクティブsysを作成できます。

1444
00:54:12,720 --> 00:54:14,880


1445
00:54:14,880 --> 00:54:17,760
いくつかのノードに対して堅牢で耐性があり、たとえば、障害が発生したノードや障害が発生

1446
00:54:17,760 --> 00:54:18,960


1447
00:54:18,960 --> 00:54:21,760
したセンサーからのデータの欠落このような

1448
00:54:21,760 --> 00:54:23,920
ことが発生した場合は、事前定義されたシャドウを修正

1449
00:54:23,920 --> 00:54:25,440
し

1450
00:54:25,440 --> 00:54:27,200
ます。最初からすべてを実行する

1451
00:54:27,200 --> 00:54:29,280
必要があります。モデルを再作成する必要があり

1452
00:54:29,280 --> 00:54:31,839
ます。シャドウを再度作成する

1453
00:54:31,839 --> 00:54:34,240
必要があります。

1454
00:54:34,240 --> 00:54:36,960
リアクティブメッセージバスティングに少し時間がかかる

1455
00:54:36,960 --> 00:54:39,599
だけで、欠落しているデータ

1456
00:54:39,599 --> 00:54:42,160
や障害のあるセンサー

1457
00:54:42,160 --> 00:54:44,160
への反応を停止する可能性があります。また、それらが再び利用可能になるのを待つことが

1458
00:54:44,160 --> 00:54:46,160
できます。

1459
00:54:46,160 --> 00:54:48,319
その意味で非常に堅牢になり

1460
00:54:48,319 --> 00:54:50,799


1461
00:54:50,799 --> 00:54:53,440
、グラフを変更する機会も得られます。 実行時に構造化され、

1462
00:54:53,440 --> 00:54:55,440


1463
00:54:55,440 --> 00:54:57,920
停止

1464
00:54:58,880 --> 00:55:01,599
することなく推論を実行するため、ラボでジュリアのメインプログラミング言語を使用する実際の方法についてのスライドがあります。

1465
00:55:01,599 --> 00:55:02,720


1466
00:55:02,720 --> 00:55:04,799


1467
00:55:04,799 --> 00:55:07,920
約1年

1468
00:55:07,920 --> 00:55:09,839
半前

1469
00:55:09,839 --> 00:55:11,440
にジュリアでリアクティブプログラミング用のライブラリを作成した

1470
00:55:11,440 --> 00:55:13,599
ので、完全に

1471
00:55:13,599 --> 00:55:15,359


1472
00:55:15,359 --> 00:55:17,200
イベントベースのシステムの一般的なフレームワークでのメッセージパッシングとは関係あり

1473
00:55:17,200 --> 00:55:18,240


1474
00:55:18,240 --> 00:55:20,640
ませんが、後でリアクティブmp.jlパッケージを構築することができました。

1475
00:55:20,640 --> 00:55:24,160


1476
00:55:24,160 --> 00:55:25,680


1477
00:55:25,680 --> 00:55:29,359
メッセージパッシングによる自由エネルギーの最小化を実装します。

1478
00:55:29,359 --> 00:55:31,599
また、デモで使用

1479
00:55:31,599 --> 00:55:33,520
する高レベルでユーザーフレンドリーな

1480
00:55:33,520 --> 00:55:35,119
確率モデル仕様

1481
00:55:35,119 --> 00:55:38,640
言語である

1482
00:55:38,640 --> 00:55:41,040


1483
00:55:41,040 --> 00:55:43,119
graphpl.gelパッケージを導入

1484
00:55:43,119 --> 00:55:45,119
しました。 第二

1485
00:55:45,119 --> 00:55:47,599
に、あなたは私の画面を正しく見ることができます

1486
00:55:47,599 --> 00:55:49,119
うん、

1487
00:55:49,119 --> 00:55:53,040
多分少し大きいか2つ

1488
00:55:53,440 --> 00:55:56,799
は壊れないことを願っています

1489
00:55:56,799 --> 00:55:58,240
ええそれを少し大きくしてくださいそして

1490
00:55:58,240 --> 00:56:02,759
それが予期しないように見えるならあなたは

1491
00:56:02,799 --> 00:56:04,960
ここで大丈夫に

1492
00:56:04,960 --> 00:56:07,599
引き戻すことが

1493
00:56:07,599 --> 00:56:10,720
できます は私たちの例なので、

1494
00:56:10,720 --> 00:56:11,520
いくつかの

1495
00:56:11,520 --> 00:56:14,240
移動オブジェクトがあると仮定します。

1496
00:56:14,240 --> 00:56:16,079
それはいくつかの隠れた状態を持っており、単純化のために

1497
00:56:16,079 --> 00:56:18,400
線形ダイナミクスであることがわかっていると仮定し

1498
00:56:18,400 --> 00:56:21,200


1499
00:56:21,200 --> 00:56:23,359
ます。その場所に直接アクセスすることはできませ

1500
00:56:23,359 --> 00:56:25,200
んが、ノイズの多い観測があります。 この

1501
00:56:25,200 --> 00:56:26,480
移動オブジェクト

1502
00:56:26,480 --> 00:56:28,799
と、ノイズの多い測定値を観察

1503
00:56:28,799 --> 00:56:31,599
するだけでこの移動オブジェクトの実際の位置を推定したい

1504
00:56:31,599 --> 00:56:35,040


1505
00:56:35,040 --> 00:56:38,160
と考えています。方程式のような線形多変量ガウス状態空間モデルを使用すると、次の

1506
00:56:38,160 --> 00:56:41,119


1507
00:56:41,119 --> 00:56:44,000
ようになります。  e

1508
00:56:44,000 --> 00:56:46,480
同等の表記法は同じで

1509
00:56:46,480 --> 00:56:48,960
あり、基本的にここでは

1510
00:56:48,960 --> 00:56:52,400
、時間ステップkに状態xがあり、

1511
00:56:52,400 --> 00:56:54,400


1512
00:56:54,400 --> 00:56:55,920


1513
00:56:55,920 --> 00:56:58,400
線形演算子aを介した前の時間ステップにのみ依存し

1514
00:56:58,400 --> 00:57:00,880
、ガウス行列である遷移ノイズもあると言います。

1515
00:57:00,880 --> 00:57:03,599
共分散行列bを使用すると

1516
00:57:03,599 --> 00:57:06,000
、観測値は

1517
00:57:06,000 --> 00:57:07,200


1518
00:57:07,200 --> 00:57:10,319
基本的に共分散行列qを使用したガウス行列としてもモデル化される

1519
00:57:10,319 --> 00:57:11,040


1520
00:57:11,040 --> 00:57:12,960


1521
00:57:12,960 --> 00:57:15,520
ため、基本的にこれはモデル

1522
00:57:15,520 --> 00:57:17,599
であり、それから因子グラフを作成するだけ

1523
00:57:17,599 --> 00:57:19,440


1524
00:57:19,440 --> 00:57:21,040
で

1525
00:57:21,040 --> 00:57:22,240


1526
00:57:22,240 --> 00:57:25,359
済みます。モデルの仕様は

1527
00:57:25,359 --> 00:57:27,760
、 上で定義された方程式な

1528
00:57:27,760 --> 00:57:29,359
ので、ここ

1529
00:57:29,359 --> 00:57:32,240
に状態xkがあり、既知の共分散行列を使用して前の状態のガウスのようにモデル化され

1530
00:57:32,240 --> 00:57:35,040
ています。

1531
00:57:35,040 --> 00:57:38,240


1532
00:57:38,240 --> 00:57:40,400
これがモデルの構築方法

1533
00:57:40,400 --> 00:57:42,400
であり、この

1534
00:57:42,400 --> 00:57:45,359
コードの内部で因子グラフを生成します。

1535
00:57:45,359 --> 00:57:48,319
後ですべて、

1536
00:57:48,319 --> 00:57:49,359
リアクティブ

1537
00:57:49,359 --> 00:57:51,839
mp.jail apiを使用してシステムの隠れた状態を推定できます

1538
00:57:51,839 --> 00:57:54,000
が、これが例です。少しズームインしたためか、少し外れているように見えますが、問題はないと思います。

1539
00:57:54,000 --> 00:57:55,760


1540
00:57:55,760 --> 00:57:59,119


1541
00:57:59,119 --> 00:58:01,599


1542
00:58:01,599 --> 00:58:04,400
この例では

1543
00:58:04,400 --> 00:58:07,119
、500ポイントに対してカルマンスムーザーを実行し、

1544
00:58:07,119 --> 00:58:08,720


1545
00:58:08,720 --> 00:58:10,480
この移動オブジェクトの軌道を

1546
00:58:10,480 --> 00:58:13,359
2軸のx軸とy

1547
00:58:13,359 --> 00:58:14,880
軸に分解しました。

1548
00:58:14,880 --> 00:58:17,440
一般的なスムーザー

1549
00:58:17,440 --> 00:58:19,359
は、システムの実際の隠れた状態のように

1550
00:58:19,359 --> 00:58:21,599
正しく予測され

1551
00:58:21,599 --> 00:58:23,200
ていることがわかります。 システムに多くのノイズがある

1552
00:58:23,200 --> 00:58:25,440
ので、これらの青い点は

1553
00:58:25,440 --> 00:58:28,480
ノイズの多い観測

1554
00:58:28,480 --> 00:58:31,440
のようですが、これをさらに進めることができ

1555
00:58:31,440 --> 00:58:34,240
ます。システムはリアクティブであるため

1556
00:58:34,240 --> 00:58:37,760
、リアルタイムで状態を推定でき

1557
00:58:37,760 --> 00:58:38,799


1558
00:58:38,799 --> 00:58:41,839
ます。これが例です。 実行してみましょう。

1559
00:58:41,839 --> 00:58:43,839


1560
00:58:43,839 --> 00:58:46,319
私のコンピューターではスムーズに見える

1561
00:58:46,319 --> 00:58:48,559
といいのですが、実際には非常にスムーズです

1562
00:58:48,559 --> 00:58:51,200
が、

1563
00:58:51,200 --> 00:58:53,520
記録は画面共有のようにスムーズではないかもしれ

1564
00:58:53,520 --> 00:58:56,480
ませんが、この例

1565
00:58:56,480 --> 00:58:58,559
では、無限の

1566
00:58:58,559 --> 00:59:01,040
データストリームがあります。 動くオブジェクトの青

1567
00:59:01,040 --> 00:59:02,559
は実際のもので、赤は

1568
00:59:02,559 --> 00:59:05,440
推定値

1569
00:59:05,440 --> 00:59:07,760
です。それは一種の

1570
00:59:07,760 --> 00:59:10,559


1571
00:59:10,720 --> 00:59:13,680
オフであり、

1572
00:59:13,920 --> 00:59:16,160
リアクティブmpが実行でき、

1573
00:59:16,160 --> 00:59:18,640
ベイジアン推論が可能であることがわかります。  n

1574
00:59:18,640 --> 00:59:21,359
リアルタイムで、実際に環境の変化に適応

1575
00:59:21,359 --> 00:59:23,760


1576
00:59:23,760 --> 00:59:27,200
し、現在の推定

1577
00:59:27,200 --> 00:59:28,559
状態の後方も変化し

1578
00:59:28,559 --> 00:59:30,480
ます。さらに先に進むと、

1579
00:59:30,480 --> 00:59:32,880
このオレンジ色の線

1580
00:59:32,880 --> 00:59:35,520
が今のところ非アクティブになっていることに気付くでしょうが、このモデルの予測を組み込むこともできます。

1581
00:59:35,520 --> 00:59:38,640


1582
00:59:38,640 --> 00:59:41,440


1583
00:59:41,440 --> 00:59:44,160
グラフを少し拡張するだけ

1584
00:59:44,160 --> 00:59:47,280
で、このようにシステムの将来の状態を予測することもでき

1585
00:59:47,280 --> 00:59:49,119


1586
00:59:49,119 --> 00:59:50,240


1587
00:59:50,240 --> 00:59:52,799
ます。この例で

1588
00:59:52,799 --> 00:59:55,119
は、ベイズ推定をリアルタイムで実行し

1589
00:59:55,119 --> 00:59:57,760


1590
00:59:57,760 --> 01:00:00,160
、オレンジやオレンジのようにシステムの将来の状態も予測します。

1591
01:00:00,160 --> 01:00:02,319
予測

1592
01:00:02,319 --> 01:00:04,960
は新しい観測にも適応し、

1593
01:00:04,960 --> 01:00:08,240
基本的に将来の状態に対する将来の信念を変えることがわかります。ええ、それを

1594
01:00:08,240 --> 01:00:09,520


1595
01:00:09,520 --> 01:00:12,720


1596
01:00:12,720 --> 01:00:14,559


1597
01:00:14,559 --> 01:00:16,720
止めてプレゼンテーションを続けましょう。

1598
01:00:16,720 --> 01:00:19,439


1599
01:00:21,040 --> 01:00:23,119
そうですね

1600
01:00:23,119 --> 01:00:25,040


1601
01:00:25,040 --> 01:00:27,200
、リアクティブメッセージパッシングが

1602
01:00:27,200 --> 01:00:30,000
利用可能になったときのように話します。 実際に

1603
01:00:30,000 --> 01:00:32,480
は、すでに機能しています。正確で変化に富んだベイズ推定のための完全に機能する安定した

1604
01:00:32,480 --> 01:00:34,480
バックハンドとapi

1605
01:00:34,480 --> 01:00:36,799


1606
01:00:36,799 --> 01:00:39,280
がありますが、期待値の伝播もサポートしています。

1607
01:00:39,280 --> 01:00:44,079
apiはまだ安定していないため、変更される可能性があります。

1608
01:00:44,079 --> 01:00:46,799


1609
01:00:46,799 --> 01:00:48,960
指数ファミリの共役モデルのみ

1610
01:00:48,960 --> 01:00:50,799
をサポートします。

1611
01:00:50,799 --> 01:00:53,680


1612
01:00:53,680 --> 01:00:55,599
フォームまたは因数分解の制約など、バリエーション最適化手順の追加の制約をサポートし

1613
01:00:55,599 --> 01:00:56,880


1614
01:00:56,880 --> 01:00:59,440
ます。rocket.jlライブラリ

1615
01:00:59,440 --> 01:01:01,280


1616
01:01:01,280 --> 01:01:03,599
は、インターネットなどからの無限のデータストリームを自然にサポートします。 または、一部の

1617
01:01:03,599 --> 01:01:05,280
センサー

1618
01:01:05,280 --> 01:01:07,680
とフレームワーク自体は

1619
01:01:07,680 --> 01:01:09,280
欠落しているデータを処理できます

1620
01:01:09,280 --> 01:01:10,480
が、その

1621
01:01:10,480 --> 01:01:14,960
apiはまだ安定していません。

1622
01:01:16,079 --> 01:01:17,040


1623
01:01:17,040 --> 01:01:19,520
このプラットフォームの将来の計画の一部は、

1624
01:01:19,520 --> 01:01:22,400


1625
01:01:22,400 --> 01:01:24,720
非共役モデルをサポートするように拡張したいと考えています。

1626
01:01:24,720 --> 01:01:26,960
基本的に、外国のラボはすでにサポートしています。

1627
01:01:26,960 --> 01:01:28,079


1628
01:01:28,079 --> 01:01:30,319


1629
01:01:30,319 --> 01:01:32,160
利用可能な既存の機能をすべて、

1630
01:01:32,160 --> 01:01:35,599
外国のラボからリアクティブmp

1631
01:01:35,599 --> 01:01:37,680
に慎重に移植する必要があります。また

1632
01:01:37,680 --> 01:01:39,440


1633
01:01:39,440 --> 01:01:42,960
、7月のコミュニティの

1634
01:01:43,520 --> 01:01:45,359
リアクティブメッセージパッシングに存在する他の確率的プログラミングライブラリと

1635
01:01:45,359 --> 01:01:47,280


1636
01:01:47,280 --> 01:01:50,480
統合することで、並列推論を統合し

1637
01:01:50,480 --> 01:01:52,079
て反応する機会が得られます。 マルチコア機能の

1638
01:01:52,079 --> 01:01:53,920
ようなものを同時に使用してグラフのさまざまな部分

1639
01:01:53,920 --> 01:01:57,280
o 私たちのcpus

1640
01:01:57,280 --> 01:01:58,079
ええと

1641
01:01:58,079 --> 01:01:59,839


1642
01:01:59,839 --> 01:02:02,640


1643
01:02:02,640 --> 01:02:04,880
、今のところモジュラーモデル仕様をサポートするためにグラフpplを拡張したいのですが、残念ながら

1644
01:02:04,880 --> 01:02:07,839
不可能です。

1645
01:02:08,960 --> 01:02:11,200
また、リアクティブメッセージの受け渡し

1646
01:02:11,200 --> 01:02:13,039
は

1647
01:02:13,039 --> 01:02:15,280
、さまざまなデータストリームの更新レートが異なる場合に推論を実行する機会を自然に与えます。

1648
01:02:15,280 --> 01:02:19,280


1649
01:02:19,280 --> 01:02:21,359


1650
01:02:21,359 --> 01:02:22,960


1651
01:02:22,960 --> 01:02:25,520
堅牢性については最初からですが、

1652
01:02:25,520 --> 01:02:27,920
それをどこまでプッシュできるかということも興味深いです。

1653
01:02:27,920 --> 01:02:30,319
おそらく、自由エネルギーに基づいて実行時に

1654
01:02:30,319 --> 01:02:32,480
モデルのグラフ構造を自動的に適応させる

1655
01:02:32,480 --> 01:02:35,039


1656
01:02:35,039 --> 01:02:37,520


1657
01:02:38,000 --> 01:02:39,839


1658
01:02:39,839 --> 01:02:41,520
ことが可能ですが、それが可能かどうかは本当にわからない研究プロジェクトのようなもの

1659
01:02:41,520 --> 01:02:43,599
です。 今、

1660
01:02:43,599 --> 01:02:45,440
私たちは

1661
01:02:45,440 --> 01:02:47,280
メッセージ

1662
01:02:47,280 --> 01:02:49,359
パッシングベースのアルゴリズムのインタラクティブな視覚化

1663
01:02:49,359 --> 01:02:50,960
と自由エネルギー最小化の

1664
01:02:50,960 --> 01:02:53,520
視覚化についていくつかのアイデアを持っています、

1665
01:02:53,520 --> 01:02:56,400
そして最終的に私たちは

1666
01:02:56,400 --> 01:02:58,799
この新しいプラットフォームをおそらく2.0で数式の安定したバージョンとしてリリースすることを計画し

1667
01:02:58,799 --> 01:03:01,280


1668
01:03:01,280 --> 01:03:03,200
ています

1669
01:03:03,200 --> 01:03:05,280
そしてそれは基本的に私

1670
01:03:05,280 --> 01:03:07,039
があなたに見せたかったすべてです 私のスライドで、

1671
01:03:07,039 --> 01:03:08,319
あなたの注意に感謝します私は

1672
01:03:08,319 --> 01:03:12,079
あなたの質問に喜んで答えるでしょう ons

1673
01:03:13,760 --> 01:03:16,640
素晴らしい最初の質問は

1674
01:03:16,640 --> 01:03:18,680
、このreactivemp.jlに関する論文があり

1675
01:03:18,680 --> 01:03:22,720
ますか、それはどのように機能しますか？

1676
01:03:22,720 --> 01:03:25,760


1677
01:03:25,760 --> 01:03:27,920


1678
01:03:27,920 --> 01:03:30,240


1679
01:03:30,240 --> 01:03:31,920


1680
01:03:31,920 --> 01:03:33,599


1681
01:03:33,599 --> 01:03:36,960
それがどのように機能し、どのように使用するかすべて

1682
01:03:36,960 --> 01:03:39,039
です。もちろん、誰かが紙の

1683
01:03:39,039 --> 01:03:41,599
早期コピーを希望するメールを

1684
01:03:41,599 --> 01:03:44,240
私たちに書いてくれたら、それ

1685
01:03:44,240 --> 01:03:45,599
が

1686
01:03:45,599 --> 01:03:49,359
秘密にされていれば喜んで共有し

1687
01:03:49,520 --> 01:03:50,799
ます。

1688
01:03:50,799 --> 01:03:51,920


1689
01:03:51,920 --> 01:03:54,559


1690
01:03:54,559 --> 01:03:55,760


1691
01:03:55,760 --> 01:03:56,799


1692
01:03:56,799 --> 01:03:58,480


1693
01:03:58,480 --> 01:04:01,839
フォーニーラボの他のエポックが

1694
01:04:01,839 --> 01:04:02,799


1695
01:04:02,799 --> 01:04:05,440
どのようにしてこのリアクティブプログラミングパラダイムに到達したかなど、他の著者にとって非常に興味深い開発でした。

1696
01:04:05,440 --> 01:04:07,200
また、リアクティブプログラミングに関するラボ

1697
01:04:07,200 --> 01:04:09,039
での基本的な作業の多くを行ったようです。

1698
01:04:09,039 --> 01:04:10,480


1699
01:04:10,480 --> 01:04:13,039


1700
01:04:13,039 --> 01:04:14,400
ジュリアの

1701
01:04:14,400 --> 01:04:17,119
実装またはより概念的な

1702
01:04:17,119 --> 01:04:19,599
根拠のあるええと

1703
01:04:19,599 --> 01:04:20,559


1704
01:04:20,559 --> 01:04:22,559


1705
01:04:22,559 --> 01:04:24,720
、ジュリアでリアクティブプログラミングをサポートするために実際に多くの作業を行っ

1706
01:04:24,720 --> 01:04:28,559
たということです。基本的にジュリアは若い言語のようなものであり、

1707
01:04:28,559 --> 01:04:30,960


1708
01:04:30,960 --> 01:04:33,839


1709
01:04:33,839 --> 01:04:36,960
システムのようにリアクティブベースを実行するための優れた機能があるので、基本的には

1710
01:04:36,960 --> 01:04:39,599
ゼロから構築します

1711
01:04:39,599 --> 01:04:42,640
が

1712
01:04:42,640 --> 01:04:43,760


1713
01:04:43,760 --> 01:04:46,240
、他のプログラミング言語のアイデアを使って、私たちが経験した他のプログラミング言語のアイデアを使用しました。

1714
01:04:46,240 --> 01:04:50,240


1715
01:04:53,200 --> 01:04:55,119
つまり、アクティブな影響力のある

1716
01:04:55,119 --> 01:04:57,200
コミュニティ

1717
01:04:57,200 --> 01:05:00,559
uhmatlabと matlabは素晴らしいです

1718
01:05:00,559 --> 01:05:02,160
が

1719
01:05:02,160 --> 01:05:05,280


1720
01:05:05,280 --> 01:05:09,119
、ストリーミングデータのリアルタイム処理が必要な場合

1721
01:05:09,119 --> 01:05:10,720
は、juliaが非常に

1722
01:05:10,720 --> 01:05:13,839
優れたオプションです。これは、juliaがユーザーの観点

1723
01:05:13,839 --> 01:05:16,480
からmatlabの構文をほぼ備えているためです

1724
01:05:16,480 --> 01:05:17,680


1725
01:05:17,680 --> 01:05:19,039


1726
01:05:19,039 --> 01:05:21,520
が、箱から出してすぐに使用できるのとほぼ同じです。

1727
01:05:21,520 --> 01:05:23,119


1728
01:05:23,119 --> 01:05:25,920
cしたがって

1729
01:05:25,920 --> 01:05:27,680
、エンジニアリングを行っていて、

1730
01:05:27,680 --> 01:05:29,280
実際

1731
01:05:29,280 --> 01:05:31,599
にリアルタイムで実行されるシステムを構築

1732
01:05:31,599 --> 01:05:34,640
したい場合は、デモを作成したい場合に適した組み合わせでした。ジュリアはより優れた

1733
01:05:34,640 --> 01:05:37,920
言語です。また、ディミトリはジュリアで

1734
01:05:37,920 --> 01:05:41,760
非常に高度なものを利用しています。

1735
01:05:41,760 --> 01:05:43,280
これはマルチディスパッチと呼ばれますが、それ

1736
01:05:43,280 --> 01:05:44,720
が何であるかは関係ありません

1737
01:05:44,720 --> 01:05:46,960
が、それは非常に高度

1738
01:05:46,960 --> 01:05:48,160
であり

1739
01:05:48,160 --> 01:05:51,359
、MATLABでは利用できませんが、

1740
01:05:51,359 --> 01:05:53,760
私たちが行うことには非常に役立ち

1741
01:05:53,760 --> 01:05:55,520
ます

1742
01:05:55,520 --> 01:05:59,039
ツールボックス

1743
01:05:59,039 --> 01:06:01,599
グラフとメッセージ

1744
01:06:01,599 --> 01:06:04,240
パッシングを見ると、

1745
01:06:04,240 --> 01:06:05,680
実際には実装はそれほど難しくないように見え

1746
01:06:05,680 --> 01:06:07,839


1747
01:06:07,839 --> 01:06:09,359


1748
01:06:09,359 --> 01:06:11,680
ますが、ファクターグラフ用のツールボックスが非常に少ないのには理由があり

1749
01:06:11,680 --> 01:06:14,880
ます。マイクロソフトが1つの

1750
01:06:14,880 --> 01:06:18,640
推論を作成しました。  .netは素晴らしいですが、

1751
01:06:18,640 --> 01:06:21,200
実際にはリアルタイムのツール

1752
01:06:21,200 --> 01:06:24,799
ボックスでは

1753
01:06:24,799 --> 01:06:26,400
ありません。

1754
01:06:26,400 --> 01:06:28,079
現時点

1755
01:06:28,079 --> 01:06:30,240
では、ツールボックスが非常に高度であるということではなく、競争はあまり

1756
01:06:30,240 --> 01:06:31,359
ありませんが、

1757
01:06:31,359 --> 01:06:33,680
私にはわかりません。

1758
01:06:33,680 --> 01:06:36,720
これに取り組んでいる多くの人々私は多くの人々がマルチカーターサンプリングに取り組んでいるのを見ます

1759
01:06:36,720 --> 01:06:38,799
が、マルチカー

1760
01:06:38,799 --> 01:06:41,359
サンプリング

1761
01:06:41,359 --> 01:06:43,920
はシステムのサイズと私たちが取り組んでいるアクティブな推論

1762
01:06:43,920 --> 01:06:45,680
でやりたいリアルタイムデータストリームには機能しません

1763
01:06:45,680 --> 01:06:48,480


1764
01:06:48,480 --> 01:06:50,079


1765
01:06:50,079 --> 01:06:53,119
アクションを実行してデータに影響を与えたいシステムな

1766
01:06:53,119 --> 01:06:55,359
ので、これはリアルタイムシステム

1767
01:06:55,359 --> 01:06:56,240


1768
01:06:56,240 --> 01:06:59,119


1769
01:06:59,119 --> 01:07:01,520
です。実際にスケールアップしたいので、

1770
01:07:01,520 --> 01:07:02,640


1771
01:07:02,640 --> 01:07:05,039


1772
01:07:05,039 --> 01:07:06,640


1773
01:07:06,640 --> 01:07:09,599
メッセージパッシングを自動化する非常に高品質のプロフェッショナルツールボックスを構築する必要があります。

1774
01:07:09,599 --> 01:07:12,160
ええと、それらのツールボックスの1つで

1775
01:07:12,160 --> 01:07:13,839
あり、うまくいけば他の

1776
01:07:13,839 --> 01:07:15,280
ツールボックスにもなりますが、

1777
01:07:15,280 --> 01:07:18,400
そういうわけで

1778
01:07:18,400 --> 01:07:21,760


1779
01:07:21,760 --> 01:07:23,440


1780
01:07:23,440 --> 01:07:25,119


1781
01:07:25,119 --> 01:07:27,200
、数学とプログラミングとコンピュータ

1782
01:07:27,200 --> 01:07:28,880
サイエンスの側面、そしてアクティブな

1783
01:07:28,880 --> 01:07:32,559
推論の側面の間の対話は、それぞれが持っているもののようでした。

1784
01:07:32,559 --> 01:07:34,240


1785
01:07:34,240 --> 01:07:36,240


1786
01:07:36,240 --> 01:07:38,480
アクティブな推論のリアルタイムの洞察の一部がアルゴリズム

1787
01:07:38,480 --> 01:07:40,319
の設計に戻って伝播しているように聞こえるので、副次的な貢献があります。それから、

1788
01:07:40,319 --> 01:07:42,559


1789
01:07:42,559 --> 01:07:44,319
両方の

1790
01:07:44,319 --> 01:07:46,480


1791
01:07:46,480 --> 01:07:48,880
方向がわかります。

1792
01:07:49,359 --> 01:07:52,720


1793
01:07:52,720 --> 01:07:54,960
私の観点からすると、この質問に答えることもできます。私は

1794
01:07:54,960 --> 01:07:57,200
プログラミング

1795
01:07:57,200 --> 01:07:59,039


1796
01:07:59,039 --> 01:08:02,000
をするのが好きですが、ラボの数学者とのこの絶え間ない対話が好きなので、毎回新しいことを

1797
01:08:02,000 --> 01:08:03,359


1798
01:08:03,359 --> 01:08:05,920


1799
01:08:05,920 --> 01:08:07,440
学びます。たとえば、毎日新しいことを学びます。

1800
01:08:07,440 --> 01:08:10,400
もちろん、それは

1801
01:08:10,400 --> 01:08:13,200
私たちのソフトウェアの設計選択のように反映されている

1802
01:08:13,200 --> 01:08:16,158
ので、一種ですが、

1803
01:08:16,158 --> 01:08:18,640
この高レベルの数学的アイデアを実際に適合させるのは非常に難しい場合があります

1804
01:08:18,640 --> 01:08:21,040


1805
01:08:21,040 --> 01:08:22,560
実装

1806
01:08:22,560 --> 01:08:25,120
とそれを効率化するのは非常に難しい

1807
01:08:25,120 --> 01:08:26,799


1808
01:08:26,799 --> 01:08:28,960
ので、

1809
01:08:31,359 --> 01:08:34,319
ええ、私たちはこのumで終わっていません。

1810
01:08:34,319 --> 01:08:37,040
つまり、ツールボックス

1811
01:08:37,040 --> 01:08:39,040
は誰でも利用でき、

1812
01:08:39,040 --> 01:08:41,198
すべての素晴らしい地域の例では、

1813
01:08:41,198 --> 01:08:44,080
基本的なサーモスタット、ティックタックトー、そしてそれは

1814
01:08:44,080 --> 01:08:46,080
すべて機能します 非常にスムーズ

1815
01:08:46,080 --> 01:08:48,318


1816
01:08:49,198 --> 01:08:51,519


1817
01:08:51,759 --> 01:08:54,158
です。リアクティブメッセージ

1818
01:08:54,158 --> 01:08:55,679
パッシングを使用すると、

1819
01:08:55,679 --> 01:08:56,880


1820
01:08:56,880 --> 01:08:59,359
これを深刻なアプリケーションにスケールアップするためのパスを実際に知ることができます。

1821
01:08:59,359 --> 01:09:00,719


1822
01:09:00,719 --> 01:09:02,560
つまり、私たちは本当に何かを行うシステム

1823
01:09:02,560 --> 01:09:04,158
を構築したいエンジニアリンググループです。

1824
01:09:04,158 --> 01:09:06,799


1825
01:09:06,799 --> 01:09:09,198
便利な私は補聴器会社でも働いている

1826
01:09:09,198 --> 01:09:12,640
ので、リアルタイムのオーディオ処理アルゴリズムを構築したい

1827
01:09:12,640 --> 01:09:16,479


1828
01:09:16,479 --> 01:09:17,359


1829
01:09:17,359 --> 01:09:18,960
と思っています。他の人はこれをロボット工学に使用したいと思うかもしれません。

1830
01:09:18,960 --> 01:09:21,439


1831
01:09:21,439 --> 01:09:24,399
そうですが

1832
01:09:24,399 --> 01:09:26,479
、リアルタイムモデルでは機能しません。

1833
01:09:26,479 --> 01:09:28,399


1834
01:09:28,399 --> 01:09:31,679
ええ、すべてのマルチカードか

1835
01:09:31,679 --> 01:09:33,600
何かで少しですので、

1836
01:09:33,600 --> 01:09:36,080
これは私たちの努力です

1837
01:09:36,080 --> 01:09:38,560
、そしてそれは私たちのグループで私

1838
01:09:38,560 --> 01:09:40,560


1839
01:09:40,560 --> 01:09:42,880
たちが持っている非常に学際的な努力であるため、かなり長い時間がかかります

1840
01:09:42,880 --> 01:09:46,000
私たちは数学者

1841
01:09:46,000 --> 01:09:47,279
と

1842
01:09:47,279 --> 01:09:49,120
神経質です 生物

1843
01:09:49,120 --> 01:09:51,359
学者やコンピューター科学者は難しいので、アクティブな推論の

1844
01:09:51,359 --> 01:09:53,439


1845
01:09:53,439 --> 01:09:55,520


1846
01:09:55,520 --> 01:09:57,199


1847
01:09:57,199 --> 01:09:59,360
ための優れたツールボックスを構築するために必要なさまざまな専門知識がたくさんある

1848
01:09:59,360 --> 01:10:02,880


1849
01:10:02,880 --> 01:10:04,640
ので

1850
01:10:04,640 --> 01:10:06,159


1851
01:10:06,159 --> 01:10:08,080


1852
01:10:08,080 --> 01:10:09,679
、アクティブな

1853
01:10:09,679 --> 01:10:11,840
推論コミュニティと

1854
01:10:11,840 --> 01:10:13,840
私たちがコミュニティで行っている工学は

1855
01:10:13,840 --> 01:10:15,840
、生物学のモデルとして

1856
01:10:15,840 --> 01:10:18,560
のエネルギー原理と能動的推論を生物学的システムに正しく説明することに主

1857
01:10:18,560 --> 01:10:20,239


1858
01:10:20,239 --> 01:10:21,840


1859
01:10:21,840 --> 01:10:24,000


1860
01:10:24,000 --> 01:10:25,440
に関心

1861
01:10:25,440 --> 01:10:26,960
があります。自然には物事を効率的に行う特定の方法

1862
01:10:26,960 --> 01:10:28,840
が

1863
01:10:28,840 --> 01:10:30,800


1864
01:10:30,800 --> 01:10:32,719
ありますが、これが そのためのモデルを作成

1865
01:10:32,719 --> 01:10:34,320
するのも良い考えです。それ

1866
01:10:34,320 --> 01:10:36,000
をエンジニアリング

1867
01:10:36,000 --> 01:10:37,920
に取り入れることもお勧めです。アクティブ

1868
01:10:37,920 --> 01:10:40,000
な推論コミュニティで利用できるアイデアを取り入れて、

1869
01:10:40,000 --> 01:10:41,199


1870
01:10:41,199 --> 01:10:43,360
脳を説明し、

1871
01:10:43,360 --> 01:10:45,120
脳について考え、

1872
01:10:45,120 --> 01:10:47,120
どうすればよいかを考えます。 これらの

1873
01:10:47,120 --> 01:10:48,320
アイデアを取り入れて

1874
01:10:48,320 --> 01:10:49,120


1875
01:10:49,120 --> 01:10:53,440
、エンジニアリングシステム

1876
01:10:53,440 --> 01:10:56,320
を構築するために使用してください。そう、それがメインのようなものだと思います。

1877
01:10:56,320 --> 01:10:57,920
それとうまくいけば、コミュニティとの間の主な相互作用は

1878
01:10:57,920 --> 01:11:00,800


1879
01:11:00,800 --> 01:11:02,719
、コミュニティが彼らの研究でも使用できるツールを構築し、

1880
01:11:02,719 --> 01:11:06,080
最終

1881
01:11:07,199 --> 01:11:09,520
的に私が考えさせられ

1882
01:11:09,520 --> 01:11:11,840
たのは、信号処理をリアルタイムのイベントとして見たり、見たりするなどの主要な課題のいくつかを実際に再構成したことでした

1883
01:11:11,840 --> 01:11:14,080


1884
01:11:14,080 --> 01:11:16,000


1885
01:11:16,000 --> 01:11:16,800


1886
01:11:16,800 --> 01:11:18,960
アクション

1887
01:11:18,960 --> 01:11:21,440
と将来のデータとの因果関係問題のこれらすべての種類の

1888
01:11:21,440 --> 01:11:24,080
リフレーミング

1889
01:11:24,080 --> 01:11:26,239
アクティブな推論

1890
01:11:26,239 --> 01:11:27,600
アルゴリズム

1891
01:11:27,600 --> 01:11:31,199
が大規模なマトリックスを実行するのと

1892
01:11:31,199 --> 01:11:34,080
は異なり、それ自体は非常に単純であるかどうかはわかりません

1893
01:11:34,080 --> 01:11:35,760
が、実際に

1894
01:11:35,760 --> 01:11:38,480
はアクションの埋め込みでのリフレーミングです

1895
01:11:38,480 --> 01:11:39,440


1896
01:11:39,440 --> 01:11:42,080
スケーリングを解決するすべてのステップ内

1897
01:11:42,080 --> 01:11:44,000
で、スケーリングの課題のいくつかは、レジリエンスの課題のいくつかを解決し

1898
01:11:44,000 --> 01:11:45,440


1899
01:11:45,440 --> 01:11:47,040


1900
01:11:47,040 --> 01:11:49,040
ます。これは、都市の交通ネットワークのレジリエンスのように、

1901
01:11:49,040 --> 01:11:50,000


1902
01:11:50,000 --> 01:11:51,600
サンプリングを行う

1903
01:11:51,600 --> 01:11:53,440
か、展開する動的プロセスである何かを取得してから

1904
01:11:53,440 --> 01:11:55,520
展開しようとするためです。 静的に100万

1905
01:11:55,520 --> 01:11:58,080
回繰り返されるので

1906
01:11:58,080 --> 01:12:00,080


1907
01:12:00,080 --> 01:12:01,360


1908
01:12:01,360 --> 01:12:02,880
、ループ内の計算はhではありません。 挑戦する必要があり

1909
01:12:02,880 --> 01:12:05,520
ますそれは、

1910
01:12:05,520 --> 01:12:07,520
優先順位付けのアクションの再構成が

1911
01:12:07,520 --> 01:12:08,960


1912
01:12:08,960 --> 01:12:11,280
、スケーリングとリアルタイム容量のこれらの道を進むことになっただけです

1913
01:12:11,280 --> 01:12:14,400


1914
01:12:14,400 --> 01:12:16,640
ええ、私は

1915
01:12:16,640 --> 01:12:18,800
おそらく私が取り組んでいるものの文脈でそれについて何かを言うことができるという考えが好きです

1916
01:12:18,800 --> 01:12:20,560


1917
01:12:20,560 --> 01:12:22,800


1918
01:12:22,800 --> 01:12:24,880
基本的に私は[音楽]に取り組んでいる補聴器エンジニアです。

1919
01:12:24,880 --> 01:12:25,860


1920
01:12:25,860 --> 01:12:27,120


1921
01:12:27,120 --> 01:12:29,120
補聴器エンジニアに信号処理エンジニアに依頼すると、あなたの

1922
01:12:29,120 --> 01:12:31,040


1923
01:12:31,040 --> 01:12:32,480


1924
01:12:32,480 --> 01:12:34,320
仕事は最高の

1925
01:12:34,320 --> 01:12:36,400
補聴器アルゴリズム

1926
01:12:36,400 --> 01:12:37,600
を構築

1927
01:12:37,600 --> 01:12:39,600


1928
01:12:39,600 --> 01:12:41,920
すること

1929
01:12:41,920 --> 01:12:44,159
です。 補聴器のクライアントが店に行っ

1930
01:12:44,159 --> 01:12:46,719
て補聴器を購入するのはたいてい

1931
01:12:46,719 --> 01:12:48,640
とても幸せで外出してから

1932
01:12:48,640 --> 01:12:50,880
2週間後にレストランに座ります。

1933
01:12:50,880 --> 01:12:52,400


1934
01:12:52,400 --> 01:12:54,960


1935
01:12:54,960 --> 01:12:57,520
ノイズがあり、これは予期

1936
01:12:57,520 --> 01:13:00,480
していなかったため、彼女ができることは何もありませ

1937
01:13:00,480 --> 01:13:02,960
ん。 クライアントに補聴器のパラメータをいじるように依頼することはできない

1938
01:13:02,960 --> 01:13:05,199


1939
01:13:05,199 --> 01:13:06,560


1940
01:13:06,560 --> 01:13:08,480
ので、

1941
01:13:08,480 --> 01:13:09,760
これが

1942
01:13:09,760 --> 01:13:11,679
数回発生した

1943
01:13:11,679 --> 01:13:13,760
場合、彼女は投げるか、

1944
01:13:13,760 --> 01:13:16,400
補聴器を引き出しに入れます。

1945
01:13:16,400 --> 01:13:19,199
実際、補聴器の約10〜20％

1946
01:13:19,199 --> 01:13:20,880
は非常に

1947
01:13:20,880 --> 01:13:21,910
高価で、

1948
01:13:21,910 --> 01:13:23,520
[音楽]

1949
01:13:23,520 --> 01:13:24,400
20

1950
01:13:24,400 --> 01:13:27,040
は本当に悲しい統計として使用されていない

1951
01:13:27,040 --> 01:13:28,960


1952
01:13:28,960 --> 01:13:31,040
ので、

1953
01:13:31,040 --> 01:13:32,960
それを裏返して

1954
01:13:32,960 --> 01:13:35,040
、本当の補聴器は何であるかを大丈夫と言うことができます。 デザインの

1955
01:13:35,040 --> 01:13:36,560
問題本当の補聴器のデザインの

1956
01:13:36,560 --> 01:13:39,280
問題は、補聴器を持って誰かを送り出す

1957
01:13:39,280 --> 01:13:41,440
ことですが、彼女がレストランのフィールドで不満を持っているとき、あなたはどうしますか？

1958
01:13:41,440 --> 01:13:43,679


1959
01:13:43,679 --> 01:13:46,320


1960
01:13:46,320 --> 01:13:48,320


1961
01:13:48,320 --> 01:13:49,360


1962
01:13:49,360 --> 01:13:52,080


1963
01:13:52,080 --> 01:13:54,080
私は幸せです。今、このエージェントは

1964
01:13:54,080 --> 01:13:55,679
行動を起こし、彼女

1965
01:13:55,679 --> 01:13:58,239
にとって最も興味深い新しいパラメータ設定を与える必要があります。

1966
01:13:58,239 --> 01:14:00,719


1967
01:14:00,719 --> 01:14:02,239
そして、

1968
01:14:02,239 --> 01:14:04,480
情報探索

1969
01:14:04,480 --> 01:14:07,040
と目標駆動型のゴールドリベンが

1970
01:14:07,040 --> 01:14:08,719
彼女を幸せにしている

1971
01:14:08,719 --> 01:14:10,320
ので、最高の妥協点があります。

1972
01:14:10,320 --> 01:14:12,960
私の視点から見たデザイン

1973
01:14:12,960 --> 01:14:16,159
は、彼女が不幸なときに補聴器の提案を行うアクションを作成するエージェントを構築すること

1974
01:14:16,159 --> 01:14:18,800


1975
01:14:18,800 --> 01:14:20,800


1976
01:14:20,800 --> 01:14:22,320
です。彼女が正しければ、

1977
01:14:22,320 --> 01:14:24,159
彼女は不幸であり、混合提案を聞くと、それ

1978
01:14:24,159 --> 01:14:25,920
は良くありません。

1979
01:14:25,920 --> 01:14:28,000
gentは別の提案

1980
01:14:28,000 --> 01:14:30,159
をしますが、それは大丈夫です。それから

1981
01:14:30,159 --> 01:14:32,159
先に進み、おそらく1週間後に

1982
01:14:32,159 --> 01:14:35,600
同じイベントが続きます。これは継続的に続き

1983
01:14:35,600 --> 01:14:38,719
ますが、少なくとも時間の経過とともに

1984
01:14:38,719 --> 01:14:41,120
改善を続けるための手順があります。

1985
01:14:41,120 --> 01:14:44,000


1986
01:14:44,000 --> 01:14:45,360
これ

1987
01:14:45,360 --> 01:14:48,159
が本物です。 設計の問題

1988
01:14:48,159 --> 01:14:52,239
は、c2のフィールドでのアクションであり、

1989
01:14:52,239 --> 01:14:53,600


1990
01:14:53,600 --> 01:14:56,000
現在起こっていることとは大きく異なります。これは、環境にないモデルを

1991
01:14:56,000 --> 01:14:58,159
上にして机に座っている補聴器エンジニア

1992
01:14:58,159 --> 01:15:01,920


1993
01:15:01,920 --> 01:15:04,400
であるため、パラダイムシフト

1994
01:15:04,400 --> 01:15:07,760
とアクティブな推論です。 エージェント

1995
01:15:07,760 --> 01:15:09,679
はそれを実現できるかもしれませんし、

1996
01:15:09,679 --> 01:15:10,960


1997
01:15:10,960 --> 01:15:12,640


1998
01:15:12,640 --> 01:15:14,560


1999
01:15:14,560 --> 01:15:16,719
信号処理設計のようなものの要点を作成

2000
01:15:16,719 --> 01:15:18,400


2001
01:15:18,400 --> 01:15:19,920
できる

2002
01:15:19,920 --> 01:15:21,679
と思います。それは、神経科学者のときに考えていることではないことを知って

2003
01:15:21,679 --> 01:15:23,520
いますが、これはエンジニアリングにとって大きな意味を持つ可能性が

2004
01:15:23,520 --> 01:15:25,440


2005
01:15:25,440 --> 01:15:27,040
あります。 信号処理だけで

2006
01:15:27,040 --> 01:15:29,120
なく、さまざまな工学分野でも使用されている

2007
01:15:29,120 --> 01:15:31,120


2008
01:15:31,120 --> 01:15:32,960
ため、時間の経過とともに、さまざまな分野

2009
01:15:32,960 --> 01:15:35,280
からの人々が増えると思います。

2010
01:15:35,280 --> 01:15:37,360
この分野

2011
01:15:37,360 --> 01:15:41,040
は、

2012
01:15:41,040 --> 01:15:42,480
アクティブな推論と自由エネルギーの

2013
01:15:42,480 --> 01:15:43,920
原則に関心を持っ

2014
01:15:43,920 --> 01:15:47,360


2015
01:15:47,360 --> 01:15:49,199
ています。神経科学者ではないのですが、

2016
01:15:49,199 --> 01:15:50,840
エンジニアは

2017
01:15:50,840 --> 01:15:54,159
そう願ってい

2018
01:15:54,159 --> 01:15:56,560
ます。それは、実際的な方向転換を思い出させてくれます。

2019
01:15:56,560 --> 01:15:58,159


2020
01:15:58,159 --> 01:15:59,920
エンジニアや哲学者との馬蹄理論は、

2021
01:15:59,920 --> 01:16:01,600


2022
01:16:01,600 --> 01:16:04,239


2023
01:16:04,239 --> 01:16:06,080
さまざまな方法でさまざまな方法でプラグマティズムについて話し合うことがよくありますさまざまなコミュニティ

2024
01:16:06,080 --> 01:16:07,600
さまざまなツール

2025
01:16:07,600 --> 01:16:09,520


2026
01:16:09,520 --> 01:16:12,719


2027
01:16:12,719 --> 01:16:14,560


2028
01:16:14,560 --> 01:16:16,640


2029
01:16:16,640 --> 01:16:18,880
デザイン

2030
01:16:18,880 --> 01:16:22,400
サイエンスの予測的デザインサイエンスの

2031
01:16:22,400 --> 01:16:24,080
それを取るか、哲学を残すか、または

2032
01:16:24,080 --> 01:16:26,400
ツールキットを開発するためのツールキットがありますツールキットを使用してから

2033
01:16:26,400 --> 01:16:28,480
5年後

2034
01:16:28,480 --> 01:16:30,000
、または哲学の5年後、ツールキットに

2035
01:16:30,000 --> 01:16:31,280


2036
01:16:31,280 --> 01:16:33,360
興味がある

2037
01:16:33,360 --> 01:16:34,640
ので、1つの

2038
01:16:34,640 --> 01:16:36,320
質問は

2039
01:16:36,320 --> 01:16:38,480
どのように行うかでした これらのグラフは、

2040
01:16:38,480 --> 01:16:41,280
時間的に深いモデルを説明しています。これらのモデルはどのように

2041
01:16:41,280 --> 01:16:42,800
指定されているの

2042
01:16:42,800 --> 01:16:43,920
か、または

2043
01:16:43,920 --> 01:16:46,080
グラフの違いは何であるのか。

2044
01:16:46,080 --> 01:16:48,400
e提供した例を取り入れて、次のアクションを計算しているだけ

2045
01:16:48,400 --> 01:16:50,000


2046
01:16:50,000 --> 01:16:52,400


2047
01:16:53,120 --> 01:16:55,920
です。グラフをもう一度表示して

2048
01:16:55,920 --> 01:16:58,640
、未来がどのように表されるか、

2049
01:16:58,640 --> 01:17:00,560
それに時間的な厚みを追加する方法を教え

2050
01:17:00,560 --> 01:17:02,560


2051
01:17:02,560 --> 01:17:05,760
てください。 椅子の画面のようなグラフ

2052
01:17:06,320 --> 01:17:07,280
があり

2053
01:17:07,280 --> 01:17:10,400
ますはい

2054
01:17:12,800 --> 01:17:14,239
このようなグラフがある場合、どの

2055
01:17:14,239 --> 01:17:15,600
ように時間的な厚さを追加しますか？

2056
01:17:15,600 --> 01:17:17,840
たとえば

2057
01:17:17,920 --> 01:17:20,080
、レイヤーを追加するだけな

2058
01:17:20,080 --> 01:17:21,120


2059
01:17:21,120 --> 01:17:22,400
ので

2060
01:17:22,400 --> 01:17:25,920
、ここに表示されているのは1つのレイヤーで

2061
01:17:25,920 --> 01:17:27,280
あり、このレイヤー

2062
01:17:27,280 --> 01:17:28,320


2063
01:17:28,320 --> 01:17:30,960
は特定の時刻に機能します

2064
01:17:30,960 --> 01:17:33,840
観測は離散的に発生し

2065
01:17:33,840 --> 01:17:34,960


2066
01:17:34,960 --> 01:17:36,960
ますが

2067
01:17:36,960 --> 01:17:38,960
、この上にある層がこの下の層に何らかの形で接続されており

2068
01:17:38,960 --> 01:17:40,239


2069
01:17:40,239 --> 01:17:42,080
、より高い時間

2070
01:17:42,080 --> 01:17:43,360
スケール

2071
01:17:43,360 --> 01:17:46,239
で動作するため、展開が遅くなり

2072
01:17:46,239 --> 01:17:48,239


2073
01:17:48,239 --> 01:17:49,440
ます

2074
01:17:49,440 --> 01:17:52,000
が、たとえば、ここでの遷移モデル

2075
01:17:52,000 --> 01:17:54,480
や観測のパラメータを調整または影響します。 ここで

2076
01:17:54,480 --> 01:17:56,480


2077
01:17:56,480 --> 01:17:58,800
モデルを作成すると、その上に

2078
01:17:58,800 --> 01:17:59,679


2079
01:17:59,679 --> 01:18:02,400
あるゆっくりと進化するレイヤーの影響を受ける時間変化する観測モデルを

2080
01:18:02,400 --> 01:18:04,000
取得できます。さらに

2081
01:18:04,000 --> 01:18:05,679
ゆっくりと進化するレイヤーを正しく取得できます。

2082
01:18:05,679 --> 01:18:06,960
これ

2083
01:18:06,960 --> 01:18:09,440
が階層を構築する方法です。

2084
01:18:09,440 --> 01:18:10,640


2085
01:18:10,640 --> 01:18:13,120
実際

2086
01:18:13,120 --> 01:18:15,760
、私たちのグループのismael senosに

2087
01:18:15,760 --> 01:18:17,280
は、非常に興味深い作業を行ったpgの学生もい

2088
01:18:17,280 --> 01:18:19,280
ます。彼は、階層型ガウスフィルターを作成する方法を調査しました。

2089
01:18:19,280 --> 01:18:21,199


2090
01:18:21,199 --> 01:18:24,480


2091
01:18:24,480 --> 01:18:27,199


2092
01:18:27,199 --> 01:18:29,679
下のレイヤーの遷移モデルの分散に影響を与えるレイヤー

2093
01:18:29,679 --> 01:18:31,280


2094
01:18:31,280 --> 01:18:33,280


2095
01:18:33,280 --> 01:18:34,960


2096
01:18:34,960 --> 01:18:37,360


2097
01:18:37,360 --> 01:18:40,960
と、それを使用して非常に自然な信号をモデル化できる

2098
01:18:40,960 --> 01:18:42,960
ことがわかります。したがって、自然界

2099
01:18:42,960 --> 01:18:44,640
では、時間変化

2100
01:18:44,640 --> 01:18:46,400


2101
01:18:46,400 --> 01:18:48,880
する統計と、 これらのモデル

2102
01:18:48,880 --> 01:18:50,800
は時変である

2103
01:18:50,800 --> 01:18:52,880
ため、その意味での階層モデルはその

2104
01:18:52,880 --> 01:18:54,560
ために非常に役立ちます。もちろん、それは

2105
01:18:54,560 --> 01:18:56,719
もちろん、

2106
01:18:56,719 --> 01:18:58,960
私たちの脳がどのように構造化

2107
01:18:58,960 --> 01:19:00,800
されているかもそうです。

2108
01:19:00,800 --> 01:19:02,000


2109
01:19:02,000 --> 01:19:04,080


2110
01:19:04,080 --> 01:19:07,360


2111
01:19:07,360 --> 01:19:08,480


2112
01:19:08,480 --> 01:19:10,560


2113
01:19:10,560 --> 01:19:12,239
少なくとも理論的には、ベクトルグラフを使用してumを構築してみてください。

2114
01:19:12,239 --> 01:19:13,280


2115
01:19:13,280 --> 01:19:14,800
それらを接続するだけで、layeを接続できるため、非常に簡単なはずです。

2116
01:19:14,800 --> 01:19:17,120
その上に、

2117
01:19:17,120 --> 01:19:20,000
それがどのように動作するかを確認し

2118
01:19:20,000 --> 01:19:21,760
、最終的にモデルの複雑

2119
01:19:21,760 --> 01:19:23,760
さが非常に高くなり

2120
01:19:23,760 --> 01:19:26,159
、自動的にペナルティが課せられるため

2121
01:19:26,159 --> 01:19:28,320


2122
01:19:28,320 --> 01:19:31,120
、データに基づいてカットオフポイントがあり、それが

2123
01:19:31,120 --> 01:19:32,960
最適なレイヤー数になります 観察

2124
01:19:32,960 --> 01:19:34,400
するすべてのバリアントを説明する

2125
01:19:34,400 --> 01:19:35,679


2126
01:19:35,679 --> 01:19:38,480


2127
01:19:39,520 --> 01:19:42,560
ために必要なことです。これにより、

2128
01:19:42,560 --> 01:19:44,800
時間の厚

2129
01:19:44,800 --> 01:19:46,000
さや

2130
01:19:46,000 --> 01:19:48,239
時間依存性、および

2131
01:19:48,239 --> 01:19:50,719
これらのような動的モデルについての考え方

2132
01:19:50,719 --> 01:19:54,159
がわかります。画面を共有することもできます。

2133
01:19:54,159 --> 01:19:56,719


2134
01:19:56,719 --> 01:19:59,760
素晴らしい

2135
01:19:59,760 --> 01:20:02,080
ええ、

2136
01:20:02,400 --> 01:20:05,280
これは数年前の論文からのグラフですえ

2137
01:20:05,280 --> 01:20:08,639


2138
01:20:08,639 --> 01:20:11,520
えと、それはフロンティアと呼ばれていますええと、

2139
01:20:11,520 --> 01:20:13,440
深い時間モデルは因子

2140
01:20:13,440 --> 01:20:14,880
グラフか何か

2141
01:20:14,880 --> 01:20:17,360
を検査すると思います、そしてここにあなたは3層システムを見

2142
01:20:17,360 --> 01:20:19,679


2143
01:20:19,679 --> 01:20:21,840
ます 最上層に表示されるのは、

2144
01:20:21,840 --> 01:20:24,800
基本的に1つのセクションが1つの

2145
01:20:24,800 --> 01:20:26,400


2146
01:20:26,400 --> 01:20:28,639
タイムステップであり、最上層のそのタイムステップには

2147
01:20:28,639 --> 01:20:29,600


2148
01:20:29,600 --> 01:20:30,639


2149
01:20:30,639 --> 01:20:33,520
、ミドルウェアに2つの観測または2つのステップがあります。

2150
01:20:33,520 --> 01:20:34,800


2151
01:20:34,800 --> 01:20:37,440


2152
01:20:37,440 --> 01:20:40,159


2153
01:20:40,159 --> 01:20:43,040
私のええと、それからもう一度

2154
01:20:43,040 --> 01:20:44,880
、中間

2155
01:20:44,880 --> 01:20:47,679
層の先端が1つのステップを踏むたびに、3番目の層を見ることができるかどうかを確認してください。ここでは、2つの

2156
01:20:47,679 --> 01:20:50,400
ステップがあるので、

2157
01:20:50,400 --> 01:20:52,560


2158
01:20:52,560 --> 01:20:55,440
各層の粒度が細かくなり、構築できます。

2159
01:20:55,440 --> 01:20:57,600
階層的

2160
01:20:57,600 --> 01:21:01,280
なええと、ええと、ええと、私たち

2161
01:21:01,280 --> 01:21:04,480
もそうしています

2162
01:21:04,480 --> 01:21:05,520
。

2163
01:21:05,520 --> 01:21:07,679


2164
01:21:07,679 --> 01:21:10,080
私たちのWebサイトのいくつかの論文を見ると、chrismatisse

2165
01:21:10,080 --> 01:21:12,400
の階層型ガウスフィルターにたくさんの赤ちゃんがいます。

2166
01:21:12,400 --> 01:21:15,120
でそれを実装し

2167
01:21:15,120 --> 01:21:16,239
ました

2168
01:21:16,239 --> 01:21:19,040
が、

2169
01:21:19,040 --> 01:21:20,719
ええと、ええとのようなアクティブな影響を与えるためにもそれを行うことができます。

2170
01:21:20,719 --> 01:21:23,280


2171
01:21:23,280 --> 01:21:24,159


2172
01:21:24,159 --> 01:21:26,960


2173
01:21:26,960 --> 01:21:30,000


2174
01:21:30,000 --> 01:21:32,960


2175
01:21:33,760 --> 01:21:35,840


2176
01:21:35,840 --> 01:21:38,239
g

2177
01:21:38,239 --> 01:21:39,440
d bの

2178
01:21:39,440 --> 01:21:41,040
ような変数

2179
01:21:41,040 --> 01:21:43,520
は、アクティブな推論の別の表現の

2180
01:21:43,520 --> 01:21:44,960


2181
01:21:44,960 --> 01:21:46,800
ようなものなので、これもまた

2182
01:21:46,800 --> 01:21:49,520
、以前のフロンティアの論文に戻って

2183
01:21:49,520 --> 01:21:52,000
、大きな同等性のいくつか、

2184
01:21:52,000 --> 01:21:55,679
またはフォーニーファクターへの気密マッピングのようなものだと思います

2185
01:21:55,679 --> 01:21:57,440


2186
01:21:57,440 --> 01:21:59,120
グラフ

2187
01:21:59,120 --> 01:22:01,040


2188
01:22:01,040 --> 01:22:03,120


2189
01:22:03,120 --> 01:22:05,520


2190
01:22:05,520 --> 01:22:07,760


2191
01:22:07,760 --> 01:22:09,679
は、おそらくその基礎となるものとほぼホットスワップされる可能性のあるアプリケーションのいくつかの広い領域があるため

2192
01:22:09,679 --> 01:22:12,480
、一般的なベイジアングラフと、

2193
01:22:12,480 --> 01:22:14,480


2194
01:22:14,480 --> 01:22:17,599
そのレベルの他のトピックとの同等性

2195
01:22:21,120 --> 01:22:23,520
は、外国式のベクトルグラフ

2196
01:22:23,520 --> 01:22:26,320
または 2部グラフまたはベイジアンネットワーク

2197
01:22:26,320 --> 01:22:27,920
は、実際には違いはありません。これら

2198
01:22:27,920 --> 01:22:29,760


2199
01:22:29,760 --> 01:22:31,840


2200
01:22:31,840 --> 01:22:34,159
は、因数分解されたモデルの単なる表現であり、それらのモデル

2201
01:22:34,159 --> 01:22:37,120


2202
01:22:37,120 --> 01:22:39,520
についての考え方に影響を与える可能性がある表現方法である

2203
01:22:39,520 --> 01:22:41,440


2204
01:22:41,440 --> 01:22:43,280
ため、使用できます。  4インストールの

2205
01:22:43,280 --> 01:22:45,199
効果的なグラフ表現

2206
01:22:45,199 --> 01:22:47,120


2207
01:22:47,120 --> 01:22:49,120
は、これらのメッセージ

2208
01:22:49,120 --> 01:22:51,520
をグラフ上を流れる信号として見ることができるため、信号処理に非常に適しています。

2209
01:22:51,520 --> 01:22:53,840
エンジニアとしての私たちにとって、

2210
01:22:53,840 --> 01:22:57,679
これはベイジアンネットワークでの非常に直感的な表現

2211
01:22:57,679 --> 01:23:00,880
であり

2212
01:23:00,880 --> 01:23:02,880
、モデル表現そのものです。 可変ノート

2213
01:23:02,880 --> 01:23:05,199
しかないという意味でよりコンパクトであり、

2214
01:23:05,199 --> 01:23:06,719
それらがどのように

2215
01:23:06,719 --> 01:23:08,320
関連しているかがわかるので、

2216
01:23:08,320 --> 01:23:10,239
モデル構造

2217
01:23:10,239 --> 01:23:13,120
なので、

2218
01:23:13,120 --> 01:23:16,000
そのようなモデルの概要を簡単に把握

2219
01:23:16,000 --> 01:23:17,120
しておくと非常に便利です。たとえば、

2220
01:23:17,120 --> 01:23:19,120


2221
01:23:19,120 --> 01:23:21,120
変数間の関係をum間の

2222
01:23:21,120 --> 01:23:22,960
追加の種類の

2223
01:23:22,960 --> 01:23:25,520
ベクトルノードとして示す2分割グラフを作成する

2224
01:23:25,520 --> 01:23:27,440
と、次のようになります。

2225
01:23:27,440 --> 01:23:29,280
これらがどのように接続されているかについてもう少し細かく、

2226
01:23:29,280 --> 01:23:31,120


2227
01:23:31,120 --> 01:23:32,719
これらの変数間の関係についてよく話す余地が

2228
01:23:32,719 --> 01:23:35,280


2229
01:23:35,280 --> 01:23:39,440
あります。したがって、最終的には、

2230
01:23:39,520 --> 01:23:41,760
1つのモデルを取得して

2231
01:23:41,760 --> 01:23:45,760
、3つの異なる方法で表すことができますが、それ以上になる

2232
01:23:46,159 --> 01:23:48,560
と思います。 それは

2233
01:23:48,560 --> 01:23:49,920
あなたの

2234
01:23:49,920 --> 01:23:52,320
考え方やこれらのモデルについての考え方に影響を与えるので

2235
01:23:52,320 --> 01:23:54,559


2236
01:23:55,840 --> 01:23:56,960
、

2237
01:23:56,960 --> 01:23:58,560
それは通常、

2238
01:23:58,560 --> 01:24:00,239
論文

2239
01:24:00,239 --> 01:24:01,679
を書くときに出てくるので、実際に私のアイデアの最良の表現は何であるかを考えなければなりません。

2240
01:24:01,679 --> 01:24:03,520


2241
01:24:03,520 --> 01:24:04,639


2242
01:24:04,639 --> 01:24:06,239


2243
01:24:06,239 --> 01:24:07,520
ビジュアルネットワーク

2244
01:24:07,520 --> 01:24:10,159
時々それは写真をインストールするためのものです

2245
01:24:10,159 --> 01:24:11,120


2246
01:24:11,120 --> 01:24:14,800
ええとそれはあなたの話に依存しますええ

2247
01:24:14,800 --> 01:24:16,320
うまくいけば

2248
01:24:16,320 --> 01:24:18,480
私は私たちがシステムと全体について考えるとき私の経験で意味しますが私は見つけます

2249
01:24:18,480 --> 01:24:21,120


2250
01:24:21,120 --> 01:24:23,040
方程式のetを論文で読ん

2251
01:24:23,040 --> 01:24:24,159


2252
01:24:24,159 --> 01:24:26,880
だり、書き留めたりすると

2253
01:24:26,880 --> 01:24:28,880
、私に描画するとより多くの洞察が得られます。

2254
01:24:28,880 --> 01:24:31,280
グラフを描画し

2255
01:24:31,280 --> 01:24:32,480


2256
01:24:32,480 --> 01:24:33,760
、x

2257
01:24:33,760 --> 01:24:36,000
があれば、グラフ間に正確な対応が必要です。

2258
01:24:36,000 --> 01:24:37,920


2259
01:24:37,920 --> 01:24:40,480
そして方程式、そして

2260
01:24:40,480 --> 01:24:42,960
グラフを描いて方程式を書き留めると、対応

2261
01:24:42,960 --> 01:24:45,040
するx軸がないので、それから

2262
01:24:45,040 --> 01:24:47,360


2263
01:24:47,360 --> 01:24:50,000
あなたは基本的に

2264
01:24:50,000 --> 01:24:52,000
正確な対応がなければならないことを知っていることを学び、

2265
01:24:52,000 --> 01:24:53,600
基本的にあなたはしばしばあなたを見つけます

2266
01:24:53,600 --> 01:24:56,239
方程式やグラフに誤りがあります

2267
01:24:56,239 --> 01:24:57,920


2268
01:24:57,920 --> 01:25:00,000
が

2269
01:25:00,000 --> 01:25:03,600
、最終目標のように、最終目標

2270
01:25:03,600 --> 01:25:07,120
は、ツールボックスをツールボックスにする

2271
01:25:07,120 --> 01:25:09,199
ことであり、コミュニティ

2272
01:25:09,199 --> 01:25:12,639
が独自のアクティブな影響力のあるエージェントを設計するための

2273
01:25:12,639 --> 01:25:13,679
ものであり、私が

2274
01:25:13,679 --> 01:25:15,520
想像したものは

2275
01:25:15,520 --> 01:25:18,000
simulinkやlabviewのようなもの

2276
01:25:18,000 --> 01:25:20,080
は、人々がそれに精通しているかどうかはわかりません

2277
01:25:20,080 --> 01:25:21,280
が、

2278
01:25:21,280 --> 01:25:23,120
これらは

2279
01:25:23,120 --> 01:25:26,080
実際にグラフィカルに定義

2280
01:25:26,080 --> 01:25:27,920
したいグラフィカルモデルであり、メモとドラだけのパレットが必要です

2281
01:25:27,920 --> 01:25:29,679


2282
01:25:29,679 --> 01:25:32,320
wグラフを作成し、これが私のモデルであると言っ

2283
01:25:32,320 --> 01:25:34,639
て実行し

2284
01:25:34,639 --> 01:25:36,159
ます。推論がルート依存関係にあることを心配する必要はありません。

2285
01:25:36,159 --> 01:25:37,840


2286
01:25:37,840 --> 01:25:39,600


2287
01:25:39,600 --> 01:25:40,880


2288
01:25:40,880 --> 01:25:43,199
ツールボックスの設計者がパスを実行する必要があり

2289
01:25:43,199 --> 01:25:46,080
ますが、グラフィカル構造について考える必要があります。

2290
01:25:46,080 --> 01:25:49,360
それはええ

2291
01:25:49,360 --> 01:25:52,880
とこれですそしてそれ

2292
01:25:52,880 --> 01:25:54,880
をあなたのマウスで

2293
01:25:54,880 --> 01:25:57,440
あなたのコンピュータのあなたのマイクまたはあなたのカメラに接続します

2294
01:25:57,440 --> 01:25:59,920
そして多分あなたはロボットのため

2295
01:25:59,920 --> 01:26:01,760
のツールボックスにもコネクタがあることを知っているでしょう

2296
01:26:01,760 --> 01:26:05,280
そして

2297
01:26:05,280 --> 01:26:07,600
それはちょうどうまくいくはずですそれは

2298
01:26:07,600 --> 01:26:09,199
ボブロスになるでしょう

2299
01:26:09,199 --> 01:26:11,519


2300
01:26:11,920 --> 01:26:13,520
あなたがデザインしたい方法であるグラフの私は

2301
01:26:13,520 --> 01:26:15,280
あなたがちょうど脳

2302
01:26:15,280 --> 01:26:17,840
と少なくとも脳の生成モデルを描きたいと思います

2303
01:26:17,840 --> 01:26:19,679
そしてそれを手放す

2304
01:26:19,679 --> 01:26:21,600
だけで推論

2305
01:26:21,600 --> 01:26:24,239
が

2306
01:26:24,480 --> 01:26:26,719
どのように行われるかについてあなたが今見たことについてそこで言ったことを心配しないでください

2307
01:26:26,719 --> 01:26:29,199
方程式を

2308
01:26:29,199 --> 01:26:31,520
作成し、ペンと紙から

2309
01:26:31,520 --> 01:26:33,280
プログラミング言語、グラフィック

2310
01:26:33,280 --> 01:26:35,440
表現に移り、言語

2311
01:26:35,440 --> 01:26:37,120
を逆翻訳するときと同じようにクロスチェックし

2312
01:26:37,120 --> 01:26:38,800
ます。

2313
01:26:38,800 --> 01:26:41,120
2つの単語が相互にマップされる場所にロックインすると、マップを作成した

2314
01:26:41,120 --> 01:26:42,800
こと

2315
01:26:42,800 --> 01:26:44,239
がわかりますが、この

2316
01:26:44,239 --> 01:26:46,719
無限のループにいる場合は、

2317
01:26:46,719 --> 01:26:49,760
単語スペースで失われるため、

2318
01:26:49,760 --> 01:26:52,639
そのようなセクター間を移動すると、 コンピュータ

2319
01:26:52,639 --> 01:26:53,520
での

2320
01:26:53,520 --> 01:26:55,440
分析シミュレーション

2321
01:26:55,440 --> 01:26:57,840
とその後のグラフィカルなモダリティ全体で、

2322
01:26:57,840 --> 01:26:59,679


2323
01:26:59,679 --> 01:27:02,159
それがなければ知識製品として見られるかもしれないものにアクションを埋め込み

2324
01:27:02,159 --> 01:27:03,440


2325
01:27:03,440 --> 01:27:05,840
、推論

2326
01:27:05,840 --> 01:27:07,520
と最終アクションの結果で

2327
01:27:07,520 --> 01:27:10,239
あり、それは動的プロセスをトレーニングするための同様の誤り

2328
01:27:10,239 --> 01:27:12,719
です スナップショット

2329
01:27:12,719 --> 01:27:13,920
を作成してから、リアルタイムで機能することを期待します。これ

2330
01:27:13,920 --> 01:27:15,840


2331
01:27:15,840 --> 01:27:17,760


2332
01:27:17,760 --> 01:27:20,159
は、知識の生成にこのリアルタイムフローを組み込むようなものです。

2333
01:27:20,159 --> 01:27:24,000
ええ、はい、私たちは重要

2334
01:27:24,000 --> 01:27:25,679
です。ええ、ええと、このようなもの

2335
01:27:25,679 --> 01:27:28,080
を設計しようとしている間、アクティブな保険を実装しています。

2336
01:27:28,080 --> 01:27:30,800
それは本当です

2337
01:27:30,800 --> 01:27:34,400
ええええ1つの一般的な質問は因数分解についてでした

2338
01:27:34,400 --> 01:27:36,239


2339
01:27:36,239 --> 01:27:37,679
ので

2340
01:27:37,679 --> 01:27:40,000
、

2341
01:27:40,000 --> 01:27:41,920
私たちがそれを行う方法の因数分解は私たちの直感から始まり

2342
01:27:41,920 --> 01:27:44,880
、残差を探す

2343
01:27:44,880 --> 01:27:47,520
か、モデルを因数分解するすべての方法の方法です

2344
01:27:47,520 --> 01:27:51,600
うまくいくものを見つけますか？

2345
01:27:53,440 --> 01:27:55,440
2種類の因数分解

2346
01:27:55,440 --> 01:27:57,440
があります。たとえば

2347
01:27:57,440 --> 01:27:59,440
、生成モデル

2348
01:27:59,440 --> 01:28:02,560
の右に、私たちが描くグラフです。つまり、

2349
01:28:02,560 --> 01:28:06,639
ほとんどの人

2350
01:28:06,639 --> 01:28:10,719
、または最も一般的なモデルは、

2351
01:28:10,719 --> 01:28:13,440


2352
01:28:13,440 --> 01:28:16,239
これらのマルコフモデルです。 ここでは、過去に発生したすべてのこと

2353
01:28:16,239 --> 01:28:18,880
を要約した現在の状態を保持し、

2354
01:28:18,880 --> 01:28:20,639


2355
01:28:20,639 --> 01:28:22,239


2356
01:28:22,239 --> 01:28:25,120
その現在の状態を使用して、

2357
01:28:25,120 --> 01:28:27,440
基本的に過去を要約し

2358
01:28:27,440 --> 01:28:29,760


2359
01:28:29,760 --> 01:28:30,960
ます。これで、過去に関するすべての情報が得られるため、覚えておく必要はありません。

2360
01:28:30,960 --> 01:28:33,440
過去あなたは自分の

2361
01:28:33,440 --> 01:28:34,560


2362
01:28:34,560 --> 01:28:36,159
状態を覚えているだけで、それを使って新しい

2363
01:28:36,159 --> 01:28:39,040
観察を行い、情報を組み合わせ

2364
01:28:39,040 --> 01:28:40,560
て新しい状態

2365
01:28:40,560 --> 01:28:42,639
を作るなど、隠れマルコフ

2366
01:28:42,639 --> 01:28:44,760
モデル

2367
01:28:44,760 --> 01:28:47,600
palmdpsこれらすべてのモデルは同じ構造を持ってい

2368
01:28:47,600 --> 01:28:49,199
ますこれらはこの

2369
01:28:49,199 --> 01:28:51,360
微細構造なので

2370
01:28:51,360 --> 01:28:53,440
生成的です これらの動的

2371
01:28:53,440 --> 01:28:54,560
システムのモデル

2372
01:28:54,560 --> 01:28:56,400
では、2番目の質問があり

2373
01:28:56,400 --> 01:28:58,719
ます。推論を行う場合は

2374
01:28:58,719 --> 01:29:02,400
、ええと

2375
01:29:02,400 --> 01:29:04,880
、平均フィールドのお尻と呼ばれるものがよくあります。

2376
01:29:04,880 --> 01:29:07,040
バリエーションのある後部の要求ですが、

2377
01:29:07,040 --> 01:29:08,639


2378
01:29:08,639 --> 01:29:11,920
その構造化されたグリーンフィールドにはバリエーションもある

2379
01:29:11,920 --> 01:29:14,239
ので

2380
01:29:14,239 --> 01:29:17,520
、後部

2381
01:29:17,520 --> 01:29:19,920
をさらに構造化するか

2382
01:29:19,920 --> 01:29:22,880
、生成モデルよりもさらに因数分解するかを決定できます

2383
01:29:22,880 --> 01:29:24,480


2384
01:29:24,480 --> 01:29:27,040
が、最終的にはそう

2385
01:29:27,040 --> 01:29:29,120
です 提案を

2386
01:29:29,120 --> 01:29:30,159


2387
01:29:30,159 --> 01:29:33,120
実行するだけで、別の

2388
01:29:33,120 --> 01:29:35,040
提案がある場合は実行するだけで、

2389
01:29:35,040 --> 01:29:38,000
自由エネルギーが最も低い提案が勝ちます。

2390
01:29:38,000 --> 01:29:40,800
そうです。課題

2391
01:29:40,800 --> 01:29:44,000
は、そのプロセスを自動化すること

2392
01:29:44,000 --> 01:29:45,840


2393
01:29:45,840 --> 01:29:47,600


2394
01:29:47,600 --> 01:29:49,920
です。 分析を行うプロセス全体

2395
01:29:49,920 --> 01:29:52,159


2396
01:29:52,159 --> 01:29:55,840
を停止せずにリアルタイムでメッセージを渡すだけで最小化に失敗し

2397
01:29:55,840 --> 01:29:57,600


2398
01:29:57,600 --> 01:29:59,040


2399
01:29:59,040 --> 01:30:01,520
ただけで構造は正しく動き続ける

2400
01:30:01,520 --> 01:30:04,080


2401
01:30:04,080 --> 01:30:06,239
必要があります構造の適応は状態推定のようである必要があります

2402
01:30:06,239 --> 01:30:08,560


2403
01:30:08,560 --> 01:30:10,719


2404
01:30:10,719 --> 01:30:12,719


2405
01:30:12,719 --> 01:30:15,120


2406
01:30:15,360 --> 01:30:19,120
夢のようなステージのようなものですが

2407
01:30:19,120 --> 01:30:22,480
、主な時間は進み、それが課

2408
01:30:22,480 --> 01:30:24,239
題であり、私たちはそれ

2409
01:30:24,239 --> 01:30:26,560
を知りません 私たちのファクトリークラスですが、ええ、

2410
01:30:26,560 --> 01:30:27,840
私

2411
01:30:27,840 --> 01:30:28,719


2412
01:30:28,719 --> 01:30:31,280
たちは現在エンジニアとして

2413
01:30:31,280 --> 01:30:32,840
そのように調査している1人の

2414
01:30:32,840 --> 01:30:36,560
hd学生

2415
01:30:36,560 --> 01:30:38,320
がいることを意味します。

2416
01:30:38,320 --> 01:30:40,400


2417
01:30:40,400 --> 01:30:42,560


2418
01:30:42,560 --> 01:30:44,880
生成モデルの因数分解については、

2419
01:30:44,880 --> 01:30:47,040
すべての因子

2420
01:30:47,040 --> 01:30:49,440
が事前分布または

2421
01:30:49,440 --> 01:30:50,960
条件付き分布を表していると思います。それが

2422
01:30:50,960 --> 01:30:53,440
、モデルを構築する方法です。

2423
01:30:53,440 --> 01:30:55,040
どこから

2424
01:30:55,040 --> 01:30:57,520
始めれば

2425
01:30:57,520 --> 01:31:01,600
、世界

2426
01:31:01,600 --> 01:31:03,520
がその意味で観測を生成すると信じているかから始まります。 あなたは環境

2427
01:31:03,520 --> 01:31:05,760
の因果構造が何である

2428
01:31:05,760 --> 01:31:07,760


2429
01:31:07,760 --> 01:31:10,159
かを考え、物理学が

2430
01:31:10,159 --> 01:31:13,040
どのように機能するか、または

2431
01:31:13,040 --> 01:31:15,760
状態が環境内でどのように遷移する

2432
01:31:15,760 --> 01:31:17,280
か、または少なくともこの

2433
01:31:17,280 --> 01:31:19,040
遷移をどのよう

2434
01:31:19,040 --> 01:31:20,080


2435
01:31:20,080 --> 01:31:22,159
に信じるかについていくつかの考えを持っているかもしれません。

2436
01:31:22,159 --> 01:31:24,960
たぶん、これから1を引いた非常に粗いメモを試してみましょう。

2437
01:31:24,960 --> 01:31:27,120
たとえば、私の話では

2438
01:31:27,120 --> 01:31:28,719
、ここに何を入れたいのかよくわからないので、ここで試してみましょう。

2439
01:31:28,719 --> 01:31:30,400


2440
01:31:30,400 --> 01:31:33,440
o何かを入れて、

2441
01:31:33,440 --> 01:31:35,840
それがどのように機能するかを見てみましょう。

2442
01:31:35,840 --> 01:31:39,199
世界がどのように機能すると私が信じ

2443
01:31:39,520 --> 01:31:42,639
ているかをモデル化します。それがあなたが始めた方法です。

2444
01:31:42,639 --> 01:31:44,639
それからあなたはよく考え始めます。私は

2445
01:31:44,639 --> 01:31:46,639
実際にそれについてもう少し知っています。

2446
01:31:46,639 --> 01:31:48,960
モデル

2447
01:31:48,960 --> 01:31:51,760
は、このモデルがどのように機能するかを提案し

2448
01:31:51,760 --> 01:31:55,120
ました。たとえば、物理学を知っているので、これをマイナス1に変更できます。

2449
01:31:55,120 --> 01:31:57,280


2450
01:31:57,280 --> 01:31:59,280
物理学を知っているので、

2451
01:31:59,280 --> 01:32:00,320


2452
01:32:00,320 --> 01:32:01,679


2453
01:32:01,679 --> 01:32:03,920
温度が距離とどのように統合されるかを知って

2454
01:32:03,920 --> 01:32:06,960
います。

2455
01:32:06,960 --> 01:32:08,560
それはあなたが2番目の提案に行く方法です

2456
01:32:08,560 --> 01:32:09,920


2457
01:32:09,920 --> 01:32:12,560
そしてそれは常に

2458
01:32:12,560 --> 01:32:14,320
あなた

2459
01:32:14,320 --> 01:32:17,600
が世界の因果構造

2460
01:32:17,600 --> 01:32:19,440
がええと信じている方法に触発されていますええええ

2461
01:32:19,440 --> 01:32:21,040
それはそうですそういう意味でそれは

2462
01:32:21,040 --> 01:32:22,560
あなたが理論または説明を構築している一種の理論構築です

2463
01:32:22,560 --> 01:32:25,280
あなたの

2464
01:32:25,280 --> 01:32:27,040
環境の

2465
01:32:27,040 --> 01:32:28,239


2466
01:32:28,239 --> 01:32:30,480
そして多分あなたが本当に良い

2467
01:32:30,480 --> 01:32:32,320
ならあなたが優れたモデルを持っているならあなた

2468
01:32:32,320 --> 01:32:34,480
は常に何かを見つけるだけ

2469
01:32:34,480 --> 01:32:35,920
で改善することができるのであなたは芸術の状態を改善するようなものを

2470
01:32:35,920 --> 01:32:39,600


2471
01:32:39,600 --> 01:32:41,120
見つけることができます その意味で、

2472
01:32:41,120 --> 01:32:42,880
より低い自由エネルギーまたはより良いモデル

2473
01:32:42,880 --> 01:32:44,960
パフォーマンスを提供し、

2474
01:32:44,960 --> 01:32:46,400


2475
01:32:46,400 --> 01:32:47,679


2476
01:32:47,679 --> 01:32:48,800


2477
01:32:48,800 --> 01:32:50,800
これらのモデルを微調整し続けることができます。これらの因数分解

2478
01:32:50,800 --> 01:32:51,760
や、

2479
01:32:51,760 --> 01:32:54,960


2480
01:32:56,880 --> 01:32:58,000


2481
01:32:58,000 --> 01:32:59,360
自由エネルギーの

2482
01:32:59,360 --> 01:33:00,639
最小化など

2483
01:33:00,639 --> 01:33:03,440
は、さまざまなモデルをランク付けする方法として説明されてい

2484
01:33:03,440 --> 01:33:05,280
ます。 そして、

2485
01:33:05,280 --> 01:33:06,880
これらの複数の異なる

2486
01:33:06,880 --> 01:33:09,840
面での必須事項として、

2487
01:33:09,840 --> 01:33:11,920
自由エネルギーの最小化が弾力性のある

2488
01:33:11,920 --> 01:33:13,199
ポリシー

2489
01:33:13,199 --> 01:33:14,480
を作成して

2490
01:33:14,480 --> 01:33:16,880
いることをどの

2491
01:33:16,880 --> 01:33:18,800
ように知ることができますか？ローカル最適化と同様

2492
01:33:18,800 --> 01:33:20,639


2493
01:33:20,639 --> 01:33:22,560
に、より大きな最適化スペースのどこ

2494
01:33:22,560 --> 01:33:24,400
かに閉じ込められる方法があります 自由

2495
01:33:24,400 --> 01:33:26,639
エネルギーを最小化

2496
01:33:26,639 --> 01:33:28,560
することで、システム

2497
01:33:28,560 --> 01:33:29,920
がより速く到達するように故障するようになります。

2498
01:33:29,920 --> 01:33:31,760
加速して

2499
01:33:31,760 --> 01:33:32,880


2500
01:33:32,880 --> 01:33:35,120
、システムのある種の一時的な障害が発生し

2501
01:33:35,120 --> 01:33:38,000


2502
01:33:38,000 --> 01:33:40,639
ます。 そして、

2503
01:33:40,639 --> 01:33:43,120
そのような根本的に異なるチェス戦略や運転アプローチを最終的にどのように評価できるかを分類することができます。それは

2504
01:33:43,120 --> 01:33:44,639


2505
01:33:44,639 --> 01:33:48,639


2506
01:33:48,840 --> 01:33:50,639
単なる

2507
01:33:50,639 --> 01:33:52,719
確率理論であり、 確率

2508
01:33:52,719 --> 01:33:55,360
も正しい数値で

2509
01:33:55,360 --> 01:33:57,760
あり、そのエネルギーの種類は

2510
01:33:57,760 --> 01:33:59,760


2511
01:33:59,760 --> 01:34:01,760


2512
01:34:01,760 --> 01:34:04,800
、データを観察するモデルに従った確率である証拠に近似しているため

2513
01:34:04,800 --> 01:34:07,920
、最良の証拠を提供するモデルを作成する場合

2514
01:34:07,920 --> 01:34:10,239
は、あなたにとって良い説明になり

2515
01:34:10,239 --> 01:34:12,480
ます。 データな

2516
01:34:12,480 --> 01:34:15,040
ので、最終的

2517
01:34:15,040 --> 01:34:16,639
には、近似確率理論を実行しようとするだけで

2518
01:34:16,639 --> 01:34:19,600


2519
01:34:19,600 --> 01:34:20,639


2520
01:34:20,639 --> 01:34:22,080
、自由エネルギー

2521
01:34:22,080 --> 01:34:25,360
が証拠に拘束されます。

2522
01:34:25,360 --> 01:34:27,120
また

2523
01:34:27,120 --> 01:34:28,960


2524
01:34:28,960 --> 01:34:29,920


2525
01:34:29,920 --> 01:34:32,320
、ベイズ推定を近似するために支払う価格を表すこの事後発散項

2526
01:34:32,320 --> 01:34:35,120


2527
01:34:35,120 --> 01:34:37,600
も考慮されます。 これには2つの部分が

2528
01:34:37,600 --> 01:34:40,320
あり、モデルの証拠の部分

2529
01:34:40,320 --> 01:34:43,119
と事後発散の部分が

2530
01:34:43,119 --> 01:34:47,119
あり、どちらも1つの役割を果たします。

2531
01:34:47,119 --> 01:34:48,400
これは

2532
01:34:48,400 --> 01:34:51,040
私のソリューションの品質です。これは、

2533
01:34:51,040 --> 01:34:52,320


2534
01:34:52,320 --> 01:34:53,040


2535
01:34:53,040 --> 01:34:54,960
モデルが、観察したデータをどれだけうまく説明

2536
01:34:54,960 --> 01:34:57,040
できるかということです。 あなたは

2537
01:34:57,040 --> 01:34:59,840
その驚きまたは否定的な

2538
01:34:59,840 --> 01:35:02,239
ログモーダル証拠の数を得ることができます、

2539
01:35:02,239 --> 01:35:03,600
そしてあなたはこれが価格と情報であるとよく言うステレオ発散の他の部分を持ってい

2540
01:35:03,600 --> 01:35:05,040


2541
01:35:05,040 --> 01:35:07,040
ます

2542
01:35:07,040 --> 01:35:08,800
この

2543
01:35:08,800 --> 01:35:11,119
近似を行うために支払うnは、それがum

2544
01:35:11,119 --> 01:35:12,239


2545
01:35:12,239 --> 01:35:13,840
を評価する単なる混沌としたバージョンであるという数字を付けることもできます。

2546
01:35:13,840 --> 01:35:15,600


2547
01:35:15,600 --> 01:35:17,920
次に、これら2つを加算すると

2548
01:35:17,920 --> 01:35:20,239
、数字

2549
01:35:20,239 --> 01:35:22,559


2550
01:35:22,880 --> 01:35:24,880
umが得られます。したがって、問題は、1つの数字をどのように表すことができるかということ

2551
01:35:24,880 --> 01:35:26,639
です。

2552
01:35:26,639 --> 01:35:29,199


2553
01:35:29,199 --> 01:35:31,840
品質の面ですべてが

2554
01:35:31,840 --> 01:35:33,520


2555
01:35:33,520 --> 01:35:36,080
うまくいくと、モデルが観測を正しく予測または評価する方法とは異なることを気にする可能性が

2556
01:35:36,080 --> 01:35:39,600


2557
01:35:39,600 --> 01:35:42,480
あります。他のことを気にする場合は、

2558
01:35:42,480 --> 01:35:43,440
うん

2559
01:35:43,440 --> 01:35:45,440
、

2560
01:35:45,440 --> 01:35:47,280
そうです。異なる数を使用する可能性がありますが

2561
01:35:47,280 --> 01:35:48,400


2562
01:35:48,400 --> 01:35:52,800
、私たちの意味では 私

2563
01:35:52,800 --> 01:35:54,000
たちの仕事の中で

2564
01:35:54,000 --> 01:35:56,400
私たちは一種のええと

2565
01:35:56,400 --> 01:35:57,440


2566
01:35:57,440 --> 01:35:59,199
私たちはこのベイジアンの品質の尺度を持ちたいと思ってい

2567
01:35:59,199 --> 01:36:00,400
ます

2568
01:36:00,400 --> 01:36:01,199
ええ

2569
01:36:01,199 --> 01:36:02,400
それが本当にあなたの質問に答えるかどうかはわかりません

2570
01:36:02,400 --> 01:36:04,480
がそれはそれでも良い

2571
01:36:04,480 --> 01:36:06,159
質問

2572
01:36:06,159 --> 01:36:08,239
です 自由エネルギーまたは

2573
01:36:08,239 --> 01:36:10,400
あなたが得るその数は、

2574
01:36:10,400 --> 01:36:11,360


2575
01:36:11,360 --> 01:36:13,920
これの背後にあるものの一種で

2576
01:36:13,920 --> 01:36:16,159
あり、確率論はイエスと言いますが

2577
01:36:16,159 --> 01:36:17,600
、実際にそれを適用する場合、あなた

2578
01:36:17,600 --> 01:36:19,520
はおそらく他のことを気に

2579
01:36:19,520 --> 01:36:21,840
します 何人の人があなたが何人の間違いから何人の間違い

2580
01:36:21,840 --> 01:36:23,520
を知っているかを知る前に生き残り

2581
01:36:23,520 --> 01:36:27,199


2582
01:36:27,199 --> 01:36:29,840


2583
01:36:29,840 --> 01:36:31,600
ますそしてあなたがそれをよく気にかけているならあなたはそれを

2584
01:36:31,600 --> 01:36:33,520
パフォーマンス指標として使うべきです

2585
01:36:33,520 --> 01:36:36,880


2586
01:36:36,880 --> 01:36:39,360


2587
01:36:39,360 --> 01:36:42,639


2588
01:36:42,639 --> 01:36:45,920
複雑さから精度を差し引いたものに多くの分解が

2589
01:36:45,920 --> 01:36:48,880
あり、驚きからええと

2590
01:36:48,880 --> 01:36:51,520
、kl発散を差し引いたもの

2591
01:36:51,520 --> 01:36:54,239


2592
01:36:54,239 --> 01:36:54,960


2593
01:36:54,960 --> 01:36:56,560
ですが、質問を

2594
01:36:56,560 --> 01:36:58,320
正しく解釈できるかどうかはわかりませんが、実際にうまくいくことをどのように

2595
01:36:58,320 --> 01:37:00,560
知っていますか？

2596
01:37:00,560 --> 01:37:02,880
現場では、

2597
01:37:02,880 --> 01:37:05,679
あなたは正しくありません。

2598
01:37:05,679 --> 01:37:07,040


2599
01:37:07,040 --> 01:37:10,320


2600
01:37:10,320 --> 01:37:12,800
あなたが言える唯一のことは、システムが何をするかということ

2601
01:37:12,800 --> 01:37:15,119
です。それは

2602
01:37:15,119 --> 01:37:17,280
、自由エネルギーを最小化する構成を探します

2603
01:37:17,280 --> 01:37:19,280
が、あなたはあなたが知らないことを知りません

2604
01:37:19,280 --> 01:37:21,040
。 そのモデルをシミュレートし

2605
01:37:21,040 --> 01:37:23,119
ていなければ、より良い結果が得られる別のモデルがあるかどうかは

2606
01:37:23,119 --> 01:37:26,000
わかりません。エラーを生成する

2607
01:37:26,000 --> 01:37:27,600


2608
01:37:27,600 --> 01:37:29,679
ことが唯一の学習機会である

2609
01:37:29,679 --> 01:37:30,639


2610
01:37:30,639 --> 01:37:34,480


2611
01:37:34,480 --> 01:37:37,119
ため、モデルを実際に改善する唯一の方法はわかりません。

2612
01:37:37,119 --> 01:37:38,480
実際に

2613
01:37:38,480 --> 01:37:42,000
こんにちは 確かに、

2614
01:37:42,000 --> 01:37:43,520
それが機能していない状況を考えてみ

2615
01:37:43,520 --> 01:37:45,280
ましょう。その後、パラメータを調整する必要があります。

2616
01:37:45,280 --> 01:37:47,280


2617
01:37:47,280 --> 01:37:49,520
さらに、時間の経過とともに構造化する必要があります。

2618
01:37:49,520 --> 01:37:50,800


2619
01:37:50,800 --> 01:37:52,239


2620
01:37:52,239 --> 01:37:53,920
つまり、優れたシステムを構築することはプロセスであり、

2621
01:37:53,920 --> 01:37:55,520


2622
01:37:55,520 --> 01:37:57,679
それは

2623
01:37:57,679 --> 01:38:00,000
問題ではありません。

2624
01:38:00,000 --> 01:38:01,600


2625
01:38:01,600 --> 01:38:02,400


2626
01:38:02,400 --> 01:38:04,400
システムを構築するだけで、それが完全に

2627
01:38:04,400 --> 01:38:06,159
正しく機能する場合は、非常に

2628
01:38:06,159 --> 01:38:07,280
幸運

2629
01:38:07,280 --> 01:38:09,040
である必要があります。

2630
01:38:09,040 --> 01:38:11,119
この軌道間のアクティブな

2631
01:38:11,119 --> 01:38:13,600
影響が説明するのは

2632
01:38:13,600 --> 01:38:15,520
、より良い

2633
01:38:15,520 --> 01:38:18,000
システムに向けたプロセスですが、作成しない

2634
01:38:18,000 --> 01:38:19,440
システムについては説明して

2635
01:38:19,440 --> 01:38:21,600
いません。 間違い実際には

2636
01:38:21,600 --> 01:38:23,840
学ぶのに間違いが必要であり

2637
01:38:23,840 --> 01:38:27,040
、プロセスの素晴らしいポイントを説明してい

2638
01:38:27,040 --> 01:38:30,000


2639
01:38:30,000 --> 01:38:32,080
ます。何かのようにテストで100を取得した場合

2640
01:38:32,080 --> 01:38:35,119


2641
01:38:35,119 --> 01:38:38,159


2642
01:38:38,159 --> 01:38:40,400
、最悪の場合は有益ではないという運用上の洞察があります。

2643
01:38:40,400 --> 01:38:43,280
間違った道を進んでいくと

2644
01:38:43,280 --> 01:38:45,360
、食料品店のように

2645
01:38:45,360 --> 01:38:46,960
、さまざまなオブジェクトを1つの指標に従ってランク付けしていることを思い出しました。

2646
01:38:46,960 --> 01:38:49,520


2647
01:38:49,520 --> 01:38:51,600
実際には、見つけるためのバランス戦略のようなものではありません。

2648
01:38:51,600 --> 01:38:53,280


2649
01:38:53,280 --> 01:38:54,080


2650
01:38:54,080 --> 01:38:55,760
好みとそれ

2651
01:38:55,760 --> 01:38:56,639
は因数分解や平均場のようなこれらの仮定のすべてが

2652
01:38:56,639 --> 01:38:58,320


2653
01:38:58,320 --> 01:39:00,000
あなたに毎回最高のオブジェクトを与えることが保証されていないところです

2654
01:39:00,000 --> 01:39:02,400
そしてそれでも

2655
01:39:02,400 --> 01:39:04,560
現実世界の確率論とそれが終わりではないよう

2656
01:39:04,560 --> 01:39:06,080
に変化する食料品店の能力があります

2657
01:39:06,080 --> 01:39:08,639
話の中で、

2658
01:39:08,639 --> 01:39:10,000
これは実際に

2659
01:39:10,000 --> 01:39:12,880


2660
01:39:12,880 --> 01:39:14,560
は、反応性グラフと生物学的システムの機能のいくつかを備えたプロセスの実践にすぎ

2661
01:39:14,560 --> 01:39:17,360


2662
01:39:17,360 --> 01:39:20,080


2663
01:39:20,080 --> 01:39:22,960
ません。最終的なコメントがあれば、

2664
01:39:22,960 --> 01:39:24,840
これは本当に

2665
01:39:24,840 --> 01:39:27,520
これについて学ぶのに最もクールな時期の1つでし

2666
01:39:27,520 --> 01:39:28,800
た。

2667
01:39:28,800 --> 01:39:31,040
いつ

2668
01:39:31,040 --> 01:39:33,199
でも参加者として参加したり、プレゼンテーションを行ったりする

2669
01:39:33,199 --> 01:39:35,360
ことができます。最後のコメントがあれば、ここに

2670
01:39:35,360 --> 01:39:36,639


2671
01:39:36,639 --> 01:39:38,080
いることができて

2672
01:39:38,080 --> 01:39:41,199
本当に嬉しかった

2673
01:39:41,199 --> 01:39:43,600
です。新しいものがあれば、また戻ってきたいです。

2674
01:39:43,600 --> 01:39:45,760


2675
01:39:45,760 --> 01:39:49,520
ここで素晴らしい素晴らしいショーだと思うか、

2676
01:39:49,520 --> 01:39:52,239
フォーラムかそれが適切に呼ばれているものを見せてください、

2677
01:39:52,239 --> 01:39:54,000
しかし私はそれを本当に楽しんでいます、そして私たち

2678
01:39:54,000 --> 01:39:56,000
はそれの一部であることを本当に楽しんでい

2679
01:39:56,000 --> 01:39:58,320
ました

2680
01:39:58,320 --> 01:40:00,320
そこにも考えるべき食べ物が

2681
01:40:00,320 --> 01:40:01,520


2682
01:40:01,520 --> 01:40:03,679


2683
01:40:03,679 --> 01:40:05,840
あります。

2684
01:40:05,840 --> 01:40:06,639


2685
01:40:06,639 --> 01:40:11,320
次回まで大丈夫です。

