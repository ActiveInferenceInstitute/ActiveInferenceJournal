1
00:00:00,080 --> 00:00:02,639
신호 처리 그룹

2
00:00:02,639 --> 00:00:04,400
과 그래서 저는

3
00:00:04,400 --> 00:00:05,680
제 훈련을 설계했습니다

4
00:00:05,680 --> 00:00:08,080
죄송합니다 사실 한 가지만

5
00:00:08,080 --> 00:00:10,559
변경하면 다시 시작할 수 있지만

6
00:00:10,559 --> 00:00:11,920


7
00:00:11,920 --> 00:00:12,960
괜찮습니다

8
00:00:12,960 --> 00:00:15,679
어 소개해주셔서 감사합니다 그럼 제

9
00:00:15,679 --> 00:00:18,320
이름은 베르티 프라이입니다 저는

10
00:00:18,320 --> 00:00:20,400
아인트호벤

11
00:00:20,400 --> 00:00:21,920
공과 대학의 아인트호벤 교수입니다

12
00:00:21,920 --> 00:00:23,840
네덜란드에서

13
00:00:23,840 --> 00:00:25,920
나는 신호 처리 그룹의 전기 공학 부서의 일원이 될 것이므로

14
00:00:25,920 --> 00:00:28,000


15
00:00:28,000 --> 00:00:30,480


16
00:00:30,480 --> 00:00:33,600
신호 처리 알고리즘을 설계했으며 약

17
00:00:33,600 --> 00:00:36,320
6년 7년 전에 나는

18
00:00:36,320 --> 00:00:38,399
처음으로 칼 피스턴의 논문을 읽었습니다

19
00:00:38,399 --> 00:00:40,559


20
00:00:40,559 --> 00:00:41,760
.

21
00:00:41,760 --> 00:00:44,160
저는 이것이 신호 처리에 환상적일 수 있다는 사실에 놀랐습니다.

22
00:00:44,160 --> 00:00:46,399
그래서 그 이후

23
00:00:46,399 --> 00:00:49,039
로 저는

24
00:00:49,039 --> 00:00:50,640
제 연구실의 사람들과 함께 신호 처리 알고리즘

25
00:00:50,640 --> 00:00:53,360


26
00:00:53,360 --> 00:00:56,559
의 설계 프로세스를 자동화할 설계를 실현할 에이전트를 실현하기 위해 노력

27
00:00:56,559 --> 00:00:59,199
하고

28
00:00:59,199 --> 00:01:01,120
있습니다. 아시다시피 우리는  메시지

29
00:01:01,120 --> 00:01:02,960
전달로 이것을 하고 우리는 오늘 그것에 대해 이야기하고 싶습니다

30
00:01:02,960 --> 00:01:05,199


31
00:01:05,199 --> 00:01:06,799
어

32
00:01:06,799 --> 00:01:10,400
타이 예 음 제 이름은 타이슨입니다. 저는

33
00:01:10,400 --> 00:01:13,760
새 연구실의 포스터입니다. 저는 박사 학위도

34
00:01:13,760 --> 00:01:15,280
활성 추론을 했습니다.  이러한 프로세스를 자동화하는 방법

35
00:01:15,280 --> 00:01:17,840


36
00:01:17,840 --> 00:01:20,080
과 michael cox 및

37
00:01:20,080 --> 00:01:22,000
실험실의 모든 동료와 함께 fornilab이라는 도구 상자를 구축

38
00:01:22,000 --> 00:01:24,400


39
00:01:24,400 --> 00:01:27,600
했으며 활성 인프라 추론 컨텍스트에서 이를 적용하는 방법에 대해 이야기

40
00:01:27,600 --> 00:01:30,400


41
00:01:30,400 --> 00:01:32,560
하고 안내해 드리겠습니다.  그것으로 몇 가지 멋진 일을 하십시오.

42
00:01:32,560 --> 00:01:35,920
그럼 그건 나중을 위한 것입니다.

43
00:01:37,439 --> 00:01:39,759
안녕하세요 여러분, 제 이름은 nitri

44
00:01:39,759 --> 00:01:42,640
bhagav입니다. 저는 대학의 Hue에서도 바이어스 연구실의 박사 후보입니다.

45
00:01:42,640 --> 00:01:46,000
예 제

46
00:01:46,000 --> 00:01:48,000
작업은 주로 반응적 메시지

47
00:01:48,000 --> 00:01:50,960
가격 책정 기반 베이지안 추론

48
00:01:50,960 --> 00:01:52,960
에 관한 것입니다.  능동 추론에도 도움이 될

49
00:01:52,960 --> 00:01:55,119
것이지만 그건 나중을 위한

50
00:01:55,119 --> 00:01:56,960
것이기도 합니다. 어 시간에 그것에 대해 이야기하겠습니다.

51
00:01:56,960 --> 00:01:57,920


52
00:01:57,920 --> 00:02:01,439
예, 제 슬롯

53
00:02:01,759 --> 00:02:04,640
이 좋습니다. 감사합니다.

54
00:02:05,119 --> 00:02:07,520
음 음, 음,

55
00:02:07,520 --> 00:02:10,160
그럼 가서 약간의

56
00:02:10,160 --> 00:02:12,560
소개를

57
00:02:12,560 --> 00:02:14,000


58
00:02:14,000 --> 00:02:16,400


59
00:02:16,400 --> 00:02:18,640
하겠습니다.  내 슬라이드를 공유할 수 있다면

60
00:02:18,640 --> 00:02:20,000


61
00:02:20,000 --> 00:02:21,360


62
00:02:21,360 --> 00:02:23,040
예, 좋아 보입니다

63
00:02:23,040 --> 00:02:25,040


64
00:02:25,040 --> 00:02:25,840
.

65
00:02:25,840 --> 00:02:29,040
첫 번째 슬라이드는 어 아인트호벤

66
00:02:29,040 --> 00:02:31,120
음입니다. 암스테르담과 관련하여 제가 아는 곳이 어디인지 궁금하실 텐데요.

67
00:02:31,120 --> 00:02:33,680


68
00:02:33,680 --> 00:02:34,560


69
00:02:34,560 --> 00:02:37,280
암스테르담에서 남쪽으로 약 100km 떨어진

70
00:02:37,280 --> 00:02:39,680
곳에  벨기에 국경이고 독일에서 그리 멀지도 않은

71
00:02:39,680 --> 00:02:41,840


72
00:02:41,840 --> 00:02:42,640
음..

73
00:02:42,640 --> 00:02:44,959
그래서 일종의 하이테크 시티

74
00:02:44,959 --> 00:02:46,080
필립스가

75
00:02:46,080 --> 00:02:48,400
발원하여 열었습니다. 오른쪽

76
00:02:48,400 --> 00:02:50,560
하단에 중앙 사진이

77
00:02:50,560 --> 00:02:53,599
보이고 오른쪽 상단

78
00:02:53,599 --> 00:02:55,680
이 우리

79
00:02:55,680 --> 00:02:57,519
대학 캠퍼스 전경  여기 기술에 대한 설명이

80
00:02:57,519 --> 00:03:00,319
있습니다.

81
00:03:00,319 --> 00:03:02,840
5개의 그룹을 통과하는 그룹의 조감도입니다. 여기

82
00:03:02,840 --> 00:03:05,360
우리 캠퍼스

83
00:03:05,360 --> 00:03:07,760
의 조감도입니다. 그래서

84
00:03:07,760 --> 00:03:11,120
여기에서 포인터를 공유할 수 있는지 봅시다.

85
00:03:11,120 --> 00:03:13,440
예 그래서 어 이것은

86
00:03:13,440 --> 00:03:14,959
전기 공학을 위한 건물이므로 여기가 우리가 있는 곳

87
00:03:14,959 --> 00:03:16,239
입니다

88
00:03:16,239 --> 00:03:18,560
ios lab은 짧습니다  우리가 구축하려고 하는 베이지안

89
00:03:18,560 --> 00:03:20,480
지능형 자율 시스템의 경우

90
00:03:20,480 --> 00:03:22,959


91
00:03:22,959 --> 00:03:25,519


92
00:03:25,519 --> 00:03:28,000
교직원이 약 3명

93
00:03:28,000 --> 00:03:31,200
이고 현재 6명의 박사 과정 학생이 있다고 가정해 보겠습니다.

94
00:03:31,200 --> 00:03:33,120


95
00:03:33,120 --> 00:03:35,519


96
00:03:35,519 --> 00:03:37,760


97
00:03:37,760 --> 00:03:40,640


98
00:03:40,640 --> 00:03:43,200
능동 추론이 작동하도록 하는 방법

99
00:03:43,200 --> 00:03:45,680
그러면 우리가 하려고 하는 것은

100
00:03:45,680 --> 00:03:47,360


101
00:03:47,360 --> 00:03:50,239
이 uh 포럼의 모든 사람에게 친숙한 그림입니다. 맞습니다.

102
00:03:50,239 --> 00:03:52,560
뇌

103
00:03:52,560 --> 00:03:53,840
에서 실제로 일어나고 있는 유일한

104
00:03:53,840 --> 00:03:55,200


105
00:03:55,200 --> 00:03:57,680


106
00:03:57,680 --> 00:03:59,120


107
00:03:59,120 --> 00:04:00,560
일은 모든 것을 수행하기 위해 에너지 최소화 또는 예상되는 자유 에너지 최소화를 위한

108
00:04:00,560 --> 00:04:03,360
것이며 이는 우리 엔지니어들에게 큰 영감을 줍니다.

109
00:04:03,360 --> 00:04:05,599
그래서 우리가 하려고 하는 것은

110
00:04:05,599 --> 00:04:08,159
기본적으로 이것을 넣는 것입니다.

111
00:04:08,159 --> 00:04:10,879
아이폰이나 라즈베리 파이

112
00:04:10,879 --> 00:04:12,560
에서 로봇

113
00:04:12,560 --> 00:04:14,560
이 자전거 타는 법을 배우게 하세요.

114
00:04:14,560 --> 00:04:16,798
하지만 엔지니어링 목적을 위한 이 프레임워크의 아름다움

115
00:04:16,798 --> 00:04:19,839


116
00:04:19,839 --> 00:04:22,479
은 모든 문제에 대한 거의 하나의 솔루션 접근

117
00:04:22,479 --> 00:04:24,080


118
00:04:24,080 --> 00:04:26,240


119
00:04:26,240 --> 00:04:27,440
방식이라는 점입니다.  에너지 최소화를 작성하기 위해

120
00:04:27,440 --> 00:04:30,400
아마도

121
00:04:30,400 --> 00:04:33,360
이것을 가상 현실에 적용할 수 있고

122
00:04:33,360 --> 00:04:35,120
보청기 또는 심지어

123
00:04:35,120 --> 00:04:38,160
자율주행차용 알고리즘

124
00:04:38,240 --> 00:04:40,240


125
00:04:40,240 --> 00:04:41,280


126
00:04:41,280 --> 00:04:43,360
을

127
00:04:43,360 --> 00:04:45,840
설계

128
00:04:45,840 --> 00:04:48,240
할 수도 있습니다.

129
00:04:48,240 --> 00:04:50,240


130
00:04:50,240 --> 00:04:51,440


131
00:04:51,440 --> 00:04:53,520
응용 프로그램이 무엇이든 관계없이 모델을 제안하고 자유 에너지를 최소화하는 것이 매우 매력적입니다. 그러나

132
00:04:53,520 --> 00:04:54,840


133
00:04:54,840 --> 00:04:56,400


134
00:04:56,400 --> 00:04:59,919
엔지니어링의 문제는 이

135
00:04:59,919 --> 00:05:02,000
에너지

136
00:05:02,000 --> 00:05:04,560
기능이 관찰자의 함수라는 것입니다.  vations 및

137
00:05:04,560 --> 00:05:07,600
관찰은 스트리밍 데이터는

138
00:05:07,600 --> 00:05:08,800
일반적으로

139
00:05:08,800 --> 00:05:10,560


140
00:05:10,560 --> 00:05:13,199
매 밀리초마다 있을 수 있으므로 매우

141
00:05:13,199 --> 00:05:14,880
시변하는 함수

142
00:05:14,880 --> 00:05:17,360
이고 잠재 변수의 수

143
00:05:17,360 --> 00:05:19,919
는 잠재 변수의 공간이

144
00:05:19,919 --> 00:05:23,039
일반적으로 매우 높기 때문에 시간에 따라 변하는 매우 높은

145
00:05:23,039 --> 00:05:24,639
차원의 함수가 있다고 가정해 보겠습니다.

146
00:05:24,639 --> 00:05:25,759


147
00:05:25,759 --> 00:05:27,120
그리고

148
00:05:27,120 --> 00:05:29,280
우리는 이제 뇌가 아주 잘하고 있다는 것을 최소화하고 싶습니다.

149
00:05:29,280 --> 00:05:31,360
바로 뇌가

150
00:05:31,360 --> 00:05:34,880
14개의 시냅스의 10의 거듭제곱인

151
00:05:34,880 --> 00:05:38,720
1000억 유로

152
00:05:38,720 --> 00:05:41,039
지만 일반적인

153
00:05:41,039 --> 00:05:43,120
최적화 라이브러리와 모델업이 아니면

154
00:05:43,120 --> 00:05:45,360
파이썬이 이를 잘라낼 수 없습니다.

155
00:05:45,360 --> 00:05:47,840
최소화할 수 없습니다  matlab에 있는

156
00:05:47,840 --> 00:05:49,919
수천 개의 변수의 시변 기능

157
00:05:49,919 --> 00:05:51,759
은 작동하지 않을

158
00:05:51,759 --> 00:05:55,520
것이므로 여기에 매우 급진적인 것이 필요합니다.

159
00:05:55,520 --> 00:05:57,840
우리가 가지고 가는 아이디어는 다시 급진적이지 않습니다.

160
00:05:57,840 --> 00:06:00,800
우리

161
00:06:00,800 --> 00:06:03,520
는 뇌에서 영감을 얻습니다. 오른쪽 뇌는

162
00:06:03,520 --> 00:06:07,039
메시지 전달의 네트워크이며 밝혀졌습니다

163
00:06:07,039 --> 00:06:09,360


164
00:06:09,360 --> 00:06:12,240
신호 처리

165
00:06:12,240 --> 00:06:15,440
또는 정보 이론의 제 분야에서 정확히

166
00:06:15,440 --> 00:06:17,840
이것은 공식화되었습니다.

167
00:06:17,840 --> 00:06:18,880
여기

168
00:06:18,880 --> 00:06:22,000
에 2001년 dave forney의 논문이 있습니다.

169
00:06:22,000 --> 00:06:24,560
code on graphs normal re  그는

170
00:06:24,560 --> 00:06:27,039
그것을 normal factor graphs라고 불렀지만

171
00:06:27,039 --> 00:06:29,840
David forney를 기리기 위해 오늘날

172
00:06:29,840 --> 00:06:31,360
에는 forney style factory graphs라고 부릅니다.

173
00:06:31,360 --> 00:06:32,319


174
00:06:32,319 --> 00:06:33,440


175
00:06:33,440 --> 00:06:35,600
그래서 이것이 우리가 이야기하고 있는 factor 그래프의 기원이며

176
00:06:35,600 --> 00:06:37,280


177
00:06:37,280 --> 00:06:39,120
몇 년 후

178
00:06:39,120 --> 00:06:41,600
대학의 hans andreia luliger

179
00:06:41,600 --> 00:06:43,039
입니다.  시리즈

180
00:06:43,039 --> 00:06:45,280
어 나는 이것을

181
00:06:45,280 --> 00:06:47,840
신호 처리 커뮤니티에서 인기를

182
00:06:47,840 --> 00:06:51,360
얻었고 이미 2007년경

183
00:06:51,360 --> 00:06:54,479
그의 논문에서 볼 수 있습니다. 어

184
00:06:54,479 --> 00:06:56,720
그래

185
00:06:56,720 --> 00:06:58,560
우리가 나중에 보여줄 이러한 전형적인 구조는

186
00:06:58,560 --> 00:07:00,080
칼만 필터입니다.

187
00:07:00,080 --> 00:07:01,919
이것은 실제로 tristan이 이러한 종류에 대해 말하는 것이기도 합니다.

188
00:07:01,919 --> 00:07:04,880


189
00:07:04,880 --> 00:07:06,960


190
00:07:06,960 --> 00:07:08,639
우리 언어로 하고자 하는 것은

191
00:07:08,639 --> 00:07:10,800


192
00:07:10,800 --> 00:07:13,039


193
00:07:13,039 --> 00:07:14,319
신경과학 커뮤니티에서 영감을 얻은 능동적 추론

194
00:07:14,319 --> 00:07:16,639
을 결합하고 요인 그래프에 대한

195
00:07:16,639 --> 00:07:18,240
신호 처리 및 정보 이론에서 알고 있는 것과 결합하고

196
00:07:18,240 --> 00:07:20,560


197
00:07:20,560 --> 00:07:24,639
이러한 도구를 사용하여 다음을 수행하는 것입니다.  이를 구현하기 위해

198
00:07:24,639 --> 00:07:26,560
uh 그래서 오늘

199
00:07:26,560 --> 00:07:29,199
우리는

200
00:07:29,199 --> 00:07:30,479


201
00:07:30,479 --> 00:07:33,120
uh forney lab forney lab에서 메시지 전달 방법에 대해 텍스트로 하나씩 두 가지 프레젠테이션을 합니다.

202
00:07:33,120 --> 00:07:35,360


203
00:07:35,360 --> 00:07:36,800
우리가 쓴 도구 상자입니다

204
00:07:36,800 --> 00:07:38,160


205
00:07:38,160 --> 00:07:40,960
어 물론 이름은 forney를 나타냅니다

206
00:07:40,960 --> 00:07:42,720
어 그리고 태국 사람은 이 도구 상자로 능동적인 영향을 미치는 방법을 보여줄 것입니다.

207
00:07:42,720 --> 00:07:45,120


208
00:07:45,120 --> 00:07:47,280
그런 다음 우리는 또한 반응 메시지 전달이라고 하는 새 버전을 작업 중이며

209
00:07:47,280 --> 00:07:49,680


210
00:07:49,680 --> 00:07:51,520
dmitry가 메인입니다  거기 사람과

211
00:07:51,520 --> 00:07:53,280
dimitri 또한

212
00:07:53,280 --> 00:07:55,280
그것에 대해 조금 이야기

213
00:07:55,280 --> 00:07:57,360
하고 그게 전부입니다

214
00:07:57,360 --> 00:07:59,680
음 내가 당신에게 그것을 다시 줄 것입니다 dan 또는 어쩌면

215
00:07:59,680 --> 00:08:00,800
어

216
00:08:00,800 --> 00:08:02,960
계속할 수 있습니다 당신의 선호도가 무엇인지 계속할 수 있습니다

217
00:08:02,960 --> 00:08:03,840


218
00:08:03,840 --> 00:08:06,720
내 화면 공유를 중단하겠습니다

219
00:08:06,720 --> 00:08:08,400


220
00:08:08,400 --> 00:08:10,720
매우 흥미 롭습니다 감사합니다

221
00:08:10,720 --> 00:08:12,479
문맥에 대해 그리고

222
00:08:12,479 --> 00:08:14,400


223
00:08:14,400 --> 00:08:16,560


224
00:08:16,560 --> 00:08:18,879
당신이 제기한 일반적인 요점과

225
00:08:18,879 --> 00:08:20,960
그것이 정말로 구체적인 방식으로 적용되는 방법

226
00:08:20,960 --> 00:08:22,319


227
00:08:22,319 --> 00:08:24,960
에 대해 저자의 의견을 듣는 것은 정말 멋진 일입니다.

228
00:08:24,960 --> 00:08:27,440
하나의 통합된 접근 방식의 단순성과

229
00:08:27,440 --> 00:08:29,759
지속적인 최적화 문제의 도전

230
00:08:29,759 --> 00:08:31,520
과 자연에서 영감

231
00:08:31,520 --> 00:08:33,599
을 얻는 것 너무 좋은 것

232
00:08:33,599 --> 00:08:35,440


233
00:08:35,440 --> 00:08:36,880


234
00:08:36,880 --> 00:08:38,719


235
00:08:38,719 --> 00:08:40,640
d 그리고 내 화면을 공유해 보세요.

236
00:08:40,640 --> 00:08:42,000


237
00:08:42,000 --> 00:08:44,880


238
00:08:46,130 --> 00:08:49,189
[음악]

239
00:08:53,279 --> 00:08:56,160
Windows 화면 전체 화면 선택

240
00:08:56,160 --> 00:08:58,800
좋습니다. 훨씬 더

241
00:09:00,720 --> 00:09:02,080
실용적인 스트림입니다. 이제 내 화면을 볼 수 있다고 생각합니다.

242
00:09:02,080 --> 00:09:03,839


243
00:09:03,839 --> 00:09:05,600
네 옆에서 보기에

244
00:09:05,600 --> 00:09:07,200
크기를 조정할 수 있습니다.  잘 가겠습니다

245
00:09:07,200 --> 00:09:09,440


246
00:09:09,440 --> 00:09:11,920


247
00:09:11,920 --> 00:09:14,160
잘 가겠습니다 다시 한번 클릭해 주시면 감사

248
00:09:14,160 --> 00:09:15,440
하겠습니다 움 화면

249
00:09:15,440 --> 00:09:17,040
을 공유하고 있다고 나와 있는 부분에 약간의 소개를 할게요 죄송합니다

250
00:09:17,040 --> 00:09:19,040


251
00:09:19,040 --> 00:09:21,600
그 작은 짓을 숨길 수 있습니다

252
00:09:21,600 --> 00:09:23,600
음 그리고 사라졌습니다

253
00:09:23,600 --> 00:09:25,040
감사합니다  you

254
00:09:25,040 --> 00:09:26,880
so um

255
00:09:26,880 --> 00:09:28,560


256
00:09:28,560 --> 00:09:30,320
yes 능동적 추론의 맥락에서 가짜 랩으로 메시지 전달을 수행하는 방법에 대해 약간 소개

257
00:09:30,320 --> 00:09:32,800


258
00:09:32,800 --> 00:09:34,480
하고 이 강연에 약간의 동기

259
00:09:34,480 --> 00:09:37,040
를 부여하기 위해 음 이것은

260
00:09:37,040 --> 00:09:39,360
우리가 관심을 갖고 있는 상황입니다.

261
00:09:39,360 --> 00:09:42,000
어떤 종류의

262
00:09:42,000 --> 00:09:43,600
환경이 있고

263
00:09:43,600 --> 00:09:45,360
해당 환경에서 실행 중인 환경 프로세스가 있으며 해당 환경 내에서

264
00:09:45,360 --> 00:09:47,680


265
00:09:47,680 --> 00:09:49,760
목적이 있거나 목적이 있는

266
00:09:49,760 --> 00:09:53,120
작업을 수행하는 에이전트를

267
00:09:53,120 --> 00:09:54,959
개발하고 에이전트가

268
00:09:54,959 --> 00:09:56,640
d 환경에 대한 조치를

269
00:09:56,640 --> 00:09:58,880
취하고 해당 환경을 조작하면

270
00:09:58,880 --> 00:10:02,160
관찰이 수신

271
00:10:02,160 --> 00:10:04,320
되며 환경 프로세스에는

272
00:10:04,320 --> 00:10:05,519


273
00:10:05,519 --> 00:10:08,320
거기에서 실행되는 일부 기능 rt

274
00:10:08,320 --> 00:10:10,000
가 있으며 우리가 실행하는 시뮬레이션일 수도 있고 우리가

275
00:10:10,000 --> 00:10:11,760
상호 작용할 수도 있고 실제 프로세스일 수도 있습니다.

276
00:10:11,760 --> 00:10:14,079
물론 우리

277
00:10:14,079 --> 00:10:16,640
는 rt가 실제 세계에서 실행되고 있는지 실제로 알지 못하고

278
00:10:16,640 --> 00:10:19,120
어떻게든

279
00:10:19,120 --> 00:10:21,680
그 세계에서 무언가를 수행하는 에이전트를 만들고 싶습니다.

280
00:10:21,680 --> 00:10:23,279


281
00:10:23,279 --> 00:10:26,640
그래서 1970년대에 conant와 ashby의 이 논문이 있다는 것을 어디서부터 시작합니까?

282
00:10:26,800 --> 00:10:29,360


283
00:10:29,360 --> 00:10:31,040


284
00:10:31,040 --> 00:10:32,480
그들은

285
00:10:32,480 --> 00:10:33,600


286
00:10:33,600 --> 00:10:36,000
시스템의 모든 좋은 레귤레이터가 해당 시스템

287
00:10:36,000 --> 00:10:39,040
의 모델이어야 한다는 흥미로운 정리를 가지고 있습니다.

288
00:10:39,040 --> 00:10:39,920


289
00:10:39,920 --> 00:10:41,519
따라서 실제로 우리 시스템 환경을 규제하거나 조작

290
00:10:41,519 --> 00:10:43,120
하는 에이전트를 구축하려면

291
00:10:43,120 --> 00:10:44,839


292
00:10:44,839 --> 00:10:47,839


293
00:10:47,839 --> 00:10:51,920
해당 시스템을 다음과 같이 모델링해야 합니다.

294
00:10:51,920 --> 00:10:53,600


295
00:10:53,600 --> 00:10:55,920
엔지니어 우리는 정확한 생성

296
00:10:55,920 --> 00:10:57,839
모델을 구축하는 사업을

297
00:10:57,839 --> 00:11:00,880


298
00:11:00,880 --> 00:11:03,120
하고 있으며 이 모델은 우리의 조작에서 관찰이 어떻게 이어지는지에 대한 우리의 믿음을 나타냅니다.

299
00:11:03,120 --> 00:11:04,160


300
00:11:04,160 --> 00:11:05,920


301
00:11:05,920 --> 00:11:09,839


302
00:11:09,839 --> 00:11:12,160
y의 함수인 함수 f로 표시

303
00:11:12,160 --> 00:11:15,839


304
00:11:15,839 --> 00:11:17,839
관찰 제어 u

305
00:11:17,839 --> 00:11:20,560
및 관찰과 제어 사이의 중간 역할을 하는 일부 잠재 상태 숨겨진

306
00:11:20,560 --> 00:11:23,440
변수 x

307
00:11:23,440 --> 00:11:25,440


308
00:11:25,440 --> 00:11:29,160


309
00:11:30,160 --> 00:11:31,760
이제

310
00:11:31,760 --> 00:11:34,000
앞으로 추론하는 것은 한 가지

311
00:11:34,000 --> 00:11:36,160
이지만 결국 우리가 원하는 것은 관찰하는

312
00:11:36,160 --> 00:11:38,640
것입니다  그런 다음

313
00:11:38,640 --> 00:11:41,600
우리를 유리한 상태로 이끄는 통제를 제안

314
00:11:41,600 --> 00:11:42,959


315
00:11:42,959 --> 00:11:44,880
하고 자유 에너지 원칙

316
00:11:44,880 --> 00:11:47,519
과 능동 추론

317
00:11:47,519 --> 00:11:49,440
의 아이디어

318
00:11:49,440 --> 00:11:51,360


319
00:11:51,360 --> 00:11:53,600


320
00:11:53,600 --> 00:11:55,440
가 나오는 곳입니다.  우리는 놀라움에

321
00:11:55,440 --> 00:11:58,240
구속된 자유 에너지를 최소화함으로써

322
00:11:58,240 --> 00:12:00,240


323
00:12:00,240 --> 00:12:02,320
그렇게 할 수 있으므로 놀라움을 피하는 에이전트를 만들고

324
00:12:02,320 --> 00:12:05,040


325
00:12:05,040 --> 00:12:07,600
해당 환경에 대해 베이지안 추론을 할 수

326
00:12:07,600 --> 00:12:09,600
있으므로 에이전트가 최적화하고 기능할 수 있는 일종의 자유 에너지 기능을 구축해야 합니다.

327
00:12:09,600 --> 00:12:11,200


328
00:12:11,200 --> 00:12:13,680


329
00:12:13,680 --> 00:12:16,720


330
00:12:16,720 --> 00:12:19,540
행동과 통제

331
00:12:19,540 --> 00:12:20,959
[음악]에 대한 그 기간 추론에 의해

332
00:12:20,959 --> 00:12:23,760
그리고 우리

333
00:12:23,760 --> 00:12:26,240


334
00:12:26,240 --> 00:12:28,160
는 우리가 가지고 있는 생성 모델

335
00:12:28,160 --> 00:12:29,600
과 s 사이의 kl 발산으로 기능적 에너지로 정의했습니다.

336
00:12:29,600 --> 00:12:32,959
우리가 여기에서

337
00:12:32,959 --> 00:12:35,839
q t 를 정의

338
00:12:36,000 --> 00:12:38,240
하고 이 에너지 기능을 최소화한다고 가정하는 대략적인 사후 유형

339
00:12:38,240 --> 00:12:40,160
은 그런 다음 우리가 관찰에서 통제 쪽으로 거꾸로 추론할 수 있게 해줄

340
00:12:40,160 --> 00:12:44,560


341
00:12:45,360 --> 00:12:48,720
것입니다. 이는 일종의 일반적인 아이디어

342
00:12:48,720 --> 00:12:50,320


343
00:12:50,320 --> 00:12:52,480
이고 이것을 가정하면

344
00:12:52,480 --> 00:12:53,360


345
00:12:53,360 --> 00:12:55,680
예를 들어 하나의 큰 선택을 할 수 있습니다.

346
00:12:55,680 --> 00:12:57,760
내가 만들고 싶은 선택은 내 모델을

347
00:12:57,760 --> 00:12:59,600
선택

348
00:12:59,600 --> 00:13:01,760
하는 방법입니다. 나에게 유용한 방식으로 f를 선택하는 방법

349
00:13:01,760 --> 00:13:03,839


350
00:13:03,839 --> 00:13:06,399
과 qut를 선택

351
00:13:06,399 --> 00:13:08,320


352
00:13:08,320 --> 00:13:09,440


353
00:13:09,440 --> 00:13:13,040
하는 방법은 무엇입니까?  추론

354
00:13:13,120 --> 00:13:14,160
과

355
00:13:14,160 --> 00:13:17,360
그 과정은 일종의 시행착오를 겪으며

356
00:13:17,360 --> 00:13:19,120


357
00:13:19,120 --> 00:13:20,800


358
00:13:20,800 --> 00:13:22,480
음 엔지니어로서 당연히

359
00:13:22,480 --> 00:13:24,959
할 수 있는 최고의 모델

360
00:13:24,959 --> 00:13:26,959


361
00:13:26,959 --> 00:13:28,720


362
00:13:28,720 --> 00:13:30,959
을 만들고 싶지만  나에게

363
00:13:30,959 --> 00:13:34,199
최고의 모델

364
00:13:34,560 --> 00:13:36,800
이 표시되고 이것이 모델 디자인 주기의 아이디어가 나오는 곳

365
00:13:36,800 --> 00:13:39,199


366
00:13:39,199 --> 00:13:41,839
이며 이것은

367
00:13:41,839 --> 00:13:43,120
David

368
00:13:43,120 --> 00:13:45,440
bly가 2014년에 작성한 자신의 논문에서

369
00:13:45,440 --> 00:13:47,600


370
00:13:47,600 --> 00:13:49,760
다시 유명해졌습니다.

371
00:13:49,760 --> 00:13:52,240
엔지니어가 모델을 제안한

372
00:13:52,240 --> 00:13:54,320
다음 해당 모델을 사용

373
00:13:54,320 --> 00:13:56,480
하여 주어진 데이터의 관심 수량을

374
00:13:56,480 --> 00:13:58,079


375
00:13:58,079 --> 00:13:59,600
추론하고 싶은 경우 모델

376
00:13:59,600 --> 00:14:01,279
을 비판하고

377
00:14:01,279 --> 00:14:02,720


378
00:14:02,720 --> 00:14:04,560


379
00:14:04,560 --> 00:14:07,680
평가한 성능을 기반으로 모델을 다시 작성하고 싶은 경우 모델을 다시 작성하고 싶습니다.

380
00:14:07,680 --> 00:14:08,800


381
00:14:08,800 --> 00:14:09,839


382
00:14:09,839 --> 00:14:10,720
다시 추론

383
00:14:10,720 --> 00:14:12,959
하고 그것이 얼마나 잘 수행되는지 확인한

384
00:14:12,959 --> 00:14:14,639
다음 만족할 때까지

385
00:14:14,639 --> 00:14:16,959
에이전트에 실제로 적용할 수

386
00:14:16,959 --> 00:14:19,680
있고 실제 환경

387
00:14:19,680 --> 00:14:21,440
에서 이를 적용할 수 있습니다. 그러면 문제는

388
00:14:21,440 --> 00:14:24,079
이 디자인 주기

389
00:14:24,079 --> 00:14:27,040
를 가능한 한 빨리 통과하는 방법이 됩니다.

390
00:14:27,120 --> 00:14:29,279
우리는 유연하기를 원합니다 우리는

391
00:14:29,279 --> 00:14:31,760
사물

392
00:14:31,760 --> 00:14:34,000
을 자동화하고 모델 제안을 만드는 것 자체가

393
00:14:34,000 --> 00:14:35,040


394
00:14:35,040 --> 00:14:37,440


395
00:14:37,440 --> 00:14:38,800
엔지니어로서

396
00:14:38,800 --> 00:14:40,320
잘해야

397
00:14:40,320 --> 00:14:44,079
하는 일입니다 당신은 세상이 작동한다고 믿는 방법에 대한 제안을 제시해야

398
00:14:44,079 --> 00:14:45,920
하지만

399
00:14:45,920 --> 00:14:48,959
다른 모든 것이 있으면  확률 프로그래밍을

400
00:14:48,959 --> 00:14:50,800
통해 이러한 양을 추론

401
00:14:50,800 --> 00:14:52,480
할 수 있습니다. 모델 성능

402
00:14:52,480 --> 00:14:55,920
의 척도로 자유 에너지를 평가할 수 있고

403
00:14:55,920 --> 00:14:57,360


404
00:14:57,360 --> 00:14:59,040
[음악]

405
00:14:59,040 --> 00:15:00,399


406
00:15:00,399 --> 00:15:03,120
이 주기를 자동화할 수 있습니다.  l 실제로 유용

407
00:15:03,120 --> 00:15:05,360
할 에이전트에 대한 모델 제안을 만드는 열쇠

408
00:15:05,360 --> 00:15:07,519
이므로

409
00:15:07,519 --> 00:15:08,639
가능한 한 빨리 이 작업을 진행하고 싶기

410
00:15:08,639 --> 00:15:10,160


411
00:15:10,160 --> 00:15:11,760
때문에 특정 방법을 선택하는 이유는

412
00:15:11,760 --> 00:15:14,079
벡터 그래프

413
00:15:14,079 --> 00:15:16,240
를 선택하여 인수분해된 모델을 나타내기

414
00:15:16,240 --> 00:15:17,680
때문

415
00:15:17,680 --> 00:15:20,000
입니다. 그래프에서  조작할

416
00:15:20,000 --> 00:15:22,560
수 있음 노드를 추가할 수 있음 노드를 삭제할 수

417
00:15:22,560 --> 00:15:24,839
있음 매우

418
00:15:24,839 --> 00:15:26,959
빠르게 재연결할 수 있으며 모델의 그래픽

419
00:15:26,959 --> 00:15:29,040
표현이 있으면 추론을 자동화

420
00:15:29,040 --> 00:15:31,440
하기 위해 해당 그래프에 메시지 전달을 수행

421
00:15:31,440 --> 00:15:34,399


422
00:15:34,399 --> 00:15:36,720
할 수 있으며 로컬 기여로 자유 에너지를 평가할 수도 있습니다

423
00:15:36,720 --> 00:15:38,839
.

424
00:15:38,839 --> 00:15:41,920
그래서 우리

425
00:15:41,920 --> 00:15:43,519
가 그래픽 표현을

426
00:15:43,519 --> 00:15:45,440
선택하고 메시지 전달을 하려는 이유는

427
00:15:45,440 --> 00:15:47,440
모델을 빠르게 설계하여 이제

428
00:15:47,440 --> 00:15:51,680
효과적인 에이전트를 설계할 수 있기를 원하기 때문입니다.

429
00:15:52,639 --> 00:15:54,880


430
00:15:54,880 --> 00:15:57,279


431
00:15:57,279 --> 00:15:58,639
그래프 또는 그것이 어떻게

432
00:15:58,639 --> 00:16:00,560


433
00:16:00,560 --> 00:16:03,040
생겼는지 모델의 특정 표현을 선택

434
00:16:03,040 --> 00:16:04,560


435
00:16:04,560 --> 00:16:06,880
하고 이것은 5개 변수의 생성 모델이 있는 예입니다.

436
00:16:06,880 --> 00:16:09,120
x1

437
00:16:09,120 --> 00:16:10,959
에서 x5까지

438
00:16:10,959 --> 00:16:15,759
그리고 우리는 세 가지 요인 f b와 c

439
00:16:15,759 --> 00:16:18,079
를 가지고 있습니다. 여기 오른쪽 그림

440
00:16:18,079 --> 00:16:20,240
은 해당 모델의 그래픽 표현입니다.

441
00:16:20,240 --> 00:16:21,279


442
00:16:21,279 --> 00:16:23,440
보시다시피 모서리

443
00:16:23,440 --> 00:16:25,680
는 변수에

444
00:16:25,680 --> 00:16:28,560
해당하고 노드는 벡터

445
00:16:28,560 --> 00:16:31,360
에 해당하며 모서리는 다음과 같이 연결됩니다.

446
00:16:31,360 --> 00:16:32,399


447
00:16:32,399 --> 00:16:34,560
벡터가 인수에 있는 노드이므로 여기에서 x1과 x2가 fb와 fc에 대해 동일한 fa의 인수이기 때문에

448
00:16:34,560 --> 00:16:37,040
모서리 x1과 x2를 잘 연결하는 노드 fa를 볼 수 있습니다.

449
00:16:37,040 --> 00:16:39,759


450
00:16:39,759 --> 00:16:42,160


451
00:16:42,160 --> 00:16:45,519


452
00:16:46,800 --> 00:16:48,079
이제

453
00:16:48,079 --> 00:16:50,639
이 그래프에서 추론을 수행하는 방법은 다음과 같습니다.

454
00:16:50,639 --> 00:16:53,680


455
00:16:53,680 --> 00:16:56,480
이 작은 정사각형

456
00:16:56,480 --> 00:16:58,399


457
00:16:58,399 --> 00:17:00,560
으로 표시된 x5를 관찰하고 x5가 주어진 x2에 대한 우리의 믿음을 계산하고 싶습니다.

458
00:17:00,560 --> 00:17:02,800


459
00:17:02,800 --> 00:17:05,359


460
00:17:05,359 --> 00:17:07,199


461
00:17:07,199 --> 00:17:09,119


462
00:17:09,119 --> 00:17:10,959


463
00:17:10,959 --> 00:17:12,559


464
00:17:12,559 --> 00:17:14,319
x2

465
00:17:14,319 --> 00:17:16,559
를 수락하고 모든 것을 통합

466
00:17:16,559 --> 00:17:20,640
하고 x5를 관찰하는 이 제약 조건을 추가하면

467
00:17:20,640 --> 00:17:23,199
큰 모델이 있는

468
00:17:23,199 --> 00:17:25,599
경우 이 통합이 매우

469
00:17:25,599 --> 00:17:28,319


470
00:17:28,319 --> 00:17:30,480
번거로워집니다.  이 방에 통합할 변수가 있는

471
00:17:30,480 --> 00:17:32,559


472
00:17:32,559 --> 00:17:33,520


473
00:17:33,520 --> 00:17:35,679
이 통합 공간

474
00:17:35,679 --> 00:17:37,840
은 순진하게 수행하고 싶지만 이에 대해 현명

475
00:17:37,840 --> 00:17:40,320


476
00:17:40,320 --> 00:17:43,039


477
00:17:43,039 --> 00:17:45,120


478
00:17:45,120 --> 00:17:47,640
할 수 있습니다. 각 용어

479
00:17:47,640 --> 00:17:49,919
에 따라 이러한 적분을 다시 섞을 수 있습니다.

480
00:17:49,919 --> 00:17:52,080


481
00:17:52,080 --> 00:17:54,480
예를 들어

482
00:17:54,480 --> 00:17:57,600
이 통합을 통해  x5

483
00:17:57,600 --> 00:18:00,000
글쎄, x5가 인수인 단 하나의 요소가

484
00:18:00,000 --> 00:18:01,440


485
00:18:01,440 --> 00:18:03,520
있으므로 분배 규칙을 사용하여

486
00:18:03,520 --> 00:18:06,960
이 적분을 내부로 가져올 수

487
00:18:07,280 --> 00:18:09,840
있으므로 이러한 적분

488
00:18:09,840 --> 00:18:14,120
을 관리 가능한 더 작은 부분으로 나눌 수

489
00:18:14,320 --> 00:18:16,400
있으며 이것이

490
00:18:16,400 --> 00:18:17,200


491
00:18:17,200 --> 00:18:19,919
메시지 전달이 본질적으로 메시지 전달에서 오는 곳입니다

492
00:18:19,919 --> 00:18:22,559
이러한 통합을 하나씩 해결하여

493
00:18:22,559 --> 00:18:25,520
먼저 여기에 x x 1을 적분할 수 있습니다.

494
00:18:25,520 --> 00:18:27,520
예를 들어

495
00:18:27,520 --> 00:18:28,559


496
00:18:28,559 --> 00:18:31,280


497
00:18:31,280 --> 00:18:33,840
이 주황색 상자 안에 있는 모든 정보를 요약하면 이 주황색 상자

498
00:18:33,840 --> 00:18:35,919
를 종료하는 첫 번째 메시지가 여기에 표시됩니다.

499
00:18:35,919 --> 00:18:38,480


500
00:18:38,480 --> 00:18:40,320
그런 다음 계속할 수 있습니다.  하단에서

501
00:18:40,320 --> 00:18:43,120
통합 x5를 통합하고

502
00:18:43,120 --> 00:18:45,840
두 번째 메시지를

503
00:18:45,840 --> 00:18:48,160
받고 이 두 번째 메시지를 세 번째 메시지 계산에 사용할 수 있습니다.

504
00:18:48,160 --> 00:18:50,559


505
00:18:50,559 --> 00:18:52,880


506
00:18:52,880 --> 00:18:56,080


507
00:18:56,080 --> 00:18:58,240


508
00:18:58,240 --> 00:18:59,600


509
00:18:59,600 --> 00:19:01,760
메시지 3

510
00:19:01,760 --> 00:19:03,679


511
00:19:03,679 --> 00:19:05,600
의 계산에서

512
00:19:05,600 --> 00:19:08,320
메시지 2에 대해 가지고 있는 솔루션

513
00:19:08,320 --> 00:19:10,000
을 사용하는 중첩된 솔루션 접근 방식을 얻는 방법입니다.

514
00:19:10,000 --> 00:19:12,480
내 비례 믿음

515
00:19:12,480 --> 00:19:14,960


516
00:19:14,960 --> 00:19:19,280
내가 관찰

517
00:19:21,120 --> 00:19:24,400


518
00:19:24,400 --> 00:19:27,679


519
00:19:27,679 --> 00:19:30,320


520
00:19:30,320 --> 00:19:32,080


521
00:19:32,080 --> 00:19:33,120


522
00:19:33,120 --> 00:19:34,640


523
00:19:34,640 --> 00:19:36,320


524
00:19:36,320 --> 00:19:38,400
한 x2에 대한 내

525
00:19:38,400 --> 00:19:41,280
비례 후방  equal

526
00:19:41,280 --> 00:19:43,840
um 그리고 그것이 하는 일은

527
00:19:43,840 --> 00:19:45,440
우리가 수학을 여기에서 진행한다면 그들이 따를 것이라는 것입니다.

528
00:19:45,440 --> 00:19:46,559


529
00:19:46,559 --> 00:19:47,520
um

530
00:19:47,520 --> 00:19:48,880
이것은 노드 함수가 어떻게 생겼는지입니다.

531
00:19:48,880 --> 00:19:51,200
그래서 저는 OK라고 말합니다. 그것은

532
00:19:51,200 --> 00:19:53,200
세 개의 변수 x y 및 z의 함수이고

533
00:19:53,200 --> 00:19:55,679
z

534
00:19:55,679 --> 00:19:58,960
를 x로 제한하고  나는 z도 y로 제한

535
00:19:58,960 --> 00:20:00,000
하므로

536
00:20:00,000 --> 00:20:01,760


537
00:20:01,760 --> 00:20:03,840
이 두 가지를 동일

538
00:20:03,840 --> 00:20:05,679
하게 제한하면 x도 y가 됩니다. 따라서 이를 기반으로 메시지를 도출할 수 있는지 봅시다

539
00:20:05,679 --> 00:20:08,640


540
00:20:08,880 --> 00:20:09,760


541
00:20:09,760 --> 00:20:11,520
. 정보

542
00:20:11,520 --> 00:20:13,360
를 이 주황색 상자에 요약하려면

543
00:20:13,360 --> 00:20:14,960
i  하위 제품 규칙을 사용할 수 있습니다.

544
00:20:14,960 --> 00:20:16,799


545
00:20:16,799 --> 00:20:18,320
여기 왼쪽과 아래쪽

546
00:20:18,320 --> 00:20:20,880
메시지 1과 메시지 2에서 두 개의 메시지가 들어옵니다.

547
00:20:20,880 --> 00:20:23,280
이 값

548
00:20:23,280 --> 00:20:24,799
에 평등 노드의 노드 함수를 곱하고 지금 이 통합을 수행하고 싶습니다.

549
00:20:24,799 --> 00:20:27,760


550
00:20:27,760 --> 00:20:29,360


551
00:20:29,360 --> 00:20:31,280


552
00:20:31,280 --> 00:20:32,880
여기에서 이 노드 함수를 분할

553
00:20:32,880 --> 00:20:34,720
적분으로 대체한 다음

554
00:20:34,720 --> 00:20:36,240
shifting 속성

555
00:20:36,240 --> 00:20:37,200


556
00:20:37,200 --> 00:20:39,600
을 사용하여 x

557
00:20:39,600 --> 00:20:41,440
및 y

558
00:20:41,440 --> 00:20:43,840
의 인수를 z의 인수로 대체

559
00:20:43,840 --> 00:20:47,120


560
00:20:47,120 --> 00:20:49,360
할 수 있습니다.

561
00:20:49,360 --> 00:20:51,919


562
00:20:51,919 --> 00:20:53,440
왼쪽과 아래에서 들어오는 두 메시지

563
00:20:53,440 --> 00:20:55,280


564
00:20:55,280 --> 00:20:56,799
지금 눈을 조금 가늘게 뜨고

565
00:20:56,799 --> 00:20:58,799
uh 눈을 통해 보면

566
00:20:58,799 --> 00:21:00,799


567
00:21:00,799 --> 00:21:03,919
여기에 비례 기본 규칙을 인식

568
00:21:03,919 --> 00:21:06,320
할 수 있으므로 기본적으로 메시지 3이면 잘 말할 수 있습니다.

569
00:21:06,320 --> 00:21:08,000
여기에 내

570
00:21:08,000 --> 00:21:09,360


571
00:21:09,360 --> 00:21:11,919
사후 메시지가 표시되고 하나는

572
00:21:11,919 --> 00:21:15,440
내 가능성에 대한 내 사전 메시지

573
00:21:15,440 --> 00:21:17,280
를 나타낼 수 있으며 비례 사후

574
00:21:17,280 --> 00:21:19,520
메시지 3이 있고 나머지 모드에 전달할 수 있습니다.

575
00:21:19,520 --> 00:21:21,520
el

576
00:21:21,520 --> 00:21:23,200
과 이 노드는 또한 왼쪽과 아래쪽에서 오는 정보를 결합하는 데 자주 사용됩니다.

577
00:21:23,200 --> 00:21:24,880


578
00:21:24,880 --> 00:21:28,000


579
00:21:29,120 --> 00:21:31,840


580
00:21:34,320 --> 00:21:36,480
그래서 이것은 메시지 전달을 수행하는 매우 빠른 소개입니다.

581
00:21:36,480 --> 00:21:38,320


582
00:21:38,320 --> 00:21:42,240
우리는 문헌에서도 많은 규칙을 도출했고

583
00:21:42,240 --> 00:21:43,760
또한 많은 것을 구현했습니다.

584
00:21:43,760 --> 00:21:46,400
이미 파생된 규칙은

585
00:21:46,400 --> 00:21:49,200


586
00:21:49,200 --> 00:21:50,880
기본적으로

587
00:21:50,880 --> 00:21:53,679


588
00:21:53,679 --> 00:21:55,360


589
00:21:55,360 --> 00:21:57,520
일정 및

590
00:21:57,520 --> 00:22:00,240
이 메시지 계산을

591
00:22:00,240 --> 00:22:01,760
수행하는 소프트웨어 문제 프로그래밍 제품군이므로 이러한 적분을 재배포하는 방법과 파생 방법에 대해 너무 많이 생각할 필요가 없습니다.

592
00:22:01,760 --> 00:22:03,280


593
00:22:03,280 --> 00:22:06,240


594
00:22:06,240 --> 00:22:10,400
특정 노드에 대한 많은 업데이트

595
00:22:10,960 --> 00:22:13,280
음. 그래서

596
00:22:13,280 --> 00:22:15,520
우리가 자동화할 수 있는 그런 종류입니다

597
00:22:15,520 --> 00:22:17,280


598
00:22:17,280 --> 00:22:19,919
. 어 디자인 주기의 그런 측면에서

599
00:22:19,919 --> 00:22:22,320


600
00:22:23,200 --> 00:22:24,840
지금

601
00:22:24,840 --> 00:22:27,120
다른 질문이 있으면

602
00:22:27,120 --> 00:22:28,880
이 작업을 매우 빠르게 진행하고 있기

603
00:22:28,880 --> 00:22:30,240
때문에  다음으로 할 일은

604
00:22:30,240 --> 00:22:32,320
예를 살펴보고 싶은 것입니다.

605
00:22:32,320 --> 00:22:34,240
그래서 아마도

606
00:22:34,240 --> 00:22:36,880
이것은 사람들이

607
00:22:36,880 --> 00:22:38,880
저를 멈추게 하고 당신이 가고 있다고 생각할 수 있는 질문을 하는 자연스러운 지점일 것입니다.

608
00:22:38,880 --> 00:22:41,440
g 여기에서 금식

609
00:22:41,440 --> 00:22:43,600
하기 위해 예제를 보는 것이 좋을 것이라고 생각합니다.

610
00:22:43,600 --> 00:22:45,280
그런 다음 라이브 채팅에서 몇 가지 질문이

611
00:22:45,280 --> 00:22:47,039
있으며 누구든지

612
00:22:47,039 --> 00:22:49,120
더 추가

613
00:22:49,120 --> 00:22:52,158


614
00:22:52,400 --> 00:22:54,480
할 수 있습니다.

615
00:22:54,480 --> 00:22:56,640
이것은

616
00:22:56,640 --> 00:22:58,080


617
00:22:58,080 --> 00:23:00,559
베이지안 온도 조절기라고 하는 작은 예입니다.

618
00:23:00,559 --> 00:23:02,960


619
00:23:02,960 --> 00:23:03,760


620
00:23:03,760 --> 00:23:05,840
여기 왼쪽에 열원

621
00:23:05,840 --> 00:23:08,000
이 있고 주위를 이동할 수 있는 작은 자동차가 있는 환경 환경이 있고 열원

622
00:23:08,000 --> 00:23:09,600
에서 멀어

623
00:23:09,600 --> 00:23:11,520
지거나 열원 쪽으로 이동할 수 있습니다.

624
00:23:11,520 --> 00:23:13,679


625
00:23:13,679 --> 00:23:16,400
열원 이제 열원에 대한 상대적 위치

626
00:23:16,400 --> 00:23:19,120
는 우리가 x라고 부르는

627
00:23:19,120 --> 00:23:20,799
것이며 모든 위치에는

628
00:23:20,799 --> 00:23:22,799
특정 온도

629
00:23:22,799 --> 00:23:23,679
um이

630
00:23:23,679 --> 00:23:25,120
있으며 특정 위치에서 측정하는 온도는

631
00:23:25,120 --> 00:23:29,600
y

632
00:23:29,679 --> 00:23:31,600
라고 하며 선호하는

633
00:23:31,600 --> 00:23:33,440
온도는 다음과 같습니다.  4

634
00:23:33,440 --> 00:23:35,440
y 4 나는 그것이 우리가 선택하는 것인지 모르겠다.

635
00:23:35,440 --> 00:23:37,600


636
00:23:37,600 --> 00:23:39,360
우리는 이 차를

637
00:23:39,360 --> 00:23:41,279
왼쪽이나 오른쪽으로 움직여 이 차를 제어하고 우리의 제어는

638
00:23:41,279 --> 00:23:43,440
이것이 우리가 좌우로 움직이는 속도이며

639
00:23:43,440 --> 00:23:45,360


640
00:23:45,360 --> 00:23:47,520
u라고

641
00:23:47,840 --> 00:23:50,880
하므로 이것이 우리의 환경입니다.  nt

642
00:23:50,880 --> 00:23:54,320
및 우리는 이에 대한 모델을 구축하기를 원

643
00:23:54,320 --> 00:23:56,240


644
00:23:56,240 --> 00:23:57,919
하므로 능동 간섭

645
00:23:57,919 --> 00:23:59,760


646
00:23:59,760 --> 00:24:01,840


647
00:24:01,840 --> 00:24:05,039
에서 우리가 하고자 하는 것은 다음을 얻기 위해 이 현재 시간

648
00:24:05,039 --> 00:24:07,600
에 적용해야 하는 제어를 향해 우리가 원하는 상태로부터 추론

649
00:24:07,600 --> 00:24:09,679


650
00:24:09,679 --> 00:24:12,080
하기를 원하는 것입니다.  미래

651
00:24:12,080 --> 00:24:13,679
에 우리가 하고자 하는

652
00:24:13,679 --> 00:24:16,000
것은 현재 시간

653
00:24:16,000 --> 00:24:17,360


654
00:24:17,360 --> 00:24:18,400
t에서

655
00:24:18,400 --> 00:24:21,120
어떤 시간 지평선 big t까지 추론

656
00:24:21,120 --> 00:24:22,880


657
00:24:22,880 --> 00:24:25,200
하고 미래

658
00:24:25,200 --> 00:24:27,200
에 에이전트가 어떻게 이동

659
00:24:27,200 --> 00:24:29,120
하고 에이전트가 어디에 있기를 원하는지 고려하는 것입니다.

660
00:24:29,120 --> 00:24:32,960
그 시간에 그리고 결국 우리는 4도에 있기를 원할

661
00:24:32,960 --> 00:24:35,760


662
00:24:35,760 --> 00:24:37,200
것이고 그것은

663
00:24:37,200 --> 00:24:41,520
이 에이전트가 세계를 통해 스스로 이동할 방법에 대한 우리의 믿음을 나타내는 상태 공간 모델

664
00:24:41,520 --> 00:24:42,880


665
00:24:42,880 --> 00:24:44,320


666
00:24:44,320 --> 00:24:46,480


667
00:24:46,480 --> 00:24:48,720
이므로 시간 t에서 우리는 관찰이

668
00:24:48,720 --> 00:24:51,200
들어오게 됩니다.  특정 온도

669
00:24:51,200 --> 00:24:55,360
와 어쩌면 우리는 이미 행동

670
00:24:55,360 --> 00:24:56,960
um을 만들었

671
00:24:56,960 --> 00:24:59,600


672
00:24:59,600 --> 00:25:02,159
으며 현재 상태 xt는 이전 상태와 관련이 있으며

673
00:25:02,159 --> 00:25:03,840


674
00:25:03,840 --> 00:25:06,559
기본적으로 ut를 추가함으로써

675
00:25:06,559 --> 00:25:08,320
우리가 가진 행동은 여기에 우리의 현재

676
00:25:08,320 --> 00:25:09,600
위치

677
00:25:09,600 --> 00:25:12,880
um에 한 번에 추가하는 속도입니다  시각  그런 다음 우리는

678
00:25:12,880 --> 00:25:14,640


679
00:25:14,640 --> 00:25:17,039
그것을 추가하고

680
00:25:17,039 --> 00:25:19,520
약간의 가우스 노이즈

681
00:25:19,520 --> 00:25:21,279
를 적용함으로써 일종의 다음 위치를 얻습니다. 그래서 우리는 이 가산적인 상태 전환을 갖게

682
00:25:21,279 --> 00:25:23,520
됩니다. uh

683
00:25:23,520 --> 00:25:25,600
와 함께 나는 왼쪽이나 오른쪽으로 4칸 앞으로 가고 싶다고 말하는 의무가 있습니다.

684
00:25:25,600 --> 00:25:28,880


685
00:25:28,880 --> 00:25:30,559
그런 다음

686
00:25:30,559 --> 00:25:33,039
우리는

687
00:25:33,039 --> 00:25:34,799
이 에이전트가 환경에서 어떻게 움직일지 불확실하다고 말하는 가우스 노이즈를 추가합니다. 이에

688
00:25:34,799 --> 00:25:35,919


689
00:25:35,919 --> 00:25:38,159
대한 아이디어가 있지만 불확실성

690
00:25:38,159 --> 00:25:40,080
을 설명하기 위해 몇 가지 변형을 추가

691
00:25:40,080 --> 00:25:43,760


692
00:25:43,760 --> 00:25:45,520
한 다음 여기에서 이것으로 말합니다.  수직선

693
00:25:45,520 --> 00:25:47,520


694
00:25:47,520 --> 00:25:49,600
은 관측치가

695
00:25:49,600 --> 00:25:52,159
있거나 위치가 있으면

696
00:25:52,159 --> 00:25:55,840
온도 우물의 관측과 관련이 있다는

697
00:25:55,840 --> 00:25:56,960
것입니다.

698
00:25:56,960 --> 00:25:59,279
-1 그것은 일종의 대략적인 추측입니다.

699
00:25:59,279 --> 00:26:01,440


700
00:26:01,440 --> 00:26:03,200
내가 열에서 멀어지면 오른쪽으로 이동하면 잘 말하는 것입니다.

701
00:26:03,200 --> 00:26:05,200
소스 그러면 내 온도

702
00:26:05,200 --> 00:26:06,720


703
00:26:06,720 --> 00:26:09,120
는 -1의 기울기로 떨어질 것이고 실제

704
00:26:09,120 --> 00:26:11,200
세계에서는 일종의 정말 대략적인 추측

705
00:26:11,200 --> 00:26:12,880
입니다. 아마도 아주 천천히 아래로 움직일 것 같은 아주 멋진

706
00:26:12,880 --> 00:26:14,640
온도 구배가 있을 것입니다

707
00:26:14,640 --> 00:26:16,799


708
00:26:16,799 --> 00:26:19,360


709
00:26:19,360 --> 00:26:21,840
음  우리는 단지 '이봐 우리는 그것이 무엇인지 정말로 모른다'고 말하는 것뿐입니다

710
00:26:21,840 --> 00:26:24,400
.

711
00:26:24,400 --> 00:26:26,159
대략적인 추측을 해봅시다 우리는 이것이 우리의 생성 모델이라는 믿음이

712
00:26:26,159 --> 00:26:27,760


713
00:26:27,760 --> 00:26:29,520
있습니다 세상에 대한 우리의 믿음

714
00:26:29,520 --> 00:26:32,400
위치에 따라 온도가 감소한다고

715
00:26:32,400 --> 00:26:33,919
말하고 다시 우리는 매우 확신하지 못합니다

716
00:26:33,919 --> 00:26:36,559
그것에 대해 다시

717
00:26:36,559 --> 00:26:39,600
약간의 가우스 노이즈를 추가

718
00:26:39,600 --> 00:26:41,679
하고 이제 이것을 미래로 확장합니다.

719
00:26:41,679 --> 00:26:43,919
그래서 저는 실제로 잘 말합니다. 저는

720
00:26:43,919 --> 00:26:45,760
미래에 제

721
00:26:45,760 --> 00:26:48,240
환경도 이에 따라 진화할 것이라고 믿습니다.

722
00:26:48,240 --> 00:26:50,480


723
00:26:50,480 --> 00:26:51,360
그러나

724
00:26:51,360 --> 00:26:53,520
저는 또한 제가 있고 싶은 곳에 대한 몇 가지 아이디어

725
00:26:53,520 --> 00:26:55,360
가

726
00:26:55,360 --> 00:26:58,720
있습니다  내 미래의 온도 관찰을 이 원하는 온도 4도로 제한하는 금 사전이 있는 곳입니다.

727
00:26:58,720 --> 00:27:00,960


728
00:27:00,960 --> 00:27:03,200


729
00:27:03,200 --> 00:27:06,240


730
00:27:06,240 --> 00:27:08,080
그리고 여기에 약간의

731
00:27:08,080 --> 00:27:11,200
노이즈가 추가되어 음,

732
00:27:11,200 --> 00:27:13,360
4도 정도가 되고 싶습니다

733
00:27:13,360 --> 00:27:15,360
. 정확히 일치할 필요는 없습니다.  하지만

734
00:27:15,360 --> 00:27:18,240
저는 음

735
00:27:18,240 --> 00:27:21,360
, 시간 t + 1에서 약 4가 될 것이며 미래의 언젠가

736
00:27:21,360 --> 00:27:22,480


737
00:27:22,480 --> 00:27:24,080
까지 계속 거기에 있을

738
00:27:24,080 --> 00:27:25,039


739
00:27:25,039 --> 00:27:28,080
것이라고 확신하고 싶습니다.

740
00:27:30,320 --> 00:27:33,200
이제 재생 모델이

741
00:27:33,200 --> 00:27:35,200
있고

742
00:27:35,200 --> 00:27:37,279
우리는 우리의 에너지 기능을 정의할 수 있고

743
00:27:37,279 --> 00:27:39,360
우리는 ca  n

744
00:27:39,360 --> 00:27:41,919
이 그래프를 통해 전달되는 메시지에 의해 에너지 기능에 대해 이 문제를 해결

745
00:27:41,919 --> 00:27:44,960


746
00:27:44,960 --> 00:27:46,480


747
00:27:46,480 --> 00:27:49,360


748
00:27:49,360 --> 00:27:52,480


749
00:27:52,480 --> 00:27:55,279
하고 다음 시간

750
00:27:55,600 --> 00:27:57,679
부터 다음과 같이 해야 할 일을 추론하는 데 관심이 있기 때문에 이 메시지를 다음 컨트롤로 전달합니다. 여기에서 메시지를 수행할 수 있습니다.

751
00:27:57,679 --> 00:27:59,600
통과

752
00:27:59,600 --> 00:28:02,720
하면 과거에서 얻은 모든 정보를 요약

753
00:28:02,720 --> 00:28:04,159
할 수 있으므로 에이전트

754
00:28:04,159 --> 00:28:06,240
의 현재 상태에 대한 추정치가

755
00:28:06,240 --> 00:28:07,679


756
00:28:07,679 --> 00:28:09,600
되고 미래에 대한 신념

757
00:28:09,600 --> 00:28:11,279
에 따라

758
00:28:11,279 --> 00:28:12,240


759
00:28:12,240 --> 00:28:14,799
편향될 것입니다.

760
00:28:14,799 --> 00:28:17,039


761
00:28:17,039 --> 00:28:18,640
현재

762
00:28:18,640 --> 00:28:21,520
또는 다음 시간

763
00:28:21,600 --> 00:28:24,640


764
00:28:24,640 --> 00:28:26,559


765
00:28:26,559 --> 00:28:28,880


766
00:28:28,880 --> 00:28:31,039


767
00:28:34,080 --> 00:28:35,600
에 어떤 제어를 취할 것인지에 대한 모든 세부

768
00:28:35,600 --> 00:28:37,440


769
00:28:37,440 --> 00:28:40,000


770
00:28:40,000 --> 00:28:42,240
사항

771
00:28:42,240 --> 00:28:43,520
은 2019년부터 이 백서에 설명되어 있습니다.  당신

772
00:28:43,520 --> 00:28:44,960


773
00:28:44,960 --> 00:28:46,799
의 주 추정치

774
00:28:46,799 --> 00:28:48,159
가 당신의 행동에 따라 바뀔 것이기 때문에 매번 t마다 이것을

775
00:28:48,159 --> 00:28:49,760
해야 할 것입니다. 그래서 당신은 매번

776
00:28:49,760 --> 00:28:51,600
새로운 행동을 다시 계산해야 할 것입니다.

777
00:28:51,600 --> 00:28:54,719
t 당신은 다음에 할

778
00:28:55,120 --> 00:28:57,600
것이고 이것은

779
00:28:57,600 --> 00:28:59,360
일종의 주요 아이디어입니다. 물론 우리는

780
00:28:59,360 --> 00:29:01,120
이

781
00:29:01,120 --> 00:29:03,679
모든 것을 손으로 하고 싶지는 않습니다. 그래서 우리가

782
00:29:03,679 --> 00:29:07,200
하고자 하는 것은 잘 하는

783
00:29:07,679 --> 00:29:09,039
것입니다.

784
00:29:09,039 --> 00:29:10,960
이제 공식 확률 프로그래밍 도구를 사용하여 이 um을 구현하는 방법에 대한 약간의 데모를 보여

785
00:29:10,960 --> 00:29:12,880
드리겠습니다.

786
00:29:12,880 --> 00:29:15,360


787
00:29:15,360 --> 00:29:17,520


788
00:29:17,520 --> 00:29:19,840
그래서

789
00:29:19,840 --> 00:29:22,480
우리의 작은 데모를 열 수 있는지 봅시다. 그래서

790
00:29:22,480 --> 00:29:24,320
이것은 실제로 읽을 수 있습니다. 아니면

791
00:29:24,320 --> 00:29:25,520
더 확대해야

792
00:29:25,520 --> 00:29:27,279
할까요

793
00:29:27,279 --> 00:29:30,640
?  조금 더 확대할 수 있습니다

794
00:29:32,720 --> 00:29:35,440
어쩌면 이렇게

795
00:29:35,440 --> 00:29:37,840
할 수 있습니다 어 예 크기를 조정할 수 있습니다

796
00:29:37,840 --> 00:29:39,360


797
00:29:39,360 --> 00:29:41,520
음 꽤 좋습니다

798
00:29:41,520 --> 00:29:42,880
오 완벽

799
00:29:42,880 --> 00:29:46,159
합니다 꽤 좋습니다 네 감사합니다

800
00:29:48,640 --> 00:29:52,000
그래서 이것은 음 그래서

801
00:29:52,000 --> 00:29:55,279
우리가 무엇을 하고 싶은지 일종의 설정

802
00:29:55,440 --> 00:29:58,080
이지만 그래서 이것은

803
00:29:58,080 --> 00:29:59,919
환경 자체에 대한 일종의 정의이므로

804
00:29:59,919 --> 00:30:01,279
이것이 실제 세계

805
00:30:01,279 --> 00:30:03,039
입니다. 열원에서 온도가 100도이고 아래로 내려가는

806
00:30:03,039 --> 00:30:05,120
아주 좋은 기능인

807
00:30:05,120 --> 00:30:07,840
매우 부드러운 기능인

808
00:30:07,840 --> 00:30:09,039
이 온도 구배가 있습니다.

809
00:30:09,039 --> 00:30:10,640


810
00:30:10,640 --> 00:30:12,960


811
00:30:12,960 --> 00:30:14,880


812
00:30:14,880 --> 00:30:18,410
열원 [음악]에서 위치와 함께

813
00:30:18,410 --> 00:30:20,240


814
00:30:20,240 --> 00:30:21,679
t  그의 것은 실제 세계입니다. 우리는 이것을 잘

815
00:30:21,679 --> 00:30:23,360
모릅니다. 그래서 이것은 우리가 이

816
00:30:23,360 --> 00:30:25,279


817
00:30:25,279 --> 00:30:28,640
매우 거친 빼기 1로 근사화

818
00:30:28,640 --> 00:30:31,279
할 것입니다. 그러면 이제 그것이 효과가 있는지 여부를 보게 될 것입니다.

819
00:30:31,279 --> 00:30:33,360
이것은 제 멋진 아스키 아트입니다.

820
00:30:33,360 --> 00:30:35,600
이제 기본적

821
00:30:35,600 --> 00:30:38,880
으로 슬라이드에 표시한 모델의 크기가

822
00:30:38,880 --> 00:30:40,559
조정

823
00:30:40,559 --> 00:30:42,960
되었으며 이것이 우리의 모델 정의입니다. 그래서

824
00:30:42,960 --> 00:30:44,480
실제로는 좀 더 읽기 쉽게 만들기 위해 약간 축소해야 합니다.

825
00:30:44,480 --> 00:30:45,919


826
00:30:45,919 --> 00:30:48,399
그래서 이 오른쪽에 대한 그래프를 만들고 싶습니다.

827
00:30:48,399 --> 00:30:50,799
여기에서 우리는

828
00:30:50,799 --> 00:30:53,679
관찰 상태를 제어

829
00:30:53,679 --> 00:30:56,720
하고 t - 1에 대한 사전 믿음을 정의합니다.

830
00:30:56,720 --> 00:30:59,200
그래서

831
00:30:59,200 --> 00:31:01,120
우리가 말하려고 하는 위치는 가우스

832
00:31:01,120 --> 00:31:05,039
이고 약간의 평균과 약간의 편차가

833
00:31:05,039 --> 00:31:07,440
있고 그 다음부터 미래의 모든 시간에 대해

834
00:31:07,440 --> 00:31:11,039
어 1부터 지평선까지

835
00:31:11,039 --> 00:31:12,320
우리

836
00:31:12,320 --> 00:31:15,840
는 기본적으로 잘 말해 주는 컨트롤에 대한 사전 믿음을 가질

837
00:31:15,840 --> 00:31:18,240


838
00:31:18,240 --> 00:31:19,039
것입니다.

839
00:31:19,039 --> 00:31:20,159
음, 음

840
00:31:20,159 --> 00:31:22,640


841
00:31:22,640 --> 00:31:24,480


842
00:31:24,480 --> 00:31:26,159
, 평균이 0인 컨트롤에 대한 사전 가우초가

843
00:31:26,159 --> 00:31:28,480
있을 것입니다  거기로 대체하고

844
00:31:28,480 --> 00:31:31,279
아마도 약간의 차이

845
00:31:31,279 --> 00:31:32,880
와 음

846
00:31:32,880 --> 00:31:34,960
그는  다시 말하지만 이 추가

847
00:31:34,960 --> 00:31:37,600
로 내 제어와 관련된 에이전트의 위치가 있습니다. 여기에는

848
00:31:37,600 --> 00:31:38,399


849
00:31:38,399 --> 00:31:39,919


850
00:31:39,919 --> 00:31:41,120


851
00:31:41,120 --> 00:31:42,880
정밀 감마가 추가되어

852
00:31:42,880 --> 00:31:44,640
이것이 우리의 전환 모델입니다.

853
00:31:44,640 --> 00:31:46,880
이것은 수평선

854
00:31:46,880 --> 00:31:48,480


855
00:31:48,480 --> 00:31:50,480
이고

856
00:31:50,480 --> 00:31:52,640
이것은 매우

857
00:31:52,640 --> 00:31:54,399
대략적인 추정치에서 다음 중 하나를 뺀 관찰 모델입니다.

858
00:31:54,399 --> 00:31:56,000
온도 구배

859
00:31:56,000 --> 00:31:58,880
시간 현재 상태 및

860
00:31:58,880 --> 00:32:00,640
일부 정밀

861
00:32:00,640 --> 00:32:03,200
보존 정밀도

862
00:32:03,200 --> 00:32:06,320
및 이것은 이전에 내 목표를 나타내

863
00:32:06,320 --> 00:32:09,120
므로 여기에 특정 값을 입력하지 않았음에 유의

864
00:32:09,120 --> 00:32:12,320
하십시오. 아직

865
00:32:12,320 --> 00:32:14,399
실제 통계 및 값에 대한 자리 표시자가 있습니다.

866
00:32:14,399 --> 00:32:16,880


867
00:32:16,880 --> 00:32:18,480
내 알고리즘의 실제 파생은

868
00:32:18,480 --> 00:32:20,480
실제로 통계에 의존하지 않기 때문에 입력

869
00:32:20,480 --> 00:32:23,120
할 것입니다. 그것은

870
00:32:23,120 --> 00:32:27,799
우리가 나중에 입력할 수 있는

871
00:32:28,240 --> 00:32:29,760
것이므로 이것이 내가 하고 싶은

872
00:32:29,760 --> 00:32:31,919
자유 에너지 기능을 구축하고 가짜 연구실

873
00:32:31,919 --> 00:32:33,679
은 실제로 그냥

874
00:32:33,679 --> 00:32:36,720
기본적으로 네 줄의 코드

875
00:32:36,720 --> 00:32:39,279
um 그래서

876
00:32:39,279 --> 00:32:42,559
q에 대한 내 인수분해를 정의하는 이 스테레오 인수분해는

877
00:32:42,559 --> 00:32:44,240
um에

878
00:32:44,240 --> 00:32:46,960


879
00:32:46,960 --> 00:32:50,640
대해 공동 변형 분포

880
00:32:50,640 --> 00:32:52,880
um을 가질 것이라고 말합니다.  타이어

881
00:32:52,880 --> 00:32:54,559
그래프 구조화된 인수분해로 구조로 세분화하지는 않습니다.

882
00:32:54,559 --> 00:32:55,840


883
00:32:55,840 --> 00:32:57,760
일부 사람들은

884
00:32:57,760 --> 00:32:59,279
그

885
00:32:59,279 --> 00:33:01,440
음에 익숙하지만 그냥 괜찮다고 말합니다

886
00:33:01,440 --> 00:33:03,039
. 변동 분포의 이 스테레오 인수분해

887
00:33:03,039 --> 00:33:05,919
가 내 전체

888
00:33:05,919 --> 00:33:08,640
그래프가 되고

889
00:33:08,640 --> 00:33:11,120
내가 파생할 수 있는 단 하나의 명령이 될 수 없습니다.

890
00:33:11,120 --> 00:33:14,080
모든 메시지

891
00:33:14,080 --> 00:33:16,320
를 제어 u2로 전파하는 메시지 전달 알고리즘

892
00:33:16,320 --> 00:33:18,159
은 다음

893
00:33:18,159 --> 00:33:21,039
시간 단계 t에 1을 더한 제어이며

894
00:33:21,039 --> 00:33:23,039
자유 에너지를 평가하고 싶으

895
00:33:23,039 --> 00:33:24,799
므로 동시에

896
00:33:24,799 --> 00:33:27,840
실행할 수 있는 알고리즘을 제공합니다.

897
00:33:27,840 --> 00:33:31,439
내 자유 에너지를 평가하기 위해

898
00:33:31,919 --> 00:33:35,279
이 줄은 이것을

899
00:33:35,279 --> 00:33:36,320


900
00:33:36,320 --> 00:33:38,320
두 개의 소스 코드로 변환하여 내 환경에 로드할 수

901
00:33:38,320 --> 00:33:41,120


902
00:33:41,200 --> 00:33:43,519
있으며 이것이 하는 일은

903
00:33:43,519 --> 00:33:46,480
우리를 위한 메시지 전달 알고리즘을 구축하는

904
00:33:46,480 --> 00:33:48,559
것이므로 이것이 메시지를 실행하는 코드입니다

905
00:33:48,559 --> 00:33:50,159


906
00:33:50,159 --> 00:33:51,200
그래프

907
00:33:51,200 --> 00:33:53,120
를 전달하면 여기에서

908
00:33:53,120 --> 00:33:54,640


909
00:33:54,640 --> 00:33:57,039


910
00:33:57,039 --> 00:33:58,559
우리가 미리 파생하고

911
00:33:58,559 --> 00:34:01,279
fornilab에서 구현한 일부 제품 규칙

912
00:34:01,279 --> 00:34:03,039
및 기타 규칙에 따라 이러한 모든 메시지를 계산한다는 것을 알 수 있습니다.  이 메시지는 통계에 의존한다는 것을 알 수 있습니다.

913
00:34:03,039 --> 00:34:05,360
그래서 이것은

914
00:34:05,360 --> 00:34:07,679
예를 들어

915
00:34:07,679 --> 00:34:09,520
우리의 이전

916
00:34:09,520 --> 00:34:11,280
과대 상태의 평균과 이전 과대 상태의 분산

917
00:34:11,280 --> 00:34:13,839


918
00:34:14,079 --> 00:34:15,599
이고 우리는 내가 메시지 전달을 설명한 방식으로 이전 메시지에 의존하는 다른 메시지를 가지고 있습니다.

919
00:34:15,599 --> 00:34:18,000


920
00:34:18,000 --> 00:34:19,359


921
00:34:19,359 --> 00:34:21,199


922
00:34:21,199 --> 00:34:23,839


923
00:34:23,839 --> 00:34:27,599
이 경우 26개 메시지의 전체 목록을 작성

924
00:34:27,599 --> 00:34:29,918
하고 결국 우리는

925
00:34:29,918 --> 00:34:32,079
주변 신념에 관심이 있으므로

926
00:34:32,079 --> 00:34:35,040
예를 들어 또는 통제에 대한 사후 주변 신념에 관심이 있습니다. 예

927
00:34:35,040 --> 00:34:36,480


928
00:34:36,480 --> 00:34:38,399


929
00:34:38,399 --> 00:34:40,879
를 들어 새로운 신념을 얻기 위해 메시지를 함께 곱하여 이러한 신념을 얻

930
00:34:40,879 --> 00:34:43,199
습니다.  다음 컨트롤을 통해

931
00:34:43,199 --> 00:34:44,560


932
00:34:44,560 --> 00:34:48,639
메시지 9와 25

933
00:34:48,639 --> 00:34:50,719


934
00:34:50,719 --> 00:34:52,560


935
00:34:52,560 --> 00:34:54,239


936
00:34:54,239 --> 00:34:56,239
를 곱하고 사후 신념을 얻기 위해 곱하는 충돌 메시지가 있는 도입부 이전의 약간의 소개에서 이것을 인식

937
00:34:56,239 --> 00:34:58,400


938
00:34:58,400 --> 00:34:59,920
하고 그것이 결국 우리가 반환

939
00:34:59,920 --> 00:35:03,720
하는 것입니다.

940
00:35:06,160 --> 00:35:07,760
이 알고리즘의 실행에 관심이 있으며

941
00:35:07,760 --> 00:35:08,960


942
00:35:08,960 --> 00:35:10,640


943
00:35:10,640 --> 00:35:12,160
여기에서 전체 일정을 작성했으며

944
00:35:12,160 --> 00:35:14,800
매우 복잡할 수 있습니다.  rsome

945
00:35:14,800 --> 00:35:17,119
은 매우 긴 일정이 될 수

946
00:35:17,119 --> 00:35:19,599
있으므로 로드하고 실행하는 데 비용이 많이 들 수 있습니다.

947
00:35:19,599 --> 00:35:21,359


948
00:35:21,359 --> 00:35:22,800
dimitri는 이에 대한 솔루션을 가지고

949
00:35:22,800 --> 00:35:25,359
있으며 그는 곧 설명할

950
00:35:25,359 --> 00:35:27,520
것이므로

951
00:35:27,520 --> 00:35:29,119
일정을 작성하는 데 매우 만족

952
00:35:29,119 --> 00:35:32,400
하고 um dimitri는 그렇지 않습니다.  너무 많이 어

953
00:35:32,400 --> 00:35:34,560
그리고 그는 어 그들을 위한 해결책을 찾으려고 노력합니다

954
00:35:34,560 --> 00:35:36,160
그들을 제거하십시오

955
00:35:36,160 --> 00:35:37,680
음 결국

956
00:35:37,680 --> 00:35:38,800


957
00:35:38,800 --> 00:35:40,400


958
00:35:40,400 --> 00:35:41,839
실제로 레시피가 없는 스케줄을 가지지 않고 주어진

959
00:35:41,839 --> 00:35:44,880
대로 요리하는 것이 가장 빠를 것이기 때문입니다

960
00:35:44,880 --> 00:35:47,440


961
00:35:49,920 --> 00:35:51,599
이제 우리는 실제로 이 알고리즘을

962
00:35:51,599 --> 00:35:52,800
실행하므로 이것은 우리가 원하는

963
00:35:52,800 --> 00:35:55,520
모든 시간 단계에 대한

964
00:35:55,520 --> 00:35:57,599


965
00:35:57,599 --> 00:35:59,119


966
00:35:59,119 --> 00:36:01,359
행동 인식

967
00:36:01,359 --> 00:36:04,240


968
00:36:04,240 --> 00:36:06,720
루프입니다.  이것은

969
00:36:06,720 --> 00:36:09,040
실제 현실

970
00:36:09,040 --> 00:36:11,200
세계 또는 일종의 시뮬레이션된 세계를 향한 행동을 보내는 것입니다. 이

971
00:36:11,200 --> 00:36:13,680
경우에서 우리가 얻는 것은

972
00:36:13,680 --> 00:36:15,680
관찰

973
00:36:15,680 --> 00:36:18,079
이며 우리의 행동 관찰에서 우리는

974
00:36:18,079 --> 00:36:20,640


975
00:36:20,960 --> 00:36:22,640
우리의 새로운 행동을 추론하고

976
00:36:22,640 --> 00:36:24,320


977
00:36:24,320 --> 00:36:26,560
자유 에너지 um의 변화를 반환하기를 원합니다

978
00:36:26,560 --> 00:36:28,240


979
00:36:28,240 --> 00:36:30,160
.  d 그런 다음 다음 단계를 준비하여

980
00:36:30,160 --> 00:36:31,920
모든 단계에서 실제로 실행되는 환경에 대한 작업을 제안합니다

981
00:36:31,920 --> 00:36:34,160


982
00:36:34,160 --> 00:36:35,839
. 새로운 결과를 관찰하고

983
00:36:35,839 --> 00:36:37,920
새로운 작업을

984
00:36:37,920 --> 00:36:41,680
추론하고 해당 작업을 얼마나 잘 수행했는지 평가

985
00:36:41,680 --> 00:36:44,319


986
00:36:46,480 --> 00:36:48,480
한 다음 좋은 플롯을 얻습니다.  이것과 같이

987
00:36:48,480 --> 00:36:50,160


988
00:36:50,160 --> 00:36:52,480
이것은 우리가 0에서 시작하는 에이전트의 속도입니다.

989
00:36:52,480 --> 00:36:54,240
그리고 여러분은 그것이

990
00:36:54,240 --> 00:36:56,960
오른쪽 um으로 매우 빠르게 이동

991
00:36:56,960 --> 00:36:57,920


992
00:36:57,920 --> 00:36:59,920
한 다음

993
00:36:59,920 --> 00:37:02,240


994
00:37:02,240 --> 00:37:05,200
끝이 어느 정도 고정점에 도달할 때까지

995
00:37:05,200 --> 00:37:06,839


996
00:37:06,839 --> 00:37:09,680
약간 um 뒤로 이동하는 것을 볼 수 있습니다.  여기에서 실제로 수행하는 작업을

997
00:37:09,680 --> 00:37:11,119
볼 수 있습니다. 온도 20에서 시작

998
00:37:11,119 --> 00:37:13,359


999
00:37:13,359 --> 00:37:15,920


1000
00:37:15,920 --> 00:37:17,760
하여 열원에서 매우 빠르게 오른쪽으로 이동

1001
00:37:17,760 --> 00:37:20,560
하여 표시를 초과

1002
00:37:20,560 --> 00:37:22,560
한 다음 실제로 되돌아가

1003
00:37:22,560 --> 00:37:23,920
원하는 온도인 4 주위로 안정됩니다.

1004
00:37:23,920 --> 00:37:26,320
우리

1005
00:37:26,320 --> 00:37:30,480
는 우리의 목표 이전

1006
00:37:31,839 --> 00:37:34,400
음으로 인코딩되어 있는데 왜 우리

1007
00:37:34,400 --> 00:37:36,480
의 환경 모델이 완벽하지

1008
00:37:36,480 --> 00:37:39,119


1009
00:37:39,119 --> 00:37:40,560


1010
00:37:40,560 --> 00:37:43,040


1011
00:37:43,040 --> 00:37:46,240
않았습니까?  d 복잡한 기능

1012
00:37:46,240 --> 00:37:47,280


1013
00:37:47,280 --> 00:37:51,680
um 이런 종류의 종 모양을 가지고

1014
00:37:51,680 --> 00:37:54,000
있으므로

1015
00:37:54,000 --> 00:37:55,599
환경의 생성 모델이

1016
00:37:55,599 --> 00:37:57,200
완벽하지 않더라도

1017
00:37:57,200 --> 00:37:59,520
결국 우리

1018
00:37:59,520 --> 00:38:01,599
는 약간 오버슈팅하여 그 대가를 지불했지만

1019
00:38:01,599 --> 00:38:04,880
여전히 우리의 목표에 도달할 수 있었습니다.

1020
00:38:04,880 --> 00:38:06,560
4도의 온도에서 원하는 상태를 유지

1021
00:38:06,560 --> 00:38:07,440
하므로 결국

1022
00:38:07,440 --> 00:38:10,720
꽤 잘 작동

1023
00:38:10,800 --> 00:38:12,240


1024
00:38:12,240 --> 00:38:14,880
했으며 에이전트의 자유 에너지도

1025
00:38:14,880 --> 00:38:16,880
시간이 지남에 따라 감소하는 것을 볼 수 있습니다. 그래서 우리는 약 1000부터 시작

1026
00:38:16,880 --> 00:38:19,680
하므로 여기에서 스케일의 로그가

1027
00:38:19,680 --> 00:38:22,640
매우 감소합니다.  빨리 um 우리의

1028
00:38:22,640 --> 00:38:24,720
합계 값은

1029
00:38:24,720 --> 00:38:27,040
다소 낮습니다. 그리고 우리는

1030
00:38:27,040 --> 00:38:29,359


1031
00:38:29,359 --> 00:38:32,320
예상치 못한 변화나 예상치 못한

1032
00:38:32,320 --> 00:38:34,079
놀라움을 유발하는 약간의 소음이 있습니다

1033
00:38:34,079 --> 00:38:36,079
음 그래서 당신이 여기에 작은 잔물결을 가지고

1034
00:38:36,079 --> 00:38:38,240


1035
00:38:38,240 --> 00:38:39,760
있지만 결국 우리는 자유 에너지를 최소화하고 있습니다  그리고

1036
00:38:39,760 --> 00:38:41,920
그것은 급격하게 감소

1037
00:38:41,920 --> 00:38:43,440
할 것이므로 우리는 실제로 이 자유 에너지

1038
00:38:43,440 --> 00:38:47,079
최소화 에이전트를 가지고 있습니다

1039
00:38:47,200 --> 00:38:48,079


1040
00:38:48,079 --> 00:38:50,880
음 그리고 네 그게 기본적으로

1041
00:38:50,880 --> 00:38:53,200
제가 가지고 있는 전부

1042
00:38:53,200 --> 00:38:55,759


1043
00:38:56,880 --> 00:39:00,320
입니다 멋진 이야기와 데모가 있습니다 감사합니다  우리

1044
00:39:00,320 --> 00:39:03,520
는 화면 공유를 켜거나

1045
00:39:03,520 --> 00:39:05,040
라이브 채팅에서 몇 가지 질문을 하지 않거나

1046
00:39:05,040 --> 00:39:07,040
사람들에게 몇 초

1047
00:39:07,040 --> 00:39:08,720
더 입력할 수 있도록 할 수 있습니다.

1048
00:39:08,720 --> 00:39:10,160
그래서 먼저 질문에 뛰어들

1049
00:39:10,160 --> 00:39:12,320


1050
00:39:12,320 --> 00:39:14,480
겠습니다. 스크린샷을 중지하겠습니다.

1051
00:39:14,480 --> 00:39:16,640
그래서 우리는 여전히 화면 이야기를 공유하고 있습니다

1052
00:39:16,640 --> 00:39:19,280
음 우리는 jitsies를 볼 수 있으므로 jitsi

1053
00:39:19,280 --> 00:39:21,119
에서 화면 공유 버튼을 다시 클릭하면 됩니다

1054
00:39:21,119 --> 00:39:23,599
.

1055
00:39:25,440 --> 00:39:27,599
정말 감사합니다. 첫 번째

1056
00:39:27,599 --> 00:39:29,359
질문

1057
00:39:29,359 --> 00:39:31,920
은 john이 하고 john은 그래프가 다음과 같은

1058
00:39:31,920 --> 00:39:34,320
경우 팩터 그래프 접근 방식이 작동하는 방식을 씁니다.

1059
00:39:34,320 --> 00:39:36,960
구조는 미리 알 수 없습니다

1060
00:39:36,960 --> 00:39:41,079
구조 학습이 가능합니다

1061
00:39:43,040 --> 00:39:44,720
어 예 그래서

1062
00:39:44,720 --> 00:39:46,800
좋은 질문입니다 그래서 이러한 그래프에서 구조 학습이

1063
00:39:46,800 --> 00:39:49,520
가능합니다

1064
00:39:49,520 --> 00:39:51,839
음.

1065
00:39:52,079 --> 00:39:54,240
그래서 실제로

1066
00:39:54,240 --> 00:39:55,520
여전히 활성

1067
00:39:55,520 --> 00:39:57,520
연구 분야인 것입니다. 가능하다면 대단

1068
00:39:57,520 --> 00:39:59,599
할 것입니다  그래프 자체의 구조 학습도 자동화

1069
00:39:59,599 --> 00:40:01,599


1070
00:40:01,599 --> 00:40:02,880
하지만 거기에는 많은 도전 과제가

1071
00:40:02,880 --> 00:40:04,400
있으므로 이 그래프 구조를 매개

1072
00:40:04,400 --> 00:40:07,520
변수화하는 방법은 무엇이며 어떻게 합니까?

1073
00:40:07,520 --> 00:40:08,960


1074
00:40:08,960 --> 00:40:12,560
그래프 측면에서 검색 공간 s 그래프에

1075
00:40:12,560 --> 00:40:14,240
대해 노드

1076
00:40:14,240 --> 00:40:15,920
기능이 제공되지 않은 경우 노드 기능을 어떻게 배우나요?

1077
00:40:15,920 --> 00:40:18,160


1078
00:40:18,160 --> 00:40:19,760
매우 어려운 질문이고

1079
00:40:19,760 --> 00:40:21,200
간단한 답  

1080
00:40:21,200 --> 00:40:23,040
이 

1081
00:40:23,040 --> 00:40:24,800
으므로 다음과 같습니다.  설계 주기 자체

1082
00:40:24,800 --> 00:40:27,040
의 이 실제 모델 설계 단계

1083
00:40:27,040 --> 00:40:27,920


1084
00:40:27,920 --> 00:40:29,359


1085
00:40:29,359 --> 00:40:31,440
가 여전히 일종의 창의적인 프로세스인

1086
00:40:31,440 --> 00:40:33,359


1087
00:40:33,359 --> 00:40:34,880


1088
00:40:34,880 --> 00:40:36,560


1089
00:40:36,560 --> 00:40:38,400


1090
00:40:38,400 --> 00:40:40,240
이유  에이전트를

1091
00:40:40,240 --> 00:40:42,160
잘 실행한 후에도 자유 에너지가 여전히 높으면

1092
00:40:42,160 --> 00:40:44,400


1093
00:40:44,400 --> 00:40:45,760


1094
00:40:45,760 --> 00:40:46,720
모델에 문제

1095
00:40:46,720 --> 00:40:48,960
가 있는 것입니다.

1096
00:40:48,960 --> 00:40:50,720
이는 환경에 대한 정확한 표현이 아니며 현재

1097
00:40:50,720 --> 00:40:53,599
잘 조정하는 방법을 조정할 수 있습니다.

1098
00:40:53,599 --> 00:40:55,040
여전히 시행착오일 뿐이

1099
00:40:55,040 --> 00:40:57,280
므로 괜찮다고 말할 수 있습니다.

1100
00:40:57,280 --> 00:40:58,640
여기 여전히 개선할 수 있는 부분이 있다고 생각

1101
00:40:58,640 --> 00:41:00,640
합니다. 아마도 노드를 제거할 수 있습니다. 아마도

1102
00:41:00,640 --> 00:41:03,598
모델이 너무 복잡할 수

1103
00:41:04,130 --> 00:41:05,440


1104
00:41:05,440 --> 00:41:08,880
있지만 [음악] 자체적으로 실행되는 구조는

1105
00:41:08,880 --> 00:41:10,800
음 뭔가요  g 그것은

1106
00:41:10,800 --> 00:41:12,560
또한 해결할 수 있으므로

1107
00:41:12,560 --> 00:41:15,599
중첩 모델 비교와 같은 방법이 있고

1108
00:41:15,599 --> 00:41:17,359


1109
00:41:17,359 --> 00:41:19,280
실제로 그래프를 작성할 수 있는 것과 같은 방법이 있습니다

1110
00:41:19,280 --> 00:41:20,800
. 예를 들어 중첩 모델이 있는 경우

1111
00:41:20,800 --> 00:41:22,880
야만적인 디키 비율을 계산한 다음

1112
00:41:22,880 --> 00:41:25,440
일종의  이를 기반으로 모델을 정리

1113
00:41:25,440 --> 00:41:27,440


1114
00:41:27,440 --> 00:41:29,040
하면 복잡한 모델을 찾고 제거할 수 있는 항목을 확인하기 위해 할

1115
00:41:29,040 --> 00:41:31,759
수 있는 일

1116
00:41:32,480 --> 00:41:34,000
이지만 해당 모델에 추가하는 것은 여전히

1117
00:41:34,000 --> 00:41:35,440
습니

1118
00:41:35,440 --> 00:41:37,680


1119
00:41:37,680 --> 00:41:39,040
다.  정말 잘 모르겠습니다. 그래서

1120
00:41:39,040 --> 00:41:41,200
좋은 질문이군요. 그리고 어 나는 매우

1121
00:41:41,200 --> 00:41:43,040
간단하고 스위치

1122
00:41:43,040 --> 00:41:46,319
가 내 덜거덕임에서 할 수 있는 것을 가지고 있지 않습니다. 그래서 예

1123
00:41:46,800 --> 00:41:49,839
아마도 그것에 대해 뭔가 말할 수 있을 것입니다 음 제

1124
00:41:49,839 --> 00:41:52,960
말은 저는 전적으로 동의합니다 어

1125
00:41:52,960 --> 00:41:55,200
맛 내 말은 일반적으로

1126
00:41:55,200 --> 00:41:57,520


1127
00:41:57,520 --> 00:41:59,520
시스템이나 신호 처리 시스템

1128
00:41:59,520 --> 00:42:00,839
을 설계할 때 구조를 설계해야

1129
00:42:00,839 --> 00:42:03,119
합니다. 어

1130
00:42:03,119 --> 00:42:05,520
매개변수를 추정한 다음 상태를 올바르게 추론해야

1131
00:42:05,520 --> 00:42:08,480
합니다. 상태는 매우 빠르게 변합니다.

1132
00:42:08,480 --> 00:42:11,359


1133
00:42:11,359 --> 00:42:13,040


1134
00:42:13,040 --> 00:42:15,599
잘  요인 그래프

1135
00:42:15,599 --> 00:42:17,920
로 알려지면 다음 단계는 우리

1136
00:42:17,920 --> 00:42:20,800
가 장기적으로 매개변수를 학습

1137
00:42:20,800 --> 00:42:23,200
할 수 있고 우리의 효과 그래프가 이를 꽤 잘 수행할 수 있다는

1138
00:42:23,200 --> 00:42:24,240
것입니다.

1139
00:42:24,240 --> 00:42:27,040
이제 생물학의 다음 단계입니다. 즉

1140
00:42:27,040 --> 00:42:29,280
, 구조가

1141
00:42:29,280 --> 00:42:31,440
훨씬 더 오랜 시간

1142
00:42:31,440 --> 00:42:33,920
동안 경고를 받는다는 것을 알 수 있습니다.  그것은 공식에서 현재 작동하지 않습니다.

1143
00:42:33,920 --> 00:42:37,040
테스트처럼 비교할

1144
00:42:37,040 --> 00:42:39,119
수 있습니다. 두 가지 예가 있으면

1145
00:42:39,119 --> 00:42:41,359
자유 에너지를 비교

1146
00:42:41,359 --> 00:42:43,119
하고 가장 좋은 것을 선택할 수

1147
00:42:43,119 --> 00:42:45,359
있지만 우리는 그것에 대해 작업하고 있으며

1148
00:42:45,359 --> 00:42:47,280
이것은 우리가 다시 주도권을 잡고 있다는 것을 의미합니다  by uh

1149
00:42:47,280 --> 00:42:49,599
베이지안 모델 축소에 대한 carl의 아이디어에서

1150
00:42:49,599 --> 00:42:51,920
하지만 요인 그래프에서 이를 구현하는 방법

1151
00:42:51,920 --> 00:42:54,400
은 연구 프로젝트이므로

1152
00:42:54,400 --> 00:42:55,839
우리는 그것에 대해

1153
00:42:55,839 --> 00:42:58,160
작업하고 있고 그것이 어디에서 끝날지 확신

1154
00:42:58,160 --> 00:43:00,560
하지 못하지만 그것이 우리의 목표였습니다

1155
00:43:00,560 --> 00:43:02,640
당신은 phd 위치를 사용할 수 있습니다. 그래서

1156
00:43:02,640 --> 00:43:04,799
어

1157
00:43:05,920 --> 00:43:07,920
또한

1158
00:43:07,920 --> 00:43:08,640


1159
00:43:08,640 --> 00:43:10,640
자동차가 최적

1160
00:43:10,640 --> 00:43:13,040
의 온도에 도달하는 예를 다시 가져오려면 마치 매시간

1161
00:43:13,040 --> 00:43:14,720
자유 에너지에 충돌이 있음을 알아차린

1162
00:43:14,720 --> 00:43:16,960
다음 드로잉

1163
00:43:16,960 --> 00:43:18,640
보드로 돌아가서  너는 간다

1164
00:43:18,640 --> 00:43:20,800
그 지역에서 그 차에 타고 있는 사람들에게

1165
00:43:20,800 --> 00:43:23,200
매시간 무슨 일이 일어나는지 잘 물어보십시오. 아니면

1166
00:43:23,200 --> 00:43:24,960
이 다른 정보 소스를 포함해야 할 수도

1167
00:43:24,960 --> 00:43:28,000
있지만 당신이 가지고 있던 모델

1168
00:43:28,000 --> 00:43:30,480
이 제 역할을 하므로

1169
00:43:30,480 --> 00:43:32,400
벽지와 방의 다른 기능을 포함할 수 있습니다.

1170
00:43:32,400 --> 00:43:35,040
하지만 그것은 일종의 공학의 예술이자 과학

1171
00:43:35,040 --> 00:43:36,720
이며, 그래서

1172
00:43:36,720 --> 00:43:39,599


1173
00:43:39,599 --> 00:43:41,280
연구에서 종종

1174
00:43:41,280 --> 00:43:42,640
분석을 마치자고 하기 때문에 작업하는 것이 항상 흥미로운 이유입니다.

1175
00:43:42,640 --> 00:43:45,200
하지만 실제로는

1176
00:43:45,200 --> 00:43:46,240
전체

1177
00:43:46,240 --> 00:43:48,160
모델이 내장되어

1178
00:43:48,160 --> 00:43:50,400
있어 항상 관찰하는 데 도움이 되는 주기가 있습니다.

1179
00:43:50,400 --> 00:43:52,160


1180
00:43:52,160 --> 00:43:54,160
현재 모델에서 캡처할 수 없는 패턴

1181
00:43:54,160 --> 00:43:56,319


1182
00:43:56,319 --> 00:43:57,839
이

1183
00:43:57,839 --> 00:44:00,960
있습니다. 채팅에서 두 번째 질문입니다.

1184
00:44:00,960 --> 00:44:03,119


1185
00:44:03,119 --> 00:44:05,680
이 예에서 목표 온도가

1186
00:44:05,680 --> 00:44:08,079
미리 정의되지 않은 경우 요인 그래프 접근 방식은 어떻게 작동합니까?

1187
00:44:08,079 --> 00:44:09,920
목표가 추상적일 수 있으므로 유사한

1188
00:44:09,920 --> 00:44:11,440
질문이지만 오히려  구조

1189
00:44:11,440 --> 00:44:13,599
학습보다 선호도와 목표

1190
00:44:13,599 --> 00:44:16,319
지향성이 어떻게 다시 발생하는가

1191
00:44:16,319 --> 00:44:19,440


1192
00:44:19,920 --> 00:44:20,960


1193
00:44:20,960 --> 00:44:22,560


1194
00:44:22,560 --> 00:44:24,240
하는 질문과 잘 관련이 있는 훌륭한 질문입니다.

1195
00:44:24,240 --> 00:44:25,359
ts 목표

1196
00:44:25,359 --> 00:44:28,560
또는 목표를 설정하는 방법

1197
00:44:29,680 --> 00:44:30,640


1198
00:44:30,640 --> 00:44:32,560
예에

1199
00:44:32,560 --> 00:44:34,560
대한 간단한 대답은 음, 음

1200
00:44:34,560 --> 00:44:36,880
을 정의하는 엔지니어

1201
00:44:36,880 --> 00:44:39,359
이지만

1202
00:44:39,359 --> 00:44:40,319


1203
00:44:40,319 --> 00:44:42,640
추론을 수행하고

1204
00:44:42,640 --> 00:44:44,960


1205
00:44:45,040 --> 00:44:47,599
목표를 설정하여 거북이 종류에 도달하는 더 높은 수준의 에이전트일 수도 있습니다.

1206
00:44:47,599 --> 00:44:49,280


1207
00:44:49,280 --> 00:44:51,520
어떤 의미에서 논쟁의 여지가 없습니다. 당신은

1208
00:44:51,520 --> 00:44:53,760
레이어에 레이어를 레이어 위에 레이어 위에 레이어를 놓을 수 있습니다.

1209
00:44:53,760 --> 00:44:55,760
그리고 레이어는 목표와 다른 레이어

1210
00:44:55,760 --> 00:44:58,560
를 해당 레이어 등의 목표로 설정할 수

1211
00:44:58,560 --> 00:44:59,760


1212
00:44:59,760 --> 00:45:03,280
있습니다. 음, 실제로 작동하는 방식

1213
00:45:03,280 --> 00:45:06,160
음, 여전히 음

1214
00:45:06,160 --> 00:45:08,240
활성 연구입니다.  영역

1215
00:45:08,240 --> 00:45:10,240
음

1216
00:45:10,240 --> 00:45:11,920
하지만 결국 그것은 자유 에너지를 최소화하는 것으로 귀결되어야 합니다.

1217
00:45:11,920 --> 00:45:14,400


1218
00:45:14,400 --> 00:45:16,720
그래서 이것이 일종의 중심 주제

1219
00:45:16,720 --> 00:45:18,720
입니다. 우리는 자유 에너지를 최소화하고 싶습니다

1220
00:45:18,720 --> 00:45:19,920


1221
00:45:19,920 --> 00:45:21,760


1222
00:45:21,760 --> 00:45:22,880


1223
00:45:22,880 --> 00:45:26,480
.  목표

1224
00:45:26,480 --> 00:45:28,480
는 자유 에너지를 최소화하는 방식으로 추진되어야

1225
00:45:28,480 --> 00:45:30,240
하므로 에너지를 최소화하는 목표를 선택해야 합니다. 당신은

1226
00:45:30,240 --> 00:45:32,240
어떻게

1227
00:45:32,240 --> 00:45:33,680


1228
00:45:33,680 --> 00:45:34,800
하고 있는지 모르겠

1229
00:45:34,800 --> 00:45:36,640
군요 당신이 제대로 말했는지

1230
00:45:36,640 --> 00:45:38,879
예

1231
00:45:41,280 --> 00:45:44,640
질문한 또 다른 질문은 이것이 어떻게 또는 그래프와 통합되는가 하는 것이었습니다

1232
00:45:44,640 --> 00:45:47,119


1233
00:45:47,119 --> 00:45:48,560
데이터베이스

1234
00:45:48,560 --> 00:45:50,960
또는 대규모 데이터 세트는

1235
00:45:50,960 --> 00:45:52,640
이러한 종류의 실증적 데이터와 함께 작동하도록 확장되거나 이미

1236
00:45:52,640 --> 00:45:54,319
통합되어 있는 것입니다.

1237
00:45:54,319 --> 00:45:56,160


1238
00:45:56,160 --> 00:45:58,319


1239
00:45:58,319 --> 00:45:59,760
음 제 생각에는 큰 데이터 세트가 무엇을 의미하는지에 따라 달라집니다

1240
00:45:59,760 --> 00:46:03,119


1241
00:46:03,119 --> 00:46:04,000
음

1242
00:46:04,000 --> 00:46:04,800
그래서

1243
00:46:04,800 --> 00:46:06,640
큰 데이터 세트를 들을 때 보통

1244
00:46:06,640 --> 00:46:09,200
생각하는 것  그와 같은 빅 데이터 것들

1245
00:46:09,200 --> 00:46:11,200
음

1246
00:46:11,200 --> 00:46:13,359
너무 음

1247
00:46:13,359 --> 00:46:16,800
이 도구 상자는 바로 지금 동적 모델링을 위해 특별히 제작

1248
00:46:16,800 --> 00:46:18,240


1249
00:46:18,240 --> 00:46:19,359


1250
00:46:19,359 --> 00:46:20,880


1251
00:46:20,880 --> 00:46:23,440
되었으므로 데이터에 많은 기능이 있지만 신호

1252
00:46:23,440 --> 00:46:25,359
처리이므로 데이터가 매우 빠르게 입력될

1253
00:46:25,359 --> 00:46:27,280
수

1254
00:46:27,280 --> 00:46:28,720
있고 방법에 대한 모델이 있습니다.  이러한 데이터

1255
00:46:28,720 --> 00:46:30,319
는 시간이 지남에

1256
00:46:30,319 --> 00:46:31,119
따라 변경되므로

1257
00:46:31,119 --> 00:46:33,200


1258
00:46:33,200 --> 00:46:35,119
빠르게 처리하고 싶으므로 속도를 원합니다.

1259
00:46:35,119 --> 00:46:37,599


1260
00:46:37,599 --> 00:46:39,599


1261
00:46:39,599 --> 00:46:41,760


1262
00:46:41,760 --> 00:46:43,839
예를 들어 다른 문제 프로그래밍

1263
00:46:43,839 --> 00:46:47,119
도구 상자

1264
00:46:47,119 --> 00:46:49,359
는 토치 및  올바른

1265
00:46:49,359 --> 00:46:51,599
샘플링 기본 도구 상자와 같은 것은

1266
00:46:51,599 --> 00:46:53,359


1267
00:46:53,359 --> 00:46:56,640


1268
00:46:56,640 --> 00:46:58,400
데이터 측면에서 볼륨이 있고

1269
00:46:58,400 --> 00:47:00,880
예를 들어 원하는 iid 모델이 있는 경우 모든 훌륭한 도구 상자를

1270
00:47:00,880 --> 00:47:03,040
말합니다.

1271
00:47:03,040 --> 00:47:04,960
우리가 큰 데이터에 대해 이야기한다면 우리

1272
00:47:04,960 --> 00:47:06,720
는 볼륨에 대해 이야기

1273
00:47:06,720 --> 00:47:08,720
하고 매우 빨리 들어오는 데이터를 우리가 잘하려고 하는 우리의 감각

1274
00:47:08,720 --> 00:47:11,599
에

1275
00:47:11,599 --> 00:47:14,640


1276
00:47:14,640 --> 00:47:17,760
um을 맞추려고 합니다.  전달

1277
00:47:17,760 --> 00:47:19,040
은

1278
00:47:19,040 --> 00:47:21,520


1279
00:47:22,240 --> 00:47:26,319
그런 종류의 데이터 세트에 폭탄이

1280
00:47:26,640 --> 00:47:31,520
될 것입니다. 거기에는

1281
00:47:31,520 --> 00:47:34,079
우리가

1282
00:47:34,079 --> 00:47:36,480
능동적인 영향 에이전트를 구축하기 위해 이러한 도구 상자를 구축하려고 실제로 시도

1283
00:47:36,480 --> 00:47:38,640
하는 것이 있고 이러한 에이전트를 그들이 행동하는 환경에 배치한다는 아이디어도 있습니다.

1284
00:47:38,640 --> 00:47:40,800


1285
00:47:40,800 --> 00:47:44,000
그들은 자체 데이터를 선택

1286
00:47:44,000 --> 00:47:47,119
하므로 고정 집합 데이터베이스에

1287
00:47:47,119 --> 00:47:49,040


1288
00:47:49,040 --> 00:47:51,359
대해 기계 학습을 수행하는 데 정말 좋은 도구 상자를 만들려고 하지 않습니다.

1289
00:47:51,359 --> 00:47:54,160


1290
00:47:54,160 --> 00:47:56,720
오히려

1291
00:47:56,720 --> 00:47:58,319


1292
00:47:58,319 --> 00:48:01,119
적응할 수 있고 조치를 취할 수 있는 동적 모델이라고 하는 모델을

1293
00:48:01,119 --> 00:48:03,119
만들려고 합니다.  그리고

1294
00:48:03,119 --> 00:48:06,559
그것은 실시간으로 스트리밍 데이터를 처리할 수

1295
00:48:06,559 --> 00:48:09,359
있고, 그런 의미에서 시간이 지남에 따라

1296
00:48:09,359 --> 00:48:11,599
충분히 오래 기다리면 많은 데이터

1297
00:48:11,599 --> 00:48:13,760
스트리밍이

1298
00:48:13,760 --> 00:48:16,880
있지만 그것은 일종의 당신에 의해 생성되었거나

1299
00:48:16,880 --> 00:48:19,119
최소한 에이전트 자체의 영향을 받은 것입니다.

1300
00:48:19,119 --> 00:48:21,200


1301
00:48:21,200 --> 00:48:23,839
티  환경에서 데이터

1302
00:48:23,839 --> 00:48:29,200
를 스트리밍하는 것보다 큰 고정 데이터베이스에 대해 최적화하려고 시도

1303
00:48:29,200 --> 00:48:32,559


1304
00:48:32,559 --> 00:48:34,480
하는 것은 정말 매력적인 포인트입니다. 자율 주행과 같은

1305
00:48:34,480 --> 00:48:36,640
많은 시간 종속적인 작업

1306
00:48:36,640 --> 00:48:39,040
이 있기 때문에

1307
00:48:39,040 --> 00:48:42,160
괜찮습니다. 여기 500테라바이트의 비디오

1308
00:48:42,160 --> 00:48:43,839
또는 여기가 최고입니다.

1309
00:48:43,839 --> 00:48:45,280


1310
00:48:45,280 --> 00:48:48,800
시간 스냅샷에서 가능한 점수이고

1311
00:48:48,800 --> 00:48:50,400
활성 추론 에이전트를 사용하는 매 시간입니다.

1312
00:48:50,400 --> 00:48:52,319
우리는 항상

1313
00:48:52,319 --> 00:48:54,880
루프에 조치 및 정책 선택을 포함

1314
00:48:54,880 --> 00:48:56,480
하고

1315
00:48:56,480 --> 00:48:58,400
있으므로 이를 어떻게 처리할 것인가?

1316
00:48:58,400 --> 00:49:00,319
하지만 이것이 생물학적 시스템에서 영감을 얻는 이유입니다.

1317
00:49:00,319 --> 00:49:02,640
중요한

1318
00:49:02,640 --> 00:49:04,559
것은 사람들이 잘 할

1319
00:49:04,559 --> 00:49:06,960
때 두뇌가 이 처리

1320
00:49:06,960 --> 00:49:09,040
능력을 가지고 있어야 하고 그것이 전구

1321
00:49:09,040 --> 00:49:10,559
이거나 실리콘 컴퓨터와 같은 종류의

1322
00:49:10,559 --> 00:49:11,839
컴퓨터라면 이 정도의 에너지를 차지할 때와 같습니다.

1323
00:49:11,839 --> 00:49:14,160
어고의 효율성은

1324
00:49:14,160 --> 00:49:16,640
이러하지만 그렇습니다.  이미 존재하는 것으로부터 시작하여 t에 있는 답을 찾는 대신

1325
00:49:16,640 --> 00:49:18,720
우리가 보던 컴퓨터의 종류를 기반으로 합니다.

1326
00:49:18,720 --> 00:49:20,800


1327
00:49:20,800 --> 00:49:22,800


1328
00:49:22,800 --> 00:49:24,160


1329
00:49:24,160 --> 00:49:26,480
오히려 우리가

1330
00:49:26,480 --> 00:49:28,800
저전력 트랜지스터를 만들어 뇌에 넣을 수 있도록 하는 것이 아니라

1331
00:49:28,800 --> 00:49:31,040


1332
00:49:31,040 --> 00:49:31,920
매우

1333
00:49:31,920 --> 00:49:34,559
멋진 주제입니다. 다음 프레젠테이션을 준비할 준비가 된 것 같습니다.

1334
00:49:34,559 --> 00:49:37,680


1335
00:49:39,440 --> 00:49:41,599
예 안녕하세요. 모두들 제 화면도 공유해 드리겠습니다.

1336
00:49:41,599 --> 00:49:45,839
어

1337
00:49:47,920 --> 00:49:52,400
잠시만 작동되기를 바랍니다.  이제 괜찮아 보입니다.

1338
00:49:52,400 --> 00:49:56,800
이제 내 슬라이드를 볼 수 있습니다. 예,

1339
00:49:56,800 --> 00:49:59,119
좋습니다. 예, 안녕하세요. 다시 한 번 제 이름은

1340
00:49:59,119 --> 00:50:02,000
mitri bhagav이며 7월

1341
00:50:02,000 --> 00:50:04,319


1342
00:50:04,319 --> 00:50:06,400
에 베이지안 임프린트를 위한 이 새로운 반응 메시지 전달 기반 프레임워크를 소개

1343
00:50:06,400 --> 00:50:08,880


1344
00:50:08,880 --> 00:50:11,200
하고 싶습니다.

1345
00:50:11,200 --> 00:50:14,079
능동 추론을 위한 솔루션에 대한 미래 비전 fornilab.jl은

1346
00:50:14,079 --> 00:50:15,680


1347
00:50:15,680 --> 00:50:18,800
작동하는 성숙한 프레임워크와 같으며, 현재로서는 Reactive mp가

1348
00:50:18,800 --> 00:50:22,720
우리의 연구 프로젝트입니다.

1349
00:50:22,720 --> 00:50:24,400
우리

1350
00:50:24,400 --> 00:50:25,520


1351
00:50:25,520 --> 00:50:27,359
는 실제로 반응성 메시지 버스팅이 무엇

1352
00:50:27,359 --> 00:50:28,400


1353
00:50:28,400 --> 00:50:29,839
인지에 대한 질문으로 시작하려고 합니다

1354
00:50:29,839 --> 00:50:31,920
. 대부분의 의미에서

1355
00:50:31,920 --> 00:50:34,960
수식으로 전달되는 동일한 메시지이지만

1356
00:50:34,960 --> 00:50:37,680
반응 패러다임으로 다시 구현되므로 기본적으로 포르노 연구실의

1357
00:50:37,680 --> 00:50:39,760
전통적인 접근 방식의 주요 문제

1358
00:50:39,760 --> 00:50:40,960


1359
00:50:40,960 --> 00:50:43,760


1360
00:50:43,760 --> 00:50:45,839
는 우리 모델에 대한 추론을 실행할 수 있다는 것입니다.  이

1361
00:50:45,839 --> 00:50:48,480
메시지의 그림자를 미리 생성

1362
00:50:48,480 --> 00:50:50,720
해야 하므로 그래프를 사전 분석

1363
00:50:50,720 --> 00:50:53,119
해야 하며 기본적으로 모든 것을 분석

1364
00:50:53,119 --> 00:50:55,200
해야 하며 그래프 구조를 변경할 때마다 수행해야 하며

1365
00:50:55,200 --> 00:50:57,200


1366
00:50:57,200 --> 00:51:00,480
그래프가 크면 이 그래프 분석

1367
00:51:00,480 --> 00:51:02,319
시간과  섀도우 생성은 추가 시간이 많이

1368
00:51:02,319 --> 00:51:04,240


1369
00:51:04,240 --> 00:51:07,280
소요될 수 있고 큰 문제는

1370
00:51:07,280 --> 00:51:09,200
아니지만 엔지니어로서 성능에 만족할 때까지 많은 모델을 테스트하고 싶을 수 있습니다.

1371
00:51:09,200 --> 00:51:11,359


1372
00:51:11,359 --> 00:51:14,079
이러한 추가 지연

1373
00:51:14,079 --> 00:51:16,079
및 셔틀 생성 시간

1374
00:51:16,079 --> 00:51:19,680
은  마지막으로 전달되는 약간의 성가시고 반응적인

1375
00:51:19,680 --> 00:51:21,520
메시지를 통해

1376
00:51:21,520 --> 00:51:24,400
사전 정의된 그림자를 제거

1377
00:51:24,400 --> 00:51:26,240
할 수 있으며 또한 많은 다른 이점

1378
00:51:26,240 --> 00:51:30,400
과 가능한 향후 연구 방향을 제공

1379
00:51:30,400 --> 00:51:32,880
하므로

1380
00:51:32,880 --> 00:51:35,839
고정된 그림자를 갖는 대신 이벤트처럼 그래프를 캐스트합니다.

1381
00:51:35,839 --> 00:51:37,760
-

1382
00:51:37,760 --> 00:51:39,520
모든 것이 이웃 환경에 반응할 수 있고

1383
00:51:39,520 --> 00:51:41,119


1384
00:51:41,119 --> 00:51:43,440
메시지 전달 측면에서

1385
00:51:43,440 --> 00:51:45,920
노드가 수신 메시지

1386
00:51:45,920 --> 00:51:48,319
에 반응하고 매개변수에 대해 업데이트된 사후 한계에 반응하는 기반 시스템

1387
00:51:48,319 --> 00:51:50,800


1388
00:51:50,800 --> 00:51:53,760
d 전체 모델은 반응형이 됩니다.

1389
00:51:53,760 --> 00:51:56,319
또한 이 시스템의 변경 사항에 반응할 수

1390
00:51:56,319 --> 00:51:58,960
있고 기본적으로 우리가 원하는 대로 할 수 있으므로

1391
00:51:58,960 --> 00:52:00,800


1392
00:52:00,800 --> 00:52:04,800
새로운 업데이트된 사후 한계값을 기반으로 일부 작업을 수행

1393
00:52:04,800 --> 00:52:07,680
할 수도 있습니다. 메시지에서도 자연스러운 시작점을 전달합니다.

1394
00:52:07,680 --> 00:52:11,280
uh is uh 우리의 데이터 또는

1395
00:52:11,280 --> 00:52:14,400
관찰 및  모델 자체는

1396
00:52:14,400 --> 00:52:18,559
데이터 또는 사전의 변경에 반응하고

1397
00:52:18,559 --> 00:52:20,319
그에 따라 사후도 변경

1398
00:52:20,319 --> 00:52:23,040
됩니다.

1399
00:52:23,040 --> 00:52:26,480
그래서 여기에서는 능동 메시지 수동 구현의 몇 가지 추가 이점에 대해 설명했습니다.

1400
00:52:26,480 --> 00:52:27,760


1401
00:52:27,760 --> 00:52:29,839
따라서 우선

1402
00:52:29,839 --> 00:52:32,400
생물학적 타당성을 개략적으로 설명

1403
00:52:32,400 --> 00:52:34,480
할 수 있습니다.

1404
00:52:34,480 --> 00:52:36,800


1405
00:52:36,800 --> 00:52:39,440


1406
00:52:39,440 --> 00:52:41,520
예를 들어 뇌의

1407
00:52:41,520 --> 00:52:43,920
뉴런에 흐르는 정보에 대한 사전 정의된 스케줄러는

1408
00:52:43,920 --> 00:52:46,960
물리학과 같은 화학에 의해 구동되며 어떤 의미에서는

1409
00:52:46,960 --> 00:52:49,200
반응 시스템과도 같습니다

1410
00:52:49,200 --> 00:52:52,240
. 환경의 변화에 지속적으로 적응하고 필  

1411
00:52:52,240 --> 00:52:55,599
할 때만 반응합니

1412
00:52:55,599 --> 00:52:57,359
다.  메시지 전달 기반

1413
00:52:57,359 --> 00:52:59,520
추론의 용어는 그렇지 않은 경우

1414
00:52:59,520 --> 00:53:02,400
일부 메시지와 같은 일부 이벤트에 반응하는

1415
00:53:02,400 --> 00:53:05,760
것조차 불필요할 수 있습니다.  정말 중요

1416
00:53:05,760 --> 00:53:08,240
합니다. 미리 정의된 고정된 그림자가

1417
00:53:08,240 --> 00:53:10,480


1418
00:53:10,480 --> 00:53:13,280
실제로 필요하지 않더라도 모든 계산을 수행해야 합니다.

1419
00:53:13,280 --> 00:53:15,040
어 크래프트 메시지 버스팅의 또 다른 큰 이점은

1420
00:53:15,040 --> 00:53:17,040


1421
00:53:17,040 --> 00:53:19,599
매우 큰 그래프에 대해 매우 멋지게 확장되므로

1422
00:53:19,599 --> 00:53:22,319
이전에 대한 답변과 더 비슷하다는 것입니다.  질문

1423
00:53:22,319 --> 00:53:24,559
어, 그래서

1424
00:53:24,559 --> 00:53:26,800
수십만 개의 요소 메모를 지원합니다. 심지어

1425
00:53:26,800 --> 00:53:29,040
수백만 개도 가능합니다.

1426
00:53:29,040 --> 00:53:30,559
어 몇 분 안에 예를 보여 드리겠습니다. 하지만

1427
00:53:30,559 --> 00:53:32,800
약간의 컨텍스트를 제공하기 위해 이

1428
00:53:32,800 --> 00:53:35,359
플롯에서 우리는 몇 가지 움직이는

1429
00:53:35,359 --> 00:53:38,559
물체를 모델링했습니다.  알려진 선 선형 역학

1430
00:53:38,559 --> 00:53:40,559
및 아이디어는 이 예에서 잡음이 있는 관측이 제공되는 세단 상태를 추정하는 것이었습니다.

1431
00:53:40,559 --> 00:53:43,520


1432
00:53:43,520 --> 00:53:45,520
저는

1433
00:53:45,520 --> 00:53:47,280
50,000개의

1434
00:53:47,280 --> 00:53:49,680
관측으로 칼만 스무더를 사용했으며 이 모델에는

1435
00:53:49,680 --> 00:53:53,280
약 150,000개의 요인 노드가 포함

1436
00:53:53,280 --> 00:53:55,040
되어 있으므로 이러한 종류의 모델에 대한 베이지안 추론

1437
00:53:55,040 --> 00:53:57,839
은 샘플링에서 불가능합니다.  기반

1438
00:53:57,839 --> 00:53:59,520
추론

1439
00:53:59,520 --> 00:54:01,200
이지만 반응 메시지 전달을 사용

1440
00:54:01,200 --> 00:54:03,119


1441
00:54:03,119 --> 00:54:06,480
하면 가정용 macbook 랩톱에서 약 8초 밖에 걸리지

1442
00:54:06,480 --> 00:54:09,480


1443
00:54:10,559 --> 00:54:12,720
않으므로 조금 더 나아가

1444
00:54:12,720 --> 00:54:14,880
반응 시스템을 만들 수 있습니다.  일부에 대해 견고하고 관대합니다.

1445
00:54:14,880 --> 00:54:17,760
노드에 오류가 발생하거나

1446
00:54:17,760 --> 00:54:18,960


1447
00:54:18,960 --> 00:54:21,760
센서에 데이터가 누락되었다고 가정해 봅시다.

1448
00:54:21,760 --> 00:54:23,920


1449
00:54:23,920 --> 00:54:25,440
이와 같은 일이 발생

1450
00:54:25,440 --> 00:54:27,200


1451
00:54:27,200 --> 00:54:29,280
하면 사전 정의

1452
00:54:29,280 --> 00:54:31,839
된 그림자

1453
00:54:31,839 --> 00:54:34,240
를 수정합니다.

1454
00:54:34,240 --> 00:54:36,960
반응형 메시지 버스팅으로 시간을 내어

1455
00:54:36,960 --> 00:54:39,599
일부 누락된 데이터 또는 센서 오류에 대한 반응을 중지

1456
00:54:39,599 --> 00:54:42,160


1457
00:54:42,160 --> 00:54:44,160
할 수 있으며 다시 사용할 수 있을 때까지 기다릴 수 있습니다

1458
00:54:44,160 --> 00:54:46,160


1459
00:54:46,160 --> 00:54:48,319
. 그런 의미에서 매우 강력

1460
00:54:48,319 --> 00:54:50,799


1461
00:54:50,799 --> 00:54:53,440
해 그래프를 변경할 수 있는 기회도 제공합니다.  런타임에 구조를 유지

1462
00:54:53,440 --> 00:54:55,440
하고 여전히 멈추지 않고 추론을 수행

1463
00:54:55,440 --> 00:54:57,920


1464
00:54:58,880 --> 00:55:01,599
하므로 약 1년 반 전에 실험실에서

1465
00:55:01,599 --> 00:55:02,720


1466
00:55:02,720 --> 00:55:04,799
julia의 주요 프로그래밍 언어를 실제로 사용하는 방법에 대한 슬라이드가 있습니다.

1467
00:55:04,799 --> 00:55:07,920


1468
00:55:07,920 --> 00:55:09,839


1469
00:55:09,839 --> 00:55:11,440


1470
00:55:11,440 --> 00:55:13,599


1471
00:55:13,599 --> 00:55:15,359


1472
00:55:15,359 --> 00:55:17,200
이벤트 기반 시스템을 위한 일반 프레임워크에서 전달되는 메시지와 관련이

1473
00:55:17,200 --> 00:55:18,240


1474
00:55:18,240 --> 00:55:20,640
없지만 나중에

1475
00:55:20,640 --> 00:55:24,160
반응형 mp.jl 패키지를 빌드할 수 있게 되었습니다.

1476
00:55:24,160 --> 00:55:25,680
그리고 메시지 전달을 통한 자유 에너지 최소화를 구현합니다.

1477
00:55:25,680 --> 00:55:29,359


1478
00:55:29,359 --> 00:55:31,599
또한 우리는 데모에서 사용

1479
00:55:31,599 --> 00:55:33,520
하는 높은 수준의 사용자 친화적인

1480
00:55:33,520 --> 00:55:35,119
확률 모델 사양

1481
00:55:35,119 --> 00:55:38,640
언어인

1482
00:55:38,640 --> 00:55:41,040


1483
00:55:41,040 --> 00:55:43,119
graphpl.gel 패키지를 도입

1484
00:55:43,119 --> 00:55:45,119
했습니다.  두 번째

1485
00:55:45,119 --> 00:55:47,599
로 제 화면을 바로 볼 수 있습니다. 예,

1486
00:55:47,599 --> 00:55:49,119


1487
00:55:49,119 --> 00:55:53,040
한 사이즈나 두 사이즈 더 크거나

1488
00:55:53,440 --> 00:55:56,799
깨지지 않기를 바랍니다.

1489
00:55:56,799 --> 00:55:58,240
예, 조금 더 크게 만들고

1490
00:55:58,240 --> 00:56:02,759
예상치 못한 경우 뒤로 물러날

1491
00:56:02,799 --> 00:56:04,960


1492
00:56:04,960 --> 00:56:07,599


1493
00:56:07,599 --> 00:56:10,720
수 있습니다.  는 우리의 예이므로 움직이는 물체가 있다고 가정

1494
00:56:10,720 --> 00:56:11,520


1495
00:56:11,520 --> 00:56:14,240
합니다. 어

1496
00:56:14,240 --> 00:56:16,079
그것은 숨겨진 상태를 가지고 있으며 단순성을 위해

1497
00:56:16,079 --> 00:56:18,400
선형 역학이라는 것을 알고 있다고 가정

1498
00:56:18,400 --> 00:56:21,200


1499
00:56:21,200 --> 00:56:23,359
하고 위치에 직접 액세스 할 수는

1500
00:56:23,359 --> 00:56:25,200
없지만 노이즈가 많은 관찰이 있습니다.  이

1501
00:56:25,200 --> 00:56:26,480
움직이는 물체

1502
00:56:26,480 --> 00:56:28,799
와 잡음이 있는 측정값

1503
00:56:28,799 --> 00:56:31,599
만 관찰하여 이 움직이는 물체의 실제 위치를 추정

1504
00:56:31,599 --> 00:56:35,040


1505
00:56:35,040 --> 00:56:38,160
하기를 원하며 방정식과 같은 선형 다변수

1506
00:56:38,160 --> 00:56:41,119
가우스 상태 공간 모델을 사용할 수 있습니다.

1507
00:56:41,119 --> 00:56:44,000
e

1508
00:56:44,000 --> 00:56:46,480
등가 표기법은 동일

1509
00:56:46,480 --> 00:56:48,960
하며 기본적으로 여기에서

1510
00:56:48,960 --> 00:56:52,400
우리는 시간 단계 k에서 상태 x가 있고

1511
00:56:52,400 --> 00:56:54,400


1512
00:56:54,400 --> 00:56:55,920


1513
00:56:55,920 --> 00:56:58,400
일부 선형 연산자 a를 통한 이전 시간 단계에만 의존

1514
00:56:58,400 --> 00:57:00,880
하며 가우스인 전이 잡음도 가지고 있다고

1515
00:57:00,880 --> 00:57:03,599
말합니다.  공분산 행렬 b를 사용하고

1516
00:57:03,599 --> 00:57:06,000
우리의 관찰은

1517
00:57:06,000 --> 00:57:07,200


1518
00:57:07,200 --> 00:57:10,319
기본적으로 공분산 행렬 q를 사용하는 가우스로 모델링

1519
00:57:10,319 --> 00:57:11,040


1520
00:57:11,040 --> 00:57:12,960


1521
00:57:12,960 --> 00:57:15,520
되므로 기본적으로 이것이 우리의 모델

1522
00:57:15,520 --> 00:57:17,599
이며 간단히 요인 그래프를 만들 수

1523
00:57:17,599 --> 00:57:19,440


1524
00:57:19,440 --> 00:57:21,040


1525
00:57:21,040 --> 00:57:22,240
있습니다.

1526
00:57:22,240 --> 00:57:25,359
우리의 모델 사양은 다음과 매우

1527
00:57:25,359 --> 00:57:27,760
유사합니다.  위에서 정의한 방정식

1528
00:57:27,760 --> 00:57:29,359
그래서 여기에

1529
00:57:29,359 --> 00:57:32,240
우리의 상태 xk가 있고 알려진 공분산 행렬을 사용

1530
00:57:32,240 --> 00:57:35,040
하여 이전 상태에 대한 가우스처럼 모델링되었습니다.

1531
00:57:35,040 --> 00:57:38,240


1532
00:57:38,240 --> 00:57:40,400
이것이 우리가 모델을 구축하는 방법

1533
00:57:40,400 --> 00:57:42,400
이며 후드 아래에서 이

1534
00:57:42,400 --> 00:57:45,359
코드는 요인 그래프를 생성합니다.

1535
00:57:45,359 --> 00:57:48,319
어 그리고 우리는 할 수 있습니다  나중에 모두

1536
00:57:48,319 --> 00:57:49,359
반응형

1537
00:57:49,359 --> 00:57:51,839
mp.jail API를 사용하여 시스템의 숨겨진 상태를 추정할 수

1538
00:57:51,839 --> 00:57:54,000
있지만 여기에 우리의 예가 있습니다. 제가

1539
00:57:54,000 --> 00:57:55,760


1540
00:57:55,760 --> 00:57:59,119
조금 확대

1541
00:57:59,119 --> 00:58:01,599
했지만 괜찮

1542
00:58:01,599 --> 00:58:04,400
습니다.  nd 이 예에서 나는

1543
00:58:04,400 --> 00:58:07,119
500개 포인트에 대해 칼만 스무더를 수행하고

1544
00:58:07,119 --> 00:58:08,720


1545
00:58:08,720 --> 00:58:10,480
이 움직이는 물체의 궤적을

1546
00:58:10,480 --> 00:58:13,359
2축 x축과 y축으로 분해했습니다.

1547
00:58:13,359 --> 00:58:14,880
그리고 우리는

1548
00:58:14,880 --> 00:58:17,440
공통 스무더

1549
00:58:17,440 --> 00:58:19,359
가 우리 시스템의 실제 은닉 상태처럼

1550
00:58:19,359 --> 00:58:21,599
정확하게 예측되었음을 알 수

1551
00:58:21,599 --> 00:58:23,200
있습니다.  우리 시스템에는 많은 노이즈가

1552
00:58:23,200 --> 00:58:25,440
있으므로 이 파란색 점

1553
00:58:25,440 --> 00:58:28,480
은 노이즈가 있는 관찰

1554
00:58:28,480 --> 00:58:31,440
과 같으며 더 멀리 갈 수 있습니다.

1555
00:58:31,440 --> 00:58:34,240
시스템이 반응하기 때문에

1556
00:58:34,240 --> 00:58:37,760
실시간으로 상태를 추정할 수

1557
00:58:37,760 --> 00:58:38,799


1558
00:58:38,799 --> 00:58:41,839
있으므로 여기에 우리의 예가 있습니다.  실행해 보겠습니다.

1559
00:58:41,839 --> 00:58:43,839


1560
00:58:43,839 --> 00:58:46,319
어, 제 컴퓨터에서 매끄럽게 보이길 바랍니다.

1561
00:58:46,319 --> 00:58:48,559
실제로는 매우 부드럽

1562
00:58:48,559 --> 00:58:51,200
지만

1563
00:58:51,200 --> 00:58:53,520
녹화가 화면 공유처럼 매끄럽지 않을 수도 있다는 것을 압니다.

1564
00:58:53,520 --> 00:58:56,480
하지만 이 예에서

1565
00:58:56,480 --> 00:58:58,559
우리가 볼 수 있는 것은 괜찮습니다. 무한한

1566
00:58:58,559 --> 00:59:01,040
데이터 스트림이 있다는 것입니다  움직이는 물체의 파란색

1567
00:59:01,040 --> 00:59:02,559
은 실제 물체이고 빨간색

1568
00:59:02,559 --> 00:59:05,440
은 추정값입니다.

1569
00:59:05,440 --> 00:59:07,760
어, 꺼진 상태이므로 다시 로드하겠습니다.

1570
00:59:07,760 --> 00:59:10,559


1571
00:59:10,720 --> 00:59:13,680


1572
00:59:13,920 --> 00:59:16,160
반응 mp가 수행할 수 있고 베이지안 추론을 수행할 수 있음을 알 수 있습니다.

1573
00:59:16,160 --> 00:59:18,640
n 실시간

1574
00:59:18,640 --> 00:59:21,359
으로 환경의 변화에 실제로 적응하고

1575
00:59:21,359 --> 00:59:23,760
현재 추정된 상태에 대한 사후도 변경합니다. 더  

1576
00:59:23,760 --> 00:59:27,200


1577
00:59:27,200 --> 00:59:28,559


1578
00:59:28,559 --> 00:59:30,480
아가 여  

1579
00:59:30,480 --> 00:59:32,880
에서 이 주황색 선이 현  

1580
00:59:32,880 --> 00:59:35,520
비활성화되어 있음을 알 수 있지만 이  

1581
00:59:35,520 --> 00:59:38,640


1582
00:59:38,640 --> 00:59:41,440
델에 대한 예측을 통합할 수도 있으므로  우리는

1583
00:59:41,440 --> 00:59:44,160
그래프를 약간 확장

1584
00:59:44,160 --> 00:59:47,280
할 수 있고 이와 같이 시스템의 미래 상태를 예측할 수도 있습니다.

1585
00:59:47,280 --> 00:59:49,119


1586
00:59:49,119 --> 00:59:50,240


1587
00:59:50,240 --> 00:59:52,799
그래서 이제 이 예

1588
00:59:52,799 --> 00:59:55,119
에서 실시간으로 베이지안 추론을 수행

1589
00:59:55,119 --> 00:59:57,760


1590
00:59:57,760 --> 01:00:00,160
하고 주황색과 같이 시스템의 미래 상태도 예측합니다.

1591
01:00:00,160 --> 01:00:02,319
예측도 새로운 관찰에 적응한다는 것을 알 수 있습니다.

1592
01:00:02,319 --> 01:00:04,960


1593
01:00:04,960 --> 01:00:08,240
예, 기본적으로 미래 상태에 대한 미래의

1594
01:00:08,240 --> 01:00:09,520
믿음

1595
01:00:09,520 --> 01:00:12,720
을 변경합니다.

1596
01:00:12,720 --> 01:00:14,559
어 예

1597
01:00:14,559 --> 01:00:16,720
, 중지하고

1598
01:00:16,720 --> 01:00:19,439
프레젠테이션

1599
01:00:21,040 --> 01:00:23,119


1600
01:00:23,119 --> 01:00:25,040


1601
01:00:25,040 --> 01:00:27,200
을 계속

1602
01:00:27,200 --> 01:00:30,000
하겠습니다.  실제로는 이미 작동 중

1603
01:00:30,000 --> 01:00:32,480


1604
01:00:32,480 --> 01:00:34,480
입니다. 정확하고

1605
01:00:34,480 --> 01:00:36,799
가변적인 베이지안 추론을 위해 완전히 작동하는 안정적인 백핸드와 API가 있습니다. 우리는

1606
01:00:36,799 --> 01:00:39,280
기대 전파도 지원하지만 th

1607
01:00:39,280 --> 01:00:44,079
api에서는 아직 안정적이지 않으므로 변경될 수 있습니다.

1608
01:00:44,079 --> 01:00:46,799
지금

1609
01:00:46,799 --> 01:00:48,960
은 지수 계열의 켤레 모델

1610
01:00:48,960 --> 01:00:50,799
만 지원합니다. 변형 최적화 절차에 대한 추가 제약 조건을 지원

1611
01:00:50,799 --> 01:00:53,680


1612
01:00:53,680 --> 01:00:55,599
하므로 형태 또는 인수분해

1613
01:00:55,599 --> 01:00:56,880
제약 조건이

1614
01:00:56,880 --> 01:00:59,440
있으므로 로켓.jl 라이브러리

1615
01:00:59,440 --> 01:01:01,280
는 예를 들어 인터넷의 무한 데이터 스트림을 자연스럽게 지원합니다.

1616
01:01:01,280 --> 01:01:03,599
또는 일부

1617
01:01:03,599 --> 01:01:05,280
센서

1618
01:01:05,280 --> 01:01:07,680
및 프레임워크 자체에서 누락된 데이터를 처리할 수

1619
01:01:07,680 --> 01:01:09,280


1620
01:01:09,280 --> 01:01:10,480
있지만 해당

1621
01:01:10,480 --> 01:01:14,960
API도 아직 여기에서 안정적이지 않으므로

1622
01:01:16,079 --> 01:01:17,040


1623
01:01:17,040 --> 01:01:19,520
이 플랫폼에 대한 향후 계획 중 일부는

1624
01:01:19,520 --> 01:01:22,400


1625
01:01:22,400 --> 01:01:24,720
비결합 모델을 지원하도록 확장하고

1626
01:01:24,720 --> 01:01:26,960
기본적으로 외국 연구소에서 이미 지원

1627
01:01:26,960 --> 01:01:28,079
합니다.

1628
01:01:28,079 --> 01:01:30,319
우리

1629
01:01:30,319 --> 01:01:32,160
는 사용 가능한 모든 기존 기능

1630
01:01:32,160 --> 01:01:35,599
을 외국 연구실에서 반응 mp로 조심스럽게 이식해야

1631
01:01:35,599 --> 01:01:37,680


1632
01:01:37,680 --> 01:01:39,440


1633
01:01:39,440 --> 01:01:42,960
하며 7월에 존재하는 다른 확률 프로그래밍 라이브러리와 통합하기를 원합니다.

1634
01:01:43,520 --> 01:01:45,359
반응 메시지 전달은

1635
01:01:45,359 --> 01:01:47,280


1636
01:01:47,280 --> 01:01:50,480
병렬 추론을 통합

1637
01:01:50,480 --> 01:01:52,079
하고 반응할 수 있는 기회를 제공합니다.  같은 멀티 코어 기능을 사용하여 그래프의 다른 부분을

1638
01:01:52,079 --> 01:01:53,920
동시에 사용

1639
01:01:53,920 --> 01:01:57,280
o  f 우리 CPU

1640
01:01:57,280 --> 01:01:58,079
uh

1641
01:01:58,079 --> 01:01:59,839
우리

1642
01:01:59,839 --> 01:02:02,640


1643
01:02:02,640 --> 01:02:04,880
는 지금은 모듈식 모델 사양을 지원하기 위해 그래프 ppl을 확장하고 싶습니다. 또한 불행히도

1644
01:02:04,880 --> 01:02:07,839
불가능합니다.

1645
01:02:08,960 --> 01:02:11,200
또한 반응 메시지 전달은 자연스럽게

1646
01:02:11,200 --> 01:02:13,039


1647
01:02:13,039 --> 01:02:15,280
다른 데이터

1648
01:02:15,280 --> 01:02:19,280
스트림이 다른 업데이트 속도를 갖는 추론을 실행할 수 있는 기회를 제공합니다.

1649
01:02:19,280 --> 01:02:21,359
음

1650
01:02:21,359 --> 01:02:22,960
제가 말한 내용

1651
01:02:22,960 --> 01:02:25,520
견고성에 대한 시작이지만

1652
01:02:25,520 --> 01:02:27,920
우리가 그것을 어디까지 밀어붙일 수 있는지 또한 흥미롭습니다.

1653
01:02:27,920 --> 01:02:30,319
아마도 자유 에너지를 기반으로 런타임에

1654
01:02:30,319 --> 01:02:32,480
모델의 그래프 구조를 자동으로 적응시키는 것이 가능

1655
01:02:32,480 --> 01:02:35,039


1656
01:02:35,039 --> 01:02:37,520


1657
01:02:38,000 --> 01:02:39,839
하지만 그것이 가능한지 여부를 실제로 알지 못하는 연구 프로젝트와 같습니다.

1658
01:02:39,839 --> 01:02:41,520


1659
01:02:41,520 --> 01:02:43,599


1660
01:02:43,599 --> 01:02:45,440
이제 우리는

1661
01:02:45,440 --> 01:02:47,280
메시지 전달 기반 알고리즘 및 자유 에너지 최소화 시각화를 위한 대화형 시각화에 대한 몇 가지 아이디어를 가지고

1662
01:02:47,280 --> 01:02:49,359


1663
01:02:49,359 --> 01:02:50,960


1664
01:02:50,960 --> 01:02:53,520


1665
01:02:53,520 --> 01:02:56,400
있으며 궁극적으로

1666
01:02:56,400 --> 01:02:58,799
이 새로운 플랫폼을 2.0에서 공식의 안정적인 버전으로 출시할 계획

1667
01:02:58,799 --> 01:03:01,280


1668
01:03:01,280 --> 01:03:03,200


1669
01:03:03,200 --> 01:03:05,280
이며 기본적으로 이것이 제가

1670
01:03:05,280 --> 01:03:07,039
여러분에게 보여주고 싶었던 모든 것입니다.

1671
01:03:07,039 --> 01:03:08,319
관심을 가져주셔서 감사합니다. 귀하의

1672
01:03:08,319 --> 01:03:12,079
질문에 기꺼이 답변해 드리겠습니다.

1673
01:03:13,760 --> 01:03:16,640
멋진 첫 번째 질문은 이 reactmp.jl에 대한

1674
01:03:16,640 --> 01:03:18,680
논문이

1675
01:03:18,680 --> 01:03:22,720
있는지 또는 그 작업이 어떻게

1676
01:03:22,720 --> 01:03:25,760
진행 중인지

1677
01:03:25,760 --> 01:03:27,920
공개적으로 사용할 수는

1678
01:03:27,920 --> 01:03:30,240
없지만 진행 중이므로

1679
01:03:30,240 --> 01:03:31,920
결국 이 모든 접근 방식에 대한 논문이

1680
01:03:31,920 --> 01:03:33,599
나올 것입니다.

1681
01:03:33,599 --> 01:03:36,960
작동 방식과 사용 방법에 대한 모든

1682
01:03:36,960 --> 01:03:39,039
것입니다. 물론 누군가

1683
01:03:39,039 --> 01:03:41,599
가 논문의 초기 사본을 원하는 이메일을 우리에게 쓴

1684
01:03:41,599 --> 01:03:44,240
다면

1685
01:03:44,240 --> 01:03:45,599


1686
01:03:45,599 --> 01:03:49,359
기밀로 유지된다면 기꺼이 공유하겠습니다.

1687
01:03:49,520 --> 01:03:50,799


1688
01:03:50,799 --> 01:03:51,920


1689
01:03:51,920 --> 01:03:54,559
다른 저자들에게는 매우 흥미로운 개발이 있었을 것

1690
01:03:54,559 --> 01:03:55,760


1691
01:03:55,760 --> 01:03:56,799


1692
01:03:56,799 --> 01:03:58,480


1693
01:03:58,480 --> 01:04:01,839
입니다. 포니 랩의 다른 시대에는

1694
01:04:01,839 --> 01:04:02,799
음

1695
01:04:02,799 --> 01:04:05,440
우리가 어떻게 이 반응형

1696
01:04:05,440 --> 01:04:07,200
프로그래밍 패러다임을 접하게 되었고 또한

1697
01:04:07,200 --> 01:04:09,039
당신은 반응형 프로그래밍에 대해 실험실에서 기초 작업을 많이 한 것 같습니다.

1698
01:04:09,039 --> 01:04:10,480


1699
01:04:10,480 --> 01:04:13,039


1700
01:04:13,039 --> 01:04:14,400
julia

1701
01:04:14,400 --> 01:04:17,119
구현이나 더 개념적인

1702
01:04:17,119 --> 01:04:19,599
기초에서

1703
01:04:19,599 --> 01:04:20,559


1704
01:04:20,559 --> 01:04:22,559
음, 사실 우리는 julia

1705
01:04:22,559 --> 01:04:24,720
에서 반응형 프로그래밍을 지원하기 위해 실제로 많은 작업을 했습니다.

1706
01:04:24,720 --> 01:04:28,559
기본적으로 julia는 젊은

1707
01:04:28,559 --> 01:04:30,960
언어와 같으며 l이 없습니다.

1708
01:04:30,960 --> 01:04:33,839
시스템과 같은 반응 기반을 실행하는 좋은 기능이

1709
01:04:33,839 --> 01:04:36,960
있으므로 기본적으로

1710
01:04:36,960 --> 01:04:39,599
처음부터 빌드합니다.

1711
01:04:39,599 --> 01:04:42,640
하지만 우리는 많은 것을 사용했습니다. 예

1712
01:04:42,640 --> 01:04:43,760


1713
01:04:43,760 --> 01:04:46,240


1714
01:04:46,240 --> 01:04:50,240
를 들어 우리가 경험한 다른 프로그래밍 언어의

1715
01:04:53,200 --> 01:04:55,119


1716
01:04:55,119 --> 01:04:57,200
아이디어를 말해보자.

1717
01:04:57,200 --> 01:05:00,559
matlab은 환상적

1718
01:05:00,559 --> 01:05:02,160
이지만

1719
01:05:02,160 --> 01:05:05,280


1720
01:05:05,280 --> 01:05:09,119
스트리밍 데이터의 실시간 처리를 원할 경우 julia

1721
01:05:09,119 --> 01:05:10,720


1722
01:05:10,720 --> 01:05:13,839
는 매우 좋은 옵션입니다. julia

1723
01:05:13,839 --> 01:05:16,480
는 사용자의 관점에서 matlab의 구문을 거의 가지고

1724
01:05:16,480 --> 01:05:17,680


1725
01:05:17,680 --> 01:05:19,039


1726
01:05:19,039 --> 01:05:21,520
있지만 기본적으로는 거의

1727
01:05:21,520 --> 01:05:23,119
빠릅니다.

1728
01:05:23,119 --> 01:05:25,920
c 따라서

1729
01:05:25,920 --> 01:05:27,680
엔지니어링에 있고

1730
01:05:27,680 --> 01:05:29,280
실제로

1731
01:05:29,280 --> 01:05:31,599
실시간으로 실행되는 시스템을 구축하려는 경우

1732
01:05:31,599 --> 01:05:34,640
데모를 만들고 싶고 julia가 더 나은 언어인 경우 더 나은 조합

1733
01:05:34,640 --> 01:05:37,920


1734
01:05:37,920 --> 01:05:41,760
이었습니다.

1735
01:05:41,760 --> 01:05:43,280
다중 디스패치

1736
01:05:43,280 --> 01:05:44,720


1737
01:05:44,720 --> 01:05:46,960
라고 하지만 그것이 무엇인지는 중요

1738
01:05:46,960 --> 01:05:48,160
하지 않지만 상당히 고급이고

1739
01:05:48,160 --> 01:05:51,359
matlab에서 사용할 수 없지만

1740
01:05:51,359 --> 01:05:53,760


1741
01:05:53,760 --> 01:05:55,520
우리가 하는 일에 매우 유용합니다.

1742
01:05:55,520 --> 01:05:59,039
도구 상자

1743
01:05:59,039 --> 01:06:01,599
그래프와

1744
01:06:01,599 --> 01:06:04,240
전달되는 메시지를 보면 아,

1745
01:06:04,240 --> 01:06:05,680
실제로 구현하기 어렵지는

1746
01:06:05,680 --> 01:06:07,839


1747
01:06:07,839 --> 01:06:09,359
않지만 요인 그래프를 위한 도구 상자가 극히 적은 이유가 있습니다.

1748
01:06:09,359 --> 01:06:11,680


1749
01:06:11,680 --> 01:06:14,880


1750
01:06:14,880 --> 01:06:18,640
.net은 훌륭하지만

1751
01:06:18,640 --> 01:06:21,200
실제로는 실시간 도구 상자가 아닙니다.

1752
01:06:21,200 --> 01:06:24,799
음, 우리가 아는

1753
01:06:24,799 --> 01:06:26,400
한

1754
01:06:26,400 --> 01:06:28,079
현재

1755
01:06:28,079 --> 01:06:30,240
로서는 우리 도구 상자가 매우 발전된 것이 아니라 현재 경쟁자

1756
01:06:30,240 --> 01:06:31,359


1757
01:06:31,359 --> 01:06:33,680
가 많지 않습니다.  이

1758
01:06:33,680 --> 01:06:36,720
작업을 하는 많은 사람들이 멀티카터 샘플링에 대해 작업하는 것을

1759
01:06:36,720 --> 01:06:38,799
보았지만 멀티 카

1760
01:06:38,799 --> 01:06:41,359
샘플링

1761
01:06:41,359 --> 01:06:43,920
은 시스템 크기

1762
01:06:43,920 --> 01:06:45,680
와 우리가 작업하고 있는 능동 추론 권한으로 수행하려는 실시간 데이터 스트림에 대해 작동하지 않습니다.

1763
01:06:45,680 --> 01:06:48,480


1764
01:06:48,480 --> 01:06:50,079
우리

1765
01:06:50,079 --> 01:06:53,119
가 작업을 수행하고 데이터에 영향을 미치고 싶은 시스템

1766
01:06:53,119 --> 01:06:55,359
은 실시간 시스템입니다. 그래서

1767
01:06:55,359 --> 01:06:56,240


1768
01:06:56,240 --> 01:06:59,119


1769
01:06:59,119 --> 01:07:01,520
실제로 확장해야 하므로 메시지 전달을 자동화

1770
01:07:01,520 --> 01:07:02,640


1771
01:07:02,640 --> 01:07:05,039
하는 정말 고품질의 전문 도구 상자를 구축해야

1772
01:07:05,039 --> 01:07:06,640


1773
01:07:06,640 --> 01:07:09,599


1774
01:07:09,599 --> 01:07:12,160
합니다.  어 그 도구 상자 중 하나가 될

1775
01:07:12,160 --> 01:07:13,839
것이고 다른 도구 상자도 될 것입니다.

1776
01:07:13,839 --> 01:07:15,280
하지만 그렇습니다.

1777
01:07:15,280 --> 01:07:18,400
그래서 우리가 이

1778
01:07:18,400 --> 01:07:21,760
매우 흥미로운

1779
01:07:21,760 --> 01:07:23,440
대답을 하고

1780
01:07:23,440 --> 01:07:25,119


1781
01:07:25,119 --> 01:07:27,200


1782
01:07:27,200 --> 01:07:28,880


1783
01:07:28,880 --> 01:07:32,559


1784
01:07:32,559 --> 01:07:34,240
있습니다  활성 추론

1785
01:07:34,240 --> 01:07:36,240
의 실시간 통찰력 중 일부가 알고리즘

1786
01:07:36,240 --> 01:07:38,480


1787
01:07:38,480 --> 01:07:40,319
설계로 다시 전파되는 것처럼 들리기

1788
01:07:40,319 --> 01:07:42,559


1789
01:07:42,559 --> 01:07:44,319
때문에 우리는 양방향을

1790
01:07:44,319 --> 01:07:46,480


1791
01:07:46,480 --> 01:07:48,880


1792
01:07:49,359 --> 01:07:52,720
보고 있습니다.  내 관점에서 이 질문에 대답할 수도

1793
01:07:52,720 --> 01:07:54,960
있습니다. 저는 주로

1794
01:07:54,960 --> 01:07:57,200
프로그래밍을 하는 것을 좋아

1795
01:07:57,200 --> 01:07:59,039
하지만 항상 새로운 것을 배웁니다.

1796
01:07:59,039 --> 01:08:02,000
왜냐하면 우리는 계속해서

1797
01:08:02,000 --> 01:08:03,359


1798
01:08:03,359 --> 01:08:05,920
우리 연구실에서 수학 친구들

1799
01:08:05,920 --> 01:08:07,440
과 나누는 대화를 좋아하기 때문입니다.

1800
01:08:07,440 --> 01:08:10,400
물론 그것은

1801
01:08:10,400 --> 01:08:13,200
우리의 소프트웨어에 대한 우리의 디자인 선택처럼 반영됩니다.

1802
01:08:13,200 --> 01:08:16,158
그래서 그것은 일종의 하지만 때로는

1803
01:08:16,158 --> 01:08:18,640
이 높은 수준의 수학적 아이디어를 실제에 맞추는 것이 매우 어렵습니다.

1804
01:08:18,640 --> 01:08:21,040


1805
01:08:21,040 --> 01:08:22,560
구현

1806
01:08:22,560 --> 01:08:25,120
및 또한 그것을 효율적으로 만드는 것은 매우 어렵습니다.

1807
01:08:25,120 --> 01:08:26,799


1808
01:08:26,799 --> 01:08:28,960
그래서

1809
01:08:31,359 --> 01:08:34,319
예, 어 우리는 이 작업을 끝내지

1810
01:08:34,319 --> 01:08:37,040
않았습니다 음 내 말은 도구 상자는 누구나 사용할 수

1811
01:08:37,040 --> 01:08:39,040
있고

1812
01:08:39,040 --> 01:08:41,198
모든 좋은 영역의 예는

1813
01:08:41,198 --> 01:08:44,080
기본 온도 조절기 tic tac toe 및

1814
01:08:44,080 --> 01:08:46,080
모두 작동합니다.

1815
01:08:46,080 --> 01:08:48,318


1816
01:08:49,198 --> 01:08:51,519
우리의

1817
01:08:51,759 --> 01:08:54,158
희망은 반응 메시지

1818
01:08:54,158 --> 01:08:55,679
전달을 통해 실제로

1819
01:08:55,679 --> 01:08:56,880


1820
01:08:56,880 --> 01:08:59,359
이것을 심각한 응용 프로그램으로 확장하는 경로를 얻을 수

1821
01:08:59,359 --> 01:09:00,719


1822
01:09:00,719 --> 01:09:02,560
있다는

1823
01:09:02,560 --> 01:09:04,158


1824
01:09:04,158 --> 01:09:06,799
것입니다.

1825
01:09:06,799 --> 01:09:09,198
유용합니다. 저는 보청기

1826
01:09:09,198 --> 01:09:12,640
회사에서 일하기 때문에 실시간

1827
01:09:12,640 --> 01:09:16,479
오디오 처리 알고리즘

1828
01:09:16,479 --> 01:09:17,359
을

1829
01:09:17,359 --> 01:09:18,960
만들고 싶고 다른 사람들은 이것을 로봇 공학에 사용하고 싶을 수도 있습니다.

1830
01:09:18,960 --> 01:09:21,439


1831
01:09:21,439 --> 01:09:24,399
예, 하지만

1832
01:09:24,399 --> 01:09:26,479
실시간 모델에서는 작동하지 않을 것입니다. 작동하지 않을 것입니다

1833
01:09:26,479 --> 01:09:28,399


1834
01:09:28,399 --> 01:09:31,679
음  예, 모든 멀티 카드 또는 기타와 함께

1835
01:09:31,679 --> 01:09:33,600
약간 그래서

1836
01:09:33,600 --> 01:09:36,080
이것은 우리의 노력

1837
01:09:36,080 --> 01:09:38,560
이며

1838
01:09:38,560 --> 01:09:40,560
꽤 오랜 시간이 걸립니다.

1839
01:09:40,560 --> 01:09:42,880
우리 그룹에는 수학자와 신경이 있는 매우 다학문적인 노력이 있기 때문입니다

1840
01:09:42,880 --> 01:09:46,000


1841
01:09:46,000 --> 01:09:47,279


1842
01:09:47,279 --> 01:09:49,120
oscientists와

1843
01:09:49,120 --> 01:09:51,359
컴퓨터 과학자

1844
01:09:51,359 --> 01:09:53,439
는 그것이 어렵기

1845
01:09:53,439 --> 01:09:55,520
때문에 능동 추론을 위한

1846
01:09:55,520 --> 01:09:57,199


1847
01:09:57,199 --> 01:09:59,360
좋은 도구 상자를 구축하는 데 필요한 많은 다른 전문 지식

1848
01:09:59,360 --> 01:10:02,880


1849
01:10:02,880 --> 01:10:04,640
이 있기 때문에 활성 추론 커뮤니티와 활성 추론 커뮤니티 사이에 교차 수정이 너무 어렵기 때문에 많은 유사점이 있다고 생각합니다.

1850
01:10:04,640 --> 01:10:06,159


1851
01:10:06,159 --> 01:10:08,080


1852
01:10:08,080 --> 01:10:09,679


1853
01:10:09,679 --> 01:10:11,840


1854
01:10:11,840 --> 01:10:13,840
우리

1855
01:10:13,840 --> 01:10:15,840
가 커뮤니티에서 하는 공학은 주로

1856
01:10:15,840 --> 01:10:18,560
생물학의 모델로서

1857
01:10:18,560 --> 01:10:20,239
올바른 에너지 원리와 능동적

1858
01:10:20,239 --> 01:10:21,840
추론을 설명

1859
01:10:21,840 --> 01:10:24,000
하는

1860
01:10:24,000 --> 01:10:25,440
데 관심

1861
01:10:25,440 --> 01:10:26,960
이 있습니다. 자연은 일을 효율적으로 수행하는 특정 방식이 있기 때문에 매우 흥미롭다고 생각합니다.

1862
01:10:26,960 --> 01:10:28,840


1863
01:10:28,840 --> 01:10:30,800


1864
01:10:30,800 --> 01:10:32,719
음.  이를 위한 모델을 엔지니어링

1865
01:10:32,719 --> 01:10:34,320
에 적용하는 것도 좋은

1866
01:10:34,320 --> 01:10:36,000


1867
01:10:36,000 --> 01:10:37,920
생각이며 이는 우리가 권장하는 것이므로

1868
01:10:37,920 --> 01:10:40,000


1869
01:10:40,000 --> 01:10:41,199
활성 추론 커뮤니티에서 사용할 수 있는 아이디어를 가져

1870
01:10:41,199 --> 01:10:43,360
오고 두뇌를 설명하고

1871
01:10:43,360 --> 01:10:45,120
두뇌에 대해 생각하고

1872
01:10:45,120 --> 01:10:47,120
우리가 어떻게 할 수 있는지 생각합니다.  이

1873
01:10:47,120 --> 01:10:48,320
아이디어를 가지고

1874
01:10:48,320 --> 01:10:49,120


1875
01:10:49,120 --> 01:10:53,440
엔지니어링 시스템을 구축하는 데 사용

1876
01:10:53,440 --> 01:10:56,320


1877
01:10:56,320 --> 01:10:57,920
하십시오.  그것 사이의 주요 상호 작용과

1878
01:10:57,920 --> 01:11:00,800
희망적으로 우리

1879
01:11:00,800 --> 01:11:02,719
는 커뮤니티가 그들의 연구에서 사용할 수 있는 도구를 구축합니다.

1880
01:11:02,719 --> 01:11:06,080
결국

1881
01:11:07,199 --> 01:11:09,520
제가 생각하게 된 것은 신호 처리를 실시간 이벤트로 보는 것과 같은 주요 과제

1882
01:11:09,520 --> 01:11:11,840
중 일부를 재구성하는 것이라는 것이었습니다.

1883
01:11:11,840 --> 01:11:14,080


1884
01:11:14,080 --> 01:11:16,000


1885
01:11:16,000 --> 01:11:16,800


1886
01:11:16,800 --> 01:11:18,960
행동

1887
01:11:18,960 --> 01:11:21,440
과 미래 데이터 사이의 인과 관계 문제의 이러한 모든 종류의

1888
01:11:21,440 --> 01:11:24,080
재구성은

1889
01:11:24,080 --> 01:11:26,239
능동 추론

1890
01:11:26,239 --> 01:11:27,600


1891
01:11:27,600 --> 01:11:31,199
알고리즘과 같지 않습니다. 그 자체로 대규모 행렬을 사용하는 계산은

1892
01:11:31,199 --> 01:11:34,080
매우 간단할 수도 있고 그렇지 않을 수도

1893
01:11:34,080 --> 01:11:35,760
있지만 실제로는 행동의 임베딩에서 재구성하는

1894
01:11:35,760 --> 01:11:38,480
것입니다  모든 단계 내

1895
01:11:38,480 --> 01:11:39,440


1896
01:11:39,440 --> 01:11:42,080
에서 확장을 해결하는 것으로 끝나는

1897
01:11:42,080 --> 01:11:44,000
확장 문제 중 일부 확장 문제 중 일부

1898
01:11:44,000 --> 01:11:45,440


1899
01:11:45,440 --> 01:11:47,040


1900
01:11:47,040 --> 01:11:49,040
는 도시의 교통 네트워크의 탄력성과 같이

1901
01:11:49,040 --> 01:11:50,000


1902
01:11:50,000 --> 01:11:51,600
샘플링을 수행

1903
01:11:51,600 --> 01:11:53,440
하거나 전개되는 동적 프로세스인 무언가를 취한

1904
01:11:53,440 --> 01:11:55,520
다음 롤아웃하려고 하기 때문에 일부 탄력성 문제  정적으로 백만 번

1905
01:11:55,520 --> 01:11:58,080
반복

1906
01:11:58,080 --> 01:12:00,080
하므로 루프 내부의 계산이 아닙니다.

1907
01:12:00,080 --> 01:12:01,360


1908
01:12:01,360 --> 01:12:02,880
h  도전하기 위해

1909
01:12:02,880 --> 01:12:05,520
그것은 단지

1910
01:12:05,520 --> 01:12:07,520
우선 순위 지정 작업의 재구성일

1911
01:12:07,520 --> 01:12:08,960


1912
01:12:08,960 --> 01:12:11,280
뿐입니다. 확장 및

1913
01:12:11,280 --> 01:12:14,400
실시간 용량의

1914
01:12:14,400 --> 01:12:16,640


1915
01:12:16,640 --> 01:12:18,800
길을 따라가게

1916
01:12:18,800 --> 01:12:20,560


1917
01:12:20,560 --> 01:12:22,800


1918
01:12:22,800 --> 01:12:24,880
되었습니다.  디자인 기본적으로 저는 보청기

1919
01:12:24,880 --> 01:12:25,860
엔지니어입니다.

1920
01:12:25,860 --> 01:12:27,120
[Music]

1921
01:12:27,120 --> 01:12:29,120
에서 일합니다. 보청기 엔지니어에게

1922
01:12:29,120 --> 01:12:31,040
신호 처리 엔지니어에게 질문하면 귀하의 작업은 무엇입니까?

1923
01:12:31,040 --> 01:12:32,480


1924
01:12:32,480 --> 01:12:34,320
우리의 임무는 최고의

1925
01:12:34,320 --> 01:12:36,400
보청기 알고리즘

1926
01:12:36,400 --> 01:12:37,600


1927
01:12:37,600 --> 01:12:39,600


1928
01:12:39,600 --> 01:12:41,920
을 구축하는 것

1929
01:12:41,920 --> 01:12:44,159
입니다.  보청기 고객은 가게에 가서

1930
01:12:44,159 --> 01:12:46,719
보청기를 구입합니다. 일반적

1931
01:12:46,719 --> 01:12:48,640
으로 매우 만족하며 나가고

1932
01:12:48,640 --> 01:12:50,880
2주 후에 레스토랑에 앉습니다.

1933
01:12:50,880 --> 01:12:52,400


1934
01:12:52,400 --> 01:12:54,960


1935
01:12:54,960 --> 01:12:57,520
소음이 있고 예상하지 못한 일

1936
01:12:57,520 --> 01:13:00,480
이었고 그녀가 할 수 있는 것이 없기

1937
01:13:00,480 --> 01:13:02,960
때문에 그녀의 대화 상대를 이해할 수 없습니다.  보청기 고객에게 보청기 매개변수를 만지작거리라고 요청할 수 없습니다.

1938
01:13:02,960 --> 01:13:05,199


1939
01:13:05,199 --> 01:13:06,560


1940
01:13:06,560 --> 01:13:08,480
그래서

1941
01:13:08,480 --> 01:13:09,760
이런 일

1942
01:13:09,760 --> 01:13:11,679
이 몇 번 발생하면

1943
01:13:11,679 --> 01:13:13,760
음 그녀는

1944
01:13:13,760 --> 01:13:16,400
보청기를 던지거나 서랍에 넣고 이것을 어

1945
01:13:16,400 --> 01:13:19,199
실제로 보청기의 약 10 20 퍼센트가

1946
01:13:19,199 --> 01:13:20,880
서랍에 들어갑니다. 매우

1947
01:13:20,880 --> 01:13:21,910
비싸고

1948
01:13:21,910 --> 01:13:23,520
[Music]

1949
01:13:23,520 --> 01:13:24,400
20

1950
01:13:24,400 --> 01:13:27,040
은 사용되지 않는 정말

1951
01:13:27,040 --> 01:13:28,960
슬픈 통계입니다.

1952
01:13:28,960 --> 01:13:31,040
그래서 오히려

1953
01:13:31,040 --> 01:13:32,960
당신이 그것을 돌려서

1954
01:13:32,960 --> 01:13:35,040
진짜 보청기가 무엇인지 말할 수 있습니다.  디자인

1955
01:13:35,040 --> 01:13:36,560
문제 진짜 보청기 디자인

1956
01:13:36,560 --> 01:13:39,280
문제는 보청기를 가지고 누군가를 보내는 것입니다.

1957
01:13:39,280 --> 01:13:41,440
하지만 그녀가 식당에서 현장에서 불행할 때 당신은 어떻게 합니까

1958
01:13:41,440 --> 01:13:43,679


1959
01:13:43,679 --> 01:13:46,320


1960
01:13:46,320 --> 01:13:48,320
? 우리가 만들고 싶은 것은

1961
01:13:48,320 --> 01:13:49,360


1962
01:13:49,360 --> 01:13:52,080
그런 다음 그녀가 손목을 찰싹 때릴 에이전트입니다.

1963
01:13:52,080 --> 01:13:54,080
나는 행복합니다. 이제 이 에이전트

1964
01:13:54,080 --> 01:13:55,679
는 행동을 취하고 그녀에게 가장 흥미로운 새로운

1965
01:13:55,679 --> 01:13:58,239
매개변수 설정을 제공해야 합니다.

1966
01:13:58,239 --> 01:14:00,719


1967
01:14:00,719 --> 01:14:02,239


1968
01:14:02,239 --> 01:14:04,480


1969
01:14:04,480 --> 01:14:07,040


1970
01:14:07,040 --> 01:14:08,719


1971
01:14:08,719 --> 01:14:10,320


1972
01:14:10,320 --> 01:14:12,960
지금 내 관점에서 디자인은

1973
01:14:12,960 --> 01:14:16,159


1974
01:14:16,159 --> 01:14:18,800


1975
01:14:18,800 --> 01:14:20,800
그녀가 불행할 때 보청기 제안을

1976
01:14:20,800 --> 01:14:22,320
하고 그녀가

1977
01:14:22,320 --> 01:14:24,159
맞다면 불행할 때 행동을 하도록 하는 에이전트를 구축한 다음

1978
01:14:24,159 --> 01:14:25,920
혼합 제안을 듣는 것이 좋지 않다고 말하는 혼합된 제안을 듣는

1979
01:14:25,920 --> 01:14:28,000
것입니다.  gent가 또 다른 제안

1980
01:14:28,000 --> 01:14:30,159
을 하면 괜찮습니다. 그러면

1981
01:14:30,159 --> 01:14:32,159
우리는 계속 진행하고 아마도 일주일 후에

1982
01:14:32,159 --> 01:14:35,600
같은 이벤트가 계속 진행

1983
01:14:35,600 --> 01:14:38,719
되지만 시간이 지남

1984
01:14:38,719 --> 01:14:41,120
에 따라 계속 개선되도록 계속 진행하는 절차가

1985
01:14:41,120 --> 01:14:44,000
있습니다.

1986
01:14:44,000 --> 01:14:45,360
그래서

1987
01:14:45,360 --> 01:14:48,159
그게 진짜입니다.  디자인의 문제는

1988
01:14:48,159 --> 01:14:52,239
c2의 현장에서의 행동

1989
01:14:52,239 --> 01:14:53,600
이 현재 일어나고 있는 것과는 매우 다른 것

1990
01:14:53,600 --> 01:14:56,000
입니다. 보청기

1991
01:14:56,000 --> 01:14:58,159
엔지니어

1992
01:14:58,159 --> 01:15:01,920
가 환경이 아닌 모델을 사용하여 책상에 앉아 있는 것입니다.

1993
01:15:01,920 --> 01:15:04,400
그래서 그것이 바로 패러다임 전환

1994
01:15:04,400 --> 01:15:07,760
과 능동적 추론입니다.  요원

1995
01:15:07,760 --> 01:15:09,679
이 그런 일이 일어나도록 할 수 있고

1996
01:15:09,679 --> 01:15:10,960
실제로

1997
01:15:10,960 --> 01:15:12,640
어

1998
01:15:12,640 --> 01:15:14,560


1999
01:15:14,560 --> 01:15:16,719
신호 처리 설계와 같은 것의 중심점을

2000
01:15:16,719 --> 01:15:18,400


2001
01:15:18,400 --> 01:15:19,920
만들 수 있다고 생각합니다. 어

2002
01:15:19,920 --> 01:15:21,679
, 신경과학자일 때 생각하는

2003
01:15:21,679 --> 01:15:23,520
것이

2004
01:15:23,520 --> 01:15:25,440
아니라 엔지니어링

2005
01:15:25,440 --> 01:15:27,040
및  신호 처리뿐만

2006
01:15:27,040 --> 01:15:29,120
아니라 다른 엔지니어링

2007
01:15:29,120 --> 01:15:31,120
분야에서도

2008
01:15:31,120 --> 01:15:32,960
마찬가지이므로 시간이 지남에 따라

2009
01:15:32,960 --> 01:15:35,280
점점 더 많은 사람들이 다른 분야에서 오는 것을

2010
01:15:35,280 --> 01:15:37,360
보게 될 것이라고 생각합니다.  nt

2011
01:15:37,360 --> 01:15:41,040
분야가 이 어

2012
01:15:41,040 --> 01:15:42,480
능동 추론과 자유 에너지

2013
01:15:42,480 --> 01:15:43,920
원리에 관심을 갖고 있습니다.

2014
01:15:43,920 --> 01:15:47,360
어 심지어 어 심지어

2015
01:15:47,360 --> 01:15:49,199
어 신경과학자는 아니지만

2016
01:15:49,199 --> 01:15:50,840
엔지니어가

2017
01:15:50,840 --> 01:15:54,159
맞습니다. 그렇습니다. 멋지네요. 그렇게 되기를 바랍니다

2018
01:15:54,159 --> 01:15:56,560


2019
01:15:56,560 --> 01:15:58,159
.

2020
01:15:58,159 --> 01:15:59,920
엔지니어와 철학자와의 말굽 이론은

2021
01:15:59,920 --> 01:16:01,600


2022
01:16:01,600 --> 01:16:04,239
종종

2023
01:16:04,239 --> 01:16:06,080
다른 방식으로 실용주의에 대해 이야기합니다. 다른 커뮤니티는

2024
01:16:06,080 --> 01:16:07,600
다른 도구입니다.

2025
01:16:07,600 --> 01:16:09,520
이제 그 격차

2026
01:16:09,520 --> 01:16:12,719


2027
01:16:12,719 --> 01:16:14,560
를 좁힐 방법이 있습니다.

2028
01:16:14,560 --> 01:16:16,640


2029
01:16:16,640 --> 01:16:18,880
디자인

2030
01:16:18,880 --> 01:16:22,400
과학의 예상 디자인 과학

2031
01:16:22,400 --> 01:16:24,080
철학 또는

2032
01:16:24,080 --> 01:16:26,400
개발할 툴킷이 있습니다. 툴킷으로 작업

2033
01:16:26,400 --> 01:16:28,480
한 지 5년 또는 철학의 5년 후에 흥미로울

2034
01:16:28,480 --> 01:16:30,000


2035
01:16:30,000 --> 01:16:31,280
수 있습니다. 그러면

2036
01:16:31,280 --> 01:16:33,360
툴킷에 대해 궁금해

2037
01:16:33,360 --> 01:16:34,640
하므로 한 가지

2038
01:16:34,640 --> 01:16:36,320
질문

2039
01:16:36,320 --> 01:16:38,480
은  이 그래프는

2040
01:16:38,480 --> 01:16:41,280
시간적으로 깊은 모델을 설명합니다. 이러한 모델은 어떻게 지정되는지

2041
01:16:41,280 --> 01:16:42,800


2042
01:16:42,800 --> 01:16:43,920
또는

2043
01:16:43,920 --> 01:16:46,080
그래프에서 무엇이 다른지 확인합니다.

2044
01:16:46,080 --> 01:16:48,400
e 그것은 단지

2045
01:16:48,400 --> 01:16:50,000
당신이 제공한 예에서 취할 다음 조치를 계산하는 것뿐입니다.

2046
01:16:50,000 --> 01:16:52,400


2047
01:16:53,120 --> 01:16:55,920
아마도 여러분은 그래프를 다시 보여줄 수 있습니다

2048
01:16:55,920 --> 01:16:58,640
. 미래가 어떻게 표현

2049
01:16:58,640 --> 01:17:00,560
되는지 그리고 시간적 두께를 어떻게 추가합니까

2050
01:17:00,560 --> 01:17:02,560


2051
01:17:02,560 --> 01:17:05,760
?  의자 화면과 같은 그래프가

2052
01:17:06,320 --> 01:17:07,280


2053
01:17:07,280 --> 01:17:10,400
있습니다

2054
01:17:12,800 --> 01:17:14,239
예 이런 그래프가 있는 경우

2055
01:17:14,239 --> 01:17:15,600
시간적 두께를 어떻게 추가합니까?

2056
01:17:15,600 --> 01:17:17,840


2057
01:17:17,920 --> 01:17:20,080


2058
01:17:20,080 --> 01:17:21,120


2059
01:17:21,120 --> 01:17:22,400


2060
01:17:22,400 --> 01:17:25,920


2061
01:17:25,920 --> 01:17:27,280


2062
01:17:27,280 --> 01:17:28,320


2063
01:17:28,320 --> 01:17:30,960


2064
01:17:30,960 --> 01:17:33,840
관찰은 개별적으로

2065
01:17:33,840 --> 01:17:34,960


2066
01:17:34,960 --> 01:17:36,960
오지만 이 위의 레이어가 더 높은 시간적 시간 척도에서 작동하는 아래

2067
01:17:36,960 --> 01:17:38,960
레이어에 어떻게든 연결되어 있을 수 있습니다.

2068
01:17:38,960 --> 01:17:40,239


2069
01:17:40,239 --> 01:17:42,080


2070
01:17:42,080 --> 01:17:43,360


2071
01:17:43,360 --> 01:17:46,239


2072
01:17:46,239 --> 01:17:48,239


2073
01:17:48,239 --> 01:17:49,440


2074
01:17:49,440 --> 01:17:52,000


2075
01:17:52,000 --> 01:17:54,480
여기에서 모델

2076
01:17:54,480 --> 01:17:56,480
을 만들면 더 느리게 진화하는 레이어의 영향을 받는 시간에 따라 변하는

2077
01:17:56,480 --> 01:17:58,800
관찰 모델을

2078
01:17:58,800 --> 01:17:59,679


2079
01:17:59,679 --> 01:18:02,400


2080
01:18:02,400 --> 01:18:04,000
얻을 수 있고 그 위에 더 느리게 진화하는 레이어를 얻을 수 있습니다.

2081
01:18:04,000 --> 01:18:05,679


2082
01:18:05,679 --> 01:18:06,960
그것이

2083
01:18:06,960 --> 01:18:09,440
당신이 계층 구조를 구축할 수 있는

2084
01:18:09,440 --> 01:18:10,640


2085
01:18:10,640 --> 01:18:13,120
방법입니다 음 사실

2086
01:18:13,120 --> 01:18:15,760
우리 그룹 ismael senos에 pg 학생이 있습니다. 그는 그것에

2087
01:18:15,760 --> 01:18:17,280
대해 매우 흥미로운 작업

2088
01:18:17,280 --> 01:18:19,280
을 했고 그는 계층적 가우스 필터를 만드는 방법을 조사했습니다.

2089
01:18:19,280 --> 01:18:21,199


2090
01:18:21,199 --> 01:18:24,480


2091
01:18:24,480 --> 01:18:27,199


2092
01:18:27,199 --> 01:18:29,679
레이어는 아래 레이어의 전환 모델의 분산에 영향을 미치며 이를 통해

2093
01:18:29,679 --> 01:18:31,280


2094
01:18:31,280 --> 01:18:33,280


2095
01:18:33,280 --> 01:18:34,960


2096
01:18:34,960 --> 01:18:37,360


2097
01:18:37,360 --> 01:18:40,960
매우 자연스러운 신호를 모델링할 수 있다는 것을 알 수 있습니다.

2098
01:18:40,960 --> 01:18:42,960


2099
01:18:42,960 --> 01:18:44,640


2100
01:18:44,640 --> 01:18:46,400


2101
01:18:46,400 --> 01:18:48,880
이러한 모델

2102
01:18:48,880 --> 01:18:50,800
은 시간에 따라 다양

2103
01:18:50,800 --> 01:18:52,880
하므로 그런 의미에서 계층적 모델은

2104
01:18:52,880 --> 01:18:54,560
매우 유용할 수 있습니다.

2105
01:18:54,560 --> 01:18:56,719
물론

2106
01:18:56,719 --> 01:18:58,960
그렇습니다. 물론 우리의 두뇌가 어떻게 구성되어 있는지도 마찬가지입니다. 그래서

2107
01:18:58,960 --> 01:19:00,800
다시 자연에서 영감을 얻었습니다.

2108
01:19:00,800 --> 01:19:02,000


2109
01:19:02,000 --> 01:19:04,080
음 우리가 모델을 구성하는 방법에 대해

2110
01:19:04,080 --> 01:19:07,360


2111
01:19:07,360 --> 01:19:08,480


2112
01:19:08,480 --> 01:19:10,560


2113
01:19:10,560 --> 01:19:12,239
최소한 이론상으로는 벡터 그래프로 um을 구축해 보세요.

2114
01:19:12,239 --> 01:19:13,280


2115
01:19:13,280 --> 01:19:14,800
그것들을 연결할 수 있기 때문에 꽤 쉬워야 합니다.

2116
01:19:14,800 --> 01:19:17,120
r 그 위에 r 그리고

2117
01:19:17,120 --> 01:19:20,000
그것이 어떻게 작동하는지 확인

2118
01:19:20,000 --> 01:19:21,760
하고 결국에는

2119
01:19:21,760 --> 01:19:23,760
모델의 복잡성이 매우 높아져

2120
01:19:23,760 --> 01:19:26,159
자동으로 그에 대한 불이익

2121
01:19:26,159 --> 01:19:28,320


2122
01:19:28,320 --> 01:19:31,120
을 받게 되므로 주어진 데이터에 따라 컷오프 포인트가 있게 되며 이것이

2123
01:19:31,120 --> 01:19:32,960
최적의 레이어 양이 될 것입니다.  관찰하는

2124
01:19:32,960 --> 01:19:34,400
모든 변종을 설명하기 위해 필요합니다.

2125
01:19:34,400 --> 01:19:35,679


2126
01:19:35,679 --> 01:19:38,480


2127
01:19:39,520 --> 01:19:42,560
그래서 우리가

2128
01:19:42,560 --> 01:19:44,800
시간적 두께

2129
01:19:44,800 --> 01:19:46,000
와

2130
01:19:46,000 --> 01:19:48,239
시간 의존성, 그리고

2131
01:19:48,239 --> 01:19:50,719
이와 같은 동적 모델에 대해 생각하는 방식과 같은 것입니다.

2132
01:19:50,719 --> 01:19:54,159
그러면 내 화면을 공유할 수 있습니다. 그렇습니다.

2133
01:19:54,159 --> 01:19:56,719


2134
01:19:56,719 --> 01:19:59,760
굉장합니다

2135
01:19:59,760 --> 01:20:02,080
예

2136
01:20:02,400 --> 01:20:05,280
이것은 몇 년 전의 한 신문에서 나온 그래프입니다

2137
01:20:05,280 --> 01:20:08,639
uh in frontiers

2138
01:20:08,639 --> 01:20:11,520
um 그것은 uh

2139
01:20:11,520 --> 01:20:13,440
깊은 시간적 모델이 요인

2140
01:20:13,440 --> 01:20:14,880
그래프나 무엇인가

2141
01:20:14,880 --> 01:20:17,360
를 검사한다고 생각합니다. 여기에 3계층 시스템이 있습니다. 제

2142
01:20:17,360 --> 01:20:19,679
말은 지금 세부사항에 대해 신경쓰지 않아도 된다는 뜻입니다

2143
01:20:19,679 --> 01:20:21,840
.  맨 위

2144
01:20:21,840 --> 01:20:24,800
레이어에는 기본적으로 하나의 섹션이 하나의

2145
01:20:24,800 --> 01:20:26,400
시간 단계

2146
01:20:26,400 --> 01:20:28,639
이고 맨 위 레이어의 해당 시간

2147
01:20:28,639 --> 01:20:29,600


2148
01:20:29,600 --> 01:20:30,639


2149
01:20:30,639 --> 01:20:33,520
단계에는 미들웨어에 두 개의 관찰 또는 두 개의 단계가 있습니다.

2150
01:20:33,520 --> 01:20:34,800


2151
01:20:34,800 --> 01:20:37,440


2152
01:20:37,440 --> 01:20:40,159
제 어

2153
01:20:40,159 --> 01:20:43,040
그래요. 그런 다음

2154
01:20:43,040 --> 01:20:44,880
중간 레이어 팁이 한 단계를 밟을 때마다 세 번째 레이어에 대해 다시 말

2155
01:20:44,880 --> 01:20:47,679
하겠습니다.

2156
01:20:47,679 --> 01:20:50,400
여기에 두 단계가 있으므로

2157
01:20:50,400 --> 01:20:52,560


2158
01:20:52,560 --> 01:20:55,440
각 레이어 오른쪽에 더 미세한 입도가 있으므로 빌드할 수 있습니다.

2159
01:20:55,440 --> 01:20:57,600
계층적

2160
01:20:57,600 --> 01:21:01,280
어 모델은 정말 그리고 어, 그래서 우리

2161
01:21:01,280 --> 01:21:04,480
는 또한 그렇게 하고 있습니다. 제 말은 또한 그렇습니다. 만약 당신

2162
01:21:04,480 --> 01:21:05,520
이

2163
01:21:05,520 --> 01:21:07,679
우리

2164
01:21:07,679 --> 01:21:10,080
웹사이트의 몇몇 논문을 보면 크리스 마티스의 계층적 가우스 필터에 관한 많은 아기들을 발견할 것입니다.

2165
01:21:10,080 --> 01:21:12,400


2166
01:21:12,400 --> 01:21:15,120


2167
01:21:15,120 --> 01:21:16,239
in

2168
01:21:16,239 --> 01:21:19,040
뿐만 아니라 음 내

2169
01:21:19,040 --> 01:21:20,719
말은 당신이 능동적인 영향을 미치기 위해 할 수도 있다는 것을 의미합니다.

2170
01:21:20,719 --> 01:21:23,280
어 그리고

2171
01:21:23,280 --> 01:21:24,159
다음

2172
01:21:24,159 --> 01:21:26,960
과 같이 보일 것입니다 어

2173
01:21:26,960 --> 01:21:30,000
thomas pyre 또한 그의 논문 중 일부에서 이와 같은 그래프를

2174
01:21:30,000 --> 01:21:32,960


2175
01:21:33,760 --> 01:21:35,840
매우 흥미롭게 볼 수 있으며 우리는 같은 것을 많이 봅니다.

2176
01:21:35,840 --> 01:21:38,239


2177
01:21:38,239 --> 01:21:39,440


2178
01:21:39,440 --> 01:21:41,040
우리가 할 수 있는 것과 같은 g d b와 같은 변수는 일종의

2179
01:21:41,040 --> 01:21:43,520
능동 추론의 표현입니다. 그래서

2180
01:21:43,520 --> 01:21:44,960
예

2181
01:21:44,960 --> 01:21:46,800
이것도 일종의 되돌아가는 것 같습니다. 저는

2182
01:21:46,800 --> 01:21:49,520
이전 프론티어 논문으로 생각

2183
01:21:49,520 --> 01:21:52,000
합니다. 큰 동등성

2184
01:21:52,000 --> 01:21:55,679
또는 forney factor로의 완벽한 매핑과 같은 종류는 무엇입니까?

2185
01:21:55,679 --> 01:21:57,440


2186
01:21:57,440 --> 01:21:59,120
그래프

2187
01:21:59,120 --> 01:22:01,040
는 아마도 이것에

2188
01:22:01,040 --> 01:22:03,120


2189
01:22:03,120 --> 01:22:05,520
대해 거의 핫 스왑될

2190
01:22:05,520 --> 01:22:07,760
수 있는 응용 프로그램의 일부 영역이 있기 때문에 아마도

2191
01:22:07,760 --> 01:22:09,679


2192
01:22:09,679 --> 01:22:12,480
일반적으로 베이지안 그래프와

2193
01:22:12,480 --> 01:22:14,480
요인 그래프 대

2194
01:22:14,480 --> 01:22:17,599
해당 수준의 다른 주제와의 동등성

2195
01:22:21,120 --> 01:22:23,520
은 외국 스타일의 벡터 그래프

2196
01:22:23,520 --> 01:22:26,320
또는  이분 그래프 또는 베이징 네트워크

2197
01:22:26,320 --> 01:22:27,920
그것들은 실제로 다르지 않습니다.

2198
01:22:27,920 --> 01:22:29,760


2199
01:22:29,760 --> 01:22:31,840
그것들은 단지

2200
01:22:31,840 --> 01:22:34,159
인수분해된 모델의 표현일 뿐이고

2201
01:22:34,159 --> 01:22:37,120
당신이 표현하는 방식은 당신이 해당 모델에

2202
01:22:37,120 --> 01:22:39,520
대해 생각하는 방식에 영향을 미칠 수

2203
01:22:39,520 --> 01:22:41,440


2204
01:22:41,440 --> 01:22:43,280
있기 때문에 사용할 수 있습니다. 예를 들어 다음을 선택하는 경우  4-설치

2205
01:22:43,280 --> 01:22:45,199
효과적인 그래프 표현 이것은

2206
01:22:45,199 --> 01:22:47,120
신호 처리에 매우 적합합니다. 왜냐하면

2207
01:22:47,120 --> 01:22:49,120
이러한 메시지를

2208
01:22:49,120 --> 01:22:51,520
그래프를 통해 흐르는 신호로 볼 수 있기

2209
01:22:51,520 --> 01:22:53,840
때문에 엔지니어인 우리에게

2210
01:22:53,840 --> 01:22:57,679
이것은 베이지안 네트워크에서 매우 직관적인 표현

2211
01:22:57,679 --> 01:23:00,880
이며

2212
01:23:00,880 --> 01:23:02,880
모델 표현 자체에 조금 더 가깝습니다.

2213
01:23:02,880 --> 01:23:05,199


2214
01:23:05,199 --> 01:23:06,719
가변 메모만 있고 그것들

2215
01:23:06,719 --> 01:23:08,320
이 어떻게 관련되어 있는지 볼 수 있다는 점에서 더 간결합니다.

2216
01:23:08,320 --> 01:23:10,239
모델 구조를

2217
01:23:10,239 --> 01:23:13,120
사용하면

2218
01:23:13,120 --> 01:23:16,000
이와 같은 모델에 대한 간략한 개요

2219
01:23:16,000 --> 01:23:17,120
를 갖는 것이 매우 좋을 수 있습니다. 예를 들어

2220
01:23:17,120 --> 01:23:19,120


2221
01:23:19,120 --> 01:23:21,120
변수 간의 관계를 um 사이에

2222
01:23:21,120 --> 01:23:22,960
추가 종류의

2223
01:23:22,960 --> 01:23:25,520
벡터 노드로 보여주는 이분 그래프

2224
01:23:25,520 --> 01:23:27,440
가 있습니다.

2225
01:23:27,440 --> 01:23:29,280
이것들이 어떻게 연결되는지에 대해 좀 더 세분화하고

2226
01:23:29,280 --> 01:23:31,120


2227
01:23:31,120 --> 01:23:32,719
이 변수들 사이의 관계가 무엇인지에 대해 잘 이야기할 수 있는 여지를 제공

2228
01:23:32,719 --> 01:23:35,280


2229
01:23:35,280 --> 01:23:39,440
하므로 결국 그들은 동일

2230
01:23:39,520 --> 01:23:41,760
합니다. 하나의 모델을 사용

2231
01:23:41,760 --> 01:23:45,760
하여 세 가지 다른 방식으로 표현할 수 있지만 어쩌면 훨씬 더 많을 수도

2232
01:23:46,159 --> 01:23:48,560
있지만 제 생각에는  그것은

2233
01:23:48,560 --> 01:23:49,920
당신이

2234
01:23:49,920 --> 01:23:52,320
생각하는 방식이나 이러한 모델에 대해 생각하는 방식에 영향을

2235
01:23:52,320 --> 01:23:54,559
미치

2236
01:23:55,840 --> 01:23:56,960


2237
01:23:56,960 --> 01:23:58,560
므로 일반적으로 논문을 작성할 때 나오는

2238
01:23:58,560 --> 01:24:00,239


2239
01:24:00,239 --> 01:24:01,679
그런 다음

2240
01:24:01,679 --> 01:24:03,520
실제로 내 아이디어를 가장 잘 표현하는 것이 무엇인지 생각해야 합니다.

2241
01:24:03,520 --> 01:24:04,639


2242
01:24:04,639 --> 01:24:06,239
때로는 예산 그래프에 관한

2243
01:24:06,239 --> 01:24:07,520
것이기도 합니다.  시각적 네트워크

2244
01:24:07,520 --> 01:24:10,159
때때로 그것은 설치 사진을 위한 것입니다

2245
01:24:10,159 --> 01:24:11,120
음

2246
01:24:11,120 --> 01:24:14,800
그것은 당신의 이야기에 달려 있습니다 예

2247
01:24:14,800 --> 01:24:16,320
바라건대

2248
01:24:16,320 --> 01:24:18,480
나는 우리가 시스템과 전체에 대해 생각할 때 내 경험을 의미하지만 찾을 수 있습니다.

2249
01:24:18,480 --> 01:24:21,120


2250
01:24:21,120 --> 01:24:23,040
방정식의 et of 방정식을 종이에서 읽

2251
01:24:23,040 --> 01:24:24,159


2252
01:24:24,159 --> 01:24:26,880
거나 기록하면 음,

2253
01:24:26,880 --> 01:24:28,880
저에게 그림을 그리면 더 많은 통찰력을 얻을

2254
01:24:28,880 --> 01:24:31,280
수 있습니다. 그래프를

2255
01:24:31,280 --> 01:24:32,480
그리고

2256
01:24:32,480 --> 01:24:33,760
x

2257
01:24:33,760 --> 01:24:36,000
가 있으면 더 많은 통찰력을 얻을 수 있습니다. 그래프 사이에 정확한 대응이 있어야 합니다.

2258
01:24:36,000 --> 01:24:37,920


2259
01:24:37,920 --> 01:24:40,480
그리고 방정식과 매우

2260
01:24:40,480 --> 01:24:42,960
자주 그래프를 그린 다음

2261
01:24:42,960 --> 01:24:45,040
방정식을 기록하면 해당하는

2262
01:24:45,040 --> 01:24:47,360
x축이 없으므로

2263
01:24:47,360 --> 01:24:50,000
기본적으로

2264
01:24:50,000 --> 01:24:52,000
정확한 대응이 있어야 함

2265
01:24:52,000 --> 01:24:53,600
을 알 수 있으며 기본적으로 자주 발견하게 됩니다.

2266
01:24:53,600 --> 01:24:56,239
방정식이나 그래프에 오류가

2267
01:24:56,239 --> 01:24:57,920


2268
01:24:57,920 --> 01:25:00,000
있지만

2269
01:25:00,000 --> 01:25:03,600
최종 목표와 같은 최종 목표

2270
01:25:03,600 --> 01:25:07,120
는 커뮤니티에서 도구 상자를

2271
01:25:07,120 --> 01:25:09,199


2272
01:25:09,199 --> 01:25:12,639


2273
01:25:12,639 --> 01:25:13,679


2274
01:25:13,679 --> 01:25:15,520
만드는 것입니다.

2275
01:25:15,520 --> 01:25:18,000
simulink 또는 labview와 같은 것은 확실하지 않습니다.

2276
01:25:18,000 --> 01:25:20,080
사람들이 그것에 대해 잘 알고 있는지 확실하지

2277
01:25:20,080 --> 01:25:21,280
않지만 음

2278
01:25:21,280 --> 01:25:23,120
이것들은

2279
01:25:23,120 --> 01:25:26,080
실제로 그래픽으로 정의

2280
01:25:26,080 --> 01:25:27,920
하고 싶은 그래픽 모델이며 메모와 드라가 있는 팔레트를 갖고 싶어합니다.

2281
01:25:27,920 --> 01:25:29,679


2282
01:25:29,679 --> 01:25:32,320
w 귀하의 그래프와 이것이 내 모델이라고

2283
01:25:32,320 --> 01:25:34,639
말하고 이제 실행

2284
01:25:34,639 --> 01:25:36,159
하십시오. 추론이 루트 종속성 아래에 있다는 추론에 대해 걱정하고 싶지 않습니다.

2285
01:25:36,159 --> 01:25:37,840


2286
01:25:37,840 --> 01:25:39,600
전달

2287
01:25:39,600 --> 01:25:40,880


2288
01:25:40,880 --> 01:25:43,199
은 도구 상자의 디자이너가 수행

2289
01:25:43,199 --> 01:25:46,080
해야 하지만 그래픽 구조에 대해 생각해야 합니다.

2290
01:25:46,080 --> 01:25:49,360
그게 어

2291
01:25:49,360 --> 01:25:52,880
그리고 이것이고

2292
01:25:52,880 --> 01:25:54,880
마우스로 컴퓨터의 마이크

2293
01:25:54,880 --> 01:25:57,440
나 카메라에 연결

2294
01:25:57,440 --> 01:25:59,920
하고 아마도 어, 어

2295
01:25:59,920 --> 01:26:01,760
, 도구 상자에 로봇용 커넥터도 있다는 것을 알고 있을

2296
01:26:01,760 --> 01:26:05,280


2297
01:26:05,280 --> 01:26:07,600
것입니다. 그러면 바로 가야 합니다. 그것이

2298
01:26:07,600 --> 01:26:09,199
밥 로스가 될 것입니다  그래프

2299
01:26:09,199 --> 01:26:11,519


2300
01:26:11,920 --> 01:26:13,520
를 디자인하려는 방식이

2301
01:26:13,520 --> 01:26:15,280
맞다고 생각합니다. 뇌

2302
01:26:15,280 --> 01:26:17,840
와 최소한 뇌의 생성 모델

2303
01:26:17,840 --> 01:26:19,679
을 그리고 그냥

2304
01:26:19,679 --> 01:26:21,600
놔두고 추론이 어떻게 일어나는지 걱정하지 마세요. 보기에

2305
01:26:21,600 --> 01:26:24,239


2306
01:26:24,480 --> 01:26:26,719
대해 방금 말한 것을

2307
01:26:26,719 --> 01:26:29,199
방정식을

2308
01:26:29,199 --> 01:26:31,520
푼 다음 펜과 종이에서

2309
01:26:31,520 --> 01:26:33,280
프로그래밍 언어로, 그래픽으로

2310
01:26:33,280 --> 01:26:35,440
표현한 다음

2311
01:26:35,440 --> 01:26:37,120
교차 확인하는 방식으로

2312
01:26:37,120 --> 01:26:38,800
언어를 역번역

2313
01:26:38,800 --> 01:26:41,120
할 때와 같이  두 단어가 서로 다시 매핑되는 위치를 잠급니다.

2314
01:26:41,120 --> 01:26:42,800


2315
01:26:42,800 --> 01:26:44,239
지도를 만들었다는 것을 알지만 이

2316
01:26:44,239 --> 01:26:46,719
무한 루프에 있는 경우 단어 공간에서 길을 잃습니다.

2317
01:26:46,719 --> 01:26:49,760
그래서 그런 섹터를 가로질러 이동할 때

2318
01:26:49,760 --> 01:26:52,639
또는  컴퓨터

2319
01:26:52,639 --> 01:26:53,520
에서

2320
01:26:53,520 --> 01:26:55,440
분석적 시뮬레이션을 사용하여 모달리티 전반

2321
01:26:55,440 --> 01:26:57,840
에 걸쳐 그래픽

2322
01:26:57,840 --> 01:26:59,679
은 추론의 산물

2323
01:26:59,679 --> 01:27:02,159
로 볼 수 있는

2324
01:27:02,159 --> 01:27:03,440
지식

2325
01:27:03,440 --> 01:27:05,840
제품

2326
01:27:05,840 --> 01:27:07,520
과 최종 작업

2327
01:27:07,520 --> 01:27:10,239
으로 볼 수 있는 작업을 포함합니다.

2328
01:27:10,239 --> 01:27:12,719
이는 동적 프로세스를 훈련하는 것과 유사한 오류입니다.  스냅샷

2329
01:27:12,719 --> 01:27:13,920
을 찍은 다음 실시간으로 작동할 것으로 예상

2330
01:27:13,920 --> 01:27:15,840


2331
01:27:15,840 --> 01:27:17,760


2332
01:27:17,760 --> 01:27:20,159
하여 지식 생산에 실시간 흐름을 포함시키는 것과 같습니다. 예

2333
01:27:20,159 --> 01:27:24,000
예 예 우리는 중요합니다 예 예

2334
01:27:24,000 --> 01:27:25,679
음 예

2335
01:27:25,679 --> 01:27:28,080
우리는 이 물건을 설계하는 동안 활성 보험을 구현하고 있습니다

2336
01:27:28,080 --> 01:27:30,800
맞아요 예

2337
01:27:30,800 --> 01:27:34,400
예 하나의 일반적인 질문은

2338
01:27:34,400 --> 01:27:36,239
인수분해에 관한

2339
01:27:36,239 --> 01:27:37,679


2340
01:27:37,679 --> 01:27:40,000
것이므로 인수분해는

2341
01:27:40,000 --> 01:27:41,920


2342
01:27:41,920 --> 01:27:44,880
직관으로 시작하여 잔차 또는

2343
01:27:44,880 --> 01:27:47,520
모델을 인수분해하는 모든 방법의 방법을 찾는 것입니다.

2344
01:27:47,520 --> 01:27:51,600
우리는 작동하는 것을 찾을 수

2345
01:27:53,440 --> 01:27:55,440
있습니까 예 두 가지 종류의 인수분해

2346
01:27:55,440 --> 01:27:57,440
가 있습니다 거기에 인수분해가 있습니다

2347
01:27:57,440 --> 01:27:59,440
생성 모델에서

2348
01:27:59,440 --> 01:28:02,560
오른쪽이 우리가 그리는 그래프

2349
01:28:02,560 --> 01:28:06,639
이고 그래서 제 말은 대부분의 사람들이

2350
01:28:06,639 --> 01:28:10,719
어 또는 가장 일반적인 모델이

2351
01:28:10,719 --> 01:28:13,440


2352
01:28:13,440 --> 01:28:16,239
바로 이 마르코프 모델입니다  과거에 일어난 모든 일

2353
01:28:16,239 --> 01:28:18,880
을 요약하는 현재 상태를 유지하는

2354
01:28:18,880 --> 01:28:20,639
것입니다.

2355
01:28:20,639 --> 01:28:22,239


2356
01:28:22,239 --> 01:28:25,120
어 그리고 그 현재 상태를 사용하여

2357
01:28:25,120 --> 01:28:27,440
기본적으로 과거를 요약하면 과거

2358
01:28:27,440 --> 01:28:29,760
에 대한 모든 정보가

2359
01:28:29,760 --> 01:28:30,960
있으므로 기억할 필요가 없습니다.

2360
01:28:30,960 --> 01:28:33,440
과거 당신은 당신의 상태를 기억

2361
01:28:33,440 --> 01:28:34,560


2362
01:28:34,560 --> 01:28:36,159
하고 그것과 함께 새로운

2363
01:28:36,159 --> 01:28:39,040
관찰을 했습니다 당신은 정보를 결합

2364
01:28:39,040 --> 01:28:40,560
하여 새로운 상태를 만드는

2365
01:28:40,560 --> 01:28:42,639
등 거기에 숨겨진 마르코프

2366
01:28:42,639 --> 01:28:44,760
모델

2367
01:28:44,760 --> 01:28:47,600
palmdps 이 모든 모델은 동일한

2368
01:28:47,600 --> 01:28:49,199
구조를 가지고 있습니다 이

2369
01:28:49,199 --> 01:28:51,360
미세 구조는 생성을 위한 것입니다

2370
01:28:51,360 --> 01:28:53,440
이러한 동적 시스템의 모델을 사용

2371
01:28:53,440 --> 01:28:54,560


2372
01:28:54,560 --> 01:28:56,400
하면 두 번째 질문이 있습니다.

2373
01:28:56,400 --> 01:28:58,719
이제 추론을 수행하면

2374
01:28:58,719 --> 01:29:02,400
음, 음, 예,

2375
01:29:02,400 --> 01:29:04,880
우리가 평균 필드 엉덩이라고 부르는 것이 종종 있습니다.  가변적

2376
01:29:04,880 --> 01:29:07,040
사후에 대한 추천이 있지만

2377
01:29:07,040 --> 01:29:08,639


2378
01:29:08,639 --> 01:29:11,920
구조화된 그린 필드에 변형도

2379
01:29:11,920 --> 01:29:14,239
있으므로

2380
01:29:14,239 --> 01:29:17,520
사후

2381
01:29:17,520 --> 01:29:19,920
구조를 훨씬 더 구조화할지 또는 생성 모델

2382
01:29:19,920 --> 01:29:22,880
보다 훨씬 더 인수분해할지 여부를 결정할 수

2383
01:29:22,880 --> 01:29:24,480


2384
01:29:24,480 --> 01:29:27,040
있지만 결국에는

2385
01:29:27,040 --> 01:29:29,120
그렇습니다.  제안서

2386
01:29:29,120 --> 01:29:30,159
어

2387
01:29:30,159 --> 01:29:33,120


2388
01:29:33,120 --> 01:29:35,040
그냥 실행하고 다른 제안서가 있으면 실행하면

2389
01:29:35,040 --> 01:29:38,000
자유 에너지가 가장 낮은 제안서가 이기는

2390
01:29:38,000 --> 01:29:40,800
것이 맞습니다. 문제

2391
01:29:40,800 --> 01:29:44,000
는 해당 프로세스를 자동화

2392
01:29:44,000 --> 01:29:45,840


2393
01:29:45,840 --> 01:29:47,600
하는 것입니다. 열악한 구조에서

2394
01:29:47,600 --> 01:29:49,920
더 나은 구조로 이동  전체 프로세스

2395
01:29:49,920 --> 01:29:52,159


2396
01:29:52,159 --> 01:29:55,840
를 중지하지 않고 실시간으로 메시지를 전달하는

2397
01:29:55,840 --> 01:29:57,600


2398
01:29:57,600 --> 01:29:59,040
것만으로 최소화에 실패하여 구조가

2399
01:29:59,040 --> 01:30:01,520
올바르게 계속 올바르게 이동

2400
01:30:01,520 --> 01:30:04,080


2401
01:30:04,080 --> 01:30:06,239
해야 합니다. 구조 적응만 상태 추정과 같아야 합니다.

2402
01:30:06,239 --> 01:30:08,560
시간이 지남에 따라 계속 이동합니다.

2403
01:30:08,560 --> 01:30:10,719


2404
01:30:10,719 --> 01:30:12,719


2405
01:30:12,719 --> 01:30:15,120


2406
01:30:15,360 --> 01:30:19,120
꿈을 꾸는 무대와 같은

2407
01:30:19,120 --> 01:30:22,480
것이지만 원칙적인 시간은

2408
01:30:22,480 --> 01:30:24,239
흐르고 그것이 도전이고 우리는 그것을

2409
01:30:24,239 --> 01:30:26,560
알지 못합니다.  우리 공장 수업이지만 예

2410
01:30:26,560 --> 01:30:27,840
우리

2411
01:30:27,840 --> 01:30:28,719


2412
01:30:28,719 --> 01:30:31,280
는 현재 엔지니어처럼 그것을 조사하고 있는 한 명의 HD 학생이 있다는 것을 의미합니다. 제

2413
01:30:31,280 --> 01:30:32,840


2414
01:30:32,840 --> 01:30:36,560
생각에는 음

2415
01:30:36,560 --> 01:30:38,320
질문은 글쎄요.

2416
01:30:38,320 --> 01:30:40,400
초기 모델 제안으로 무엇을 시작합니까?

2417
01:30:40,400 --> 01:30:42,560


2418
01:30:42,560 --> 01:30:44,880
생성 모델의 인수분해

2419
01:30:44,880 --> 01:30:47,040
에 대해 모든 요소

2420
01:30:47,040 --> 01:30:49,440
는 사전 분포 또는 조건부 분포를 나타냅니다. 이것이 바로

2421
01:30:49,440 --> 01:30:50,960


2422
01:30:50,960 --> 01:30:53,440
모델을 구축하는 방법입니다.

2423
01:30:53,440 --> 01:30:55,040
어디서 시작

2424
01:30:55,040 --> 01:30:57,520


2425
01:30:57,520 --> 01:31:01,600
하고 세상

2426
01:31:01,600 --> 01:31:03,520
이 그런 의미에서 관찰을 생성한다고 믿는 방법으로 시작합니다.  환경

2427
01:31:03,520 --> 01:31:05,760
의 인과 구조가 무엇인지

2428
01:31:05,760 --> 01:31:07,760


2429
01:31:07,760 --> 01:31:10,159
생각하고 물리학이 어떻게 작동

2430
01:31:10,159 --> 01:31:13,040
하는지 또는

2431
01:31:13,040 --> 01:31:15,760
환경에서 상태가 어떻게 전환되는지

2432
01:31:15,760 --> 01:31:17,280
또는 적어도 이

2433
01:31:17,280 --> 01:31:19,040
전환을 믿는 방법에 대해 약간의 아이디어가 있을 수

2434
01:31:19,040 --> 01:31:20,080


2435
01:31:20,080 --> 01:31:22,159
있습니다.

2436
01:31:22,159 --> 01:31:24,960


2437
01:31:24,960 --> 01:31:27,120
예를 들어 제 강연에서 이 마이너스 1이라는 아주 거친 음표를 시도해 보겠습니다.

2438
01:31:27,120 --> 01:31:28,719


2439
01:31:28,719 --> 01:31:30,400
거기에 무엇을 넣고 싶은지 잘 모르겠

2440
01:31:30,400 --> 01:31:33,440
기 때문에 여기에서 시도해 보겠습니다.  o 뭔가를 넣어 봅시다 뭔가를 시도

2441
01:31:33,440 --> 01:31:35,840
하고 그것이 어떻게 작동하는지 봅시다

2442
01:31:35,840 --> 01:31:39,199
세상이 어떻게 작동하는지 내가 믿는 방식입니다. 그것이

2443
01:31:39,520 --> 01:31:42,639
당신이 시작하고 잘 생각하기 시작하는 방법입니다.

2444
01:31:42,639 --> 01:31:44,639


2445
01:31:44,639 --> 01:31:46,639
나는 실제로 그것에 대해 조금 더 알고 있습니다.

2446
01:31:46,639 --> 01:31:48,960
모델

2447
01:31:48,960 --> 01:31:51,760
은 이 모델이 어떻게 작동하는지 제안

2448
01:31:51,760 --> 01:31:55,120
했고 예를 들어 이것을 마이너스 1로 변경할 수 있습니다. 예를

2449
01:31:55,120 --> 01:31:57,280
들어 물리학을 알고 있기 때문에 조금 더 복잡한 것으로 변경할 수 있습니다. 예를 들어

2450
01:31:57,280 --> 01:31:59,280


2451
01:31:59,280 --> 01:32:00,320


2452
01:32:00,320 --> 01:32:01,679


2453
01:32:01,679 --> 01:32:03,920
온도가 거리와 통합되는 방식을

2454
01:32:03,920 --> 01:32:06,960


2455
01:32:06,960 --> 01:32:08,560
알고 있습니다.  그게 당신이 두 번째 제안을 하는 방법

2456
01:32:08,560 --> 01:32:09,920


2457
01:32:09,920 --> 01:32:12,560
이고 항상 어에서 영감을 얻습니다.

2458
01:32:12,560 --> 01:32:14,320
당신

2459
01:32:14,320 --> 01:32:17,600
이 세계의 인과 구조가

2460
01:32:17,600 --> 01:32:19,440


2461
01:32:19,440 --> 01:32:21,040


2462
01:32:21,040 --> 01:32:22,560


2463
01:32:22,560 --> 01:32:25,280
당신의

2464
01:32:25,280 --> 01:32:27,040
환경

2465
01:32:27,040 --> 01:32:28,239
과

2466
01:32:28,239 --> 01:32:30,480
글쎄요 아마도 당신이 정말 훌륭

2467
01:32:30,480 --> 01:32:32,320
하다면 훌륭한 모델을 가지고 있다면 항상 개선할

2468
01:32:32,320 --> 01:32:34,480
수 있는 무언가를 찾을

2469
01:32:34,480 --> 01:32:35,920


2470
01:32:35,920 --> 01:32:39,600
수 있기 때문에 최신 기술을 향상시키는

2471
01:32:39,600 --> 01:32:41,120
무언가를 찾을 수 있을 것입니다.  그런 의미에서

2472
01:32:41,120 --> 01:32:42,880
더 낮은 자유 에너지 또는 더 나은 모델

2473
01:32:42,880 --> 01:32:44,960
성능을 제공하는 ng

2474
01:32:44,960 --> 01:32:46,400
음,

2475
01:32:46,400 --> 01:32:47,679


2476
01:32:47,679 --> 01:32:48,800


2477
01:32:48,800 --> 01:32:50,800
이러한 모델과 이러한 인수분해

2478
01:32:50,800 --> 01:32:51,760
및

2479
01:32:51,760 --> 01:32:54,960
이와 유사한 것을 계속 조정하고 조정할 수 있습니다.

2480
01:32:56,880 --> 01:32:58,000
예

2481
01:32:58,000 --> 01:32:59,360
자유 에너지

2482
01:32:59,360 --> 01:33:00,639
최소화

2483
01:33:00,639 --> 01:33:03,440
는 다른 모델의 순위를 매기는 방법으로 설명되었습니다.

2484
01:33:03,440 --> 01:33:05,280


2485
01:33:05,280 --> 01:33:06,880
이러한 여러 다른 전선에 대한 필수 요소

2486
01:33:06,880 --> 01:33:09,840
로서

2487
01:33:09,840 --> 01:33:11,920
자유 에너지 최소화가

2488
01:33:11,920 --> 01:33:13,199
정책

2489
01:33:13,199 --> 01:33:14,480


2490
01:33:14,480 --> 01:33:16,880
을 탄력적으로 만드는지 어떻게 알

2491
01:33:16,880 --> 01:33:18,800
수 있습니까? 로컬 최적화와 유사한 방식

2492
01:33:18,800 --> 01:33:20,639


2493
01:33:20,639 --> 01:33:22,560
이 더 큰 최적화 공간 어딘가에 갇혀

2494
01:33:22,560 --> 01:33:24,400


2495
01:33:24,400 --> 01:33:26,639


2496
01:33:26,639 --> 01:33:28,560


2497
01:33:28,560 --> 01:33:29,920
우리가 거기에 더 빨리 도착할 것처럼 시스템을 무너뜨리는 자유 에너지 최소화의 길 그냥

2498
01:33:29,920 --> 01:33:31,760
가속

2499
01:33:31,760 --> 01:33:32,880


2500
01:33:32,880 --> 01:33:35,120
하고 시스템의 일회성 오류가

2501
01:33:35,120 --> 01:33:38,000
있습니다.

2502
01:33:38,000 --> 01:33:40,639


2503
01:33:40,639 --> 01:33:43,120
어떻게 이렇게

2504
01:33:43,120 --> 01:33:44,639
근본적으로 다른

2505
01:33:44,639 --> 01:33:48,639
체스 전략이나 추진

2506
01:33:48,840 --> 01:33:50,639
방식을 평가할 수 있는지 분류할 수 있습니다. 결국

2507
01:33:50,639 --> 01:33:52,719
확률 이론일 뿐이고  확률은

2508
01:33:52,719 --> 01:33:55,360
또한 숫자에 불과

2509
01:33:55,360 --> 01:33:57,760
하며 에너지 종류

2510
01:33:57,760 --> 01:33:59,760


2511
01:33:59,760 --> 01:34:01,760


2512
01:34:01,760 --> 01:34:04,800
는 데이터를 관찰하는 모델에 따른 확률인 증거에 가깝습니다. 따라서

2513
01:34:04,800 --> 01:34:07,920
최상의 증거를 제공하는 모델을 만드는 경우 사용자

2514
01:34:07,920 --> 01:34:10,239
에 대한 좋은 설명이 됩니다.

2515
01:34:10,239 --> 01:34:12,480
데이터

2516
01:34:12,480 --> 01:34:15,040
그래서 결국

2517
01:34:15,040 --> 01:34:16,639
당신은

2518
01:34:16,639 --> 01:34:19,600
근사 확률 이론을

2519
01:34:19,600 --> 01:34:20,639
시도

2520
01:34:20,639 --> 01:34:22,080
하고 자유 에너지

2521
01:34:22,080 --> 01:34:25,360
는 당신의 증거에 구속되며 베이지안 추론

2522
01:34:25,360 --> 01:34:27,120


2523
01:34:27,120 --> 01:34:28,960


2524
01:34:28,960 --> 01:34:29,920


2525
01:34:29,920 --> 01:34:32,320
을 근사하기 위해 지불하는 대가를 말하는 이 사후 발산

2526
01:34:32,320 --> 01:34:35,120
항도 고려합니다.

2527
01:34:35,120 --> 01:34:37,600
그것의 두 부분에는

2528
01:34:37,600 --> 01:34:40,320
음 모델 증거

2529
01:34:40,320 --> 01:34:43,119
부분이 있고 후방 발산 부분

2530
01:34:43,119 --> 01:34:47,119
이 있고 둘 다 하나의 역할

2531
01:34:47,119 --> 01:34:48,400


2532
01:34:48,400 --> 01:34:51,040


2533
01:34:51,040 --> 01:34:52,320


2534
01:34:52,320 --> 01:34:53,040


2535
01:34:53,040 --> 01:34:54,960
을 합니다.

2536
01:34:54,960 --> 01:34:57,040


2537
01:34:57,040 --> 01:34:59,840
놀라움 또는 음수

2538
01:34:59,840 --> 01:35:02,239
로그 모달 증거에 대한 숫자

2539
01:35:02,239 --> 01:35:03,600
를 얻을 수 있으며

2540
01:35:03,600 --> 01:35:05,040


2541
01:35:05,040 --> 01:35:07,040
이것이 가격과 정보라고 잘 말하는 스테레오 발산의 다른 부분이 있습니다.

2542
01:35:07,040 --> 01:35:08,800
n 당신이 이 근사치를 만드는 데 비용을 지불한다는

2543
01:35:08,800 --> 01:35:11,119


2544
01:35:11,119 --> 01:35:12,239


2545
01:35:12,239 --> 01:35:13,840
것은 당신이 um을 평가하는 혼란스러운 버전일 뿐이라는 숫자를 붙일 수 있다는 것입니다.

2546
01:35:13,840 --> 01:35:15,600


2547
01:35:15,600 --> 01:35:17,920
그리고 당신은 그 두 개를 더하고 당신

2548
01:35:17,920 --> 01:35:20,239
은 숫자를 얻습니다.

2549
01:35:20,239 --> 01:35:22,559


2550
01:35:22,880 --> 01:35:24,880


2551
01:35:24,880 --> 01:35:26,639


2552
01:35:26,639 --> 01:35:29,199


2553
01:35:29,199 --> 01:35:31,840
품질 측면에서 모든

2554
01:35:31,840 --> 01:35:33,520


2555
01:35:33,520 --> 01:35:36,080
것은 모델

2556
01:35:36,080 --> 01:35:39,600
이 관찰을 올바르게 예측하거나 평가하는 것과는 다른 것에 관심을 가질 수 있습니다.

2557
01:35:39,600 --> 01:35:42,480
그리고 다른 것에 관심이

2558
01:35:42,480 --> 01:35:43,440


2559
01:35:43,440 --> 01:35:45,440
있다면 음,

2560
01:35:45,440 --> 01:35:47,280
네, 다른

2561
01:35:47,280 --> 01:35:48,400
숫자를 사용할 수 있습니다. 하지만

2562
01:35:48,400 --> 01:35:52,800
우리의 의미에서 음  우리의

2563
01:35:52,800 --> 01:35:54,000
어 우리의 작업

2564
01:35:54,000 --> 01:35:56,400
예 우리는 일종의

2565
01:35:56,400 --> 01:35:57,440
어

2566
01:35:57,440 --> 01:35:59,199
우리는 품질의 베이지안 측정을 원합니다

2567
01:35:59,199 --> 01:36:00,400


2568
01:36:00,400 --> 01:36:01,199
예

2569
01:36:01,199 --> 01:36:02,400
그게 정말로 당신의 질문에 대답하는지

2570
01:36:02,400 --> 01:36:04,480
모르겠지만 그것은 여전히 좋은 질문입  

2571
01:36:04,480 --> 01:36:06,159
다 음 그것은  

2572
01:36:06,159 --> 01:36:08,239
종의  자유 에너지 또는

2573
01:36:08,239 --> 01:36:10,400
당신이 얻는 그 숫자는 충분한

2574
01:36:10,400 --> 01:36:11,360
권리

2575
01:36:11,360 --> 01:36:13,920
입니다. 그것은 이것의 배후에 있는 것입니다.

2576
01:36:13,920 --> 01:36:16,159
확률 이론은 그렇다고 말합니다.

2577
01:36:16,159 --> 01:36:17,600


2578
01:36:17,600 --> 01:36:19,520


2579
01:36:19,520 --> 01:36:21,840
얼마나 많은 사람들이 살아남기 전에 생존

2580
01:36:21,840 --> 01:36:23,520


2581
01:36:23,520 --> 01:36:27,199
했는지 얼마나 많은 실수를 했는지 uh

2582
01:36:27,199 --> 01:36:29,840
당신은 무언가로부터 돈을 벌고

2583
01:36:29,840 --> 01:36:31,600
그것을 잘 신경 쓴다면 그것을

2584
01:36:31,600 --> 01:36:33,520
성과 지표로 사용해야 합니다 제

2585
01:36:33,520 --> 01:36:36,880
생각이 맞다 제 생각은 그것이

2586
01:36:36,880 --> 01:36:39,360
uh 당연히 에너지가 가지고 있다는 뜻입니다

2587
01:36:39,360 --> 01:36:42,639


2588
01:36:42,639 --> 01:36:45,920
복잡성에서 정확도를 뺀

2589
01:36:45,920 --> 01:36:48,880
것과 놀라움에서 빼기 어

2590
01:36:48,880 --> 01:36:51,520
빼기 kl 발산

2591
01:36:51,520 --> 01:36:54,239
음에서 많은 분해가 있습니다.

2592
01:36:54,239 --> 01:36:54,960


2593
01:36:54,960 --> 01:36:56,560
하지만 제가 질문을 올바르게 해석했는지 확실하지

2594
01:36:56,560 --> 01:36:58,320
않지만 당신이

2595
01:36:58,320 --> 01:37:00,560
그렇게 말하면 실제로 잘한다는 것을 어떻게 알 수 있습니까?

2596
01:37:00,560 --> 01:37:02,880
현장에서

2597
01:37:02,880 --> 01:37:05,679
당신은 옳지 않습니다

2598
01:37:05,679 --> 01:37:07,040


2599
01:37:07,040 --> 01:37:10,320
음 그리고

2600
01:37:10,320 --> 01:37:12,800
당신이 말할 수있는 유일한 것은

2601
01:37:12,800 --> 01:37:15,119
시스템이하는 일을 의미합니다 시스템이

2602
01:37:15,119 --> 01:37:17,280
자유 에너지를 최소화하는 구성을 찾을

2603
01:37:17,280 --> 01:37:19,280
것이지만 당신이 무엇을 모르는지 모릅니다

2604
01:37:19,280 --> 01:37:21,040


2605
01:37:21,040 --> 01:37:23,119
우리가 그 모델을 시뮬레이션하지 않았다면 더 잘할 수 있는 또 다른 모델이 있는지 알 수 없습니다.

2606
01:37:23,119 --> 01:37:26,000
그러면 우리는 알지 못합니다.

2607
01:37:26,000 --> 01:37:27,600


2608
01:37:27,600 --> 01:37:29,679
거기에 있는 유일한 학습 기회

2609
01:37:29,679 --> 01:37:30,639


2610
01:37:30,639 --> 01:37:34,480
는 오류를 생성하는 것이므로

2611
01:37:34,480 --> 01:37:37,119
모델을 실제로 개선할 수 있는 유일한 방법입니다.

2612
01:37:37,119 --> 01:37:38,480
실제로

2613
01:37:38,480 --> 01:37:42,000
안녕이다  실제로 음 작동하지 않는 상황을 가정해 보겠습니다.

2614
01:37:42,000 --> 01:37:43,520


2615
01:37:43,520 --> 01:37:45,280
그러면 매개변수를 조정해야

2616
01:37:45,280 --> 01:37:47,280


2617
01:37:47,280 --> 01:37:49,520
하고 시간이 지남에 따라 더욱 더

2618
01:37:49,520 --> 01:37:50,800
구조화해야 하므로

2619
01:37:50,800 --> 01:37:52,239


2620
01:37:52,239 --> 01:37:53,920
좋은 시스템을 구축하는 것이 프로세스라는 뜻입니다.

2621
01:37:53,920 --> 01:37:55,520


2622
01:37:55,520 --> 01:37:57,679


2623
01:37:57,679 --> 01:38:00,000


2624
01:38:00,000 --> 01:38:01,600


2625
01:38:01,600 --> 01:38:02,400


2626
01:38:02,400 --> 01:38:04,400
완전히 제대로 작동하는 시스템을 구축하는 경우 매우 운이

2627
01:38:04,400 --> 01:38:06,159


2628
01:38:06,159 --> 01:38:07,280
좋아야

2629
01:38:07,280 --> 01:38:09,040
합니다. 어,

2630
01:38:09,040 --> 01:38:11,119
이 궤도 사이의 활성

2631
01:38:11,119 --> 01:38:13,600
영향이 설명하는

2632
01:38:13,600 --> 01:38:15,520
것은 더 나은

2633
01:38:15,520 --> 01:38:18,000
시스템을 향한 과정이지만 그렇지

2634
01:38:18,000 --> 01:38:19,440
않은 시스템을 설명

2635
01:38:19,440 --> 01:38:21,600
하지 않는 것은 아닙니다.  실수

2636
01:38:21,600 --> 01:38:23,840
는 실수를 배우기 위해 실수가 필요

2637
01:38:23,840 --> 01:38:27,040
하고 프로세스를 설명하는

2638
01:38:27,040 --> 01:38:30,000
멋진 요점

2639
01:38:30,000 --> 01:38:32,080
입니다. 테스트에서 100점을 받는 것과 같은 운영 통찰력은 최악의

2640
01:38:32,080 --> 01:38:35,119


2641
01:38:35,119 --> 01:38:38,159
경우 정보보다 훨씬 적습니다.

2642
01:38:38,159 --> 01:38:40,400


2643
01:38:40,400 --> 01:38:43,280
잘못된 길로 내려가서 음,

2644
01:38:43,280 --> 01:38:45,360
식료품

2645
01:38:45,360 --> 01:38:46,960
점처럼 우리

2646
01:38:46,960 --> 01:38:49,520
가 하나의 척도에 따라 다른 물건의 순위를 매기는

2647
01:38:49,520 --> 01:38:51,600
것이 아니라 실제로 찾기 위한 균형 전략과 같다는 것을 상기시켰습니다

2648
01:38:51,600 --> 01:38:53,280


2649
01:38:53,280 --> 01:38:54,080


2650
01:38:54,080 --> 01:38:55,760
기본 설정이 바로 여기에서

2651
01:38:55,760 --> 01:38:56,639


2652
01:38:56,639 --> 01:38:58,320
인수분해 및 평균 필드와 같은 모든 가정이 있으며

2653
01:38:58,320 --> 01:39:00,000
매번 최상의 개체를 제공한다는 보장이 없으며

2654
01:39:00,000 --> 01:39:02,400


2655
01:39:02,400 --> 01:39:04,560
현실 세계의 확률성과

2656
01:39:04,560 --> 01:39:06,080
식료품점이

2657
01:39:06,080 --> 01:39:08,639
끝이 아닌 것처럼 변화하는 능력이 여전히 존재합니다.

2658
01:39:08,639 --> 01:39:10,000
이야기의 사실은 반응 그래프와 생물학적 시스템의 기능

2659
01:39:10,000 --> 01:39:12,880
중 일부를 포함하는 프로세스의 연습일 뿐입니다.

2660
01:39:12,880 --> 01:39:14,560


2661
01:39:14,560 --> 01:39:17,360


2662
01:39:17,360 --> 01:39:20,080


2663
01:39:20,080 --> 01:39:22,960
맞습니다. 음 음, 최종

2664
01:39:22,960 --> 01:39:24,840
의견이 있으신가요? 이것은 정말로 이것에

2665
01:39:24,840 --> 01:39:27,520
대해 배울 수 있는 가장 멋진 시간 중

2666
01:39:27,520 --> 01:39:28,800
하나였습니다.

2667
01:39:28,800 --> 01:39:31,040


2668
01:39:31,040 --> 01:39:33,199
언제든지 참가자로 참여하거나 발표

2669
01:39:33,199 --> 01:39:35,360
할 수 있습니다. 최종 의견이 있으면

2670
01:39:35,360 --> 01:39:36,639
메모해 둘

2671
01:39:36,639 --> 01:39:38,080


2672
01:39:38,080 --> 01:39:41,199
수 있습니다. 여기에 오게 되어 정말 기뻤습니다.

2673
01:39:41,199 --> 01:39:43,600
새로운 것이 있으면

2674
01:39:43,600 --> 01:39:45,760
다시 오고 싶습니다.  여기에서 환상적인

2675
01:39:45,760 --> 01:39:49,520
환상적인 쇼라고 생각하거나

2676
01:39:49,520 --> 01:39:52,239
포럼 또는 제대로 명명된 무엇이든 보여

2677
01:39:52,239 --> 01:39:54,000
주지만 나는 정말 그것을 즐기고 우리

2678
01:39:54,000 --> 01:39:56,000
는 그 일부가 된 것을 정말로 즐겼습니다.

2679
01:39:56,000 --> 01:39:58,320
어 토론에 대해 대단히 감사합니다.

2680
01:39:58,320 --> 01:40:00,320
거기에 생각을위한 약간의 음식도

2681
01:40:00,320 --> 01:40:01,520
있습니다. 정말 멋진

2682
01:40:01,520 --> 01:40:03,679
좋은 질문입니다. 예를 제시 할 때마다 좋은 질문입니다.

2683
01:40:03,679 --> 01:40:05,840


2684
01:40:05,840 --> 01:40:06,639


2685
01:40:06,639 --> 01:40:11,320
다음 시간까지 안녕

