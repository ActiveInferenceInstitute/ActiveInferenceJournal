1
00:00:00,080 --> 00:00:02,639
一個信號處理小組

2
00:00:02,639 --> 00:00:04,400
，所以我設計了

3
00:00:04,400 --> 00:00:05,680
我的培訓，

4
00:00:05,680 --> 00:00:08,080
對不起，實際上我只是改變了一件事

5
00:00:08,080 --> 00:00:10,559
，你能不能重新開始，但是

6
00:00:10,559 --> 00:00:11,920
去吧，

7
00:00:11,920 --> 00:00:12,960
好吧，

8
00:00:12,960 --> 00:00:15,679
謝謝你的介紹，然後我的

9
00:00:15,679 --> 00:00:18,320
名字是 bertie fries，我是

10
00:00:18,320 --> 00:00:20,400
埃因霍溫

11
00:00:20,400 --> 00:00:21,920
科技大學的教授 在

12
00:00:21,920 --> 00:00:23,840
荷蘭，

13
00:00:23,840 --> 00:00:25,920
我將成為

14
00:00:25,920 --> 00:00:28,000


15
00:00:28,000 --> 00:00:30,480
信號處理組電氣工程系的一員，因此我們設計了

16
00:00:30,480 --> 00:00:33,600
信號處理算法，大約

17
00:00:33,600 --> 00:00:36,320
六七年前，我

18
00:00:36,320 --> 00:00:38,399
第一次閱讀了 carl fiston 的一篇論文，

19
00:00:38,399 --> 00:00:40,559
它被稱為粗略

20
00:00:40,559 --> 00:00:41,760
指南 大腦

21
00:00:41,760 --> 00:00:44,160
並讓我感到震驚，這

22
00:00:44,160 --> 00:00:46,399
對於信號處理來說可能非常棒，所以

23
00:00:46,399 --> 00:00:49,039
從那時起，我真的在努力與

24
00:00:49,039 --> 00:00:50,640
我實驗室的人合作

25
00:00:50,640 --> 00:00:53,360
，實現將

26
00:00:53,360 --> 00:00:56,559
設計的代理將自動化

27
00:00:56,559 --> 00:00:59,199
信號處理算法的設計過程，正如

28
00:00:59,199 --> 00:01:01,120
你所知，我們正在 通過消息傳遞來做到這一點

29
00:01:01,120 --> 00:01:02,960
，我們今天想談談這個，

30
00:01:02,960 --> 00:01:05,199


31
00:01:05,199 --> 00:01:06,799
嗯，

32
00:01:06,799 --> 00:01:10,400
泰森，嗯，我的名字是泰森，我是

33
00:01:10,400 --> 00:01:13,760
鳥實驗室的海報，我做了我的博士學位，也是一個

34
00:01:13,760 --> 00:01:15,280
積極的推論 關於如何自動化

35
00:01:15,280 --> 00:01:17,840
這些過程，呃，我們還

36
00:01:17,840 --> 00:01:20,080
與 michael cox 和

37
00:01:20,080 --> 00:01:22,000
實驗室的所有同事一起構建了名為 fornilab 的工具箱

38
00:01:22,000 --> 00:01:24,400
，我將與您交談並引導

39
00:01:24,400 --> 00:01:27,600
您了解我們如何將其應用到

40
00:01:27,600 --> 00:01:30,400
活動的基礎設施推理環境

41
00:01:30,400 --> 00:01:32,560
中 用它做一些很酷的事情

42
00:01:32,560 --> 00:01:35,920
，所以這是為了以後

43
00:01:37,439 --> 00:01:39,759
是的，大家好，所以我的名字是

44
00:01:39,759 --> 00:01:42,640
nitri bhagav，我是bias實驗室的博士候選人，

45
00:01:42,640 --> 00:01:46,000
也是大學的hue，是的，我的

46
00:01:46,000 --> 00:01:48,000
工作主要是關於我們希望的基於反應消息

47
00:01:48,000 --> 00:01:50,960
定價的貝葉斯推理

48
00:01:50,960 --> 00:01:52,960
也將有助於主動

49
00:01:52,960 --> 00:01:55,119
推理，但這也是為了

50
00:01:55,119 --> 00:01:56,960
以後我會

51
00:01:56,960 --> 00:01:57,920
在我的

52
00:01:57,920 --> 00:02:01,439
時間談論它是的，我的插槽

53
00:02:01,759 --> 00:02:04,640
很酷，謝謝你，

54
00:02:05,119 --> 00:02:07,520


55
00:02:07,520 --> 00:02:10,160
嗯，我應該嗯，然後做一些

56
00:02:10,160 --> 00:02:12,560
介紹，幾張幻燈片

57
00:02:12,560 --> 00:02:14,000
讓我們看看

58
00:02:14,000 --> 00:02:16,400
是的，好吧，

59
00:02:16,400 --> 00:02:18,640
讓我們看看 如果我可以分享我的

60
00:02:18,640 --> 00:02:20,000
幻燈片

61
00:02:20,000 --> 00:02:21,360


62
00:02:21,360 --> 00:02:23,040


63
00:02:23,040 --> 00:02:25,040


64
00:02:25,040 --> 00:02:25,840


65
00:02:25,840 --> 00:02:29,040


66
00:02:29,040 --> 00:02:31,120


67
00:02:31,120 --> 00:02:33,680


68
00:02:33,680 --> 00:02:34,560


69
00:02:34,560 --> 00:02:37,280


70
00:02:37,280 --> 00:02:39,680
是的 比利時邊境，

71
00:02:39,680 --> 00:02:41,840
距離德國也

72
00:02:41,840 --> 00:02:42,640


73
00:02:42,640 --> 00:02:44,959


74
00:02:44,959 --> 00:02:46,080


75
00:02:46,080 --> 00:02:48,400


76
00:02:48,400 --> 00:02:50,560


77
00:02:50,560 --> 00:02:53,599


78
00:02:53,599 --> 00:02:55,680


79
00:02:55,680 --> 00:02:57,519
不遠 技術方面

80
00:02:57,519 --> 00:03:00,319
這是

81
00:03:00,319 --> 00:03:02,840
經過五個小組的鳥瞰圖 這

82
00:03:02,840 --> 00:03:05,360
是我們校園

83
00:03:05,360 --> 00:03:07,760
的鳥瞰圖 呃所以

84
00:03:07,760 --> 00:03:11,120
這裡讓我們看看我是否可以分享一個

85
00:03:11,120 --> 00:03:13,440


86
00:03:13,440 --> 00:03:14,959


87
00:03:14,959 --> 00:03:16,239


88
00:03:16,239 --> 00:03:18,560
指針 對於我們嘗試構建的貝葉斯

89
00:03:18,560 --> 00:03:20,480
智能自治系統，

90
00:03:20,480 --> 00:03:22,959


91
00:03:22,959 --> 00:03:25,519
我們大約有 3

92
00:03:25,519 --> 00:03:28,000
名工作人員，教職員工

93
00:03:28,000 --> 00:03:31,200
，目前有 6 名博士生 dmitry 是

94
00:03:31,200 --> 00:03:33,120
其中一名 pc 學生

95
00:03:33,120 --> 00:03:35,519
，如果有人對概率編程感興趣，我們有空缺職位

96
00:03:35,519 --> 00:03:37,760


97
00:03:37,760 --> 00:03:40,640
或 如何使

98
00:03:40,640 --> 00:03:43,200
主動推理起作用

99
00:03:43,200 --> 00:03:45,680
那麼我們要做什麼 這是這個呃論壇

100
00:03:45,680 --> 00:03:47,360
上的每個人都可能熟悉的圖片，這就是

101
00:03:47,360 --> 00:03:50,239


102
00:03:50,239 --> 00:03:52,560
呃，這是想要的 大腦中

103
00:03:52,560 --> 00:03:53,840
唯一真正發生的事情

104
00:03:53,840 --> 00:03:55,200


105
00:03:55,200 --> 00:03:57,680
是能量最小化或預期的自由

106
00:03:57,680 --> 00:03:59,120
能最小

107
00:03:59,120 --> 00:04:00,560
化來做所有事情

108
00:04:00,560 --> 00:04:03,360
，這對我們工程師來說是一個巨大的靈感，

109
00:04:03,360 --> 00:04:05,599
所以我們嘗試做的

110
00:04:05,599 --> 00:04:08,159
基本上就是我們想要把它放進去 在

111
00:04:08,159 --> 00:04:10,879
iPhone 或樹莓派上

112
00:04:10,879 --> 00:04:12,560
，讓機器人

113
00:04:12,560 --> 00:04:14,560
學習如何騎自行車，

114
00:04:14,560 --> 00:04:16,798
但這個框架用於工程目的的美妙之處

115
00:04:16,798 --> 00:04:19,839
在於，它幾乎

116
00:04:19,839 --> 00:04:22,479
是解決任何問題的一種解決方案，

117
00:04:22,479 --> 00:04:24,080
所以

118
00:04:24,080 --> 00:04:26,240
如果我們能做到，你可以教機器人

119
00:04:26,240 --> 00:04:27,440
如何 寫一個

120
00:04:27,440 --> 00:04:30,400
能量最小化也許我們也可以

121
00:04:30,400 --> 00:04:33,360
將它應用到虛擬現實中，並

122
00:04:33,360 --> 00:04:35,120
為助聽器甚至

123
00:04:35,120 --> 00:04:38,160
自動駕駛汽車設計算法。

124
00:04:38,240 --> 00:04:40,240


125
00:04:40,240 --> 00:04:41,280
我們說最大的

126
00:04:41,280 --> 00:04:43,360
承諾或

127
00:04:43,360 --> 00:04:45,840
工程的吸引力在於它

128
00:04:45,840 --> 00:04:48,240
只是你所擁有的始終相同的東西

129
00:04:48,240 --> 00:04:50,240
提出一個模型並最小化自由

130
00:04:50,240 --> 00:04:51,440
能，

131
00:04:51,440 --> 00:04:53,520
無論應用是什麼，但

132
00:04:53,520 --> 00:04:54,840
它非常吸引

133
00:04:54,840 --> 00:04:56,400


134
00:04:56,400 --> 00:04:59,919
工程的問題是這個

135
00:04:59,919 --> 00:05:02,000
能量

136
00:05:02,000 --> 00:05:04,560
泛函是觀察者的函數 vations 和

137
00:05:04,560 --> 00:05:07,600
觀察是流數據，

138
00:05:07,600 --> 00:05:08,800


139
00:05:08,800 --> 00:05:10,560
通常可能是

140
00:05:10,560 --> 00:05:13,199
每毫秒，所以它是一個高度時

141
00:05:13,199 --> 00:05:14,880
變的函數，

142
00:05:14,880 --> 00:05:17,360
並且潛在變量的數量

143
00:05:17,360 --> 00:05:19,919
假設潛在變量的空間

144
00:05:19,919 --> 00:05:23,039
通常非常高，所以我們有一個非常高

145
00:05:23,039 --> 00:05:24,639
維的時變函數

146
00:05:24,639 --> 00:05:25,759


147
00:05:25,759 --> 00:05:27,120


148
00:05:27,120 --> 00:05:29,280
我們想要最小化現在大腦

149
00:05:29,280 --> 00:05:31,360
非常擅長它，大腦有

150
00:05:31,360 --> 00:05:34,880
14 突觸的 10 次方

151
00:05:34,880 --> 00:05:38,720
1000 億歐元，

152
00:05:38,720 --> 00:05:41,039
但是一個正常的

153
00:05:41,039 --> 00:05:43,120
優化庫和模型或者

154
00:05:43,120 --> 00:05:45,360
python 不會削減它你不能

155
00:05:45,360 --> 00:05:47,840
最小化 matlab中千變量的時變函數

156
00:05:47,840 --> 00:05:49,919


157
00:05:49,919 --> 00:05:51,759
它不起作用

158
00:05:51,759 --> 00:05:55,520
所以我們需要一些非常激進的東西

159
00:05:55,520 --> 00:05:57,840
，我們所採用的想法也不是那麼

160
00:05:57,840 --> 00:06:00,800
激進，我們只是

161
00:06:00,800 --> 00:06:03,520
從大腦中獲得靈感，大腦是一個

162
00:06:03,520 --> 00:06:07,039
消息傳遞網絡，結果證明

163
00:06:07,039 --> 00:06:09,360


164
00:06:09,360 --> 00:06:12,240


165
00:06:12,240 --> 00:06:15,440
確切地說，在我自己的信號處理或信息理論領域中，

166
00:06:15,440 --> 00:06:17,840
這已經被形式化了，這裡有一篇

167
00:06:17,840 --> 00:06:18,880
由

168
00:06:18,880 --> 00:06:22,000
dave forney 於 2001 年撰寫的論文，

169
00:06:22,000 --> 00:06:24,560
關於圖形正常重新編碼 alizations 他

170
00:06:24,560 --> 00:06:27,039
稱之為正態因子圖，但為了

171
00:06:27,039 --> 00:06:29,840
紀念大衛福尼，今天

172
00:06:29,840 --> 00:06:31,360
它們被稱為福尼風格工廠

173
00:06:31,360 --> 00:06:32,319
圖

174
00:06:32,319 --> 00:06:33,440
，

175
00:06:33,440 --> 00:06:35,600
所以這就是我們正在談論的因子圖的起源，

176
00:06:35,600 --> 00:06:37,280


177
00:06:37,280 --> 00:06:39,120
幾年後，

178
00:06:39,120 --> 00:06:41,600
漢斯安德烈亞盧利格在

179
00:06:41,600 --> 00:06:43,039
大學 系列

180
00:06:43,039 --> 00:06:45,280
嗯，我已經

181
00:06:45,280 --> 00:06:47,840
在信號處理社區中流行了它，

182
00:06:47,840 --> 00:06:51,360
並且已經在 2007 年左右，你

183
00:06:51,360 --> 00:06:54,479
在他的論文中看到了這些，嗯，

184
00:06:54,479 --> 00:06:56,720
是的，這些典型的結構

185
00:06:56,720 --> 00:06:58,560
，我們稍後將展示這些是

186
00:06:58,560 --> 00:07:00,080
卡爾曼濾波器，

187
00:07:00,080 --> 00:07:01,919
這也是特里斯坦所說的

188
00:07:01,919 --> 00:07:04,880
這些類型 結構，所以

189
00:07:04,880 --> 00:07:06,960
嗯，這

190
00:07:06,960 --> 00:07:08,639
就是我們想要用我們的語言做的是將

191
00:07:08,639 --> 00:07:10,800


192
00:07:10,800 --> 00:07:13,039
來自神經科學界的啟發靈感的主動推理

193
00:07:13,039 --> 00:07:14,319


194
00:07:14,319 --> 00:07:16,639
結合起來，並將其與

195
00:07:16,639 --> 00:07:18,240
我們在信號處理和

196
00:07:18,240 --> 00:07:20,560
信息論中關於因子圖的知識結合起來，

197
00:07:20,560 --> 00:07:24,639
並使用這些工具來 為了實現這一點，

198
00:07:24,639 --> 00:07:26,560
所以今天

199
00:07:26,560 --> 00:07:29,199
我們有兩個演示文稿，一個是

200
00:07:29,199 --> 00:07:30,479
來自 uh 行的文本，內容是

201
00:07:30,479 --> 00:07:33,120
關於如何通過

202
00:07:33,120 --> 00:07:35,360
forney lab forney lab 進行消息傳遞 是

203
00:07:35,360 --> 00:07:36,800
我們寫的工具箱，

204
00:07:36,800 --> 00:07:38,160
嗯，你

205
00:07:38,160 --> 00:07:40,960
知道名字當然是指福尼，

206
00:07:40,960 --> 00:07:42,720
嗯，泰國人將展示如何

207
00:07:42,720 --> 00:07:45,120
使用這個工具箱進行積極的影響，

208
00:07:45,120 --> 00:07:47,280
然後我們也在開發一個新版本，

209
00:07:47,280 --> 00:07:49,680
它被稱為反應式消息傳遞，

210
00:07:49,680 --> 00:07:51,520
dmitry 是主要的 那裡的人和

211
00:07:51,520 --> 00:07:53,280


212
00:07:53,280 --> 00:07:55,280
dimitri 我也會談談這個

213
00:07:55,280 --> 00:07:57,360
，這就是我的全部，

214
00:07:57,360 --> 00:07:59,680
嗯，我會把它還給你，丹，或者，呃，你

215
00:07:59,680 --> 00:08:00,800


216
00:08:00,800 --> 00:08:02,960
可以繼續你的偏好是什麼，

217
00:08:02,960 --> 00:08:03,840
我將

218
00:08:03,840 --> 00:08:06,720
停止分享我的屏幕，

219
00:08:06,720 --> 00:08:08,400


220
00:08:08,400 --> 00:08:10,720
非常有趣，非常感謝 對於

221
00:08:10,720 --> 00:08:12,479
上下文，

222
00:08:12,479 --> 00:08:14,400
很高興聽到

223
00:08:14,400 --> 00:08:16,560
作者對

224
00:08:16,560 --> 00:08:18,879
您提出的一般性觀點以及如何

225
00:08:18,879 --> 00:08:20,960
以非常具體的方式應用它的任何反思，

226
00:08:20,960 --> 00:08:22,319
因為您提出了

227
00:08:22,319 --> 00:08:24,960
我們一直在談論的大量話題，例如

228
00:08:24,960 --> 00:08:27,440
一種統一方法的簡單性以及

229
00:08:27,440 --> 00:08:29,759
持續優化

230
00:08:29,759 --> 00:08:31,520
問題和從

231
00:08:31,520 --> 00:08:33,599
大自然中汲取靈感的挑戰如此偉大的事情我認為我們

232
00:08:33,599 --> 00:08:35,440
可以直接跳到

233
00:08:35,440 --> 00:08:36,880


234
00:08:36,880 --> 00:08:38,719
你們都喜歡的演示文稿中，

235
00:08:38,719 --> 00:08:40,640
然後我會去啊 d 並嘗試

236
00:08:40,640 --> 00:08:42,000
分享我的屏幕，

237
00:08:42,000 --> 00:08:44,880
看看

238
00:08:46,130 --> 00:08:49,189
是否可行

239
00:08:53,279 --> 00:08:56,160


240
00:08:56,160 --> 00:08:58,800


241
00:09:00,720 --> 00:09:02,080


242
00:09:02,080 --> 00:09:03,839


243
00:09:03,839 --> 00:09:05,600


244
00:09:05,600 --> 00:09:07,200
好了，我們走了，

245
00:09:07,200 --> 00:09:09,440
看起來不錯

246
00:09:09,440 --> 00:09:11,920
，我們一切都

247
00:09:11,920 --> 00:09:14,160
很好，再次感謝您邀請我們，您可以

248
00:09:14,160 --> 00:09:15,440
點擊離開嗎？我將做一些

249
00:09:15,440 --> 00:09:17,040
介紹，抱歉，它說您正在

250
00:09:17,040 --> 00:09:19,040
共享您的屏幕，您可以隱藏

251
00:09:19,040 --> 00:09:21,600
那個小小的 jitsi 東西，

252
00:09:21,600 --> 00:09:23,600
嗯，它已經消失了，

253
00:09:23,600 --> 00:09:25,040
謝謝

254
00:09:25,040 --> 00:09:26,880
嗯，是的，我將簡要

255
00:09:26,880 --> 00:09:28,560
介紹如何

256
00:09:28,560 --> 00:09:30,320
在主動推理的背景下使用 phony lab 進行消息傳遞，

257
00:09:30,320 --> 00:09:32,800


258
00:09:32,800 --> 00:09:34,480
並為這次演講提供一點動力

259
00:09:34,480 --> 00:09:37,040
，嗯，這是

260
00:09:37,040 --> 00:09:39,360
我們感興趣的情況 因此，

261
00:09:39,360 --> 00:09:42,000
我們有某種環境，

262
00:09:42,000 --> 00:09:43,600
並且我們有一個

263
00:09:43,600 --> 00:09:45,360
在該環境中運行的環境過程，

264
00:09:45,360 --> 00:09:47,680
我們希望開發一個具有

265
00:09:47,680 --> 00:09:49,760
某種目的或在該環境中執行某些有目的的

266
00:09:49,760 --> 00:09:53,120
任務

267
00:09:53,120 --> 00:09:54,959
的代理，並且允許代理髮送

268
00:09:54,959 --> 00:09:56,640
d 對環境的操作並

269
00:09:56,640 --> 00:09:58,880
操縱該環境，它將

270
00:09:58,880 --> 00:10:02,160
接收觀察結果

271
00:10:02,160 --> 00:10:04,320
，在環境過程中，有

272
00:10:04,320 --> 00:10:05,519
一些

273
00:10:05,519 --> 00:10:08,320
函數 rt 在那裡運行，它

274
00:10:08,320 --> 00:10:10,000
可能是我們運行的模擬，我們

275
00:10:10,000 --> 00:10:11,760
與之交互，或者它甚至可能是一個

276
00:10:11,760 --> 00:10:14,079
真實世界的過程 當然，我們

277
00:10:14,079 --> 00:10:16,640
並不真正知道 rt 在現實世界中運行的是什麼，

278
00:10:16,640 --> 00:10:19,120
並且不知何故，我們想

279
00:10:19,120 --> 00:10:21,680
構建一個在那個世界中做某事的代理，

280
00:10:21,680 --> 00:10:23,279


281
00:10:23,279 --> 00:10:26,640
那麼你從哪裡開始呢？

282
00:10:26,800 --> 00:10:29,360
這是 1970 年代 conant 和 ashby 的這篇論文

283
00:10:29,360 --> 00:10:31,040


284
00:10:31,040 --> 00:10:32,480
和 他們有一個有趣的定理

285
00:10:32,480 --> 00:10:33,600
，即係統的

286
00:10:33,600 --> 00:10:36,000
每個好的調節器都必須

287
00:10:36,000 --> 00:10:39,040
是該系統的模型，

288
00:10:39,040 --> 00:10:39,920
因此

289
00:10:39,920 --> 00:10:41,519
這實際上意味著，如果您想

290
00:10:41,519 --> 00:10:43,120
構建一個

291
00:10:43,120 --> 00:10:44,839
調節或

292
00:10:44,839 --> 00:10:47,839
操縱我們系統環境的代理，

293
00:10:47,839 --> 00:10:51,920
那麼我們必須對該系統進行建模，

294
00:10:51,920 --> 00:10:53,600
以便

295
00:10:53,600 --> 00:10:55,920
我們是一名工程師，我們從事

296
00:10:55,920 --> 00:10:57,839
構建模型的業務，

297
00:10:57,839 --> 00:11:00,880
準確地說是生成模型

298
00:11:00,880 --> 00:11:03,120
，這個模型代表了我們對

299
00:11:03,120 --> 00:11:04,160


300
00:11:04,160 --> 00:11:05,920
觀察結果如何

301
00:11:05,920 --> 00:11:09,839
從我們的操作中得出的

302
00:11:09,839 --> 00:11:12,160
信念 由函數 f 表示，它

303
00:11:12,160 --> 00:11:15,839
是 y 的函數 觀察值

304
00:11:15,839 --> 00:11:17,839
控制 u

305
00:11:17,839 --> 00:11:20,560
以及一些潛在狀態隱藏

306
00:11:20,560 --> 00:11:23,440
變量

307
00:11:23,440 --> 00:11:25,440
x 充當

308
00:11:25,440 --> 00:11:29,160
觀察值和控制之間的中間體

309
00:11:30,160 --> 00:11:31,760
現在

310
00:11:31,760 --> 00:11:34,000
向前推理是一回事，

311
00:11:34,000 --> 00:11:36,160
但最終我們要做的是觀察

312
00:11:36,160 --> 00:11:38,640
事物 然後提出將

313
00:11:38,640 --> 00:11:41,600
我們引導到有利狀態的控制

314
00:11:41,600 --> 00:11:42,959
，這就是

315
00:11:42,959 --> 00:11:44,880
自由能原理

316
00:11:44,880 --> 00:11:47,519
和主動推理的想法出現的地方，

317
00:11:47,519 --> 00:11:49,440
所以如果我們

318
00:11:49,440 --> 00:11:51,360
想看到這是假設，如果

319
00:11:51,360 --> 00:11:53,600
我們想建立一個有目的的代理，

320
00:11:53,600 --> 00:11:55,440
那麼 我們可以

321
00:11:55,440 --> 00:11:58,240
通過最小化意外的自由能來做到這一點，

322
00:11:58,240 --> 00:12:00,240


323
00:12:00,240 --> 00:12:02,320
因此我們想要構建一個避免意外的代理，

324
00:12:02,320 --> 00:12:05,040
並且我們可以

325
00:12:05,040 --> 00:12:07,600
對該環境進行貝葉斯推斷，

326
00:12:07,600 --> 00:12:09,600
因此我們必須為代理構建某種自由

327
00:12:09,600 --> 00:12:11,200
能函數

328
00:12:11,200 --> 00:12:13,680
來優化

329
00:12:13,680 --> 00:12:16,720
和 通過動作和控制的持續時間推斷

330
00:12:16,720 --> 00:12:19,540


331
00:12:19,540 --> 00:12:20,959
[音樂]

332
00:12:20,959 --> 00:12:23,760
，我們將能量函數定義為

333
00:12:23,760 --> 00:12:26,240


334
00:12:26,240 --> 00:12:28,160
我們擁有的生成模型

335
00:12:28,160 --> 00:12:29,600
和 s 之間的 kl 分歧

336
00:12:29,600 --> 00:12:32,959
我們假設我們在這裡

337
00:12:32,959 --> 00:12:35,839
定義 q t

338
00:12:36,000 --> 00:12:38,240
並最小化這個能量泛函的某種近似後驗

339
00:12:38,240 --> 00:12:40,160
將允許我們

340
00:12:40,160 --> 00:12:44,560
從觀察到控制向後推理

341
00:12:45,360 --> 00:12:48,720
，這是一種普遍的想法

342
00:12:48,720 --> 00:12:50,320
，

343
00:12:50,320 --> 00:12:52,480
並且假設我有選擇

344
00:12:52,480 --> 00:12:53,360


345
00:12:53,360 --> 00:12:55,680
，例如一個大的 我

346
00:12:55,680 --> 00:12:57,760
想做的選擇是我如何選擇我的模型我

347
00:12:57,760 --> 00:12:59,600
如何

348
00:12:59,600 --> 00:13:01,760


349
00:13:01,760 --> 00:13:03,839
以對我有用的方式選擇我的 f

350
00:13:03,839 --> 00:13:06,399
以及我如何選擇我的 qut

351
00:13:06,399 --> 00:13:08,320
我如何選擇它的因式分解

352
00:13:08,320 --> 00:13:09,440


353
00:13:09,440 --> 00:13:13,040
以便我可以製作我的 推論

354
00:13:13,120 --> 00:13:14,160
，

355
00:13:14,160 --> 00:13:17,360
這個過程是一種反複試驗的事情

356
00:13:17,360 --> 00:13:19,120


357
00:13:19,120 --> 00:13:20,800
，嗯，

358
00:13:20,800 --> 00:13:22,480
作為一名工程師，我當然想建立

359
00:13:22,480 --> 00:13:24,959
我可能能做到的最好的模型，

360
00:13:24,959 --> 00:13:26,959
但是我如何才能

361
00:13:26,959 --> 00:13:28,720
通過反複試驗的過程盡快完成

362
00:13:28,720 --> 00:13:30,959
我是最好的標記

363
00:13:30,959 --> 00:13:34,199
最好的模型

364
00:13:34,560 --> 00:13:36,800
，這就是模型

365
00:13:36,800 --> 00:13:39,199
設計週期的想法出現的地方

366
00:13:39,199 --> 00:13:41,839
，這再次被 david

367
00:13:41,839 --> 00:13:43,120
bly

368
00:13:43,120 --> 00:13:45,440
在他的論文中流行起來，在 2014 年建立計算

369
00:13:45,440 --> 00:13:47,600
評論重複

370
00:13:47,600 --> 00:13:49,760
，他提出了一個循環，其中

371
00:13:49,760 --> 00:13:52,240
工程師提出了一個模型

372
00:13:52,240 --> 00:13:54,320
，然後你想用這個模型

373
00:13:54,320 --> 00:13:56,480
推斷你感興趣的給定

374
00:13:56,480 --> 00:13:58,079
數據的數量

375
00:13:58,079 --> 00:13:59,600
，如果你已經推斷出這樣的模型

376
00:13:59,600 --> 00:14:01,279
，你想批評它，

377
00:14:01,279 --> 00:14:02,720
並根據

378
00:14:02,720 --> 00:14:04,560
你評估過的性能，

379
00:14:04,560 --> 00:14:07,680
你想重申重建

380
00:14:07,680 --> 00:14:08,800
你的模型

381
00:14:08,800 --> 00:14:09,839


382
00:14:09,839 --> 00:14:10,720
再次推斷

383
00:14:10,720 --> 00:14:12,959
，看看它的表現

384
00:14:12,959 --> 00:14:14,639
如何，直到你滿意

385
00:14:14,639 --> 00:14:16,959


386
00:14:16,959 --> 00:14:19,680


387
00:14:19,680 --> 00:14:21,440


388
00:14:21,440 --> 00:14:24,079


389
00:14:24,079 --> 00:14:27,040


390
00:14:27,120 --> 00:14:29,279
為止 我們希望變得靈活，我們希望

391
00:14:29,279 --> 00:14:31,760
使事情自動化，

392
00:14:31,760 --> 00:14:34,000
並且提出模型建議本身是

393
00:14:34,000 --> 00:14:35,040


394
00:14:35,040 --> 00:14:37,440
您作為工程師必須做的事情，

395
00:14:37,440 --> 00:14:38,800
您必須提出一個

396
00:14:38,800 --> 00:14:40,320


397
00:14:40,320 --> 00:14:44,079
關於您認為世界如何運作的建議，

398
00:14:44,079 --> 00:14:45,920
但是一旦您擁有了

399
00:14:45,920 --> 00:14:48,959
其他一切 可以自動化

400
00:14:48,959 --> 00:14:50,800
您可以通過概率編程推斷這些數量

401
00:14:50,800 --> 00:14:52,480
您可以

402
00:14:52,480 --> 00:14:55,920
評估自由能作為模型性能的衡量標準

403
00:14:55,920 --> 00:14:57,360


404
00:14:57,360 --> 00:14:59,040
[音樂]

405
00:14:59,040 --> 00:15:00,399
並

406
00:15:00,399 --> 00:15:03,120
自動執行此循環 l 是

407
00:15:03,120 --> 00:15:05,360
為在實踐中有用的代理提出模型建議的關鍵，

408
00:15:05,360 --> 00:15:07,519
因此您希望

409
00:15:07,519 --> 00:15:08,639
盡快完成此過程，

410
00:15:08,639 --> 00:15:10,160


411
00:15:10,160 --> 00:15:11,760
這就是為什麼我們選擇特定方法的原因，

412
00:15:11,760 --> 00:15:14,079
我們選擇矢量圖

413
00:15:14,079 --> 00:15:16,240
來表示我們的分解模型，

414
00:15:16,240 --> 00:15:17,680
因為

415
00:15:17,680 --> 00:15:20,000
在圖中您 可以進行操作 您

416
00:15:20,000 --> 00:15:22,560
可以添加節點 刪除節點 您可以

417
00:15:22,560 --> 00:15:24,839
非常快速地重新連接事物

418
00:15:24,839 --> 00:15:26,959
，一旦您有了模型的圖形

419
00:15:26,959 --> 00:15:29,040
表示，您就可以

420
00:15:29,040 --> 00:15:31,440
在該圖上進行消息傳遞

421
00:15:31,440 --> 00:15:34,399
以自動化推理

422
00:15:34,399 --> 00:15:36,720
，您甚至可以通過本地貢獻評估自由能

423
00:15:36,720 --> 00:15:38,839
這

424
00:15:38,839 --> 00:15:41,920
就是我們選擇

425
00:15:41,920 --> 00:15:43,519
圖形表示的原因，也是

426
00:15:43,519 --> 00:15:45,440
我們想要進行消息傳遞的原因，因為我們

427
00:15:45,440 --> 00:15:47,440
想要快速設計模型，

428
00:15:47,440 --> 00:15:51,680
以便我們現在可以設計有效的代理

429
00:15:52,639 --> 00:15:54,880
這些

430
00:15:54,880 --> 00:15:57,279
圖表如何正確工作如何構建

431
00:15:57,279 --> 00:15:58,639
有效的代理 圖形或它看起來像什麼，

432
00:15:58,639 --> 00:16:00,560


433
00:16:00,560 --> 00:16:03,040
因此我們選擇模型的特定表示

434
00:16:03,040 --> 00:16:04,560


435
00:16:04,560 --> 00:16:06,880
，這是一個示例，其中我們有

436
00:16:06,880 --> 00:16:09,120
五個變量的生成模型 x1

437
00:16:09,120 --> 00:16:10,959
到 x5

438
00:16:10,959 --> 00:16:15,759
，我們有三個因子 f a b 和 c

439
00:16:15,759 --> 00:16:18,079
，右圖

440
00:16:18,079 --> 00:16:20,240
是該模型的圖形表示

441
00:16:20,240 --> 00:16:21,279


442
00:16:21,279 --> 00:16:23,440
，您可以看到邊對應

443
00:16:23,440 --> 00:16:25,680
於變量，節點

444
00:16:25,680 --> 00:16:28,560
對應於向量

445
00:16:28,560 --> 00:16:31,360
，邊連接到

446
00:16:31,360 --> 00:16:32,399


447
00:16:32,399 --> 00:16:34,560
向量在參數中的節點，所以在這裡你

448
00:16:34,560 --> 00:16:37,040
看到節點 fa 很好地連接了邊 x1 和

449
00:16:37,040 --> 00:16:39,759
x2，這是因為 x1 和 x2

450
00:16:39,759 --> 00:16:42,160
是 fa 的參數，

451
00:16:42,160 --> 00:16:45,519
對於 fb 和 fc

452
00:16:46,800 --> 00:16:48,079
現在

453
00:16:48,079 --> 00:16:50,639
我們如何在這個圖中進行推理

454
00:16:50,639 --> 00:16:53,680
所以假設我們 觀察

455
00:16:53,680 --> 00:16:56,480
由這個小實心方塊表示的 x5

456
00:16:56,480 --> 00:16:58,399


457
00:16:58,399 --> 00:17:00,560
，我們想要計算我們對 x2 的信念，

458
00:17:00,560 --> 00:17:02,800
給定 x5

459
00:17:02,800 --> 00:17:05,359
，你做得好你邊緣化

460
00:17:05,359 --> 00:17:07,199
一切

461
00:17:07,199 --> 00:17:09,119
，邊緣化我的意思是你整合

462
00:17:09,119 --> 00:17:10,959


463
00:17:10,959 --> 00:17:12,559
除你感興趣的變量之外的所有變量，

464
00:17:12,559 --> 00:17:14,319
所以 接受 x2，

465
00:17:14,319 --> 00:17:16,559
你把所有東西都整合出來，然後你

466
00:17:16,559 --> 00:17:20,640
添加這個約束，你現在觀察 x5

467
00:17:20,640 --> 00:17:23,199
如果你有一個大模型，

468
00:17:23,199 --> 00:17:25,599
那麼這個整合變得非常

469
00:17:25,599 --> 00:17:28,319
麻煩，因為這就是

470
00:17:28,319 --> 00:17:30,480
你在這裡 fo 你的變量要

471
00:17:30,480 --> 00:17:32,559
積分

472
00:17:32,559 --> 00:17:33,520
所以

473
00:17:33,520 --> 00:17:35,679
這個房間這個積分空間

474
00:17:35,679 --> 00:17:37,840
如果你想天真地做這個真的會爆炸

475
00:17:37,840 --> 00:17:40,320


476
00:17:40,320 --> 00:17:43,039
但是你可以很聰明

477
00:17:43,039 --> 00:17:45,120
你可以

478
00:17:45,120 --> 00:17:47,640


479
00:17:47,640 --> 00:17:49,919
根據

480
00:17:49,919 --> 00:17:52,080
它們各自的

481
00:17:52,080 --> 00:17:54,480
術語重新洗牌這些積分例如

482
00:17:54,480 --> 00:17:57,600
這個積分超過 x5

483
00:17:57,600 --> 00:18:00,000
好吧，只有一個因素 x5

484
00:18:00,000 --> 00:18:01,440
是一個參數，

485
00:18:01,440 --> 00:18:03,520
所以我可以使用分配規則

486
00:18:03,520 --> 00:18:06,960
將這個積分帶入內部，

487
00:18:07,280 --> 00:18:09,840
以便我將這些積分分成

488
00:18:09,840 --> 00:18:14,120
更小的部分，這些部分是可管理的

489
00:18:14,320 --> 00:18:16,400
，這就是消息傳遞來自

490
00:18:16,400 --> 00:18:17,200


491
00:18:17,200 --> 00:18:19,919
消息傳遞的地方

492
00:18:19,919 --> 00:18:22,559
逐個解決這些集成，

493
00:18:22,559 --> 00:18:25,520
因此我可以首先在這裡集成 x

494
00:18:25,520 --> 00:18:27,520
x one，例如

495
00:18:27,520 --> 00:18:28,559
，

496
00:18:28,559 --> 00:18:31,280
正如我們所說，它總結了

497
00:18:31,280 --> 00:18:33,840
這個橙色框內的所有信息，它給了我們一條

498
00:18:33,840 --> 00:18:35,919
消息，這裡的第一條消息退出了

499
00:18:35,919 --> 00:18:38,480
這個橙色框，

500
00:18:38,480 --> 00:18:40,320
然後它可以繼續 底部，所以

501
00:18:40,320 --> 00:18:43,120
積分出 x5

502
00:18:43,120 --> 00:18:45,840
，我得到第二條消息

503
00:18:45,840 --> 00:18:48,160
，我可以

504
00:18:48,160 --> 00:18:50,559
在計算第三條消息時使用第二條消息，

505
00:18:50,559 --> 00:18:52,880
所以 是您

506
00:18:52,880 --> 00:18:56,080
獲得嵌套解決方案方法的方式

507
00:18:56,080 --> 00:18:58,240
，在該方法中我

508
00:18:58,240 --> 00:18:59,600
在計算消息三時使用消息二的解決方案

509
00:18:59,600 --> 00:19:01,760


510
00:19:01,760 --> 00:19:03,679
，您會看到最後

511
00:19:03,679 --> 00:19:05,600
這兩個

512
00:19:05,600 --> 00:19:08,320
碰撞消息在 x2 邊緣的乘積

513
00:19:08,320 --> 00:19:10,000
會給我

514
00:19:10,000 --> 00:19:12,480
我的比例信念我

515
00:19:12,480 --> 00:19:14,960


516
00:19:14,960 --> 00:19:19,280
在 x2 上的比例後驗給定我所觀察到的，

517
00:19:21,120 --> 00:19:24,400
所以舉一個特定節點的小例子，

518
00:19:24,400 --> 00:19:27,679


519
00:19:27,679 --> 00:19:30,320
這裡的工作原理是一個等式約束節點

520
00:19:30,320 --> 00:19:32,080
，我們用

521
00:19:32,080 --> 00:19:33,120
它

522
00:19:33,120 --> 00:19:34,640
作為約束

523
00:19:34,640 --> 00:19:36,320


524
00:19:36,320 --> 00:19:38,400
來約束

525
00:19:38,400 --> 00:19:41,280
相鄰邊上的信念是 等於

526
00:19:41,280 --> 00:19:43,840
um，

527
00:19:43,840 --> 00:19:45,440
如果我們在這裡進行數學運算，它們將遵循，

528
00:19:45,440 --> 00:19:46,559


529
00:19:46,559 --> 00:19:47,520


530
00:19:47,520 --> 00:19:48,880
這就是節點函數的

531
00:19:48,880 --> 00:19:51,200
樣子，所以我說好吧，它是

532
00:19:51,200 --> 00:19:53,200
三個變量 x y 和 z 的函數

533
00:19:53,200 --> 00:19:55,679
，我將 z 約束

534
00:19:55,679 --> 00:19:58,960
為 x 和 我將 z 也限制為 y，

535
00:19:58,960 --> 00:20:00,000
所以

536
00:20:00,000 --> 00:20:01,760
如果我將這兩個限制為相同，那麼 x 也將是 y，

537
00:20:01,760 --> 00:20:03,840


538
00:20:03,840 --> 00:20:05,679
所以讓我們看看我們是否可以

539
00:20:05,679 --> 00:20:08,640
基於此導出消息，

540
00:20:08,880 --> 00:20:09,760
所以

541
00:20:09,760 --> 00:20:11,520
如果我想將信息匯總

542
00:20:11,520 --> 00:20:13,360
到這個橙色框中，

543
00:20:13,360 --> 00:20:14,960
我 可以使用子產品規則，

544
00:20:14,960 --> 00:20:16,799
我有兩條消息

545
00:20:16,799 --> 00:20:18,320
從左邊進來，從底部

546
00:20:18,320 --> 00:20:20,880
消息一和消息 2。

547
00:20:20,880 --> 00:20:23,280
我乘以

548
00:20:23,280 --> 00:20:24,799
相等節點的節點函數，我現在想

549
00:20:24,799 --> 00:20:27,760
執行這個集成

550
00:20:27,760 --> 00:20:29,360


551
00:20:29,360 --> 00:20:31,280


552
00:20:31,280 --> 00:20:32,880
用除法積分代替這個節點函數

553
00:20:32,880 --> 00:20:34,720
，然後我可以使用

554
00:20:34,720 --> 00:20:36,240
shift 屬性

555
00:20:36,240 --> 00:20:37,200


556
00:20:37,200 --> 00:20:39,600
將 x

557
00:20:39,600 --> 00:20:41,440
和 y

558
00:20:41,440 --> 00:20:43,840
的參數替換為 z 的參數，

559
00:20:43,840 --> 00:20:47,120
所以我在這裡所做的基本上是

560
00:20:47,120 --> 00:20:49,360
說我可以通過乘法來計算這條消息

561
00:20:49,360 --> 00:20:51,919
三

562
00:20:51,919 --> 00:20:53,440
現在從左側和底部傳入的兩條消息

563
00:20:53,440 --> 00:20:55,280


564
00:20:55,280 --> 00:20:56,799
如果您稍微瞇起眼睛

565
00:20:56,799 --> 00:20:58,799
看，呃，您通過眼睛看，

566
00:20:58,799 --> 00:21:00,799
您可以在這裡識別出

567
00:21:00,799 --> 00:21:03,919
一個比例基本規則，

568
00:21:03,919 --> 00:21:06,320
所以基本上您可以說如果

569
00:21:06,320 --> 00:21:08,000
消息三 這裡代表我的

570
00:21:08,000 --> 00:21:09,360
後驗，

571
00:21:09,360 --> 00:21:11,919
然後消息一個可以代表我之前的

572
00:21:11,919 --> 00:21:15,440
一個消息，我的可能性

573
00:21:15,440 --> 00:21:17,280
，然後我有一個成比例的後驗

574
00:21:17,280 --> 00:21:19,520
消息三，然後我可以傳遞給

575
00:21:19,520 --> 00:21:21,520
我的 mod 的其餘部分 el

576
00:21:21,520 --> 00:21:23,200
和這個節點也經常

577
00:21:23,200 --> 00:21:24,880
用於將

578
00:21:24,880 --> 00:21:28,000
來自左側和底部

579
00:21:29,120 --> 00:21:31,840


580
00:21:34,320 --> 00:21:36,480


581
00:21:36,480 --> 00:21:38,320
的信息

582
00:21:38,320 --> 00:21:42,240


583
00:21:42,240 --> 00:21:43,760


584
00:21:43,760 --> 00:21:46,400
進行組合 已經派生

585
00:21:46,400 --> 00:21:49,200
到 uh into phony lab 的規則，這基本上是

586
00:21:49,200 --> 00:21:50,880


587
00:21:50,880 --> 00:21:53,679
一個軟件問題編程

588
00:21:53,679 --> 00:21:55,360
套件

589
00:21:55,360 --> 00:21:57,520
，可以為您執行調度和

590
00:21:57,520 --> 00:22:00,240
此消息計算，

591
00:22:00,240 --> 00:22:01,760
因此您不必考慮

592
00:22:01,760 --> 00:22:03,280
太多如何重新分配這些

593
00:22:03,280 --> 00:22:06,240
積分以及如何推導

594
00:22:06,240 --> 00:22:10,400
嗯，對於特定節點有很多更新，

595
00:22:10,960 --> 00:22:13,280
所以

596
00:22:13,280 --> 00:22:15,520
我們可以

597
00:22:15,520 --> 00:22:17,280


598
00:22:17,280 --> 00:22:19,919
在設計週期的那一側自動化呃

599
00:22:19,919 --> 00:22:22,320


600
00:22:23,200 --> 00:22:24,840
現在

601
00:22:24,840 --> 00:22:27,120
其他任何關於這個的問題，因為

602
00:22:27,120 --> 00:22:28,880
我正在快速完成這個，

603
00:22:28,880 --> 00:22:30,240
什麼 我接下來要做的是有點

604
00:22:30,240 --> 00:22:32,320
想通過一個例子，

605
00:22:32,320 --> 00:22:34,240
所以也許這是一個自然的點

606
00:22:34,240 --> 00:22:36,880
，人們有問題，他們

607
00:22:36,880 --> 00:22:38,880
可以阻止我並認為嘿你

608
00:22:38,880 --> 00:22:41,440
要走了 g 在這裡快速，

609
00:22:41,440 --> 00:22:43,600
我認為看到這個例子會很好

610
00:22:43,600 --> 00:22:45,280
，然後我們在

611
00:22:45,280 --> 00:22:47,039
實時聊天中有一些問題，也歡迎任何人

612
00:22:47,039 --> 00:22:49,120
添加更多，

613
00:22:49,120 --> 00:22:52,158
好吧，確定，

614
00:22:52,400 --> 00:22:54,480
所以你如何

615
00:22:54,480 --> 00:22:56,640
在積極的推理環境中在實踐中做到這一點所以 這

616
00:22:56,640 --> 00:22:58,080
是一個小例子，它被稱為

617
00:22:58,080 --> 00:23:00,559
貝葉斯恆溫器

618
00:23:00,559 --> 00:23:02,960
，我們有一個環境環境，

619
00:23:02,960 --> 00:23:03,760


620
00:23:03,760 --> 00:23:05,840
所以我們在左邊有一個熱源

621
00:23:05,840 --> 00:23:08,000
，我們有一輛可以

622
00:23:08,000 --> 00:23:09,600
四處移動的小汽車，它可以遠離

623
00:23:09,600 --> 00:23:11,520
熱源，也可以朝 熱源

624
00:23:11,520 --> 00:23:13,679


625
00:23:13,679 --> 00:23:16,400
現在相對於熱源的位置

626
00:23:16,400 --> 00:23:19,120
是我們所說的 x

627
00:23:19,120 --> 00:23:20,799
，在每個位置都有一個

628
00:23:20,799 --> 00:23:22,799
特定的溫度

629
00:23:22,799 --> 00:23:23,679
um

630
00:23:23,679 --> 00:23:25,120
，我們在特定位置測量的溫度

631
00:23:25,120 --> 00:23:29,600
是我們所說的 y

632
00:23:29,679 --> 00:23:31,600
，我們傾向於處於

633
00:23:31,600 --> 00:23:33,440
溫度 四

634
00:23:33,440 --> 00:23:35,440
y 四 我不知道這是我們現在選擇的東西

635
00:23:35,440 --> 00:23:37,600


636
00:23:37,600 --> 00:23:39,360
我們通過

637
00:23:39,360 --> 00:23:41,279
向左或向右移動來控制這輛車 我們的控制

638
00:23:41,279 --> 00:23:43,440
這是我們向左

639
00:23:43,440 --> 00:23:45,360
或向右移動的速度 它被稱為

640
00:23:45,360 --> 00:23:47,520
u

641
00:23:47,840 --> 00:23:50,880
所以這是我們的環境 nt

642
00:23:50,880 --> 00:23:54,320
並且我們想要為此建立一個模型，

643
00:23:54,320 --> 00:23:56,240
因此

644
00:23:56,240 --> 00:23:57,919
在主動干擾中，我們想要

645
00:23:57,919 --> 00:23:59,760
做的是

646
00:23:59,760 --> 00:24:01,840
我們想要

647
00:24:01,840 --> 00:24:05,039
從我們想要控制的狀態進行推理

648
00:24:05,039 --> 00:24:07,600
，我們必須

649
00:24:07,600 --> 00:24:09,679
在當前時間應用該電流

650
00:24:09,679 --> 00:24:12,080
以獲得 在未來

651
00:24:12,080 --> 00:24:13,679
所以我們想要做的是我們想要

652
00:24:13,679 --> 00:24:16,000
從當前

653
00:24:16,000 --> 00:24:17,360
時間 t

654
00:24:17,360 --> 00:24:18,400
向前推理到

655
00:24:18,400 --> 00:24:21,120
某個時間範圍 big t

656
00:24:21,120 --> 00:24:22,880
並且

657
00:24:22,880 --> 00:24:25,200
在未來我們想要考慮

658
00:24:25,200 --> 00:24:27,200
智能體將如何移動

659
00:24:27,200 --> 00:24:29,120
以及我們希望該智能體在哪裡 在

660
00:24:29,120 --> 00:24:32,960
那個時候和最後，我們將希望

661
00:24:32,960 --> 00:24:35,760
處於 4 的溫度

662
00:24:35,760 --> 00:24:37,200
，這是一個狀態空間模型，它

663
00:24:37,200 --> 00:24:41,520
代表了我們對這個代理將如何

664
00:24:41,520 --> 00:24:42,880


665
00:24:42,880 --> 00:24:44,320


666
00:24:44,320 --> 00:24:46,480
在世界中移動的信念，

667
00:24:46,480 --> 00:24:48,720
所以在時間 t 我們有一個觀察

668
00:24:48,720 --> 00:24:51,200
到 特定的溫度

669
00:24:51,200 --> 00:24:55,360
，也許我們已經做了一個動作

670
00:24:55,360 --> 00:24:56,960
，

671
00:24:56,960 --> 00:24:59,600
我們

672
00:24:59,600 --> 00:25:02,159
說當前狀態 xt 與

673
00:25:02,159 --> 00:25:03,840
之前的狀態和動作相關，我們

674
00:25:03,840 --> 00:25:06,559
通過添加所以基本上 ut 這裡

675
00:25:06,559 --> 00:25:08,320
是我們添加到當前

676
00:25:08,320 --> 00:25:09,600
位置的

677
00:25:09,600 --> 00:25:12,880
速度 時間  一步，然後我們

678
00:25:12,880 --> 00:25:14,640


679
00:25:14,640 --> 00:25:17,039
通過添加它並應用

680
00:25:17,039 --> 00:25:19,520
一些高斯噪聲得到我們的下一個位置

681
00:25:19,520 --> 00:25:21,279
，所以我們有一個狀態轉換，它

682
00:25:21,279 --> 00:25:23,520
是這個加法的，

683
00:25:23,520 --> 00:25:25,600
有責任說我想向左移動

684
00:25:25,600 --> 00:25:28,880
或向右移動四個

685
00:25:28,880 --> 00:25:30,559
然後我們添加一些高斯噪聲說

686
00:25:30,559 --> 00:25:33,039
好的我們有點不確定

687
00:25:33,039 --> 00:25:34,799
這個代理在環境中如何移動

688
00:25:34,799 --> 00:25:35,919


689
00:25:35,919 --> 00:25:38,159
我們對此有一個想法但是讓我們添加

690
00:25:38,159 --> 00:25:40,080
一些變體以

691
00:25:40,080 --> 00:25:43,760
解釋一些不確定性

692
00:25:43,760 --> 00:25:45,520
然後我們在這裡說這個 垂直

693
00:25:45,520 --> 00:25:47,520
線，如果我們

694
00:25:47,520 --> 00:25:49,600
有一個觀察

695
00:25:49,600 --> 00:25:52,159
或如果我們有一個位置，那麼它

696
00:25:52,159 --> 00:25:55,840
與溫度的觀察有關

697
00:25:55,840 --> 00:25:56,960


698
00:25:56,960 --> 00:25:59,279


699
00:25:59,279 --> 00:26:01,440


700
00:26:01,440 --> 00:26:03,200


701
00:26:03,200 --> 00:26:05,200
來源，那麼我的溫度

702
00:26:05,200 --> 00:26:06,720


703
00:26:06,720 --> 00:26:09,120
將以負一的斜率下降

704
00:26:09,120 --> 00:26:11,200
，這是一個非常粗略的猜測，

705
00:26:11,200 --> 00:26:12,880
在現實世界中會有一個非常好的

706
00:26:12,880 --> 00:26:14,640
溫度梯度，它可能

707
00:26:14,640 --> 00:26:16,799
會像

708
00:26:16,799 --> 00:26:19,360
會非常緩慢地向下移動一樣移動，

709
00:26:19,360 --> 00:26:21,840
但是 我們只是說，嘿，我們真的不

710
00:26:21,840 --> 00:26:24,400
知道那是什麼讓

711
00:26:24,400 --> 00:26:26,159
我們粗略猜測一下，我們相信這是我們的

712
00:26:26,159 --> 00:26:27,760
生成模型

713
00:26:27,760 --> 00:26:29,520


714
00:26:29,520 --> 00:26:32,400


715
00:26:32,400 --> 00:26:33,919
關於

716
00:26:33,919 --> 00:26:36,559
這一點，讓我們再次添加

717
00:26:36,559 --> 00:26:39,600
一些高斯噪聲

718
00:26:39,600 --> 00:26:41,679
，現在我將其擴展

719
00:26:41,679 --> 00:26:43,919
到未來，所以我說得好，我

720
00:26:43,919 --> 00:26:45,760
相信未來我的

721
00:26:45,760 --> 00:26:48,240
環境也將

722
00:26:48,240 --> 00:26:50,480
根據這一點發展，

723
00:26:50,480 --> 00:26:51,360
但

724
00:26:51,360 --> 00:26:53,520
我也有一些關於我想去哪裡的想法

725
00:26:53,520 --> 00:26:55,360


726
00:26:55,360 --> 00:26:58,720
和這個 是黃金先驗出現的地方，

727
00:26:58,720 --> 00:27:00,960
它將我未來

728
00:27:00,960 --> 00:27:03,200
對溫度的觀察限制在這個

729
00:27:03,200 --> 00:27:06,240
期望的溫度四左右

730
00:27:06,240 --> 00:27:08,080
，然後我說這裡有一些額外的

731
00:27:08,080 --> 00:27:11,200
噪音，嗯，

732
00:27:11,200 --> 00:27:13,360
我想在四左右，它

733
00:27:13,360 --> 00:27:15,360
不一定是完全正確的 但我

734
00:27:15,360 --> 00:27:18,240
想非常確定，嗯，

735
00:27:18,240 --> 00:27:21,360
在時間 t 加 1 時，我將在 4 歲左右，我將

736
00:27:21,360 --> 00:27:22,480


737
00:27:22,480 --> 00:27:24,080
繼續留在那裡

738
00:27:24,080 --> 00:27:25,039
直到

739
00:27:25,039 --> 00:27:28,080
未來的某個時候，

740
00:27:30,320 --> 00:27:33,200
現在我們有了再生模型

741
00:27:33,200 --> 00:27:35,200
，

742
00:27:35,200 --> 00:27:37,279
我們可以定義我們的能量函數，

743
00:27:37,279 --> 00:27:39,360
我們可以 n

744
00:27:39,360 --> 00:27:41,919
通過在該圖上

745
00:27:41,919 --> 00:27:44,960
傳遞消息來解決能量泛函問題，我們將這些消息傳遞給

746
00:27:44,960 --> 00:27:46,480
我們的下一個控件，

747
00:27:46,480 --> 00:27:49,360
因為我們有興趣從下一次 um 中推斷

748
00:27:49,360 --> 00:27:52,480
我們接下來要做的事情

749
00:27:52,480 --> 00:27:55,279


750
00:27:55,600 --> 00:27:57,679
，這是我們可以做消息的地方

751
00:27:57,679 --> 00:27:59,600
通過我們可以總結

752
00:27:59,600 --> 00:28:02,720
我們

753
00:28:02,720 --> 00:28:04,159
從過去獲得的所有信息，因此這將是

754
00:28:04,159 --> 00:28:06,240
對代理當前狀態的估計，

755
00:28:06,240 --> 00:28:07,679


756
00:28:07,679 --> 00:28:09,600
並且會因我們對未來的信念而產生偏見，

757
00:28:09,600 --> 00:28:11,279
即我們想去哪裡

758
00:28:11,279 --> 00:28:12,240


759
00:28:12,240 --> 00:28:14,799
，這將影響或決定

760
00:28:14,799 --> 00:28:17,039
我們現在或下一次將採取哪些控制措施

761
00:28:17,039 --> 00:28:18,640


762
00:28:18,640 --> 00:28:21,520


763
00:28:21,600 --> 00:28:24,640
所有細節

764
00:28:24,640 --> 00:28:26,559
都在 2019 年的這篇論文中進行了描述，

765
00:28:26,559 --> 00:28:28,880


766
00:28:28,880 --> 00:28:31,039


767
00:28:34,080 --> 00:28:35,600
您還可以看到我們如何

768
00:28:35,600 --> 00:28:37,440


769
00:28:37,440 --> 00:28:40,000
在動作感知循環中應用它

770
00:28:40,000 --> 00:28:42,240
以及類似的事情，

771
00:28:42,240 --> 00:28:43,520
因為 您必須在每次 t 時都這樣做，

772
00:28:43,520 --> 00:28:44,960


773
00:28:44,960 --> 00:28:46,799
因為您的狀態估計會

774
00:28:46,799 --> 00:28:48,159
改變單詞會根據您的

775
00:28:48,159 --> 00:28:49,760
操作而改變，因此您

776
00:28:49,760 --> 00:28:51,600
每次都必須為 wha 重新計算一個新操作

777
00:28:51,600 --> 00:28:54,719
你接下來要做，

778
00:28:55,120 --> 00:28:57,600
嗯，這是

779
00:28:57,600 --> 00:28:59,360
現在的主要想法，當然我們不想

780
00:28:59,360 --> 00:29:01,120


781
00:29:01,120 --> 00:29:03,679
手工做這一切，所以我們想要做的

782
00:29:03,679 --> 00:29:07,200
就是我們想要使用一個工具，

783
00:29:07,679 --> 00:29:09,039
所以 現在

784
00:29:09,039 --> 00:29:10,960
我將展示一個小演示，

785
00:29:10,960 --> 00:29:12,880
你將如何

786
00:29:12,880 --> 00:29:15,360
使用公式概率

787
00:29:15,360 --> 00:29:17,520
編程工具來實現這個，

788
00:29:17,520 --> 00:29:19,840
所以讓我們看看我是否可以

789
00:29:19,840 --> 00:29:22,480
打開我們的小演示，所以

790
00:29:22,480 --> 00:29:24,320
這實際上是可讀的，或者我應該

791
00:29:24,320 --> 00:29:25,520
放大更多

792
00:29:25,520 --> 00:29:27,279


793
00:29:27,279 --> 00:29:30,640
嗎？ 可以再放大一點，

794
00:29:32,720 --> 00:29:35,440
也許像

795
00:29:35,440 --> 00:29:37,840
這樣 嗯，是的，我可以調整大小

796
00:29:37,840 --> 00:29:39,360


797
00:29:39,360 --> 00:29:41,520


798
00:29:41,520 --> 00:29:42,880


799
00:29:42,880 --> 00:29:46,159


800
00:29:48,640 --> 00:29:52,000


801
00:29:52,000 --> 00:29:55,279


802
00:29:55,440 --> 00:29:58,080
這是我們

803
00:29:58,080 --> 00:29:59,919
對環境本身的定義，所以這

804
00:29:59,919 --> 00:30:01,279
就是現實世界，

805
00:30:01,279 --> 00:30:03,039
我們有這個溫度

806
00:30:03,039 --> 00:30:05,120
梯度，這是一個非常好的函數

807
00:30:05,120 --> 00:30:07,840
，非常平滑的函數

808
00:30:07,840 --> 00:30:09,039
，在熱源處我們的

809
00:30:09,039 --> 00:30:10,640
溫度為 100

810
00:30:10,640 --> 00:30:12,960
，

811
00:30:12,960 --> 00:30:14,880
它會

812
00:30:14,880 --> 00:30:18,410
隨著 與來自熱源的位置

813
00:30:18,410 --> 00:30:20,240
[音樂]

814
00:30:20,240 --> 00:30:21,679
所以 t 他是一個真實的世界，我們並不真正

815
00:30:21,679 --> 00:30:23,360
知道這一點，所以這是我們

816
00:30:23,360 --> 00:30:25,279
將用這個

817
00:30:25,279 --> 00:30:28,640
非常粗糙的負一來近似的世界，然後

818
00:30:28,640 --> 00:30:31,279
我們將看看這是否適用於它

819
00:30:31,279 --> 00:30:33,360
現在這是我美妙的 ascii 藝術

820
00:30:33,360 --> 00:30:35,600
現在已經調整

821
00:30:35,600 --> 00:30:38,880
了我剛剛在幻燈片中展示

822
00:30:38,880 --> 00:30:40,559


823
00:30:40,559 --> 00:30:42,960
的

824
00:30:42,960 --> 00:30:44,480


825
00:30:44,480 --> 00:30:45,919


826
00:30:45,919 --> 00:30:48,399


827
00:30:48,399 --> 00:30:50,799
模型的大小 所以嗯，這裡我們有我們的

828
00:30:50,799 --> 00:30:53,679
觀察狀態控制

829
00:30:53,679 --> 00:30:56,720
，我們定義了一個

830
00:30:56,720 --> 00:30:59,200
關於 t 減一的先驗信念，所以我們去過哪裡

831
00:30:59,200 --> 00:31:01,120
，我們要說的是高斯

832
00:31:01,120 --> 00:31:05,039
，有一些平均值和一些方差

833
00:31:05,039 --> 00:31:07,440
，然後每次

834
00:31:07,440 --> 00:31:11,039
從 嗯，從一到地平線，

835
00:31:11,039 --> 00:31:12,320
我們將有一個關於控制的先驗信念，

836
00:31:12,320 --> 00:31:15,840
它基本上說好

837
00:31:15,840 --> 00:31:18,240
當我說好的時候我可以做什麼

838
00:31:18,240 --> 00:31:19,039


839
00:31:19,039 --> 00:31:20,159


840
00:31:20,159 --> 00:31:22,640
我有一個關於控制的高喬先驗

841
00:31:22,640 --> 00:31:24,480
，

842
00:31:24,480 --> 00:31:26,159
平均值為零

843
00:31:26,159 --> 00:31:28,480
我會 在那裡替換，然後

844
00:31:28,480 --> 00:31:31,279
可能會有一些差異

845
00:31:31,279 --> 00:31:32,880
，嗯，

846
00:31:32,880 --> 00:31:34,960
他 我說得好，我有我的代理位置，

847
00:31:34,960 --> 00:31:37,600
它與我的控制

848
00:31:37,600 --> 00:31:38,399


849
00:31:38,399 --> 00:31:39,919


850
00:31:39,919 --> 00:31:41,120


851
00:31:41,120 --> 00:31:42,880


852
00:31:42,880 --> 00:31:44,640


853
00:31:44,640 --> 00:31:46,880


854
00:31:46,880 --> 00:31:48,480


855
00:31:48,480 --> 00:31:50,480


856
00:31:50,480 --> 00:31:52,640


857
00:31:52,640 --> 00:31:54,399
有關

858
00:31:54,399 --> 00:31:56,000
溫度梯度

859
00:31:56,000 --> 00:31:58,880
乘以當前狀態，還有

860
00:31:58,880 --> 00:32:00,640
一些精度

861
00:32:00,640 --> 00:32:03,200
守恆精度

862
00:32:03,200 --> 00:32:06,320
，這代表了我之前的目標，

863
00:32:06,320 --> 00:32:09,120
所以請注意，我還沒有真正在這裡輸入任何

864
00:32:09,120 --> 00:32:12,320
具體值，但我只是

865
00:32:12,320 --> 00:32:14,399
為實際統計數據和

866
00:32:14,399 --> 00:32:16,880
值設置了佔位符

867
00:32:16,880 --> 00:32:18,480
因為我的算法的實際推導

868
00:32:18,480 --> 00:32:20,480
並不依賴於

869
00:32:20,480 --> 00:32:23,120
統計數據，它只是

870
00:32:23,120 --> 00:32:27,799
我們可以稍後輸入的東西，

871
00:32:28,240 --> 00:32:29,760
所以這就是我想要做的建立一個

872
00:32:29,760 --> 00:32:31,919
自由能函數，而虛假

873
00:32:31,919 --> 00:32:33,679
實驗室實際上只是

874
00:32:33,679 --> 00:32:36,720
基本上是四行代碼，

875
00:32:36,720 --> 00:32:39,279
所以這個立體

876
00:32:39,279 --> 00:32:42,559
分解定義了我對 q 的分解，

877
00:32:42,559 --> 00:32:44,240
說嗯，

878
00:32:44,240 --> 00:32:46,960
我將在 en 上有

879
00:32:46,960 --> 00:32:50,640
一個聯合變分分佈

880
00:32:50,640 --> 00:32:52,880
um 輪胎圖

881
00:32:52,880 --> 00:32:54,559
我並沒有真正將它

882
00:32:54,559 --> 00:32:55,840
細分為結構

883
00:32:55,840 --> 00:32:57,760
分解為一些人熟悉的結構分解

884
00:32:57,760 --> 00:32:59,279
，

885
00:32:59,279 --> 00:33:01,440
嗯，但只是說好吧，我只是

886
00:33:01,440 --> 00:33:03,039
將變分

887
00:33:03,039 --> 00:33:05,919
分佈的立體分解作為我的整個圖，

888
00:33:05,919 --> 00:33:08,640
而不僅僅是

889
00:33:08,640 --> 00:33:11,120
我可以推導出的一個命令 一種消息傳遞算法

890
00:33:11,120 --> 00:33:14,080
，將所有消息傳播到

891
00:33:14,080 --> 00:33:16,320
控制 u2，這

892
00:33:16,320 --> 00:33:18,159
是下一個

893
00:33:18,159 --> 00:33:21,039
時間步 t 加一的控制

894
00:33:21,039 --> 00:33:23,039
，我想評估我的自由能，所以

895
00:33:23,039 --> 00:33:24,799
同時也給我

896
00:33:24,799 --> 00:33:27,840
一個我可以執行的算法

897
00:33:27,840 --> 00:33:31,439
為了評估我的自由能

898
00:33:31,919 --> 00:33:35,279
，這條線會將其轉換

899
00:33:35,279 --> 00:33:36,320
為

900
00:33:36,320 --> 00:33:38,320
兩個源代碼，然後我可以將其加載到

901
00:33:38,320 --> 00:33:41,120
我的環境中

902
00:33:41,200 --> 00:33:43,519
，它的作用是為我們構建一個

903
00:33:43,519 --> 00:33:46,480
消息傳遞算法，

904
00:33:46,480 --> 00:33:48,559
所以這就是

905
00:33:48,559 --> 00:33:50,159
執行消息的代碼 傳遞我們的

906
00:33:50,159 --> 00:33:51,200
圖表

907
00:33:51,200 --> 00:33:53,120
，在這裡你可以看到它

908
00:33:53,120 --> 00:33:54,640


909
00:33:54,640 --> 00:33:57,039
通過一些產品規則和其他規則計算所有這些消息

910
00:33:57,039 --> 00:33:58,559
，我們已經預先導出並且我們

911
00:33:58,559 --> 00:34:01,279
已經在 fornilab

912
00:34:01,279 --> 00:34:03,039
和 您可以看到這些消息它們

913
00:34:03,039 --> 00:34:05,360
依賴於統計數據，因此這是

914
00:34:05,360 --> 00:34:07,679
例如

915
00:34:07,679 --> 00:34:09,520
我們先前

916
00:34:09,520 --> 00:34:11,280
過度狀態的平均值和先前過度狀態的方差

917
00:34:11,280 --> 00:34:13,839


918
00:34:14,079 --> 00:34:15,599
，我們還有其他消息依賴

919
00:34:15,599 --> 00:34:18,000
於先前消息

920
00:34:18,000 --> 00:34:19,359
的方式，就像我解釋消息

921
00:34:19,359 --> 00:34:21,199
傳遞

922
00:34:21,199 --> 00:34:23,839
和這個 在這種情況下構建一個包含 26 條消息的完整列表

923
00:34:23,839 --> 00:34:27,599


924
00:34:27,599 --> 00:34:29,918
，最後我們對

925
00:34:29,918 --> 00:34:32,079
邊際信念感興趣，因此後

926
00:34:32,079 --> 00:34:35,040
邊際信念關於例如

927
00:34:35,040 --> 00:34:36,480
或控制

928
00:34:36,480 --> 00:34:38,399
，您可以通過將消息相乘來獲得這些信念

929
00:34:38,399 --> 00:34:40,879
，例如得到

930
00:34:40,879 --> 00:34:43,199
一個新信念 在下面的控制中，

931
00:34:43,199 --> 00:34:44,560
您將

932
00:34:44,560 --> 00:34:48,639
消息 9 和 25 相乘，

933
00:34:48,639 --> 00:34:50,719
並且您還可以從

934
00:34:50,719 --> 00:34:52,560
過去的介紹中的一個小介紹中認識到這一點

935
00:34:52,560 --> 00:34:54,239
，在該介紹中，您在邊緣有衝突的消息

936
00:34:54,239 --> 00:34:56,239
，您將這些消息相乘以獲得

937
00:34:56,239 --> 00:34:58,400
您的後驗信念

938
00:34:58,400 --> 00:34:59,920
，這就是我們最終返回

939
00:34:59,920 --> 00:35:03,720
的內容，這就是我們 '感興趣，

940
00:35:06,160 --> 00:35:07,760
所以這是該算法的執行，請

941
00:35:07,760 --> 00:35:08,960


942
00:35:08,960 --> 00:35:10,640
注意我們已經在這裡制定了完整的

943
00:35:10,640 --> 00:35:12,160
時間表，

944
00:35:12,160 --> 00:35:14,800
它們可能非常複雜 rsome

945
00:35:14,800 --> 00:35:17,119
可能是很長很長的計劃，

946
00:35:17,119 --> 00:35:19,599
因此加載和執行可能會很昂貴

947
00:35:19,599 --> 00:35:21,359


948
00:35:21,359 --> 00:35:22,800
，dimitri 有解決方案

949
00:35:22,800 --> 00:35:25,359
，他會在一分鐘內解釋，

950
00:35:25,359 --> 00:35:27,520
所以我很高興

951
00:35:27,520 --> 00:35:29,119
制定計劃

952
00:35:29,119 --> 00:35:32,400
，嗯，dimitri 沒有 這麼多，呃

953
00:35:32,400 --> 00:35:34,560
，他試圖找到呃

954
00:35:34,560 --> 00:35:36,160
為他們找到解決方案擺脫他們，

955
00:35:36,160 --> 00:35:37,680
因為最終這將是

956
00:35:37,680 --> 00:35:38,800
最快

957
00:35:38,800 --> 00:35:40,400
的，因為最終

958
00:35:40,400 --> 00:35:41,839
沒有真正沒有食譜的時間表，

959
00:35:41,839 --> 00:35:44,880
而只是根據給你的任何東西做飯

960
00:35:44,880 --> 00:35:47,440


961
00:35:49,920 --> 00:35:51,599
所以現在我們在實踐中執行這個算法

962
00:35:51,599 --> 00:35:52,800
所以這是我們想要

963
00:35:52,800 --> 00:35:55,520
執行的每個時間步的

964
00:35:55,520 --> 00:35:57,599


965
00:35:57,599 --> 00:35:59,119


966
00:35:59,119 --> 00:36:01,359


967
00:36:01,359 --> 00:36:04,240


968
00:36:04,240 --> 00:36:06,720
動作感知循環 在這種情況下，這是

969
00:36:06,720 --> 00:36:09,040
將動作發送到實際的現實

970
00:36:09,040 --> 00:36:11,200
世界或模擬世界

971
00:36:11,200 --> 00:36:13,680
，我們從中得到的是

972
00:36:13,680 --> 00:36:15,680
觀察結果

973
00:36:15,680 --> 00:36:18,079
，從我們的動作觀察結果中，我們想

974
00:36:18,079 --> 00:36:20,640


975
00:36:20,960 --> 00:36:22,640
推斷出我們的新動作

976
00:36:22,640 --> 00:36:24,320
，並返回

977
00:36:24,320 --> 00:36:26,560
自由能的

978
00:36:26,560 --> 00:36:28,240


979
00:36:28,240 --> 00:36:30,160
變化 d 然後為下一步做準備，所以在

980
00:36:30,160 --> 00:36:31,920
每一步中，我們都會向實際執行的環境提出一個動作，

981
00:36:31,920 --> 00:36:34,160
我們

982
00:36:34,160 --> 00:36:35,839
觀察一個新的結果

983
00:36:35,839 --> 00:36:37,920
，我們推斷出新的動作，

984
00:36:37,920 --> 00:36:41,680
嗯，我們評估我們在

985
00:36:41,680 --> 00:36:44,319
該動作上做得如何

986
00:36:46,480 --> 00:36:48,480
，然後你會得到很好的情節 像

987
00:36:48,480 --> 00:36:50,160
這樣，所以

988
00:36:50,160 --> 00:36:52,480
這是我們的代理的速度，

989
00:36:52,480 --> 00:36:54,240
我們從零開始，你可以看到它

990
00:36:54,240 --> 00:36:56,960
非常快速地向右移動

991
00:36:56,960 --> 00:36:57,920


992
00:36:57,920 --> 00:36:59,920
，然後

993
00:36:59,920 --> 00:37:02,240
它也向後移動一點點，

994
00:37:02,240 --> 00:37:05,200
直到末端或多或少到達一個靜止點

995
00:37:05,200 --> 00:37:06,839


996
00:37:06,839 --> 00:37:09,680
您實際上可以在這裡

997
00:37:09,680 --> 00:37:11,119
看到它的作用，所以它從 20 的溫度開始，

998
00:37:11,119 --> 00:37:13,359


999
00:37:13,359 --> 00:37:15,920
然後它非常迅速地移動到

1000
00:37:15,920 --> 00:37:17,760
遠離熱源的地方，

1001
00:37:17,760 --> 00:37:20,560
它超過了它的標記

1002
00:37:20,560 --> 00:37:22,560
，然後它實際上又回到了它，然後

1003
00:37:22,560 --> 00:37:23,920
它穩定在這個所需

1004
00:37:23,920 --> 00:37:26,320
的 4 溫度附近 嗯，我們已經按照

1005
00:37:26,320 --> 00:37:30,480
我們的目標先驗進行了編碼，

1006
00:37:31,839 --> 00:37:34,400
那麼為什麼我們

1007
00:37:34,400 --> 00:37:36,480
的環境模型並不完美呢？

1008
00:37:36,480 --> 00:37:39,119
我們有這個非常粗略的負

1009
00:37:39,119 --> 00:37:40,560
負一

1010
00:37:40,560 --> 00:37:43,040
um 估計值，而在現實世界中，這是一個非常

1011
00:37:43,040 --> 00:37:46,240
好的平滑親屬

1012
00:37:46,240 --> 00:37:47,280


1013
00:37:47,280 --> 00:37:51,680
d 具有這種鐘形的複雜函數，

1014
00:37:51,680 --> 00:37:54,000
所以即使

1015
00:37:54,000 --> 00:37:55,599
我們的環境生成模型

1016
00:37:55,599 --> 00:37:57,200
並不

1017
00:37:57,200 --> 00:37:59,520
完美，最終我們通過稍微超調來支付那筆費用，

1018
00:37:59,520 --> 00:38:01,599
但

1019
00:38:01,599 --> 00:38:04,880
我們仍然能夠達到我們的

1020
00:38:04,880 --> 00:38:06,560
在四度的溫度下達到理想狀態，

1021
00:38:06,560 --> 00:38:07,440
所以最後

1022
00:38:07,440 --> 00:38:10,720
它工作得很好

1023
00:38:10,800 --> 00:38:12,240
，你還可以看到代理的自由

1024
00:38:12,240 --> 00:38:14,880
能也隨著

1025
00:38:14,880 --> 00:38:16,880
時間的推移而減少，所以我們從一千左右開始，

1026
00:38:16,880 --> 00:38:19,680
所以這裡的比例是對數的

1027
00:38:19,680 --> 00:38:22,640
，它減少了很多 很快，我們的

1028
00:38:22,640 --> 00:38:24,720
總和值

1029
00:38:24,720 --> 00:38:27,040
相當低，然後我們有

1030
00:38:27,040 --> 00:38:29,359
一些噪音，會引起一些

1031
00:38:29,359 --> 00:38:32,320
意想不到的變化或一些意想不到的

1032
00:38:32,320 --> 00:38:34,079


1033
00:38:34,079 --> 00:38:36,079
驚喜，這就是為什麼你在這裡有這些小

1034
00:38:36,079 --> 00:38:38,240
漣漪這些小漣漪

1035
00:38:38,240 --> 00:38:39,760
但最後我們正在最大限度地減少自由能 而且

1036
00:38:39,760 --> 00:38:41,920
它正在急劇下降，

1037
00:38:41,920 --> 00:38:43,440
所以我們實際上有這個自由能量

1038
00:38:43,440 --> 00:38:47,079
最小化劑

1039
00:38:47,200 --> 00:38:48,079


1040
00:38:48,079 --> 00:38:50,880
嗯，是的，這

1041
00:38:50,880 --> 00:38:53,200
就是我所擁有的故事

1042
00:38:53,200 --> 00:38:55,759
和演示

1043
00:38:56,880 --> 00:39:00,320
，非常棒謝謝你 您非常好，我們

1044
00:39:00,320 --> 00:39:03,520
可以打開屏幕共享或不問

1045
00:39:03,520 --> 00:39:05,040
一些實時聊天中的問題，

1046
00:39:05,040 --> 00:39:07,040
並給人們幾秒鐘的時間

1047
00:39:07,040 --> 00:39:08,720
輸入更多內容，所以

1048
00:39:08,720 --> 00:39:10,160
我將先跳入

1049
00:39:10,160 --> 00:39:12,320
問題，

1050
00:39:12,320 --> 00:39:14,480
讓我停止我的屏幕截圖

1051
00:39:14,480 --> 00:39:16,640
很棒 所以我們仍然在分享屏幕

1052
00:39:16,640 --> 00:39:19,280
故事，嗯，我們只看到了 jitsies，所以

1053
00:39:19,280 --> 00:39:21,119
只需在 jitsi 中再次單擊屏幕共享按鈕

1054
00:39:21,119 --> 00:39:23,599
，

1055
00:39:25,440 --> 00:39:27,599
太棒了，謝謝，所以第一個

1056
00:39:27,599 --> 00:39:29,359


1057
00:39:29,359 --> 00:39:31,920
問題來自 john，john 寫道，

1058
00:39:31,920 --> 00:39:34,320
如果圖表，因子圖方法如何工作

1059
00:39:34,320 --> 00:39:36,960
事先不知道

1060
00:39:36,960 --> 00:39:41,079
結構 結構學習

1061
00:39:43,040 --> 00:39:44,720


1062
00:39:44,720 --> 00:39:46,800


1063
00:39:46,800 --> 00:39:49,520


1064
00:39:49,520 --> 00:39:51,839


1065
00:39:52,079 --> 00:39:54,240


1066
00:39:54,240 --> 00:39:55,520


1067
00:39:55,520 --> 00:39:57,520


1068
00:39:57,520 --> 00:39:59,599
是可能的 自動化

1069
00:39:59,599 --> 00:40:01,599
圖本身的結構學習，

1070
00:40:01,599 --> 00:40:02,880
但是那裡有很多挑戰，

1071
00:40:02,880 --> 00:40:04,400
所以你如何參數化這個圖

1072
00:40:04,400 --> 00:40:07,520
結構，或者你

1073
00:40:07,520 --> 00:40:08,960
如何做你如何做到這一點實際上是正確的

1074
00:40:08,960 --> 00:40:12,560
s 您在圖表方面的搜索空間

1075
00:40:12,560 --> 00:40:14,240


1076
00:40:14,240 --> 00:40:15,920
如果您

1077
00:40:15,920 --> 00:40:18,160
沒有為您的圖表提供正確的節點函數，您如何學習節點函數，所以

1078
00:40:18,160 --> 00:40:19,760
這些都是非常困難的問題

1079
00:40:19,760 --> 00:40:21,200
，您沒有直接的

1080
00:40:21,200 --> 00:40:23,040
答案

1081
00:40:23,040 --> 00:40:24,800
，所以這就是 為什麼

1082
00:40:24,800 --> 00:40:27,040


1083
00:40:27,040 --> 00:40:27,920
設計

1084
00:40:27,920 --> 00:40:29,359
週期中的這個實際模型設計步驟本身

1085
00:40:29,359 --> 00:40:31,440
仍然是一種創造性的過程，

1086
00:40:31,440 --> 00:40:33,359
有一個工程師必須

1087
00:40:33,359 --> 00:40:34,880
提出一個模型

1088
00:40:34,880 --> 00:40:36,560
，作為一名工程師

1089
00:40:36,560 --> 00:40:38,400
，如果你沒有，你還必須考慮如何調整該模型

1090
00:40:38,400 --> 00:40:40,240
對它感到滿意，

1091
00:40:40,240 --> 00:40:42,160
所以如果在

1092
00:40:42,160 --> 00:40:44,400
你很好地運行你的代理之後自由能仍然很高，那麼

1093
00:40:44,400 --> 00:40:45,760
你的模型出現了問題，

1094
00:40:45,760 --> 00:40:46,720
它不能準確

1095
00:40:46,720 --> 00:40:48,960
表示環境是什麼

1096
00:40:48,960 --> 00:40:50,720
，然後

1097
00:40:50,720 --> 00:40:53,599
你可以調整一下，你現在如何調整

1098
00:40:53,599 --> 00:40:55,040
它 仍然只是反複試驗

1099
00:40:55,040 --> 00:40:57,280
所以也許你可以說好吧我認為

1100
00:40:57,280 --> 00:40:58,640
這裡仍然有一些我可以

1101
00:40:58,640 --> 00:41:00,640
改進的東西也許刪除一個節點也許

1102
00:41:00,640 --> 00:41:03,598
模型太複雜

1103
00:41:04,130 --> 00:41:05,440
[音樂]

1104
00:41:05,440 --> 00:41:08,880
但是結構本身運行是嗯

1105
00:41:08,880 --> 00:41:10,800
它是一些東西 g 那

1106
00:41:10,800 --> 00:41:12,560
也是它可以解決的，所以

1107
00:41:12,560 --> 00:41:15,599
有一些方法，比如嵌套

1108
00:41:15,599 --> 00:41:17,359
模型比較和類似的事情

1109
00:41:17,359 --> 00:41:19,280
，你可以做事實上的圖表，所以你可以

1110
00:41:19,280 --> 00:41:20,800
例如如果你有一個嵌套模型

1111
00:41:20,800 --> 00:41:22,880
計算野蠻迪基比率，然後是

1112
00:41:22,880 --> 00:41:25,440
那種 基於此修剪你的模型

1113
00:41:25,440 --> 00:41:27,440
，所以你可以做這些事情

1114
00:41:27,440 --> 00:41:29,040
來找到一個複雜的模型，看看你

1115
00:41:29,040 --> 00:41:31,759
可以剪掉什麼，

1116
00:41:32,480 --> 00:41:34,000
但是添加到那個模型仍然

1117
00:41:34,000 --> 00:41:35,440
很困難，所以一旦你把它剪掉

1118
00:41:35,440 --> 00:41:37,680
了，你如何添加是的，我我

1119
00:41:37,680 --> 00:41:39,040
我不是真的不知道，所以這是一個

1120
00:41:39,040 --> 00:41:41,200
很好的問題，嗯，我沒有一個非常

1121
00:41:41,200 --> 00:41:43,040
直接的問題，你可以

1122
00:41:43,040 --> 00:41:46,319
從我的嘎嘎聲中切換，所以是的，

1123
00:41:46,800 --> 00:41:49,839
也許我可以說點什麼，嗯，

1124
00:41:49,839 --> 00:41:52,960
我的意思是我完全同意

1125
00:41:52,960 --> 00:41:55,200
我的意思是，一般來說，

1126
00:41:55,200 --> 00:41:57,520
當你設計一個

1127
00:41:57,520 --> 00:41:59,520
系統或信號處理系統時，你

1128
00:41:59,520 --> 00:42:00,839
必須設計

1129
00:42:00,839 --> 00:42:03,119
結構，你必須估計

1130
00:42:03,119 --> 00:42:05,520
參數，然後你必須正確推斷

1131
00:42:05,520 --> 00:42:08,480
狀態，狀態變化非常快，

1132
00:42:08,480 --> 00:42:11,359
它會導致一個通用濾波器，

1133
00:42:11,359 --> 00:42:13,040
這非常

1134
00:42:13,040 --> 00:42:15,599
出色地 在因子圖中已知，

1135
00:42:15,599 --> 00:42:17,920
那麼下一階段將是我們是否也可以

1136
00:42:17,920 --> 00:42:20,800
長期學習參數

1137
00:42:20,800 --> 00:42:23,200
，我們的效應圖現在可以很好地做到這一點

1138
00:42:23,200 --> 00:42:24,240


1139
00:42:24,240 --> 00:42:27,040
生物學的下一階段我的意思是

1140
00:42:27,040 --> 00:42:29,280
我們知道該結構在

1141
00:42:29,280 --> 00:42:31,440
更長的時間內也是警覺的

1142
00:42:31,440 --> 00:42:33,920
，所以 目前這

1143
00:42:33,920 --> 00:42:37,040
在公式中不起作用你可以比較像我

1144
00:42:37,040 --> 00:42:39,119
說的測試如果你有兩個例子你可以

1145
00:42:39,119 --> 00:42:41,359
比較自由能並

1146
00:42:41,359 --> 00:42:43,119
選擇最好的

1147
00:42:43,119 --> 00:42:45,359
但我們正在努力這就是我的

1148
00:42:45,359 --> 00:42:47,280
意思是我們再次領先

1149
00:42:47,280 --> 00:42:49,599
來自卡爾關於貝葉斯模型縮減的想法，

1150
00:42:49,599 --> 00:42:51,920
但是如何在

1151
00:42:51,920 --> 00:42:54,400
因子圖中實現它是一個研究項目，所以

1152
00:42:54,400 --> 00:42:55,839
我們正在

1153
00:42:55,839 --> 00:42:58,160
努力解決這個問題，我不確定

1154
00:42:58,160 --> 00:43:00,560
它會在哪裡結束，但這就是我們的目標

1155
00:43:00,560 --> 00:43:02,640
你有 phd 職位，所以你

1156
00:43:02,640 --> 00:43:04,799


1157
00:43:05,920 --> 00:43:07,920
也要把它帶回到

1158
00:43:07,920 --> 00:43:08,640


1159
00:43:08,640 --> 00:43:10,640
汽車達到最佳

1160
00:43:10,640 --> 00:43:13,040
溫度的例子，就像你每小時都

1161
00:43:13,040 --> 00:43:14,720
注意到自由能有一個顛簸，

1162
00:43:14,720 --> 00:43:16,960
然後你回到繪圖

1163
00:43:16,960 --> 00:43:18,640
板，然後 你去 向

1164
00:43:18,640 --> 00:43:20,800
那個區域那輛車上的人

1165
00:43:20,800 --> 00:43:23,200
詢問每小時發生的事情，或者我們

1166
00:43:23,200 --> 00:43:24,960
確實需要包含其他信息來源，

1167
00:43:24,960 --> 00:43:28,000
但是您擁有的模型可以

1168
00:43:28,000 --> 00:43:30,480
完成它的工作，因此您可以包含

1169
00:43:30,480 --> 00:43:32,400
房間的牆紙和其他功能

1170
00:43:32,400 --> 00:43:35,040
但這就是這種藝術和

1171
00:43:35,040 --> 00:43:36,720
工程科學，這就是為什麼

1172
00:43:36,720 --> 00:43:39,599
工作總是很有趣的原因，因為

1173
00:43:39,599 --> 00:43:41,280
在研究中，這就像讓我們

1174
00:43:41,280 --> 00:43:42,640
完成分析，

1175
00:43:42,640 --> 00:43:45,200
但確實存在整個模型嵌入其中的循環，

1176
00:43:45,200 --> 00:43:46,240


1177
00:43:46,240 --> 00:43:48,160


1178
00:43:48,160 --> 00:43:50,400
這有助於我們始終關注

1179
00:43:50,400 --> 00:43:52,160
那些

1180
00:43:52,160 --> 00:43:54,160
排除我們當前模型捕獲的

1181
00:43:54,160 --> 00:43:56,319
模式

1182
00:43:56,319 --> 00:43:57,839
這裡只是

1183
00:43:57,839 --> 00:44:00,960
聊天中的第二個問題

1184
00:44:00,960 --> 00:44:03,119


1185
00:44:03,119 --> 00:44:05,680
如果此示例中的目標溫度

1186
00:44:05,680 --> 00:44:08,079
未事先定義，因子圖

1187
00:44:08,079 --> 00:44:09,920
方法

1188
00:44:09,920 --> 00:44:11,440
如何工作 比結構

1189
00:44:11,440 --> 00:44:13,599
學習如何再次出現偏好和目標

1190
00:44:13,599 --> 00:44:16,319
導向是一個

1191
00:44:16,319 --> 00:44:19,440
很好的問題，

1192
00:44:19,920 --> 00:44:20,960
所以

1193
00:44:20,960 --> 00:44:22,560
這種

1194
00:44:22,560 --> 00:44:24,240
問題很好地涉及到誰

1195
00:44:24,240 --> 00:44:25,359
ts 目標

1196
00:44:25,359 --> 00:44:28,560
或你如何設定目標，

1197
00:44:29,680 --> 00:44:30,640
所以

1198
00:44:30,640 --> 00:44:32,560
是

1199
00:44:32,560 --> 00:44:34,560
的，簡單的答案很好，它是一個

1200
00:44:34,560 --> 00:44:36,880
工程師，它定義了

1201
00:44:36,880 --> 00:44:39,359
這個，嗯，但它也可以是一個更高級別的

1202
00:44:39,359 --> 00:44:40,319
代理

1203
00:44:40,319 --> 00:44:42,640
，進行推理並設定他的

1204
00:44:42,640 --> 00:44:44,960
目標，

1205
00:44:45,040 --> 00:44:47,599
這樣你就會得到一種

1206
00:44:47,599 --> 00:44:49,280
烏龜 從某種意義上說，一直

1207
00:44:49,280 --> 00:44:51,520
爭論下去，你可以

1208
00:44:51,520 --> 00:44:53,760
一層一層地一層

1209
00:44:53,760 --> 00:44:55,760
一層地設置目標和其他層

1210
00:44:55,760 --> 00:44:58,560
作為該層的目標等等等等，

1211
00:44:58,560 --> 00:44:59,760


1212
00:44:59,760 --> 00:45:03,280
所以這將如何在實踐中發揮作用

1213
00:45:03,280 --> 00:45:06,160
嗯，是的，這仍然是

1214
00:45:06,160 --> 00:45:08,240
積極的研究 領域

1215
00:45:08,240 --> 00:45:10,240
嗯，

1216
00:45:10,240 --> 00:45:11,920
但最終它應該歸結為

1217
00:45:11,920 --> 00:45:14,400
最小化自由能

1218
00:45:14,400 --> 00:45:16,720
，所以這就是

1219
00:45:16,720 --> 00:45:18,720
我們想要的中心主題 我們想要最小化

1220
00:45:18,720 --> 00:45:19,920
自由能

1221
00:45:19,920 --> 00:45:21,760
我們通過感知來做到 我們通過模型

1222
00:45:21,760 --> 00:45:22,880


1223
00:45:22,880 --> 00:45:26,480
學習來做到 目標

1224
00:45:26,480 --> 00:45:28,480
應該通過最小化自由能量來驅動，

1225
00:45:28,480 --> 00:45:30,240
所以你應該

1226
00:45:30,240 --> 00:45:32,240
選擇最小化能量的

1227
00:45:32,240 --> 00:45:33,680


1228
00:45:33,680 --> 00:45:34,800


1229
00:45:34,800 --> 00:45:36,640


1230
00:45:36,640 --> 00:45:38,879
目標

1231
00:45:41,280 --> 00:45:44,640
你是

1232
00:45:44,640 --> 00:45:47,119
怎麼做的

1233
00:45:47,119 --> 00:45:48,560
數據庫

1234
00:45:48,560 --> 00:45:50,960
或大型數據集

1235
00:45:50,960 --> 00:45:52,640
是可以擴展或已經

1236
00:45:52,640 --> 00:45:54,319
集成以處理那種

1237
00:45:54,319 --> 00:45:56,160
經驗數據的

1238
00:45:56,160 --> 00:45:58,319
東西，或者

1239
00:45:58,319 --> 00:45:59,760
我認為這取決於你所說

1240
00:45:59,760 --> 00:46:03,119
的大型數據集是什麼意思，

1241
00:46:03,119 --> 00:46:04,000
嗯，

1242
00:46:04,000 --> 00:46:04,800
所以

1243
00:46:04,800 --> 00:46:06,640
當我聽到大型數據集時，我通常會

1244
00:46:06,640 --> 00:46:09,200
想到 大數據之類的東西

1245
00:46:09,200 --> 00:46:11,200


1246
00:46:11,200 --> 00:46:13,359
嗯所以

1247
00:46:13,359 --> 00:46:16,800
這個工具箱是專門為動態建模而構建的，

1248
00:46:16,800 --> 00:46:18,240


1249
00:46:18,240 --> 00:46:19,359
所以現在

1250
00:46:19,359 --> 00:46:20,880


1251
00:46:20,880 --> 00:46:23,440
你的數據中有很多特徵，但它是信號

1252
00:46:23,440 --> 00:46:25,359
處理，所以數據可能會很快進入

1253
00:46:25,359 --> 00:46:27,280


1254
00:46:27,280 --> 00:46:28,720
，你有一個模型 這些數據

1255
00:46:28,720 --> 00:46:30,319
會隨著時間而變化，

1256
00:46:30,319 --> 00:46:31,119
所以

1257
00:46:31,119 --> 00:46:33,200
從這個意義上說，你想要快速進行處理

1258
00:46:33,200 --> 00:46:35,119
，所以你想要很多你想要的

1259
00:46:35,119 --> 00:46:37,599
速度，它是基於

1260
00:46:37,599 --> 00:46:39,599
速度

1261
00:46:39,599 --> 00:46:41,760
處理而不是體積處理，

1262
00:46:41,760 --> 00:46:43,839
例如其他問題編程

1263
00:46:43,839 --> 00:46:47,119
工具箱非常擅長，比如 um

1264
00:46:47,119 --> 00:46:49,359
by torch 和

1265
00:46:49,359 --> 00:46:51,599


1266
00:46:51,599 --> 00:46:53,359


1267
00:46:53,359 --> 00:46:56,640
如果你有大量

1268
00:46:56,640 --> 00:46:58,400
的數據並且你

1269
00:46:58,400 --> 00:47:00,880
有一個你想要的 iid 模型，那麼你可以使用所有很棒的工具箱。

1270
00:47:00,880 --> 00:47:03,040


1271
00:47:03,040 --> 00:47:04,960
如果

1272
00:47:04,960 --> 00:47:06,720
我們談論大數據，

1273
00:47:06,720 --> 00:47:08,720
你

1274
00:47:08,720 --> 00:47:11,599


1275
00:47:11,599 --> 00:47:14,640
想適應我們的感覺

1276
00:47:14,640 --> 00:47:17,760


1277
00:47:17,760 --> 00:47:19,040
傳遞將成為

1278
00:47:19,040 --> 00:47:21,520


1279
00:47:22,240 --> 00:47:26,319
這類數據集的炸彈

1280
00:47:26,640 --> 00:47:31,520
還有

1281
00:47:31,520 --> 00:47:34,079
一些我們真正嘗試構建這些

1282
00:47:34,079 --> 00:47:36,480
工具箱來構建積極影響

1283
00:47:36,480 --> 00:47:38,640
代理的想法以及您只需將這些

1284
00:47:38,640 --> 00:47:40,800
代理置於他們採取行動的環境中的想法

1285
00:47:40,800 --> 00:47:44,000
他們選擇自己的數據，

1286
00:47:44,000 --> 00:47:47,119
因此我們並沒有真正

1287
00:47:47,119 --> 00:47:49,040
嘗試構建一個工具箱，該工具箱非常

1288
00:47:49,040 --> 00:47:51,359
擅長僅針對固定集合數據庫進行機器學習，

1289
00:47:51,359 --> 00:47:54,160


1290
00:47:54,160 --> 00:47:56,720
而是我們嘗試構建

1291
00:47:56,720 --> 00:47:58,319
模型，

1292
00:47:58,319 --> 00:48:01,119
比如說可以適應

1293
00:48:01,119 --> 00:48:03,119
並可以採取行動的動態模型 這

1294
00:48:03,119 --> 00:48:06,559
可以實時處理流數據，

1295
00:48:06,559 --> 00:48:09,359
並且從這個意義上說，如果你等待

1296
00:48:09,359 --> 00:48:11,599
足夠長的時間，是的，有很多數據

1297
00:48:11,599 --> 00:48:13,760
流過它，

1298
00:48:13,760 --> 00:48:16,880
但它是由你生成的，或者

1299
00:48:16,880 --> 00:48:19,119
至少受到代理本身的影響，

1300
00:48:19,119 --> 00:48:21,200


1301
00:48:21,200 --> 00:48:23,839
我們不這樣做' 噸 嘗試

1302
00:48:23,839 --> 00:48:29,200
針對大型固定數據庫進行優化，而不是僅

1303
00:48:29,200 --> 00:48:32,559
針對環境中的流式數據進行優化，

1304
00:48:32,559 --> 00:48:34,480
這是一個非常有趣的點，因為

1305
00:48:34,480 --> 00:48:36,640
有很多時間相關的任務，

1306
00:48:36,640 --> 00:48:39,040
例如自動駕駛，這就像

1307
00:48:39,040 --> 00:48:42,160
好的，這裡有 500 TB 的視頻，

1308
00:48:42,160 --> 00:48:43,839
或者現在給我最好的

1309
00:48:43,839 --> 00:48:45,280


1310
00:48:45,280 --> 00:48:48,800
時間快照中的可能得分，而且

1311
00:48:48,800 --> 00:48:50,400
每次使用主動

1312
00:48:50,400 --> 00:48:52,319
推理代理時，我們總是

1313
00:48:52,319 --> 00:48:54,880
在循環中包含動作和策略選擇

1314
00:48:54,880 --> 00:48:56,480
，所以

1315
00:48:56,480 --> 00:48:58,400
我們將如何處理它，

1316
00:48:58,400 --> 00:49:00,319
但這就是為什麼來自

1317
00:49:00,319 --> 00:49:02,640
生物系統的靈感變得如此 重要的是，

1318
00:49:02,640 --> 00:49:04,559
這有點像當人們進展順利時

1319
00:49:04,559 --> 00:49:06,960
，大腦必須具有這種處理

1320
00:49:06,960 --> 00:49:09,040
能力，然後如果它是一個燈泡

1321
00:49:09,040 --> 00:49:10,559
或這種矽膠

1322
00:49:10,559 --> 00:49:11,839
計算機，它會佔用這麼多

1323
00:49:11,839 --> 00:49:14,160
能量，所以效率是這樣的，

1324
00:49:14,160 --> 00:49:16,640
但它是

1325
00:49:16,640 --> 00:49:18,720
以我們習慣看到的計算機類型為基礎，

1326
00:49:18,720 --> 00:49:20,800
而不是從

1327
00:49:20,800 --> 00:49:22,800
已經存在的東西開始，然後尋找存在

1328
00:49:22,800 --> 00:49:24,160


1329
00:49:24,160 --> 00:49:26,480
於 t 中的答案 帽子，而不是我們如何製造

1330
00:49:26,480 --> 00:49:28,800
低功率晶體管，以便我們可以

1331
00:49:28,800 --> 00:49:31,040
將它們放入大腦中

1332
00:49:31,040 --> 00:49:31,920
如此

1333
00:49:31,920 --> 00:49:34,559
棒的話題我想我們已經為下一次演示做好了準備

1334
00:49:34,559 --> 00:49:37,680


1335
00:49:39,440 --> 00:49:41,599


1336
00:49:41,599 --> 00:49:45,839


1337
00:49:47,920 --> 00:49:52,400
現在看起來不錯，

1338
00:49:52,400 --> 00:49:56,800
所以您現在可以看到我的幻燈片了

1339
00:49:56,800 --> 00:49:59,119


1340
00:49:59,119 --> 00:50:02,000


1341
00:50:02,000 --> 00:50:04,319


1342
00:50:04,319 --> 00:50:06,400


1343
00:50:06,400 --> 00:50:08,880


1344
00:50:08,880 --> 00:50:11,200
嗎 主動推理解決方案的未來願景

1345
00:50:11,200 --> 00:50:14,079
fornilab.jl 更像是

1346
00:50:14,079 --> 00:50:15,680
成熟的

1347
00:50:15,680 --> 00:50:18,800
框架，它可以工作，反應式 mp 是

1348
00:50:18,800 --> 00:50:22,720
我們目前的研究項目

1349
00:50:22,720 --> 00:50:24,400
，我們將從一個問題開始，

1350
00:50:24,400 --> 00:50:25,520


1351
00:50:25,520 --> 00:50:27,359
什麼是反應式消息

1352
00:50:27,359 --> 00:50:28,400
破壞

1353
00:50:28,400 --> 00:50:29,839
，

1354
00:50:29,839 --> 00:50:31,920
在大多數意義上它是 相同的消息

1355
00:50:31,920 --> 00:50:34,960
作為公式傳遞，但

1356
00:50:34,960 --> 00:50:37,680
在反應範式中重新實現，所以基本上色情實驗室

1357
00:50:37,680 --> 00:50:39,760
中傳統方法的主要問題

1358
00:50:39,760 --> 00:50:40,960


1359
00:50:40,960 --> 00:50:43,760
是為了

1360
00:50:43,760 --> 00:50:45,839
對我們的模型進行推理 我們需要提前創建這個

1361
00:50:45,839 --> 00:50:48,480
消息的影子，

1362
00:50:48,480 --> 00:50:50,720
所以我們需要預先分析我們的圖表，我們

1363
00:50:50,720 --> 00:50:53,119
需要基本上分析所有內容，

1364
00:50:53,119 --> 00:50:55,200
我們需要在每次更改圖表結構時都這樣做

1365
00:50:55,200 --> 00:50:57,200


1366
00:50:57,200 --> 00:51:00,480
，如果圖表很大，這個圖表分析

1367
00:51:00,480 --> 00:51:02,319
時間和 陰影創建可能需要

1368
00:51:02,319 --> 00:51:04,240
很多額外的時間

1369
00:51:04,240 --> 00:51:07,280
，這可能不是一個大問題，但作為

1370
00:51:07,280 --> 00:51:09,200
一名工程師，您可能想要測試

1371
00:51:09,200 --> 00:51:11,359
很多模型，直到您

1372
00:51:11,359 --> 00:51:14,079
對性能以及這些額外的延遲

1373
00:51:14,079 --> 00:51:16,079
和穿梭創建時間

1374
00:51:16,079 --> 00:51:19,680
感到滿意為止 最後傳遞一些煩人和反應性的

1375
00:51:19,680 --> 00:51:21,520
消息使我們能夠

1376
00:51:21,520 --> 00:51:24,400
消除這種預定義的陰影，

1377
00:51:24,400 --> 00:51:26,240
它還為我們提供了許多其他好處

1378
00:51:26,240 --> 00:51:30,400
和可能的未來研究方向，

1379
00:51:30,400 --> 00:51:32,880
因此

1380
00:51:32,880 --> 00:51:35,839
我們將圖表投射到喜歡事件而不是固定陰影而不是固定陰影

1381
00:51:35,839 --> 00:51:37,760
-基於系統

1382
00:51:37,760 --> 00:51:39,520
，其中所有事物都可以對其鄰居環境做出反應，

1383
00:51:39,520 --> 00:51:41,119


1384
00:51:41,119 --> 00:51:43,440
並且就消息傳遞而言，

1385
00:51:43,440 --> 00:51:45,920
節點對傳入消息做出反應，

1386
00:51:45,920 --> 00:51:48,319
並且它還對我們參數的更新後邊緣做出反應

1387
00:51:48,319 --> 00:51:50,800


1388
00:51:50,800 --> 00:51:53,760
d 整個模型變得被動我們

1389
00:51:53,760 --> 00:51:56,319
也可以對這個系統的變化做出反應

1390
00:51:56,319 --> 00:51:58,960
，基本上做我們想做的任何事情，所以我們

1391
00:51:58,960 --> 00:52:00,800
可以

1392
00:52:00,800 --> 00:52:04,800
根據新更新的後邊際執行一些動作，

1393
00:52:04,800 --> 00:52:07,680
它也在消息中傳遞一個自然的

1394
00:52:07,680 --> 00:52:11,280
起點呃是我們的數據或

1395
00:52:11,280 --> 00:52:14,400
觀察結果和 模型本身

1396
00:52:14,400 --> 00:52:18,559
會對我們的數據或先驗數據的變化做出反應

1397
00:52:18,559 --> 00:52:20,319
，它也會相應地改變後驗數據

1398
00:52:20,319 --> 00:52:23,040
，

1399
00:52:23,040 --> 00:52:26,480
所以在這裡我概述

1400
00:52:26,480 --> 00:52:27,760
了主動消息被動

1401
00:52:27,760 --> 00:52:29,839
實現的一些額外好處，所以首先我們可以

1402
00:52:29,839 --> 00:52:32,400
概述生物學上的合理性，

1403
00:52:32,400 --> 00:52:34,480
因為在自然界中我們可能沒有

1404
00:52:34,480 --> 00:52:36,800
任何預定義的調度程序，用於我們的

1405
00:52:36,800 --> 00:52:39,440
信息在我們大腦中的神經元上流動

1406
00:52:39,440 --> 00:52:41,520
，例如

1407
00:52:41,520 --> 00:52:43,920
，它們是由某種

1408
00:52:43,920 --> 00:52:46,960
化學（如物理學）驅動的，從某種意義上說，它

1409
00:52:46,960 --> 00:52:49,200
就像反應系統一樣，它不斷

1410
00:52:49,200 --> 00:52:52,240
適應環境的變化

1411
00:52:52,240 --> 00:52:55,599
，而且它僅在需要時才做出反應

1412
00:52:55,599 --> 00:52:57,359
就基於消息傳遞的

1413
00:52:57,359 --> 00:52:59,520
推理而言，如果它們不是，甚至可能不需要

1414
00:52:59,520 --> 00:53:02,400
對某些事件（例如某些消息）做出反應

1415
00:53:02,400 --> 00:53:05,760
非常重要

1416
00:53:05,760 --> 00:53:08,240
uh 一個固定的預定義陰影，

1417
00:53:08,240 --> 00:53:10,480
即使

1418
00:53:10,480 --> 00:53:13,280
您並不真的需要它們，您也必須進行所有計算

1419
00:53:13,280 --> 00:53:15,040


1420
00:53:15,040 --> 00:53:17,040


1421
00:53:17,040 --> 00:53:19,599


1422
00:53:19,599 --> 00:53:22,319
問題，

1423
00:53:22,319 --> 00:53:24,559
所以它支持數

1424
00:53:24,559 --> 00:53:26,800
十萬個因子註釋，甚至數百萬個

1425
00:53:26,800 --> 00:53:29,040
是可能

1426
00:53:29,040 --> 00:53:30,559


1427
00:53:30,559 --> 00:53:32,800


1428
00:53:32,800 --> 00:53:35,359


1429
00:53:35,359 --> 00:53:38,559
的 已知線線性動力學

1430
00:53:38,559 --> 00:53:40,559
，想法是在這個例子中估計轎車

1431
00:53:40,559 --> 00:53:43,520
狀態給定嘈雜的觀察

1432
00:53:43,520 --> 00:53:45,520
我使用卡爾曼平滑

1433
00:53:45,520 --> 00:53:47,280
器和 50 000 個

1434
00:53:47,280 --> 00:53:49,680
觀察值，這個模型包含

1435
00:53:49,680 --> 00:53:53,280
大約 150 000 個因子節點，

1436
00:53:53,280 --> 00:53:55,040
因此對這種

1437
00:53:55,040 --> 00:53:57,839
模型的貝葉斯推斷在採樣時是不可能的 基於

1438
00:53:57,839 --> 00:53:59,520
推理，

1439
00:53:59,520 --> 00:54:01,200
但通過響應式消息傳遞，

1440
00:54:01,200 --> 00:54:03,119
僅

1441
00:54:03,119 --> 00:54:06,480
在家用 macbook 筆記本電腦上只需大約 8 秒，

1442
00:54:06,480 --> 00:54:09,480


1443
00:54:10,559 --> 00:54:12,720
因此我們可以更進一步並製作

1444
00:54:12,720 --> 00:54:14,880
響應式系統 tem 健壯且能夠容忍

1445
00:54:14,880 --> 00:54:17,760
某些情況，比如說失敗的節點或丟失的

1446
00:54:17,760 --> 00:54:18,960
數據

1447
00:54:18,960 --> 00:54:21,760
，比如說失敗的傳感器

1448
00:54:21,760 --> 00:54:23,920
我們修復預定義的陰影如果發生

1449
00:54:23,920 --> 00:54:25,440
這種情況我們需要

1450
00:54:25,440 --> 00:54:27,200
從頭開始做所有事情

1451
00:54:27,200 --> 00:54:29,280
我們需要重新創建我們的模型我們需要

1452
00:54:29,280 --> 00:54:31,839
再次製作一個陰影

1453
00:54:31,839 --> 00:54:34,240
，它會 只需要一些時間來

1454
00:54:34,240 --> 00:54:36,960
處理反應性消息，我們可能會

1455
00:54:36,960 --> 00:54:39,599
停止對一些丟失的數據

1456
00:54:39,599 --> 00:54:42,160
或傳感器故障做出反應

1457
00:54:42,160 --> 00:54:44,160
，我們可以等待它們

1458
00:54:44,160 --> 00:54:46,160
再次可用，

1459
00:54:46,160 --> 00:54:48,319
從這個意義上說它非常強大，它

1460
00:54:48,319 --> 00:54:50,799
也讓我們有機會改變

1461
00:54:50,799 --> 00:54:53,440
我們的圖表 運行時的結構

1462
00:54:53,440 --> 00:54:55,440
並且仍然執行推理而不

1463
00:54:55,440 --> 00:54:57,920
停止

1464
00:54:58,880 --> 00:55:01,599
所以有一張幻燈片關於我們實際上

1465
00:55:01,599 --> 00:55:02,720
是如何做的，

1466
00:55:02,720 --> 00:55:04,799
我們在我們的實驗室中使用 julia 的主要編程語言

1467
00:55:04,799 --> 00:55:07,920
大約一年

1468
00:55:07,920 --> 00:55:09,839
半我相信之前

1469
00:55:09,839 --> 00:55:11,440
我們在 julia 中編寫了用於反應式編程的庫，

1470
00:55:11,440 --> 00:55:13,599
所以它完全

1471
00:55:13,599 --> 00:55:15,359
僅在基於事件的系統的通用框架中與消息傳遞無關，

1472
00:55:15,359 --> 00:55:17,200


1473
00:55:17,200 --> 00:55:18,240


1474
00:55:18,240 --> 00:55:20,640
但這允許我們

1475
00:55:20,640 --> 00:55:24,160
稍後構建反應式 mp.jl 包

1476
00:55:24,160 --> 00:55:25,680
它

1477
00:55:25,680 --> 00:55:29,359
通過消息傳遞實現自由能最小化

1478
00:55:29,359 --> 00:55:31,599
我們還引入了graphpl.gel包

1479
00:55:31,599 --> 00:55:33,520
，它是一種高級且用戶友好的

1480
00:55:33,520 --> 00:55:35,119
概率模型規範

1481
00:55:35,119 --> 00:55:38,640
語言，我們在演示中使用

1482
00:55:38,640 --> 00:55:41,040
嗯是的，我

1483
00:55:41,040 --> 00:55:43,119
想向您展示一個

1484
00:55:43,119 --> 00:55:45,119
示例 第二個

1485
00:55:45,119 --> 00:55:47,599
這樣你就可以看到我的屏幕

1486
00:55:47,599 --> 00:55:49,119


1487
00:55:49,119 --> 00:55:53,040


1488
00:55:53,440 --> 00:55:56,799


1489
00:55:56,799 --> 00:55:58,240


1490
00:55:58,240 --> 00:56:02,759


1491
00:56:02,799 --> 00:56:04,960


1492
00:56:04,960 --> 00:56:07,599


1493
00:56:07,599 --> 00:56:10,720
了 是我們的例子，所以假設我們有

1494
00:56:10,720 --> 00:56:11,520
一些

1495
00:56:11,520 --> 00:56:14,240
移動的物體，呃，

1496
00:56:14,240 --> 00:56:16,079
它有一些隱藏狀態，為了簡單起見，我們只

1497
00:56:16,079 --> 00:56:18,400
假設我們知道它是線性動力學

1498
00:56:18,400 --> 00:56:21,200
，我們不知道我們

1499
00:56:21,200 --> 00:56:23,359
沒有直接訪問它的位置，但是

1500
00:56:23,359 --> 00:56:25,200
我們有一個嘈雜的觀察 這個

1501
00:56:25,200 --> 00:56:26,480
移動物體

1502
00:56:26,480 --> 00:56:28,799
，我們希望

1503
00:56:28,799 --> 00:56:31,599
僅通過觀察它的噪聲測量來估計這個移動物體的真實位置

1504
00:56:31,599 --> 00:56:35,040


1505
00:56:35,040 --> 00:56:38,160
，我們可以使用線性多元

1506
00:56:38,160 --> 00:56:41,119
高斯狀態空間模型，

1507
00:56:41,119 --> 00:56:44,000
比如方程看起來像這樣這些 ar

1508
00:56:44,000 --> 00:56:46,480
等價的符號它們是相同的

1509
00:56:46,480 --> 00:56:48,960
，基本上在這裡我們說，嗯，好吧，

1510
00:56:48,960 --> 00:56:52,400
我們在時間步 k 有一個狀態 x

1511
00:56:52,400 --> 00:56:54,400
，它只取決於

1512
00:56:54,400 --> 00:56:55,920


1513
00:56:55,920 --> 00:56:58,400
通過一些線性算子 a 的前一個時間步，我們

1514
00:56:58,400 --> 00:57:00,880
還有一個高斯的過渡噪聲

1515
00:57:00,880 --> 00:57:03,599
使用協方差矩陣 b 並且

1516
00:57:03,599 --> 00:57:06,000
我們的觀察結果

1517
00:57:06,000 --> 00:57:07,200


1518
00:57:07,200 --> 00:57:10,319
基本上也被建模為具有

1519
00:57:10,319 --> 00:57:11,040


1520
00:57:11,040 --> 00:57:12,960
協方差矩陣 q 的高斯，

1521
00:57:12,960 --> 00:57:15,520
所以基本上這是我們的模型

1522
00:57:15,520 --> 00:57:17,599
，我們可以簡單地從中創建一個因子

1523
00:57:17,599 --> 00:57:19,440
圖，

1524
00:57:19,440 --> 00:57:21,040
並且您可以看到

1525
00:57:21,040 --> 00:57:22,240


1526
00:57:22,240 --> 00:57:25,359
我們的模型規範非常

1527
00:57:25,359 --> 00:57:27,760
類似於 上面定義的方程，

1528
00:57:27,760 --> 00:57:29,359
所以這裡我們有

1529
00:57:29,359 --> 00:57:32,240
我們的狀態 xk 並且它被建模為像

1530
00:57:32,240 --> 00:57:35,040
先前狀態的高斯一樣，其中一些

1531
00:57:35,040 --> 00:57:38,240
假設是已知的協方差矩陣

1532
00:57:38,240 --> 00:57:40,400
，這就是我們構建模型的方式，

1533
00:57:40,400 --> 00:57:42,400
並且在引擎蓋下，這段

1534
00:57:42,400 --> 00:57:45,359
代碼生成因子圖

1535
00:57:45,359 --> 00:57:48,319
，我們可以 以後都可以使用

1536
00:57:48,319 --> 00:57:49,359
響應式

1537
00:57:49,359 --> 00:57:51,839
mp.jail api 來估計

1538
00:57:51,839 --> 00:57:54,000
我們系統的隱藏狀態，但這是我們的示例，它

1539
00:57:54,000 --> 00:57:55,760
看起來有點不對勁，

1540
00:57:55,760 --> 00:57:59,119
可能是因為我放大了一點，

1541
00:57:59,119 --> 00:58:01,599
但沒關係，我

1542
00:58:01,599 --> 00:58:04,400
相信 在這個例子中，我

1543
00:58:04,400 --> 00:58:07,119
對 500 個點執行了卡爾曼平滑器，我只是

1544
00:58:07,119 --> 00:58:08,720
將

1545
00:58:08,720 --> 00:58:10,480
這個移動對象的軌跡分解為

1546
00:58:10,480 --> 00:58:13,359
兩個軸 x 軸和 y 軸

1547
00:58:13,359 --> 00:58:14,880
，我們可以看到

1548
00:58:14,880 --> 00:58:17,440


1549
00:58:17,440 --> 00:58:19,359
像我們系統的真實隱藏狀態一樣

1550
00:58:19,359 --> 00:58:21,599
正確預測的常見

1551
00:58:21,599 --> 00:58:23,200
平滑器 雖然我們的系統中有很多噪音，

1552
00:58:23,200 --> 00:58:25,440
所以這些藍點就像

1553
00:58:25,440 --> 00:58:28,480
我們的嘈雜觀察

1554
00:58:28,480 --> 00:58:31,440
，我們可以走得更遠，

1555
00:58:31,440 --> 00:58:34,240
因為我們的系統是反應性的，我們

1556
00:58:34,240 --> 00:58:37,760
可以實時估計我們的狀態，

1557
00:58:37,760 --> 00:58:38,799


1558
00:58:38,799 --> 00:58:41,839
所以這是我們的例子 讓我嘗試運行

1559
00:58:41,839 --> 00:58:43,839
它，

1560
00:58:43,839 --> 00:58:46,319
嗯，我希望它在我的計算機上看起來很流暢，

1561
00:58:46,319 --> 00:58:48,559
實際上非常流暢，

1562
00:58:48,559 --> 00:58:51,200
但我知道

1563
00:58:51,200 --> 00:58:53,520
錄製可能不像屏幕共享那樣流暢，

1564
00:58:53,520 --> 00:58:56,480
但在這個例子中，我們

1565
00:58:56,480 --> 00:58:58,559
看到的是，好的，我們有一個無限的

1566
00:58:58,559 --> 00:59:01,040
數據流 運動物體的藍色

1567
00:59:01,040 --> 00:59:02,559
是真實的，紅色是

1568
00:59:02,559 --> 00:59:05,440
估計的，我們可以看到，嗯，

1569
00:59:05,440 --> 00:59:07,760
是的，讓我重新加載它，因為它

1570
00:59:07,760 --> 00:59:10,559
有點關閉

1571
00:59:10,720 --> 00:59:13,680
，我們可以看到

1572
00:59:13,920 --> 00:59:16,160
反應式 mp 能夠執行和

1573
00:59:16,160 --> 00:59:18,640
貝葉斯推理 i  n 實時

1574
00:59:18,640 --> 00:59:21,359
，它實際上適應了

1575
00:59:21,359 --> 00:59:23,760
環境的變化，也改變

1576
00:59:23,760 --> 00:59:27,200
了當前估計狀態的後驗

1577
00:59:27,200 --> 00:59:28,559


1578
00:59:28,559 --> 00:59:30,480
，我們可以走得更遠你可能會

1579
00:59:30,480 --> 00:59:32,880
注意到這裡的這條橙色線現在只是

1580
00:59:32,880 --> 00:59:35,520
不活動的，但我們也可以

1581
00:59:35,520 --> 00:59:38,640
結合

1582
00:59:38,640 --> 00:59:41,440
這個模型的預測，所以 我們可以只是我們可以

1583
00:59:41,440 --> 00:59:44,160
擴展一點我們的圖表

1584
00:59:44,160 --> 00:59:47,280
，我們也可以像這樣預測我們系統的未來狀態，

1585
00:59:47,280 --> 00:59:49,119


1586
00:59:49,119 --> 00:59:50,240


1587
00:59:50,240 --> 00:59:52,799
所以現在在這個例子中，我

1588
00:59:52,799 --> 00:59:55,119
實時進行貝葉斯推理，我

1589
00:59:55,119 --> 00:59:57,760
還預測我的系統的未來狀態，

1590
00:59:57,760 --> 01:00:00,160
比如橙色

1591
01:00:00,160 --> 01:00:02,319
和 你可以看到預測也

1592
01:00:02,319 --> 01:00:04,960
適應了新的觀察

1593
01:00:04,960 --> 01:00:08,240
，是的，它基本上改變了

1594
01:00:08,240 --> 01:00:09,520


1595
01:00:09,520 --> 01:00:12,720
它對未來狀態的未來信念，

1596
01:00:12,720 --> 01:00:14,559
嗯，是的，

1597
01:00:14,559 --> 01:00:16,720
讓我停止它並繼續

1598
01:00:16,720 --> 01:00:19,439
演示，

1599
01:00:21,040 --> 01:00:23,119
所以嗯，

1600
01:00:23,119 --> 01:00:25,040
是的，我將

1601
01:00:25,040 --> 01:00:27,200
談論當反應性消息傳遞

1602
01:00:27,200 --> 01:00:30,000
可用時 實際上它已經在工作了，

1603
01:00:30,000 --> 01:00:32,480
我們有一個完全工作的穩定

1604
01:00:32,480 --> 01:00:34,480
反手和 api，用於精確和

1605
01:00:34,480 --> 01:00:36,799
變分貝葉斯推理，我們也

1606
01:00:36,799 --> 01:00:39,280
支持期望傳播，但是 在

1607
01:00:39,280 --> 01:00:44,079
api 上還不穩定，所以它可能會改變

1608
01:00:44,079 --> 01:00:46,799
我們現在只支持

1609
01:00:46,799 --> 01:00:48,960
指數族的共軛模型

1610
01:00:48,960 --> 01:00:50,799
我們支持

1611
01:00:50,799 --> 01:00:53,680
變化優化過程的額外約束，

1612
01:00:53,680 --> 01:00:55,599
例如形式或分解

1613
01:00:55,599 --> 01:00:56,880
約束，

1614
01:00:56,880 --> 01:00:59,440
所以 Rocket.jl 庫它自然

1615
01:00:59,440 --> 01:01:01,280
支持無限數據流，

1616
01:01:01,280 --> 01:01:03,599
例如來自互聯網 或者來自一些

1617
01:01:03,599 --> 01:01:05,280
傳感器

1618
01:01:05,280 --> 01:01:07,680
和框架本身能夠處理

1619
01:01:07,680 --> 01:01:09,280
丟失的數據，

1620
01:01:09,280 --> 01:01:10,480
但是這個

1621
01:01:10,480 --> 01:01:14,960
api 在這裡還不穩定

1622
01:01:16,079 --> 01:01:17,040


1623
01:01:17,040 --> 01:01:19,520
，我們對這個平台的一些未來計劃，

1624
01:01:19,520 --> 01:01:22,400
所以我們想擴展它以

1625
01:01:22,400 --> 01:01:24,720
支持非共軛模型，

1626
01:01:24,720 --> 01:01:26,960
基本上外國實驗室已經支持

1627
01:01:26,960 --> 01:01:28,079
它

1628
01:01:28,079 --> 01:01:30,319
我們只需要小心地將

1629
01:01:30,319 --> 01:01:32,160
所有可用的現有功能

1630
01:01:32,160 --> 01:01:35,599
從外國實驗室移植到反應式 mp

1631
01:01:35,599 --> 01:01:37,680
，我們還希望與

1632
01:01:37,680 --> 01:01:39,440


1633
01:01:39,440 --> 01:01:42,960
7 月社區

1634
01:01:43,520 --> 01:01:45,359
反應式消息傳遞中存在的其他概率編程庫集成，這使我們有

1635
01:01:45,359 --> 01:01:47,280
機會

1636
01:01:47,280 --> 01:01:50,480
嘗試集成並行推理

1637
01:01:50,480 --> 01:01:52,079
和反應 圖的不同部分

1638
01:01:52,079 --> 01:01:53,920
同時使用類似

1639
01:01:53,920 --> 01:01:57,280
的多核功能 對於我們的 CPU

1640
01:01:57,280 --> 01:01:58,079
呃，

1641
01:01:58,079 --> 01:01:59,839
我們想擴展

1642
01:01:59,839 --> 01:02:02,640
圖形 ppl 以支持模塊化模型

1643
01:02:02,640 --> 01:02:04,880
規範，不幸的是，

1644
01:02:04,880 --> 01:02:07,839


1645
01:02:08,960 --> 01:02:11,200
反應式消息傳遞自然也不可能

1646
01:02:11,200 --> 01:02:13,039
讓我們有機會

1647
01:02:13,039 --> 01:02:15,280
在不同數據

1648
01:02:15,280 --> 01:02:19,280
流具有不同更新率的情況下運行推理，

1649
01:02:19,280 --> 01:02:21,359
嗯

1650
01:02:21,359 --> 01:02:22,960
，我在說什麼

1651
01:02:22,960 --> 01:02:25,520
關於魯棒性的一開始，但

1652
01:02:25,520 --> 01:02:27,920
也很有趣，我們可以將它推到多遠

1653
01:02:27,920 --> 01:02:30,319
，也許可以

1654
01:02:30,319 --> 01:02:32,480


1655
01:02:32,480 --> 01:02:35,039
根據自由能在運行時自動調整模型的圖形結構，

1656
01:02:35,039 --> 01:02:37,520


1657
01:02:38,000 --> 01:02:39,839
但這就像一個研究項目，我們

1658
01:02:39,839 --> 01:02:41,520
真的不知道它是否可能

1659
01:02:41,520 --> 01:02:43,599


1660
01:02:43,599 --> 01:02:45,440
現在，我們對

1661
01:02:45,440 --> 01:02:47,280


1662
01:02:47,280 --> 01:02:49,359
基於消息傳遞的算法

1663
01:02:49,359 --> 01:02:50,960
和自由能最小

1664
01:02:50,960 --> 01:02:53,520
化可視化的交互式可視化有了一些想法

1665
01:02:53,520 --> 01:02:56,400
，最終我們計劃

1666
01:02:56,400 --> 01:02:58,799
將這個新平台作為公式的穩定

1667
01:02:58,799 --> 01:03:01,280
版本發布，可能

1668
01:03:01,280 --> 01:03:03,200
在 2.0 中

1669
01:03:03,200 --> 01:03:05,280
，這基本上就是我

1670
01:03:05,280 --> 01:03:07,039
想向你展示的一切 在我的幻燈片中，

1671
01:03:07,039 --> 01:03:08,319
感謝您的關注，

1672
01:03:08,319 --> 01:03:12,079
我很樂意回答您的問題

1673
01:03:13,760 --> 01:03:16,640
非常棒的第一個問題是是否有

1674
01:03:16,640 --> 01:03:18,680
關於這個 reactivemp.jl 的論文，

1675
01:03:18,680 --> 01:03:22,720
或者它是如何

1676
01:03:22,720 --> 01:03:25,760
工作的，但它正在進行中，所以

1677
01:03:25,760 --> 01:03:27,920
它不公開，但

1678
01:03:27,920 --> 01:03:30,240
我們正在努力，所以

1679
01:03:30,240 --> 01:03:31,920
最終會有關於

1680
01:03:31,920 --> 01:03:33,599
我將描述的所有這些方法的論文

1681
01:03:33,599 --> 01:03:36,960
它是如何工作的以及我們如何使用它，所以是的，我的

1682
01:03:36,960 --> 01:03:39,039
意思是，當然，如果有人給我們寫

1683
01:03:39,039 --> 01:03:41,599
一封電子郵件，想要一份早期的論文副本，

1684
01:03:41,599 --> 01:03:44,240
我很樂意分享它，如果它

1685
01:03:44,240 --> 01:03:45,599
保持

1686
01:03:45,599 --> 01:03:49,359
機密，我很樂意分享它

1687
01:03:49,520 --> 01:03:50,799


1688
01:03:50,799 --> 01:03:51,920


1689
01:03:51,920 --> 01:03:54,559
可能對其他作者來說非常有趣的發展，

1690
01:03:54,559 --> 01:03:55,760
比如

1691
01:03:55,760 --> 01:03:56,799


1692
01:03:56,799 --> 01:03:58,480


1693
01:03:58,480 --> 01:04:01,839
福尼實驗室的其他時代，

1694
01:04:01,839 --> 01:04:02,799
嗯

1695
01:04:02,799 --> 01:04:05,440
，我們是如何接觸到這種反應式

1696
01:04:05,440 --> 01:04:07,200
編程範式的，而且

1697
01:04:07,200 --> 01:04:09,039
看起來你在實驗室裡做了很多關於反應式編程的基礎

1698
01:04:09,039 --> 01:04:10,480
工作

1699
01:04:10,480 --> 01:04:13,039


1700
01:04:13,039 --> 01:04:14,400
是 只是在 julia

1701
01:04:14,400 --> 01:04:17,119
實現或更概念化的

1702
01:04:17,119 --> 01:04:19,599
基礎上，

1703
01:04:19,599 --> 01:04:20,559
嗯，

1704
01:04:20,559 --> 01:04:22,559
是的，我們實際上做了很多

1705
01:04:22,559 --> 01:04:24,720
工作來支持 julia 中的響應式編程，

1706
01:04:24,720 --> 01:04:28,559
基本上 julia 就像一門年輕的

1707
01:04:28,559 --> 01:04:30,960
語言，它沒有

1708
01:04:30,960 --> 01:04:33,839
l 擁有運行

1709
01:04:33,839 --> 01:04:36,960
基於響應式系統的良好能力，所以基本上我們

1710
01:04:36,960 --> 01:04:39,599
從頭開始構建它

1711
01:04:39,599 --> 01:04:42,640
是的，但是我們使用了很多呃，

1712
01:04:42,640 --> 01:04:43,760
比如說我們有經驗

1713
01:04:43,760 --> 01:04:46,240
的其他編程語言的想法

1714
01:04:46,240 --> 01:04:50,240


1715
01:04:53,200 --> 01:04:55,119
我的意思是我知道積極影響

1716
01:04:55,119 --> 01:04:57,200
社區呃

1717
01:04:57,200 --> 01:05:00,559
matlab 和 matlab 非常棒，

1718
01:05:00,559 --> 01:05:02,160


1719
01:05:02,160 --> 01:05:05,280
但如果你真的想要實時

1720
01:05:05,280 --> 01:05:09,119
處理流數據，那麼 julia

1721
01:05:09,119 --> 01:05:10,720
是一個非常

1722
01:05:10,720 --> 01:05:13,839
好的選擇，因為

1723
01:05:13,839 --> 01:05:16,480
從用戶的角度來看，julia 幾乎具有 matlab 的語法，

1724
01:05:16,480 --> 01:05:17,680


1725
01:05:17,680 --> 01:05:19,039


1726
01:05:19,039 --> 01:05:21,520
但開箱即用它幾乎

1727
01:05:21,520 --> 01:05:23,119
和

1728
01:05:23,119 --> 01:05:25,920
c 所以這是一個更好的組合，

1729
01:05:25,920 --> 01:05:27,680
如果你從事工程並且你

1730
01:05:27,680 --> 01:05:29,280
真的想要構建

1731
01:05:29,280 --> 01:05:31,599
實時運行的系統，你

1732
01:05:31,599 --> 01:05:34,640
想要製作演示，並且 julia 是一種更好的

1733
01:05:34,640 --> 01:05:37,920
語言，嗯，dimitri 還使用

1734
01:05:37,920 --> 01:05:41,760
了 julia 中的一些非常先進的東西

1735
01:05:41,760 --> 01:05:43,280
它被稱為多次調度，但它

1736
01:05:43,280 --> 01:05:44,720
是什麼並不重要

1737
01:05:44,720 --> 01:05:46,960
，但它非常先進

1738
01:05:46,960 --> 01:05:48,160
，它

1739
01:05:48,160 --> 01:05:51,359
在 matlab 中不可用，但它

1740
01:05:51,359 --> 01:05:53,760
對於我們所做的事情非常有用

1741
01:05:53,760 --> 01:05:55,520


1742
01:05:55,520 --> 01:05:59,039
工具箱

1743
01:05:59,039 --> 01:06:01,599
如果您查看圖表和

1744
01:06:01,599 --> 01:06:04,240
傳遞它的

1745
01:06:04,240 --> 01:06:05,680
消息，

1746
01:06:05,680 --> 01:06:07,839


1747
01:06:07,839 --> 01:06:09,359
它似乎是

1748
01:06:09,359 --> 01:06:11,680


1749
01:06:11,680 --> 01:06:14,880


1750
01:06:14,880 --> 01:06:18,640
這樣的 .net，它很棒，但它

1751
01:06:18,640 --> 01:06:21,200
不是一個真正的實時工具箱，

1752
01:06:21,200 --> 01:06:24,799
嗯，據我們所知

1753
01:06:24,799 --> 01:06:26,400
，目前對我們來說競爭並不多，

1754
01:06:26,400 --> 01:06:28,079


1755
01:06:28,079 --> 01:06:30,240
不是我們的工具箱非常先進

1756
01:06:30,240 --> 01:06:31,359
，但

1757
01:06:31,359 --> 01:06:33,680
我沒有看到 很多人在

1758
01:06:33,680 --> 01:06:36,720
做這個我看到很多人在

1759
01:06:36,720 --> 01:06:38,799
做多車採樣，但是多車

1760
01:06:38,799 --> 01:06:41,359
採樣不適用於

1761
01:06:41,359 --> 01:06:43,920
系統的大小和

1762
01:06:43,920 --> 01:06:45,680
我們想要通過主動推理來處理的實時數據流，我們

1763
01:06:45,680 --> 01:06:48,480


1764
01:06:48,480 --> 01:06:50,079
正在使用 我們想要

1765
01:06:50,079 --> 01:06:53,119
採取行動並影響我們的數據的系統

1766
01:06:53,119 --> 01:06:55,359
所以這是一個實時系統

1767
01:06:55,359 --> 01:06:56,240


1768
01:06:56,240 --> 01:06:59,119
嗯所以我們必須去

1769
01:06:59,119 --> 01:07:01,520
想要真正擴大我們必須去

1770
01:07:01,520 --> 01:07:02,640


1771
01:07:02,640 --> 01:07:05,039
構建一個真正高質量的專業

1772
01:07:05,039 --> 01:07:06,640
工具箱

1773
01:07:06,640 --> 01:07:09,599
來自動化消息傳遞我希望

1774
01:07:09,599 --> 01:07:12,160
這個 將是呃這些工具箱之一

1775
01:07:12,160 --> 01:07:13,839
，希望也將是其他

1776
01:07:13,839 --> 01:07:15,280
工具箱，但是

1777
01:07:15,280 --> 01:07:18,400
是的，這就是為什麼我們正在做這個

1778
01:07:18,400 --> 01:07:21,760
非常有趣的答案

1779
01:07:21,760 --> 01:07:23,440


1780
01:07:23,440 --> 01:07:25,119


1781
01:07:25,119 --> 01:07:27,200
，數學和編程和計算機

1782
01:07:27,200 --> 01:07:28,880
科學方面之間的對話，然後是主動

1783
01:07:28,880 --> 01:07:32,559
推理方面，就像

1784
01:07:32,559 --> 01:07:34,240
每個人都有什麼 側面有所貢獻，因為聽起來

1785
01:07:34,240 --> 01:07:36,240


1786
01:07:36,240 --> 01:07:38,480
主動推理的一些實時見解有點

1787
01:07:38,480 --> 01:07:40,319
傳播回算法的設計

1788
01:07:40,319 --> 01:07:42,559
，然後

1789
01:07:42,559 --> 01:07:44,319
我們看到了兩個方向，所以

1790
01:07:44,319 --> 01:07:46,480
這對你們每個人或每個人來說可能是如何發揮作用的

1791
01:07:46,480 --> 01:07:48,880


1792
01:07:49,359 --> 01:07:52,720
也可以

1793
01:07:52,720 --> 01:07:54,960
從

1794
01:07:54,960 --> 01:07:57,200


1795
01:07:57,200 --> 01:07:59,039


1796
01:07:59,039 --> 01:08:02,000
我的角度回答這個問題

1797
01:08:02,000 --> 01:08:03,359


1798
01:08:03,359 --> 01:08:05,920


1799
01:08:05,920 --> 01:08:07,440


1800
01:08:07,440 --> 01:08:10,400
當然，它也反映

1801
01:08:10,400 --> 01:08:13,200
了我們對軟件的設計選擇，

1802
01:08:13,200 --> 01:08:16,158
所以有點，但有時

1803
01:08:16,158 --> 01:08:18,640
很難將這種高級

1804
01:08:18,640 --> 01:08:21,040
數學思想與實際相適應

1805
01:08:21,040 --> 01:08:22,560
實施

1806
01:08:22,560 --> 01:08:25,120
，而且很難使其

1807
01:08:25,120 --> 01:08:26,799
高效，

1808
01:08:26,799 --> 01:08:28,960
所以

1809
01:08:31,359 --> 01:08:34,319
是的，我們不是，呃，我們還沒有完成

1810
01:08:34,319 --> 01:08:37,040
這個，嗯，我的意思是工具箱

1811
01:08:37,040 --> 01:08:39,040
可供任何人使用，

1812
01:08:39,040 --> 01:08:41,198
所有漂亮的領域示例，

1813
01:08:41,198 --> 01:08:44,080
基本恆溫器，井字遊戲，

1814
01:08:44,080 --> 01:08:46,080
一切都有效 非常順利，

1815
01:08:46,080 --> 01:08:48,318


1816
01:08:49,198 --> 01:08:51,519
我們的

1817
01:08:51,759 --> 01:08:54,158
希望是，通過響應式消息

1818
01:08:54,158 --> 01:08:55,679
傳遞，我們實際上

1819
01:08:55,679 --> 01:08:56,880
可以知道如何將其

1820
01:08:56,880 --> 01:08:59,359
擴展到嚴肅的

1821
01:08:59,359 --> 01:09:00,719


1822
01:09:00,719 --> 01:09:02,560
應用程序，我的意思是這是真實的，我的意思是我們是

1823
01:09:02,560 --> 01:09:04,158
一個工程團隊，我們想要

1824
01:09:04,158 --> 01:09:06,799
構建真正做某事的系統

1825
01:09:06,799 --> 01:09:09,198
有用 我也在一家助聽器公司工作，

1826
01:09:09,198 --> 01:09:12,640
所以我想構建實時

1827
01:09:12,640 --> 01:09:16,479
音頻處理算法

1828
01:09:16,479 --> 01:09:17,359


1829
01:09:17,359 --> 01:09:18,960
，其他人可能想將它用於

1830
01:09:18,960 --> 01:09:21,439
機器人技術，所以

1831
01:09:21,439 --> 01:09:24,399
是的，但這不會

1832
01:09:24,399 --> 01:09:26,479
在實時模型中起作用，它不會

1833
01:09:26,479 --> 01:09:28,399
起作用

1834
01:09:28,399 --> 01:09:31,679
嗯 是的，所有的多卡或

1835
01:09:31,679 --> 01:09:33,600
其他東西都有

1836
01:09:33,600 --> 01:09:36,080
一點，所以這是我們的努力

1837
01:09:36,080 --> 01:09:38,560
，

1838
01:09:38,560 --> 01:09:40,560
這需要很長時間，因為這是非常

1839
01:09:40,560 --> 01:09:42,880
多學科的努力，我們

1840
01:09:42,880 --> 01:09:46,000
在我的小組中有一個數學家

1841
01:09:46,000 --> 01:09:47,279
和

1842
01:09:47,279 --> 01:09:49,120
神經 科學家和

1843
01:09:49,120 --> 01:09:51,359
計算機科學家，

1844
01:09:51,359 --> 01:09:53,439
因為這很困難

1845
01:09:53,439 --> 01:09:55,520
有很多不同的

1846
01:09:55,520 --> 01:09:57,199
專業

1847
01:09:57,199 --> 01:09:59,360
知識，你需要建立一個好的

1848
01:09:59,360 --> 01:10:02,880
工具箱來進行主動推理，

1849
01:10:02,880 --> 01:10:04,640
我認為因為這太難

1850
01:10:04,640 --> 01:10:06,159
了，就像

1851
01:10:06,159 --> 01:10:08,080


1852
01:10:08,080 --> 01:10:09,679
活躍

1853
01:10:09,679 --> 01:10:11,840
推理社區和

1854
01:10:11,840 --> 01:10:13,840
我們所做

1855
01:10:13,840 --> 01:10:15,840
的工程社區最感興趣的是

1856
01:10:15,840 --> 01:10:18,560
解釋生物系統正確

1857
01:10:18,560 --> 01:10:20,239
的能量原理和

1858
01:10:20,239 --> 01:10:21,840


1859
01:10:21,840 --> 01:10:24,000
作為生物學模型的主動推理

1860
01:10:24,000 --> 01:10:25,440
，我認為這很有趣，

1861
01:10:25,440 --> 01:10:26,960
因為雖然大自然有某種有效

1862
01:10:26,960 --> 01:10:28,840
地做事的方式，

1863
01:10:28,840 --> 01:10:30,800
嗯

1864
01:10:30,800 --> 01:10:32,719
，如果這是一個 模型，

1865
01:10:32,719 --> 01:10:34,320
然後將其用於工程也是一個好主意

1866
01:10:34,320 --> 01:10:36,000


1867
01:10:36,000 --> 01:10:37,920
，這是我們的建議，因此

1868
01:10:37,920 --> 01:10:40,000
我們採用

1869
01:10:40,000 --> 01:10:41,199
活躍推理社區中可用的想法

1870
01:10:41,199 --> 01:10:43,360
以及他們解釋大腦

1871
01:10:43,360 --> 01:10:45,120
並思考大腦

1872
01:10:45,120 --> 01:10:47,120
並思考嘿，我們怎麼能 採用這些

1873
01:10:47,120 --> 01:10:48,320
想法

1874
01:10:48,320 --> 01:10:49,120
並

1875
01:10:49,120 --> 01:10:53,440
使用它們來構建工程系統

1876
01:10:53,440 --> 01:10:56,320
，我認為這是主要

1877
01:10:56,320 --> 01:10:57,920
的 它之間的主要交互，

1878
01:10:57,920 --> 01:11:00,800
希望我們構建

1879
01:11:00,800 --> 01:11:02,719
社區也可以在他們的研究中使用的工具，

1880
01:11:02,719 --> 01:11:06,080
最終

1881
01:11:07,199 --> 01:11:09,520
讓我想到的是，

1882
01:11:09,520 --> 01:11:11,840
它實際上是對一些

1883
01:11:11,840 --> 01:11:14,080
主要挑戰的重新定義，比如將信號

1884
01:11:14,080 --> 01:11:16,000
處理視為實時事件或

1885
01:11:16,000 --> 01:11:16,800


1886
01:11:16,800 --> 01:11:18,960
行動

1887
01:11:18,960 --> 01:11:21,440
和未來數據之間的因果關係所有這些問題的重新

1888
01:11:21,440 --> 01:11:24,080
框架它

1889
01:11:24,080 --> 01:11:26,239
不像主動推理

1890
01:11:26,239 --> 01:11:27,600
算法

1891
01:11:27,600 --> 01:11:31,199
需要大量的矩陣呃

1892
01:11:31,199 --> 01:11:34,080
計算本身它們可能非常簡單

1893
01:11:34,080 --> 01:11:35,760
但實際上是

1894
01:11:35,760 --> 01:11:38,480
在嵌入行動中重新框架 在

1895
01:11:38,480 --> 01:11:39,440


1896
01:11:39,440 --> 01:11:42,080
最終解決擴展的每一步中

1897
01:11:42,080 --> 01:11:44,000
一些擴展挑戰

1898
01:11:44,000 --> 01:11:45,440
一些彈性挑戰，因為就像

1899
01:11:45,440 --> 01:11:47,040


1900
01:11:47,040 --> 01:11:49,040
城市交通網絡的彈性一樣，他們

1901
01:11:49,040 --> 01:11:50,000
會進行

1902
01:11:50,000 --> 01:11:51,600
抽樣，或者他們會採取一些

1903
01:11:51,600 --> 01:11:53,440
正在展開的動態過程，

1904
01:11:53,440 --> 01:11:55,520
然後嘗試推出 一百萬

1905
01:11:55,520 --> 01:11:58,080
次靜態迭代，

1906
01:11:58,080 --> 01:12:00,080
所以它再次不是

1907
01:12:00,080 --> 01:12:01,360


1908
01:12:01,360 --> 01:12:02,880
循環內部的計算 必須

1909
01:12:02,880 --> 01:12:05,520
具有挑戰性，這只是對

1910
01:12:05,520 --> 01:12:07,520
優先級操作的

1911
01:12:07,520 --> 01:12:08,960
重新

1912
01:12:08,960 --> 01:12:11,280
劃分，最終走上了這些擴展和

1913
01:12:11,280 --> 01:12:14,400
實時容量的道路

1914
01:12:14,400 --> 01:12:16,640
是的，我喜歡

1915
01:12:16,640 --> 01:12:18,800
這個想法，嗯，也許我可以

1916
01:12:18,800 --> 01:12:20,560
在

1917
01:12:20,560 --> 01:12:22,800
我工作的背景下說些什麼，因為我在

1918
01:12:22,800 --> 01:12:24,880
工作 基本上我是一名助聽器

1919
01:12:24,880 --> 01:12:25,860
工程師，我從事

1920
01:12:25,860 --> 01:12:27,120
[音樂]工作

1921
01:12:27,120 --> 01:12:29,120
，如果你問助聽器工程師

1922
01:12:29,120 --> 01:12:31,040
信號處理工程師，那麼

1923
01:12:31,040 --> 01:12:32,480
你

1924
01:12:32,480 --> 01:12:34,320
的任務是什麼，我們的任務是建立最好的

1925
01:12:34,320 --> 01:12:36,400
助聽器算法

1926
01:12:36,400 --> 01:12:37,600
，

1927
01:12:37,600 --> 01:12:39,600


1928
01:12:39,600 --> 01:12:41,920
那麼會發生

1929
01:12:41,920 --> 01:12:44,159
什麼 助聽器客戶去

1930
01:12:44,159 --> 01:12:46,719
商店購買助聽器通常

1931
01:12:46,719 --> 01:12:48,640
很高興然後出去然後

1932
01:12:48,640 --> 01:12:50,880
兩週後坐在餐廳裡我

1933
01:12:50,880 --> 01:12:52,400
無法理解

1934
01:12:52,400 --> 01:12:54,960
她的談話夥伴因為

1935
01:12:54,960 --> 01:12:57,520
有噪音而且這是出乎意料的

1936
01:12:57,520 --> 01:13:00,480
而且她無能為力

1937
01:13:00,480 --> 01:13:02,960
因為 你不能要求助聽器客戶

1938
01:13:02,960 --> 01:13:05,199


1939
01:13:05,199 --> 01:13:06,560


1940
01:13:06,560 --> 01:13:08,480
擺弄助聽器參數，所以如果

1941
01:13:08,480 --> 01:13:09,760
這種情況

1942
01:13:09,760 --> 01:13:11,679
發生幾次，

1943
01:13:11,679 --> 01:13:13,760
那麼她會扔掉或者她把

1944
01:13:13,760 --> 01:13:16,400
助聽器放在抽屜裡，這個呃

1945
01:13:16,400 --> 01:13:19,199
事實上，大約 10% 20% 的

1946
01:13:19,199 --> 01:13:20,880
助聽器最終都放在抽屜裡，它們非常

1947
01:13:20,880 --> 01:13:21,910
昂貴，而且

1948
01:13:21,910 --> 01:13:23,520
[Music]

1949
01:13:23,520 --> 01:13:24,400
20

1950
01:13:24,400 --> 01:13:27,040
最終沒有被使用，這是一個非常

1951
01:13:27,040 --> 01:13:28,960
可悲的統計數據，

1952
01:13:28,960 --> 01:13:31,040
所以

1953
01:13:31,040 --> 01:13:32,960
你可以把它轉過來，說

1954
01:13:32,960 --> 01:13:35,040
好吧，什麼是真正的助聽器 設計

1955
01:13:35,040 --> 01:13:36,560
問題 真正的助聽器設計

1956
01:13:36,560 --> 01:13:39,280
問題是派人帶著任何助聽器出去，

1957
01:13:39,280 --> 01:13:41,440
但是當

1958
01:13:41,440 --> 01:13:43,679
她在餐廳裡的現場不開心時你會

1959
01:13:43,679 --> 01:13:46,320


1960
01:13:46,320 --> 01:13:48,320
怎麼做，我們想要建立一個代理

1961
01:13:48,320 --> 01:13:49,360
，

1962
01:13:49,360 --> 01:13:52,080
然後她只需拍打她的手腕跑道

1963
01:13:52,080 --> 01:13:54,080
我很高興，現在這個代理需要

1964
01:13:54,080 --> 01:13:55,679
採取行動並為她提供新的

1965
01:13:55,679 --> 01:13:58,239
參數設置，這

1966
01:13:58,239 --> 01:14:00,719
對她來說是最有趣的，並且和和

1967
01:14:00,719 --> 01:14:02,239
以及

1968
01:14:02,239 --> 01:14:04,480
在信息搜索

1969
01:14:04,480 --> 01:14:07,040
和目標驅動的金裂之間的最佳折衷讓

1970
01:14:07,040 --> 01:14:08,719
她聽得很開心

1971
01:14:08,719 --> 01:14:10,320


1972
01:14:10,320 --> 01:14:12,960
從我的角度來看，現在的設計

1973
01:14:12,960 --> 01:14:16,159
只是建立一個代理，當她不開心時會

1974
01:14:16,159 --> 01:14:18,800
採取行動提出助聽器建議

1975
01:14:18,800 --> 01:14:20,800


1976
01:14:20,800 --> 01:14:22,320
，如果她是

1977
01:14:22,320 --> 01:14:24,159
對的，她不開心，然後聽到

1978
01:14:24,159 --> 01:14:25,920
混合建議說不，那

1979
01:14:25,920 --> 01:14:28,000
不好 gent 提出了另一個建議

1980
01:14:28,000 --> 01:14:30,159
，沒關係，這更好，然後

1981
01:14:30,159 --> 01:14:32,159
我們繼續前進，也許一周後

1982
01:14:32,159 --> 01:14:35,600
同樣的事件，這種情況不斷進行，

1983
01:14:35,600 --> 01:14:38,719
但至少有

1984
01:14:38,719 --> 01:14:41,120
一個程序可以繼續前進，

1985
01:14:41,120 --> 01:14:44,000
隨著時間的推移不斷改進，

1986
01:14:44,000 --> 01:14:45,360
所以這才

1987
01:14:45,360 --> 01:14:48,159
是真正的 設計的事情

1988
01:14:48,159 --> 01:14:52,239
是c2中的現場動作，

1989
01:14:52,239 --> 01:14:53,600
這與

1990
01:14:53,600 --> 01:14:56,000
當前正在發生的事情非常不同，助聽器

1991
01:14:56,000 --> 01:14:58,159
工程師坐在辦公桌前

1992
01:14:58,159 --> 01:15:01,920
，模型不在環境中，

1993
01:15:01,920 --> 01:15:04,400
所以這是一個範式轉變

1994
01:15:04,400 --> 01:15:07,760
和主動推理 代理

1995
01:15:07,760 --> 01:15:09,679
也許可以實現這一點，

1996
01:15:09,679 --> 01:15:10,960


1997
01:15:10,960 --> 01:15:12,640
我真的可以

1998
01:15:12,640 --> 01:15:14,560
為

1999
01:15:14,560 --> 01:15:16,719
信號處理設計之類

2000
01:15:16,719 --> 01:15:18,400


2001
01:15:18,400 --> 01:15:19,920
的東西創建

2002
01:15:19,920 --> 01:15:21,679
一個轉折點嗎

2003
01:15:21,679 --> 01:15:23,520


2004
01:15:23,520 --> 01:15:25,440


2005
01:15:25,440 --> 01:15:27,040
不僅用於信號處理，

2006
01:15:27,040 --> 01:15:29,120
還用於不同的工程

2007
01:15:29,120 --> 01:15:31,120
學科

2008
01:15:31,120 --> 01:15:32,960
，這就是為什麼我認為隨著時間的推移，你會

2009
01:15:32,960 --> 01:15:35,280
看到越來越多的人來自不同的領域

2010
01:15:35,280 --> 01:15:37,360


2011
01:15:37,360 --> 01:15:41,040
nt 領域對這個 uh

2012
01:15:41,040 --> 01:15:42,480
主動推理和自由能

2013
01:15:42,480 --> 01:15:43,920
原理

2014
01:15:43,920 --> 01:15:47,360
uh even uh

2015
01:15:47,360 --> 01:15:49,199
non 不是神經科學家對，但

2016
01:15:49,199 --> 01:15:50,840
工程師是的，

2017
01:15:50,840 --> 01:15:54,159
是的，我們希望如此，這真的

2018
01:15:54,159 --> 01:15:56,560
讓我想起了務實的轉變

2019
01:15:56,560 --> 01:15:58,159
，這有點像

2020
01:15:58,159 --> 01:15:59,920
工程師和哲學家的馬蹄鐵理論

2021
01:15:59,920 --> 01:16:01,600


2022
01:16:01,600 --> 01:16:04,239
經常

2023
01:16:04,239 --> 01:16:06,080
以不同的方式談論實用主義不同的社區

2024
01:16:06,080 --> 01:16:07,600
不同的

2025
01:16:07,600 --> 01:16:09,520
工具現在有一種方法可以縮小

2026
01:16:09,520 --> 01:16:12,719
這種差距，或者至少在

2027
01:16:12,719 --> 01:16:14,560
其中繪製出一些關於

2028
01:16:14,560 --> 01:16:16,640


2029
01:16:16,640 --> 01:16:18,880
真正激進主義角色的見解 設計

2030
01:16:18,880 --> 01:16:22,400
科學的預期設計科學與

2031
01:16:22,400 --> 01:16:24,080
接受或離開它的哲學

2032
01:16:24,080 --> 01:16:26,400
或有待開發的工具包

2033
01:16:26,400 --> 01:16:28,480


2034
01:16:28,480 --> 01:16:30,000
可能在使用工具包五年或

2035
01:16:30,000 --> 01:16:31,280
五年哲學之後很有趣，然後你

2036
01:16:31,280 --> 01:16:33,360
對工具包感到好奇，

2037
01:16:33,360 --> 01:16:34,640
所以一個

2038
01:16:34,640 --> 01:16:36,320
問題是

2039
01:16:36,320 --> 01:16:38,480
如何做 這些圖解釋了

2040
01:16:38,480 --> 01:16:41,280
時間上的深度模型，這些模型是如何

2041
01:16:41,280 --> 01:16:42,800
指定的，

2042
01:16:42,800 --> 01:16:43,920
或者是

2043
01:16:43,920 --> 01:16:46,080
什麼使圖有什麼不同，

2044
01:16:46,080 --> 01:16:48,400
因為 e 它只是在計算

2045
01:16:48,400 --> 01:16:50,000
您提供的示例中要採取的下一步行動，

2046
01:16:50,000 --> 01:16:52,400


2047
01:16:53,120 --> 01:16:55,920
也許伙計們，您可以再次展示您的圖表

2048
01:16:55,920 --> 01:16:58,640
如何表示

2049
01:16:58,640 --> 01:17:00,560
未來，以及您如何為其添加時間

2050
01:17:00,560 --> 01:17:02,560
厚度，例如，

2051
01:17:02,560 --> 01:17:05,760
如果您有的話 有一個

2052
01:17:06,320 --> 01:17:07,280
像

2053
01:17:07,280 --> 01:17:10,400
椅子屏幕這樣的圖表是的，

2054
01:17:12,800 --> 01:17:14,239
如果你有這樣的圖表，那麼

2055
01:17:14,239 --> 01:17:15,600
你如何添加時間厚度，

2056
01:17:15,600 --> 01:17:17,840


2057
01:17:17,920 --> 01:17:20,080
例如，這只是添加

2058
01:17:20,080 --> 01:17:21,120
層，

2059
01:17:21,120 --> 01:17:22,400


2060
01:17:22,400 --> 01:17:25,920
所以這裡顯示的是一層

2061
01:17:25,920 --> 01:17:27,280
，這一層

2062
01:17:27,280 --> 01:17:28,320
它

2063
01:17:28,320 --> 01:17:30,960
在你知道的某個時鐘時間起作用

2064
01:17:30,960 --> 01:17:33,840
觀察是離散的，

2065
01:17:33,840 --> 01:17:34,960


2066
01:17:34,960 --> 01:17:36,960
但是您可能在此之上有一個層

2067
01:17:36,960 --> 01:17:38,960
，它以某種方式與下面的這一層相連，該層

2068
01:17:38,960 --> 01:17:40,239


2069
01:17:40,239 --> 01:17:42,080
在更高的時間尺度上起作用，

2070
01:17:42,080 --> 01:17:43,360


2071
01:17:43,360 --> 01:17:46,239
因此它發展得較慢，

2072
01:17:46,239 --> 01:17:48,239
但它調節或影響

2073
01:17:48,239 --> 01:17:49,440


2074
01:17:49,440 --> 01:17:52,000
例如此處的過渡模型

2075
01:17:52,000 --> 01:17:54,480
或觀察的參數 在這裡建立模型，

2076
01:17:54,480 --> 01:17:56,480
這樣您就可以得到一個隨時間變化的

2077
01:17:56,480 --> 01:17:58,800
觀察模型，該模型

2078
01:17:58,800 --> 01:17:59,679


2079
01:17:59,679 --> 01:18:02,400
受較慢演化層的影響，

2080
01:18:02,400 --> 01:18:04,000
在此之上，您可以獲得一個更

2081
01:18:04,000 --> 01:18:05,679
慢演化層，這就是

2082
01:18:05,679 --> 01:18:06,960
這就是

2083
01:18:06,960 --> 01:18:09,440
你可以建立層次結構的方式

2084
01:18:09,440 --> 01:18:10,640


2085
01:18:10,640 --> 01:18:13,120
，實際上

2086
01:18:13,120 --> 01:18:15,760
，我們小組中還有一個 pg 學生 ismael senos，他在這

2087
01:18:15,760 --> 01:18:17,280
方面做了一些非常有趣的工作

2088
01:18:17,280 --> 01:18:19,280
，他研究了你是如何

2089
01:18:19,280 --> 01:18:21,199
製作層次

2090
01:18:21,199 --> 01:18:24,480
高斯濾波器的，嗯

2091
01:18:24,480 --> 01:18:27,199
，你有一個頂部的層次高斯系統

2092
01:18:27,199 --> 01:18:29,679
層影響下面

2093
01:18:29,679 --> 01:18:31,280
層的轉換模型的方差，

2094
01:18:31,280 --> 01:18:33,280


2095
01:18:33,280 --> 01:18:34,960


2096
01:18:34,960 --> 01:18:37,360
您可以看到您可以使用它對

2097
01:18:37,360 --> 01:18:40,960
非常自然的信號進行建模，

2098
01:18:40,960 --> 01:18:42,960
因此在自然界中，您

2099
01:18:42,960 --> 01:18:44,640
有隨時間變化的信號，其中的

2100
01:18:44,640 --> 01:18:46,400
統計數據隨時間變化

2101
01:18:46,400 --> 01:18:48,880
和統計數據 這些模型

2102
01:18:48,880 --> 01:18:50,800
是隨時間變化的，

2103
01:18:50,800 --> 01:18:52,880
所以從這個意義上說，分層模型

2104
01:18:52,880 --> 01:18:54,560
對此非常有用，

2105
01:18:54,560 --> 01:18:56,719
當然，這

2106
01:18:56,719 --> 01:18:58,960
就是我們大腦的結構，

2107
01:18:58,960 --> 01:19:00,800
所以你再次

2108
01:19:00,800 --> 01:19:02,000
從大自然中獲得靈感，

2109
01:19:02,000 --> 01:19:04,080
嗯，關於如何

2110
01:19:04,080 --> 01:19:07,360
構建我們的模型 至少在理論上嘗試用矢量圖構建

2111
01:19:07,360 --> 01:19:08,480
嗯

2112
01:19:08,480 --> 01:19:10,560


2113
01:19:10,560 --> 01:19:12,239
它們應該很

2114
01:19:12,239 --> 01:19:13,280
容易，

2115
01:19:13,280 --> 01:19:14,800
因為你可以連接它們你

2116
01:19:14,800 --> 01:19:17,120
可以連接層 r 最重要的是，

2117
01:19:17,120 --> 01:19:20,000
看看它的行為方式

2118
01:19:20,000 --> 01:19:21,760
，最終你的模型的複雜性

2119
01:19:21,760 --> 01:19:23,760
會變得非常高，你會

2120
01:19:23,760 --> 01:19:26,159
自動受到懲罰，所以

2121
01:19:26,159 --> 01:19:28,320


2122
01:19:28,320 --> 01:19:31,120
會給你的數據一個截止點，這將是

2123
01:19:31,120 --> 01:19:32,960
最佳的層數 你

2124
01:19:32,960 --> 01:19:34,400
需要為了解釋你觀察到的所有

2125
01:19:34,400 --> 01:19:35,679
變體

2126
01:19:35,679 --> 01:19:38,480


2127
01:19:39,520 --> 01:19:42,560
所以這就是我們如何看待

2128
01:19:42,560 --> 01:19:44,800
時間厚度

2129
01:19:44,800 --> 01:19:46,000
和

2130
01:19:46,000 --> 01:19:48,239
時間依賴性以及

2131
01:19:48,239 --> 01:19:50,719
像這樣的動態模型

2132
01:19:50,719 --> 01:19:54,159
然後我可以分享我的屏幕也可以

2133
01:19:54,159 --> 01:19:56,719
肯定可以讓我們看看

2134
01:19:56,719 --> 01:19:59,760
因為這個嗯 太棒了，

2135
01:19:59,760 --> 01:20:02,080
是的，

2136
01:20:02,400 --> 01:20:05,280
這是幾年前一篇論文中的圖表，

2137
01:20:05,280 --> 01:20:08,639
呃，在前沿，

2138
01:20:08,639 --> 01:20:11,520
嗯，它被稱為我認為，呃，

2139
01:20:11,520 --> 01:20:13,440
深度時間模型檢查因子

2140
01:20:13,440 --> 01:20:14,880
圖或其他東西

2141
01:20:14,880 --> 01:20:17,360
，在這裡你看到一個三層系統，我的

2142
01:20:17,360 --> 01:20:19,679
意思是現在不要打擾細節

2143
01:20:19,679 --> 01:20:21,840
但是在這裡 你在頂層看到

2144
01:20:21,840 --> 01:20:24,800
基本上只有一個部分一個

2145
01:20:24,800 --> 01:20:26,400
時間步

2146
01:20:26,400 --> 01:20:28,639
，在頂層的那個時間步中，

2147
01:20:28,639 --> 01:20:29,600
你在中間件有

2148
01:20:29,600 --> 01:20:30,639
兩個

2149
01:20:30,639 --> 01:20:33,520
觀察或兩個步驟

2150
01:20:33,520 --> 01:20:34,800


2151
01:20:34,800 --> 01:20:37,440
我需要嗯，是的，

2152
01:20:37,440 --> 01:20:40,159
我沒有 不知道你能不能看到我的呃，

2153
01:20:40,159 --> 01:20:43,040
好吧，然後再說一次，

2154
01:20:43,040 --> 01:20:44,880
假設第三層，每當中間

2155
01:20:44,880 --> 01:20:47,679
層提示邁出一步時，我們這裡有兩個

2156
01:20:47,679 --> 01:20:50,400
步驟，所以每一層都有更精細的

2157
01:20:50,400 --> 01:20:52,560


2158
01:20:52,560 --> 01:20:55,440
粒度，所以我們可以構建

2159
01:20:55,440 --> 01:20:57,600
分層的

2160
01:20:57,600 --> 01:21:01,280
呃模型真的和呃，所以我們也在這樣做

2161
01:21:01,280 --> 01:21:04,480
，呃，我的意思也是，如果

2162
01:21:04,480 --> 01:21:05,520


2163
01:21:05,520 --> 01:21:07,679
你看我們網站上的一些論文，

2164
01:21:07,679 --> 01:21:10,080
你會發現很多嬰兒都使用

2165
01:21:10,080 --> 01:21:12,400
來自 chris matisse 的分層高斯濾波器

2166
01:21:12,400 --> 01:21:15,120
我們' 已經實現

2167
01:21:15,120 --> 01:21:16,239
了，

2168
01:21:16,239 --> 01:21:19,040
但是

2169
01:21:19,040 --> 01:21:20,719
我的意思是你也可以這樣做以獲得積極的

2170
01:21:20,719 --> 01:21:23,280
影響，比如呃，看起來

2171
01:21:23,280 --> 01:21:24,159


2172
01:21:24,159 --> 01:21:26,960
像這樣，呃，

2173
01:21:26,960 --> 01:21:30,000
thomas pyre 在他的一些論文中也有這樣的圖表

2174
01:21:30,000 --> 01:21:32,960


2175
01:21:33,760 --> 01:21:35,840
非常有趣，我們看到很多

2176
01:21:35,840 --> 01:21:38,239
相同的 像 g

2177
01:21:38,239 --> 01:21:39,440
d b

2178
01:21:39,440 --> 01:21:41,040
這樣的變量，我們可以它

2179
01:21:41,040 --> 01:21:43,520
是主動推理的一種不同表示，所以

2180
01:21:43,520 --> 01:21:44,960
是的，

2181
01:21:44,960 --> 01:21:46,800
這也可以

2182
01:21:46,800 --> 01:21:49,520
追溯到早期的前沿論文，什麼

2183
01:21:49,520 --> 01:21:52,000
是大的等價物

2184
01:21:52,000 --> 01:21:55,679
或類似

2185
01:21:55,679 --> 01:21:57,440
從

2186
01:21:57,440 --> 01:21:59,120
福尼因子的密封映射 圖表，

2187
01:21:59,120 --> 01:22:01,040
因為可能有一些廣泛

2188
01:22:01,040 --> 01:22:03,120
的應用

2189
01:22:03,120 --> 01:22:05,520
領域幾乎可以熱交換

2190
01:22:05,520 --> 01:22:07,760
這個底層，

2191
01:22:07,760 --> 01:22:09,679
所以

2192
01:22:09,679 --> 01:22:12,480
一般來說貝葉斯圖與

2193
01:22:12,480 --> 01:22:14,480
因子圖與

2194
01:22:14,480 --> 01:22:17,599
該級別的其他主題的等價性

2195
01:22:21,120 --> 01:22:23,520
我認為是外國風格的矢量圖

2196
01:22:23,520 --> 01:22:26,320
或 二分圖或北京網絡

2197
01:22:26,320 --> 01:22:27,920
它們並沒有真正的不同

2198
01:22:27,920 --> 01:22:29,760
它們可以被使用，因為

2199
01:22:29,760 --> 01:22:31,840
它們只是

2200
01:22:31,840 --> 01:22:34,159
分解模型的表示，

2201
01:22:34,159 --> 01:22:37,120
並且您表示的方式

2202
01:22:37,120 --> 01:22:39,520
可能會影響您

2203
01:22:39,520 --> 01:22:41,440
對這些

2204
01:22:41,440 --> 01:22:43,280
模型的看法，例如，如果您選擇 一個 4-install

2205
01:22:43,280 --> 01:22:45,199
有效的圖形表示，它非常

2206
01:22:45,199 --> 01:22:47,120
適合信號處理，因為

2207
01:22:47,120 --> 01:22:49,120
您可以將這些消息視為

2208
01:22:49,120 --> 01:22:51,520
流過圖形的信號，

2209
01:22:51,520 --> 01:22:53,840
因此對於我們工程師來說，

2210
01:22:53,840 --> 01:22:57,679
這是貝葉斯網絡中非常直觀的表示

2211
01:22:57,679 --> 01:23:00,880
，它更像

2212
01:23:00,880 --> 01:23:02,880
是模型表示本身

2213
01:23:02,880 --> 01:23:05,199
從這個意義上說更緊湊，你只有

2214
01:23:05,199 --> 01:23:06,719
可變的音符，你會看到它們

2215
01:23:06,719 --> 01:23:08,320
是如何相關的，所以它給你一個很好的想法

2216
01:23:08,320 --> 01:23:10,239
模型結構，

2217
01:23:10,239 --> 01:23:13,120
因此

2218
01:23:13,120 --> 01:23:16,000
快速瀏覽這樣的模型會非常好

2219
01:23:16,000 --> 01:23:17,120
，然後你就有了一個例如

2220
01:23:17,120 --> 01:23:19,120
二分圖，它還顯示了

2221
01:23:19,120 --> 01:23:21,120
變量之間的關係，作為介於 um 之間的

2222
01:23:21,120 --> 01:23:22,960
另一種

2223
01:23:22,960 --> 01:23:25,520
矢量節點

2224
01:23:25,520 --> 01:23:27,440
，它會給你一個 更

2225
01:23:27,440 --> 01:23:29,280
詳細地說明這些是如何連接的，

2226
01:23:29,280 --> 01:23:31,120
並讓您有空間很好地討論

2227
01:23:31,120 --> 01:23:32,719
這些變量之間的關係

2228
01:23:32,719 --> 01:23:35,280


2229
01:23:35,280 --> 01:23:39,440
，所以最後它們是等價的，

2230
01:23:39,520 --> 01:23:41,760
您可以採用一個模型並

2231
01:23:41,760 --> 01:23:45,760
以三種不同的方式表示它，也許更多，

2232
01:23:46,159 --> 01:23:48,560
但我認為 它確實會影響

2233
01:23:48,560 --> 01:23:49,920
你的思維方式

2234
01:23:49,920 --> 01:23:52,320
或你對這些模型的看法，所以

2235
01:23:52,320 --> 01:23:54,559
嗯

2236
01:23:55,840 --> 01:23:56,960
，

2237
01:23:56,960 --> 01:23:58,560
這通常會在寫

2238
01:23:58,560 --> 01:24:00,239
論文時出現

2239
01:24:00,239 --> 01:24:01,679
，然後你必須想好什麼

2240
01:24:01,679 --> 01:24:03,520
是我的想法的最佳代表

2241
01:24:03,520 --> 01:24:04,639


2242
01:24:04,639 --> 01:24:06,239
有時它是關於預算圖

2243
01:24:06,239 --> 01:24:07,520
有時它是一個 視覺網絡

2244
01:24:07,520 --> 01:24:10,159
有時是為了安裝照片，

2245
01:24:10,159 --> 01:24:11,120


2246
01:24:11,120 --> 01:24:14,800
嗯，這取決於你的故事，是的，

2247
01:24:14,800 --> 01:24:16,320
希望

2248
01:24:16,320 --> 01:24:18,480
我能找到，儘管我的意思是

2249
01:24:18,480 --> 01:24:21,120
當我們考慮系統和整體時，我的意思

2250
01:24:21,120 --> 01:24:23,040
是 等式如果你在

2251
01:24:23,040 --> 01:24:24,159
論文中讀到

2252
01:24:24,159 --> 01:24:26,880
或者如果你把它寫下來，嗯，

2253
01:24:26,880 --> 01:24:28,880
如果你畫給我，它會給我更多的

2254
01:24:28,880 --> 01:24:31,280
洞察力，如果我畫出圖表，它會給出更多的洞察力，

2255
01:24:31,280 --> 01:24:32,480
並且

2256
01:24:32,480 --> 01:24:33,760
有一個 x

2257
01:24:33,760 --> 01:24:36,000


2258
01:24:36,000 --> 01:24:37,920


2259
01:24:37,920 --> 01:24:40,480
，圖表之間必須有一個精確的對應關係 和方程，

2260
01:24:40,480 --> 01:24:42,960
如果你畫圖然後

2261
01:24:42,960 --> 01:24:45,040
寫下方程，沒有

2262
01:24:45,040 --> 01:24:47,360
對應的x軸，所以你從中學習，

2263
01:24:47,360 --> 01:24:50,000
你基本上你知道

2264
01:24:50,000 --> 01:24:52,000
必須有一個精確的對應關係，

2265
01:24:52,000 --> 01:24:53,600
基本上你經常發現你

2266
01:24:53,600 --> 01:24:56,239
您的方程式或圖表中有錯誤，

2267
01:24:56,239 --> 01:24:57,920


2268
01:24:57,920 --> 01:25:00,000
但我認為

2269
01:25:00,000 --> 01:25:03,600
最終目標是最終目標

2270
01:25:03,600 --> 01:25:07,120
是使工具箱成為工具箱，

2271
01:25:07,120 --> 01:25:09,199
讓我們說讓社區設計

2272
01:25:09,199 --> 01:25:12,639
自己的積極影響力代理以及

2273
01:25:12,639 --> 01:25:13,679
我

2274
01:25:13,679 --> 01:25:15,520
所設想的 像simulink這樣的東西

2275
01:25:15,520 --> 01:25:18,000
我不確定或labview我

2276
01:25:18,000 --> 01:25:20,080
不確定人們是否熟悉

2277
01:25:20,080 --> 01:25:21,280
但是嗯

2278
01:25:21,280 --> 01:25:23,120
這些是圖形模型你想要

2279
01:25:23,120 --> 01:25:26,080
實際上也以圖形方式定義它們

2280
01:25:26,080 --> 01:25:27,920
並且你想要一個帶有註釋的調色板

2281
01:25:27,920 --> 01:25:29,679
並且只是

2282
01:25:29,679 --> 01:25:32,320
dra  w你的圖表，說這是我的模型

2283
01:25:32,320 --> 01:25:34,639
，現在開始運行

2284
01:25:34,639 --> 01:25:36,159
你不想擔心

2285
01:25:36,159 --> 01:25:37,840
推理在

2286
01:25:37,840 --> 01:25:39,600
根依賴傳遞應該由

2287
01:25:39,600 --> 01:25:40,880


2288
01:25:40,880 --> 01:25:43,199
工具箱的設計者完成，但你

2289
01:25:43,199 --> 01:25:46,080
應該只考慮你的

2290
01:25:46,080 --> 01:25:49,360
圖形結構 這就是呃

2291
01:25:49,360 --> 01:25:52,880
和這個，然後用鼠標將它連接

2292
01:25:52,880 --> 01:25:54,880
到

2293
01:25:54,880 --> 01:25:57,440
計算機的麥克風或相機上

2294
01:25:57,440 --> 01:25:59,920
，也許

2295
01:25:59,920 --> 01:26:01,760
你知道

2296
01:26:01,760 --> 01:26:05,280
機器人工具箱中還有連接器，然後

2297
01:26:05,280 --> 01:26:07,600
它應該就可以了

2298
01:26:07,600 --> 01:26:09,199
，這將是 bob ross 圖表

2299
01:26:09,199 --> 01:26:11,519


2300
01:26:11,920 --> 01:26:13,520
就是你想要設計的方式我認為是

2301
01:26:13,520 --> 01:26:15,280
對

2302
01:26:15,280 --> 01:26:17,840


2303
01:26:17,840 --> 01:26:19,679


2304
01:26:19,679 --> 01:26:21,600


2305
01:26:21,600 --> 01:26:24,239


2306
01:26:24,480 --> 01:26:26,719


2307
01:26:26,719 --> 01:26:29,199
的 等式，然後

2308
01:26:29,199 --> 01:26:31,520
可能從筆和紙到

2309
01:26:31,520 --> 01:26:33,280
編程語言再到圖形

2310
01:26:33,280 --> 01:26:35,440
表示，然後進行

2311
01:26:35,440 --> 01:26:37,120
交叉檢查，就像

2312
01:26:37,120 --> 01:26:38,800
您反向翻譯語言

2313
01:26:38,800 --> 01:26:41,120
時一樣 鎖定兩個單詞

2314
01:26:41,120 --> 01:26:42,800
相互映射的位置，你知道

2315
01:26:42,800 --> 01:26:44,239
你已經製作了一張地圖，但是如果你處於這個

2316
01:26:44,239 --> 01:26:46,719
無限循環中，你就會迷失在

2317
01:26:46,719 --> 01:26:49,760
單詞空間中，所以當你

2318
01:26:49,760 --> 01:26:52,639
像這樣跨部門移動時，或者 跨模態

2319
01:26:52,639 --> 01:26:53,520


2320
01:26:53,520 --> 01:26:55,440
分析，計算機上的模擬

2321
01:26:55,440 --> 01:26:57,840
，然後是圖形

2322
01:26:57,840 --> 01:26:59,679
，它將動作

2323
01:26:59,679 --> 01:27:02,159
嵌入到其他可能被視為

2324
01:27:02,159 --> 01:27:03,440
知識

2325
01:27:03,440 --> 01:27:05,840
產品的事物中，推理的產物，然後

2326
01:27:05,840 --> 01:27:07,520
是最終的動作

2327
01:27:07,520 --> 01:27:10,239
，這是一個類似的謬誤，以

2328
01:27:10,239 --> 01:27:12,719
訓練動態過程 快照

2329
01:27:12,719 --> 01:27:13,920
然後期望它會

2330
01:27:13,920 --> 01:27:15,840
實時工作，所以就像將

2331
01:27:15,840 --> 01:27:17,760
實時流程

2332
01:27:17,760 --> 01:27:20,159
嵌入到知識的生產中，

2333
01:27:20,159 --> 01:27:24,000
是的，是的，我們

2334
01:27:24,000 --> 01:27:25,679


2335
01:27:25,679 --> 01:27:28,080


2336
01:27:28,080 --> 01:27:30,800
很重要 是的，是的，

2337
01:27:30,800 --> 01:27:34,400
是的，一個普遍的問題只是

2338
01:27:34,400 --> 01:27:36,239
關於分解，

2339
01:27:36,239 --> 01:27:37,679
所以

2340
01:27:37,679 --> 01:27:40,000


2341
01:27:40,000 --> 01:27:41,920
我們進行分解的方式是從我們的

2342
01:27:41,920 --> 01:27:44,880
直覺開始，尋找殘差或

2343
01:27:44,880 --> 01:27:47,520
如何分解模型的所有方法

2344
01:27:47,520 --> 01:27:51,600
我們找到一個

2345
01:27:53,440 --> 01:27:55,440
可行的嗎是的有兩種分解

2346
01:27:55,440 --> 01:27:57,440
有一個分解假設

2347
01:27:57,440 --> 01:27:59,440
在生成

2348
01:27:59,440 --> 01:28:02,560
模型中是我們繪製的圖表

2349
01:28:02,560 --> 01:28:06,639
所以我的意思是讓我們說大多數人

2350
01:28:06,639 --> 01:28:10,719
呃或最常見的模型是這些

2351
01:28:10,719 --> 01:28:13,440


2352
01:28:13,440 --> 01:28:16,239
這些馬爾可夫模型對

2353
01:28:16,239 --> 01:28:18,880
你保留一個當前狀態，

2354
01:28:18,880 --> 01:28:20,639
總結

2355
01:28:20,639 --> 01:28:22,239
過去

2356
01:28:22,239 --> 01:28:25,120
發生的

2357
01:28:25,120 --> 01:28:27,440


2358
01:28:27,440 --> 01:28:29,760


2359
01:28:29,760 --> 01:28:30,960


2360
01:28:30,960 --> 01:28:33,440
一切 過去，您只記得您的

2361
01:28:33,440 --> 01:28:34,560
狀態

2362
01:28:34,560 --> 01:28:36,159
，然後您確實進行了新的

2363
01:28:36,159 --> 01:28:39,040
觀察，您將信息結合起來，

2364
01:28:39,040 --> 01:28:40,560
形成了新的狀態

2365
01:28:40,560 --> 01:28:42,639
，依此類推，因此隱藏的馬爾可夫

2366
01:28:42,639 --> 01:28:44,760
模型

2367
01:28:44,760 --> 01:28:47,600
palmdps 所有這些模型都具有相同的

2368
01:28:47,600 --> 01:28:49,199
結構，這些這些

2369
01:28:49,199 --> 01:28:51,360
微觀結構，因此用於

2370
01:28:51,360 --> 01:28:53,440
生成 這些動態

2371
01:28:53,440 --> 01:28:54,560
系統的模型

2372
01:28:54,560 --> 01:28:56,400
然後還有第二個問題，如果我們

2373
01:28:56,400 --> 01:28:58,719
現在進行推理，

2374
01:28:58,719 --> 01:29:02,400
嗯，嗯，是的，那麼通常就是

2375
01:29:02,400 --> 01:29:04,880
我們所說的平均場屁股

2376
01:29:04,880 --> 01:29:07,040
選擇變分後驗，但

2377
01:29:07,040 --> 01:29:08,639


2378
01:29:08,639 --> 01:29:11,920
在結構化的綠色字段上也有變體，

2379
01:29:11,920 --> 01:29:14,239
所以你

2380
01:29:14,239 --> 01:29:17,520
仍然可以決定是否希望你的後

2381
01:29:17,520 --> 01:29:19,920
驗更加結構化，或者說

2382
01:29:19,920 --> 01:29:22,880
比生成模型更加分解，

2383
01:29:22,880 --> 01:29:24,480


2384
01:29:24,480 --> 01:29:27,040
但最後是的，

2385
01:29:27,040 --> 01:29:29,120
它是 一個提案，

2386
01:29:29,120 --> 01:29:30,159
呃，

2387
01:29:30,159 --> 01:29:33,120
你就運行它，如果你有另一個

2388
01:29:33,120 --> 01:29:35,040
提案，你就運行它，

2389
01:29:35,040 --> 01:29:38,000
自由能最低

2390
01:29:38,000 --> 01:29:40,800
的那個獲勝，嗯，沒錯，挑戰

2391
01:29:40,800 --> 01:29:44,000
是自動化這個過程，

2392
01:29:44,000 --> 01:29:45,840
從

2393
01:29:45,840 --> 01:29:47,600
假設更差的結構到

2394
01:29:47,600 --> 01:29:49,920
更好的結構 結構

2395
01:29:49,920 --> 01:29:52,159
只是沒有

2396
01:29:52,159 --> 01:29:55,840
通過實時消息傳遞來最小化而不

2397
01:29:55,840 --> 01:29:57,600
停止整個過程進行

2398
01:29:57,600 --> 01:29:59,040
分析

2399
01:29:59,040 --> 01:30:01,520
正確它應該繼續向右移動

2400
01:30:01,520 --> 01:30:04,080
它應該只是結構適應

2401
01:30:04,080 --> 01:30:06,239
應該像狀態估計它只是

2402
01:30:06,239 --> 01:30:08,560
隨著時間的推移不斷移動沒有

2403
01:30:08,560 --> 01:30:10,719
重置

2404
01:30:10,719 --> 01:30:12,719
也許有 有點

2405
01:30:12,719 --> 01:30:15,120


2406
01:30:15,360 --> 01:30:19,120
像做夢的舞台，

2407
01:30:19,120 --> 01:30:22,480
但主要時間在繼續

2408
01:30:22,480 --> 01:30:24,239
，這就是挑戰，我們不

2409
01:30:24,239 --> 01:30:26,560
知道在 我們的工廠課程，但是是的

2410
01:30:26,560 --> 01:30:27,840
，

2411
01:30:27,840 --> 01:30:28,719
我的意思是

2412
01:30:28,719 --> 01:30:31,280
我們有一個高清學生，他目前

2413
01:30:31,280 --> 01:30:32,840
正在研究這個問題，

2414
01:30:32,840 --> 01:30:36,560
是的，就像作為一名工程師一樣

2415
01:30:36,560 --> 01:30:38,320


2416
01:30:38,320 --> 01:30:40,400


2417
01:30:40,400 --> 01:30:42,560
關於

2418
01:30:42,560 --> 01:30:44,880
你的生成模型的分解，

2419
01:30:44,880 --> 01:30:47,040
你認為呃每個因素

2420
01:30:47,040 --> 01:30:49,440
都代表一個先驗分佈或

2421
01:30:49,440 --> 01:30:50,960
條件分佈，這就是

2422
01:30:50,960 --> 01:30:53,440
你如何建立你的模型

2423
01:30:53,440 --> 01:30:55,040
，你從哪裡開始

2424
01:30:55,040 --> 01:30:57,520
，它從你

2425
01:30:57,520 --> 01:31:01,600
相信世界如何產生

2426
01:31:01,600 --> 01:31:03,520
這種意義上的觀察開始 你想想

2427
01:31:03,520 --> 01:31:05,760


2428
01:31:05,760 --> 01:31:07,760
環境的因果結構是什麼，你

2429
01:31:07,760 --> 01:31:10,159
可能對物理學是如何工作的，

2430
01:31:10,159 --> 01:31:13,040
或者

2431
01:31:13,040 --> 01:31:15,760
你的環境中的狀態如何轉變，

2432
01:31:15,760 --> 01:31:17,280
或者至少你如何

2433
01:31:17,280 --> 01:31:19,040
相信這種轉變，這就是你開始的地方

2434
01:31:19,040 --> 01:31:20,080


2435
01:31:20,080 --> 01:31:22,159
，你認為很好

2436
01:31:22,159 --> 01:31:24,960
也許讓我們嘗試一個非常粗略的音符

2437
01:31:24,960 --> 01:31:27,120
，例如在我的演講中減去一個，讓我們

2438
01:31:27,120 --> 01:31:28,719
在這裡嘗試一下，因為我真的不

2439
01:31:28,719 --> 01:31:30,400
知道我想在那裡放什麼，但我沒有

2440
01:31:30,400 --> 01:31:33,440
o 放點東西，讓我們嘗試一下

2441
01:31:33,440 --> 01:31:35,840
，看看它是如何工作的，它模擬

2442
01:31:35,840 --> 01:31:39,199
了我

2443
01:31:39,520 --> 01:31:42,639
相信世界是如何運作的，這就是你開始的方式

2444
01:31:42,639 --> 01:31:44,639
，然後你開始好好思考我

2445
01:31:44,639 --> 01:31:46,639
實際上對它了解得更多我對它的方式

2446
01:31:46,639 --> 01:31:48,960
不滿意 模型

2447
01:31:48,960 --> 01:31:51,760
提出了這個模型是如何工作的，嗯，我

2448
01:31:51,760 --> 01:31:55,120
可以改變這個減一，例如

2449
01:31:55,120 --> 01:31:57,280
用一些更

2450
01:31:57,280 --> 01:31:59,280
複雜的東西，因為我知道物理學，我

2451
01:31:59,280 --> 01:32:00,320
知道

2452
01:32:00,320 --> 01:32:01,679
這些，嗯

2453
01:32:01,679 --> 01:32:03,920
，溫度如何與距離

2454
01:32:03,920 --> 01:32:06,960
相結合，我可以在

2455
01:32:06,960 --> 01:32:08,560
um 中構建它 這就是你提出第二個

2456
01:32:08,560 --> 01:32:09,920
提案的方式

2457
01:32:09,920 --> 01:32:12,560
，它總是受到

2458
01:32:12,560 --> 01:32:14,320
你如何相信

2459
01:32:14,320 --> 01:32:17,600
世界的因果結構

2460
01:32:17,600 --> 01:32:19,440


2461
01:32:19,440 --> 01:32:21,040


2462
01:32:21,040 --> 01:32:22,560


2463
01:32:22,560 --> 01:32:25,280
的啟發 你的

2464
01:32:25,280 --> 01:32:27,040
環境

2465
01:32:27,040 --> 01:32:28,239
，

2466
01:32:28,239 --> 01:32:30,480
好吧，如果你真的很優秀，

2467
01:32:30,480 --> 01:32:32,320
如果你有一個優秀的模型，那麼你

2468
01:32:32,320 --> 01:32:34,480
可以找到一些

2469
01:32:34,480 --> 01:32:35,920
在最先進的基礎上改進的東西，

2470
01:32:35,920 --> 01:32:39,600
因為你總是可以改進，

2471
01:32:39,600 --> 01:32:41,120
只要找到一些東西 ng 在這個意義上給你一個

2472
01:32:41,120 --> 01:32:42,880
更低的自由能或更好的模型

2473
01:32:42,880 --> 01:32:44,960
性能

2474
01:32:44,960 --> 01:32:46,400
，你可以繼續調整和

2475
01:32:46,400 --> 01:32:47,679
調整

2476
01:32:47,679 --> 01:32:48,800


2477
01:32:48,800 --> 01:32:50,800
這些模型和這些分解

2478
01:32:50,800 --> 01:32:51,760
和

2479
01:32:51,760 --> 01:32:54,960
類似的東西，

2480
01:32:56,880 --> 01:32:58,000
是的，

2481
01:32:58,000 --> 01:32:59,360


2482
01:32:59,360 --> 01:33:00,639


2483
01:33:00,639 --> 01:33:03,440
已經描述了自由能最小化，或者只是作為

2484
01:33:03,440 --> 01:33:05,280
對不同模型進行排名的一種方式 作為

2485
01:33:05,280 --> 01:33:06,880
在這些多個不同方面的必要條件，

2486
01:33:06,880 --> 01:33:09,840
我們如何知道

2487
01:33:09,840 --> 01:33:11,920
自由能最小化正在使

2488
01:33:11,920 --> 01:33:13,199
策略

2489
01:33:13,199 --> 01:33:14,480


2490
01:33:14,480 --> 01:33:16,880
具有彈性，是否有

2491
01:33:16,880 --> 01:33:18,800
一種類似於局部

2492
01:33:18,800 --> 01:33:20,639
優化的方法被困

2493
01:33:20,639 --> 01:33:22,560
在更大的優化空間

2494
01:33:22,560 --> 01:33:24,400
中的某個地方 自由

2495
01:33:24,400 --> 01:33:26,639
能最小化的途徑，

2496
01:33:26,639 --> 01:33:28,560
使系統就像崩潰

2497
01:33:28,560 --> 01:33:29,920
一樣，我們會更快地到達那裡讓我們

2498
01:33:29,920 --> 01:33:31,760
加速，然後系統會

2499
01:33:31,760 --> 01:33:32,880
出現

2500
01:33:32,880 --> 01:33:35,120
某種一次性故障

2501
01:33:35,120 --> 01:33:38,000
我只是想知道一個指標怎麼能

2502
01:33:38,000 --> 01:33:40,639
是一個你知道的數字 並且

2503
01:33:40,639 --> 01:33:43,120
可以排序它如何評估這種

2504
01:33:43,120 --> 01:33:44,639
完全不同的

2505
01:33:44,639 --> 01:33:48,639
國際象棋策略或驅動

2506
01:33:48,840 --> 01:33:50,639
方法最後它只是

2507
01:33:50,639 --> 01:33:52,719
概率論和 概率

2508
01:33:52,719 --> 01:33:55,360
也只是一個數字

2509
01:33:55,360 --> 01:33:57,760
，它的能量

2510
01:33:57,760 --> 01:33:59,760
類型近似於你的證據，這是

2511
01:33:59,760 --> 01:34:01,760
根據你

2512
01:34:01,760 --> 01:34:04,800
觀察數據的模型的概率，所以如果你製作的

2513
01:34:04,800 --> 01:34:07,920
模型可以為你提供最好的證據，

2514
01:34:07,920 --> 01:34:10,239
那麼這對你來說是一個很好的解釋

2515
01:34:10,239 --> 01:34:12,480
數據，

2516
01:34:12,480 --> 01:34:15,040
所以最後只是

2517
01:34:15,040 --> 01:34:16,639
你嘗試做

2518
01:34:16,639 --> 01:34:19,600
近似概率論

2519
01:34:19,600 --> 01:34:20,639


2520
01:34:20,639 --> 01:34:22,080
，然後自由

2521
01:34:22,080 --> 01:34:25,360
能被綁定到你的證據上，

2522
01:34:25,360 --> 01:34:27,120
它還考慮了

2523
01:34:27,120 --> 01:34:28,960
這個後發散項，它

2524
01:34:28,960 --> 01:34:29,920


2525
01:34:29,920 --> 01:34:32,320
表示你為近似貝葉斯推理付出的代價，

2526
01:34:32,320 --> 01:34:35,120


2527
01:34:35,120 --> 01:34:37,600
所以它有 它有兩個部分，它有

2528
01:34:37,600 --> 01:34:40,320
嗯模型證據部分

2529
01:34:40,320 --> 01:34:43,119
，它有後發散部分

2530
01:34:43,119 --> 01:34:47,119
，兩者都發揮作用一個說好的，嗯，

2531
01:34:47,119 --> 01:34:48,400
這

2532
01:34:48,400 --> 01:34:51,040
是我的解決方案的質量，它是

2533
01:34:51,040 --> 01:34:52,320


2534
01:34:52,320 --> 01:34:53,040


2535
01:34:53,040 --> 01:34:54,960
你的模型解釋你觀察到的數據的程度，

2536
01:34:54,960 --> 01:34:57,040
你可以得到 你可以得到一個數字

2537
01:34:57,040 --> 01:34:59,840
來表示驚喜或負

2538
01:34:59,840 --> 01:35:02,239
對數模態證據

2539
01:35:02,239 --> 01:35:03,600
，你有立體發散的另一部分

2540
01:35:03,600 --> 01:35:05,040
，這

2541
01:35:05,040 --> 01:35:07,040
很好，這就是價格和信息

2542
01:35:07,040 --> 01:35:08,800
n 你為這個近似值付費，

2543
01:35:08,800 --> 01:35:11,119
你也可以在上面加上一個

2544
01:35:11,119 --> 01:35:12,239
數字，

2545
01:35:12,239 --> 01:35:13,840
它只是一個你評估的混亂版本，

2546
01:35:13,840 --> 01:35:15,600


2547
01:35:15,600 --> 01:35:17,920
然後你把這兩個相加，你

2548
01:35:17,920 --> 01:35:20,239
得到一個數字，

2549
01:35:20,239 --> 01:35:22,559


2550
01:35:22,880 --> 01:35:24,880
嗯，所以問題是一個數字如何

2551
01:35:24,880 --> 01:35:26,639


2552
01:35:26,639 --> 01:35:29,199
代表

2553
01:35:29,199 --> 01:35:31,840
一切就質量而言，

2554
01:35:31,840 --> 01:35:33,520
您可能關心的

2555
01:35:33,520 --> 01:35:36,080
事情與您的模型預測

2556
01:35:36,080 --> 01:35:39,600
或評估觀察結果的能力不同

2557
01:35:39,600 --> 01:35:42,480
，然後如果您關心其他事情，

2558
01:35:42,480 --> 01:35:43,440


2559
01:35:43,440 --> 01:35:45,440
那麼

2560
01:35:45,440 --> 01:35:47,280
是的，那麼您可能會使用不同的

2561
01:35:47,280 --> 01:35:48,400
數字，

2562
01:35:48,400 --> 01:35:52,800
但是在我們的意義上是 我們

2563
01:35:52,800 --> 01:35:54,000
在我們的工作中

2564
01:35:54,000 --> 01:35:56,400
是的，我們有點

2565
01:35:56,400 --> 01:35:57,440
呃，

2566
01:35:57,440 --> 01:35:59,199
我們想要這種貝葉斯

2567
01:35:59,199 --> 01:36:00,400
質量衡量標準

2568
01:36:00,400 --> 01:36:01,199
是的，

2569
01:36:01,199 --> 01:36:02,400
我不知道這是否真的回答了你的

2570
01:36:02,400 --> 01:36:04,480
問題，但它是它仍然是一個很好的

2571
01:36:04,480 --> 01:36:06,159
問題它是嗯

2572
01:36:06,159 --> 01:36:08,239
它有點是 自由能或

2573
01:36:08,239 --> 01:36:10,400
你得到的那個數字足夠

2574
01:36:10,400 --> 01:36:11,360
正確

2575
01:36:11,360 --> 01:36:13,920
，這就是這背後的原因

2576
01:36:13,920 --> 01:36:16,159
，概率論說是的，但如果

2577
01:36:16,159 --> 01:36:17,600
你在實踐中應用它，那麼你

2578
01:36:17,600 --> 01:36:19,520
可能關心其他你關心

2579
01:36:19,520 --> 01:36:21,840
的事情 任何人在你知道多少錯誤之前生存下來，

2580
01:36:21,840 --> 01:36:23,520
你知道

2581
01:36:23,520 --> 01:36:27,199
你有多少錯誤，你

2582
01:36:27,199 --> 01:36:29,840
從某事中獲利，如果你

2583
01:36:29,840 --> 01:36:31,600
關心這一點，那麼你應該把

2584
01:36:31,600 --> 01:36:33,520
它作為一個績效指標，

2585
01:36:33,520 --> 01:36:36,880
我認為是對的，我的意思是，

2586
01:36:36,880 --> 01:36:39,360
嗯，能量當然有

2587
01:36:39,360 --> 01:36:42,639
在

2588
01:36:42,639 --> 01:36:45,920
復雜性減去準確性

2589
01:36:45,920 --> 01:36:48,880
和和驚喜減去 uh

2590
01:36:48,880 --> 01:36:51,520
減去 kl 散度

2591
01:36:51,520 --> 01:36:54,239
um 中有很多分解但是

2592
01:36:54,239 --> 01:36:54,960


2593
01:36:54,960 --> 01:36:56,560
我不確定我是否正確解釋了這個問題

2594
01:36:56,560 --> 01:36:58,320
但是如果你說你

2595
01:36:58,320 --> 01:37:00,560
怎麼知道它

2596
01:37:00,560 --> 01:37:02,880
在實踐中做得很好 在現場，

2597
01:37:02,880 --> 01:37:05,679
你不正確，

2598
01:37:05,679 --> 01:37:07,040


2599
01:37:07,040 --> 01:37:10,320
嗯，

2600
01:37:10,320 --> 01:37:12,800
你唯一能說的就是，我的意思

2601
01:37:12,800 --> 01:37:15,119
是系統做什麼它會尋找

2602
01:37:15,119 --> 01:37:17,280
一個最小化自由能的配置，

2603
01:37:17,280 --> 01:37:19,280
但你不知道你不

2604
01:37:19,280 --> 01:37:21,040
知道什麼 如果我們沒有模擬那個模型，你不知道是否有另一個

2605
01:37:21,040 --> 01:37:23,119
模型會做得更好

2606
01:37:23,119 --> 01:37:26,000
，那麼我們不知道

2607
01:37:26,000 --> 01:37:27,600
，

2608
01:37:27,600 --> 01:37:29,679
嗯，唯一的學習機會

2609
01:37:29,679 --> 01:37:30,639


2610
01:37:30,639 --> 01:37:34,480
就是產生錯誤，所以嗯，

2611
01:37:34,480 --> 01:37:37,119
這是真正改進模型的唯一方法

2612
01:37:37,119 --> 01:37:38,480
是真的

2613
01:37:38,480 --> 01:37:42,000
嗨 確實，嗯，假設

2614
01:37:42,000 --> 01:37:43,520
它不起作用的情況

2615
01:37:43,520 --> 01:37:45,280
，然後你需要調整你的

2616
01:37:45,280 --> 01:37:47,280
參數，

2617
01:37:47,280 --> 01:37:49,520
而且隨著時間的推移，你必須構建更多的

2618
01:37:49,520 --> 01:37:50,800
結構，

2619
01:37:50,800 --> 01:37:52,239
所以是的，嗯，

2620
01:37:52,239 --> 01:37:53,920
我的意思是建立一個好的系統是一個

2621
01:37:53,920 --> 01:37:55,520
過程，

2622
01:37:55,520 --> 01:37:57,679
對，這不僅僅是一個

2623
01:37:57,679 --> 01:38:00,000
問題

2624
01:38:00,000 --> 01:38:01,600
如果你

2625
01:38:01,600 --> 01:38:02,400
只是

2626
01:38:02,400 --> 01:38:04,400
建立一個系統並且它完全

2627
01:38:04,400 --> 01:38:06,159
正常工作，那麼你必須非常

2628
01:38:06,159 --> 01:38:07,280
幸運，

2629
01:38:07,280 --> 01:38:09,040
這就是

2630
01:38:09,040 --> 01:38:11,119
這個軌道之間的主動

2631
01:38:11,119 --> 01:38:13,600
影響描述的是一個朝著更好系統的過程，

2632
01:38:13,600 --> 01:38:15,520


2633
01:38:15,520 --> 01:38:18,000
但不是

2634
01:38:18,000 --> 01:38:19,440
它沒有描述一個

2635
01:38:19,440 --> 01:38:21,600
不會製造的系統 錯誤 事實上，它

2636
01:38:21,600 --> 01:38:23,840
需要學習錯誤

2637
01:38:23,840 --> 01:38:27,040
，它描述了這個過程

2638
01:38:27,040 --> 01:38:30,000
很棒的點 這是一種操作

2639
01:38:30,000 --> 01:38:32,080
洞察力，如果你在測試中獲得 100 分

2640
01:38:32,080 --> 01:38:35,119
，就像某件事

2641
01:38:35,119 --> 01:38:38,159
在最好的情況下比

2642
01:38:38,159 --> 01:38:40,400
在最壞的情況下提供的信息少，你就是你

2643
01:38:40,400 --> 01:38:43,280
走錯了路，嗯，然後它

2644
01:38:43,280 --> 01:38:45,360
讓我想起了一家雜貨店，是

2645
01:38:45,360 --> 01:38:46,960
不是我們

2646
01:38:46,960 --> 01:38:49,520
根據一種衡量標準對不同的對象進行排名，

2647
01:38:49,520 --> 01:38:51,600
不是真的，這就像尋找平衡

2648
01:38:51,600 --> 01:38:53,280
策略

2649
01:38:53,280 --> 01:38:54,080


2650
01:38:54,080 --> 01:38:55,760
偏好，這就是

2651
01:38:55,760 --> 01:38:56,639
所有這些假設，例如

2652
01:38:56,639 --> 01:38:58,320
分解和平均場，

2653
01:38:58,320 --> 01:39:00,000
並且不能保證每次都給您最好的

2654
01:39:00,000 --> 01:39:02,400
對象，並且仍然存在

2655
01:39:02,400 --> 01:39:04,560
現實世界的隨機性和

2656
01:39:04,560 --> 01:39:06,080
雜貨店改變的能力，

2657
01:39:06,080 --> 01:39:08,639
就像它不是結束一樣 故事中

2658
01:39:08,639 --> 01:39:10,000
它實際上只是

2659
01:39:10,000 --> 01:39:12,880
一個過程中的實踐，它

2660
01:39:12,880 --> 01:39:14,560
具有反應

2661
01:39:14,560 --> 01:39:17,360
圖和生物系統的一些特徵，

2662
01:39:17,360 --> 01:39:20,080
是的，是的

2663
01:39:20,080 --> 01:39:22,960


2664
01:39:22,960 --> 01:39:24,840


2665
01:39:24,840 --> 01:39:27,520


2666
01:39:27,520 --> 01:39:28,800


2667
01:39:28,800 --> 01:39:31,040
隨時歡迎您

2668
01:39:31,040 --> 01:39:33,199
作為參與者加入或展示，

2669
01:39:33,199 --> 01:39:35,360
如果您有任何最終意見，您可以

2670
01:39:35,360 --> 01:39:36,639


2671
01:39:36,639 --> 01:39:38,080
很好地記錄下來，

2672
01:39:38,080 --> 01:39:41,199
很高興來到這裡，

2673
01:39:41,199 --> 01:39:43,600
如果我們有新的東西，我們很樂意

2674
01:39:43,600 --> 01:39:45,760
回來我 認為這是一個很棒的

2675
01:39:45,760 --> 01:39:49,520
精彩節目，或者顯示它是一個

2676
01:39:49,520 --> 01:39:52,239
論壇或任何它的正確名稱，

2677
01:39:52,239 --> 01:39:54,000
但我真的很喜歡它，我們真的很

2678
01:39:54,000 --> 01:39:56,000
喜歡成為它的一部分

2679
01:39:56,000 --> 01:39:58,320
，非常感謝

2680
01:39:58,320 --> 01:40:00,320
一些討論 那裡也有一些值得深思的東西，

2681
01:40:00,320 --> 01:40:01,520
這是一個非常酷的

2682
01:40:01,520 --> 01:40:03,679
好問題，每次有機會

2683
01:40:03,679 --> 01:40:05,840
展示是的，

2684
01:40:05,840 --> 01:40:06,639
很好，

2685
01:40:06,639 --> 01:40:11,320
好吧，直到下次再見

