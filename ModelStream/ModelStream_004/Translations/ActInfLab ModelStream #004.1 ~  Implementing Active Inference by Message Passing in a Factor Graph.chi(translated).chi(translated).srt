1
00:00:00,080 --> 00:00:02,639
一个信号处理小组

2
00:00:02,639 --> 00:00:04,400
，所以我设计了

3
00:00:04,400 --> 00:00:05,680
我的培训，

4
00:00:05,680 --> 00:00:08,080
对不起，实际上我只是改变了一件事

5
00:00:08,080 --> 00:00:10,559
，你能不能重新开始，但是

6
00:00:10,559 --> 00:00:11,920
去吧，

7
00:00:11,920 --> 00:00:12,960
好吧，

8
00:00:12,960 --> 00:00:15,679
谢谢你的介绍，然后我的

9
00:00:15,679 --> 00:00:18,320
名字是 bertie fries，我是

10
00:00:18,320 --> 00:00:20,400
埃因霍温

11
00:00:20,400 --> 00:00:21,920
科技大学的教授 在

12
00:00:21,920 --> 00:00:23,840
荷兰，

13
00:00:23,840 --> 00:00:25,920
我将成为

14
00:00:25,920 --> 00:00:28,000


15
00:00:28,000 --> 00:00:30,480
信号处理组电气工程系的一员，因此我们设计了

16
00:00:30,480 --> 00:00:33,600
信号处理算法，大约

17
00:00:33,600 --> 00:00:36,320
六七年前，我

18
00:00:36,320 --> 00:00:38,399
第一次阅读了 carl fiston 的一篇论文，

19
00:00:38,399 --> 00:00:40,559
它被称为粗略

20
00:00:40,559 --> 00:00:41,760
指南 大脑

21
00:00:41,760 --> 00:00:44,160
并让我感到震惊，这

22
00:00:44,160 --> 00:00:46,399
对于信号处理来说可能非常棒，所以

23
00:00:46,399 --> 00:00:49,039
从那时起，我真的在努力与

24
00:00:49,039 --> 00:00:50,640
我实验室的人合作

25
00:00:50,640 --> 00:00:53,360
，实现将

26
00:00:53,360 --> 00:00:56,559
设计的代理将自动化

27
00:00:56,559 --> 00:00:59,199
信号处理算法的设计过程，正如

28
00:00:59,199 --> 00:01:01,120
你所知，我们正在 通过消息传递来做到这一点

29
00:01:01,120 --> 00:01:02,960
，我们今天想谈谈这个，

30
00:01:02,960 --> 00:01:05,199


31
00:01:05,199 --> 00:01:06,799
嗯，

32
00:01:06,799 --> 00:01:10,400
泰森，嗯，我的名字是泰森，我是

33
00:01:10,400 --> 00:01:13,760
鸟实验室的海报，我做了我的博士学位，也是一个

34
00:01:13,760 --> 00:01:15,280
积极的推论 关于如何自动化

35
00:01:15,280 --> 00:01:17,840
这些过程，呃，我们还

36
00:01:17,840 --> 00:01:20,080
与 michael cox 和

37
00:01:20,080 --> 00:01:22,000
实验室的所有同事一起构建了名为 fornilab 的工具箱

38
00:01:22,000 --> 00:01:24,400
，我将与您交谈并引导

39
00:01:24,400 --> 00:01:27,600
您了解我们如何将其应用到

40
00:01:27,600 --> 00:01:30,400
活动的基础设施推理环境

41
00:01:30,400 --> 00:01:32,560
中 用它做一些很酷的事情

42
00:01:32,560 --> 00:01:35,920
，所以这是为了以后

43
00:01:37,439 --> 00:01:39,759
是的，大家好，所以我的名字是

44
00:01:39,759 --> 00:01:42,640
nitri bhagav，我是bias实验室的博士候选人，

45
00:01:42,640 --> 00:01:46,000
也是大学的hue，是的，我的

46
00:01:46,000 --> 00:01:48,000
工作主要是关于我们希望的基于反应消息

47
00:01:48,000 --> 00:01:50,960
定价的贝叶斯推理

48
00:01:50,960 --> 00:01:52,960
也将有助于主动

49
00:01:52,960 --> 00:01:55,119
推理，但这也是为了

50
00:01:55,119 --> 00:01:56,960
以后我会

51
00:01:56,960 --> 00:01:57,920
在我的

52
00:01:57,920 --> 00:02:01,439
时间谈论它是的，我的插槽

53
00:02:01,759 --> 00:02:04,640
很酷，谢谢你，

54
00:02:05,119 --> 00:02:07,520


55
00:02:07,520 --> 00:02:10,160
嗯，我应该嗯，然后做一些

56
00:02:10,160 --> 00:02:12,560
介绍，几张幻灯片

57
00:02:12,560 --> 00:02:14,000
让我们看看

58
00:02:14,000 --> 00:02:16,400
是的，好吧，

59
00:02:16,400 --> 00:02:18,640
让我们看看 如果我可以分享我的

60
00:02:18,640 --> 00:02:20,000
幻灯片

61
00:02:20,000 --> 00:02:21,360


62
00:02:21,360 --> 00:02:23,040


63
00:02:23,040 --> 00:02:25,040


64
00:02:25,040 --> 00:02:25,840


65
00:02:25,840 --> 00:02:29,040


66
00:02:29,040 --> 00:02:31,120


67
00:02:31,120 --> 00:02:33,680


68
00:02:33,680 --> 00:02:34,560


69
00:02:34,560 --> 00:02:37,280


70
00:02:37,280 --> 00:02:39,680
是的 比利时边境，

71
00:02:39,680 --> 00:02:41,840
距离德国也

72
00:02:41,840 --> 00:02:42,640


73
00:02:42,640 --> 00:02:44,959


74
00:02:44,959 --> 00:02:46,080


75
00:02:46,080 --> 00:02:48,400


76
00:02:48,400 --> 00:02:50,560


77
00:02:50,560 --> 00:02:53,599


78
00:02:53,599 --> 00:02:55,680


79
00:02:55,680 --> 00:02:57,519
不远 技术方面

80
00:02:57,519 --> 00:03:00,319
这是

81
00:03:00,319 --> 00:03:02,840
经过五个小组的鸟瞰图 这

82
00:03:02,840 --> 00:03:05,360
是我们校园

83
00:03:05,360 --> 00:03:07,760
的鸟瞰图 呃所以

84
00:03:07,760 --> 00:03:11,120
这里让我们看看我是否可以分享一个

85
00:03:11,120 --> 00:03:13,440


86
00:03:13,440 --> 00:03:14,959


87
00:03:14,959 --> 00:03:16,239


88
00:03:16,239 --> 00:03:18,560
指针 对于我们尝试构建的贝叶斯

89
00:03:18,560 --> 00:03:20,480
智能自治系统，

90
00:03:20,480 --> 00:03:22,959


91
00:03:22,959 --> 00:03:25,519
我们大约有 3

92
00:03:25,519 --> 00:03:28,000
名工作人员，教职员工

93
00:03:28,000 --> 00:03:31,200
，目前有 6 名博士生 dmitry 是

94
00:03:31,200 --> 00:03:33,120
其中一名 pc 学生

95
00:03:33,120 --> 00:03:35,519
，如果

96
00:03:35,519 --> 00:03:37,760
有人对

97
00:03:37,760 --> 00:03:40,640
概率编程或 如何使

98
00:03:40,640 --> 00:03:43,200
主动推理起作用

99
00:03:43,200 --> 00:03:45,680
那么我们要做什么 这是这个呃论坛

100
00:03:45,680 --> 00:03:47,360
上的每个人都可能熟悉的图片，这就是

101
00:03:47,360 --> 00:03:50,239


102
00:03:50,239 --> 00:03:52,560
呃，这是想要的 大脑中

103
00:03:52,560 --> 00:03:53,840
唯一真正发生的事情

104
00:03:53,840 --> 00:03:55,200


105
00:03:55,200 --> 00:03:57,680
是能量最小化或预期的自由

106
00:03:57,680 --> 00:03:59,120
能最小

107
00:03:59,120 --> 00:04:00,560
化来做所有事情

108
00:04:00,560 --> 00:04:03,360
，这对我们工程师来说是一个巨大的灵感，

109
00:04:03,360 --> 00:04:05,599
所以我们尝试做的

110
00:04:05,599 --> 00:04:08,159
基本上就是我们想要把它放进去 在

111
00:04:08,159 --> 00:04:10,879
iPhone 或树莓派上

112
00:04:10,879 --> 00:04:12,560
，让机器人

113
00:04:12,560 --> 00:04:14,560
学习如何骑自行车，

114
00:04:14,560 --> 00:04:16,798
但这个框架用于工程目的的美妙之处

115
00:04:16,798 --> 00:04:19,839
在于，它几乎

116
00:04:19,839 --> 00:04:22,479
是解决任何问题的一种解决方案，

117
00:04:22,479 --> 00:04:24,080
所以

118
00:04:24,080 --> 00:04:26,240
如果我们能做到，你可以教机器人

119
00:04:26,240 --> 00:04:27,440
如何 写一个

120
00:04:27,440 --> 00:04:30,400
能量最小化也许我们也可以

121
00:04:30,400 --> 00:04:33,360
将它应用到虚拟现实中，并

122
00:04:33,360 --> 00:04:35,120
为助听器甚至

123
00:04:35,120 --> 00:04:38,160
自动驾驶汽车设计算法。

124
00:04:38,240 --> 00:04:40,240


125
00:04:40,240 --> 00:04:41,280
我们说最大的

126
00:04:41,280 --> 00:04:43,360
承诺或

127
00:04:43,360 --> 00:04:45,840
工程的吸引力在于它

128
00:04:45,840 --> 00:04:48,240
只是你所拥有的始终相同的东西

129
00:04:48,240 --> 00:04:50,240
提出一个模型并最小化自由

130
00:04:50,240 --> 00:04:51,440
能，

131
00:04:51,440 --> 00:04:53,520
无论应用是什么，但

132
00:04:53,520 --> 00:04:54,840
它非常吸引

133
00:04:54,840 --> 00:04:56,400


134
00:04:56,400 --> 00:04:59,919
工程的问题是这个

135
00:04:59,919 --> 00:05:02,000
能量

136
00:05:02,000 --> 00:05:04,560
泛函是观察者的函数 vations 和

137
00:05:04,560 --> 00:05:07,600
观察是流数据，

138
00:05:07,600 --> 00:05:08,800


139
00:05:08,800 --> 00:05:10,560
通常可能是

140
00:05:10,560 --> 00:05:13,199
每毫秒，所以它是一个高度时

141
00:05:13,199 --> 00:05:14,880
变的函数，

142
00:05:14,880 --> 00:05:17,360
并且潜在变量的数量

143
00:05:17,360 --> 00:05:19,919
假设潜在变量的空间

144
00:05:19,919 --> 00:05:23,039
通常非常高，所以我们有一个非常高

145
00:05:23,039 --> 00:05:24,639
维的时变函数

146
00:05:24,639 --> 00:05:25,759


147
00:05:25,759 --> 00:05:27,120


148
00:05:27,120 --> 00:05:29,280
我们想要最小化现在大脑

149
00:05:29,280 --> 00:05:31,360
非常擅长它，大脑有

150
00:05:31,360 --> 00:05:34,880
14 突触的 10 次方

151
00:05:34,880 --> 00:05:38,720
1000 亿欧元，

152
00:05:38,720 --> 00:05:41,039
但是一个正常的

153
00:05:41,039 --> 00:05:43,120
优化库和模型或者

154
00:05:43,120 --> 00:05:45,360
python 不会削减它你不能

155
00:05:45,360 --> 00:05:47,840
最小化 matlab中千变量的时变函数

156
00:05:47,840 --> 00:05:49,919


157
00:05:49,919 --> 00:05:51,759
它不起作用

158
00:05:51,759 --> 00:05:55,520
所以我们需要一些非常激进的东西

159
00:05:55,520 --> 00:05:57,840
，我们所采用的想法也不是那么

160
00:05:57,840 --> 00:06:00,800
激进，我们只是

161
00:06:00,800 --> 00:06:03,520
从大脑中获得灵感，大脑是一个

162
00:06:03,520 --> 00:06:07,039
消息传递网络，结果证明

163
00:06:07,039 --> 00:06:09,360


164
00:06:09,360 --> 00:06:12,240


165
00:06:12,240 --> 00:06:15,440
确切地说，在我自己的信号处理或信息理论领域中，

166
00:06:15,440 --> 00:06:17,840
这已经被形式化了，这里有一篇

167
00:06:17,840 --> 00:06:18,880
由

168
00:06:18,880 --> 00:06:22,000
dave forney 于 2001 年撰写的论文，

169
00:06:22,000 --> 00:06:24,560
关于图形正常重新编码 alizations 他

170
00:06:24,560 --> 00:06:27,039
称之为正态因子图，但为了

171
00:06:27,039 --> 00:06:29,840
纪念大卫福尼，今天

172
00:06:29,840 --> 00:06:31,360
它们被称为福尼风格工厂

173
00:06:31,360 --> 00:06:32,319
图

174
00:06:32,319 --> 00:06:33,440
，

175
00:06:33,440 --> 00:06:35,600
所以这就是我们正在谈论的因子图的起源，

176
00:06:35,600 --> 00:06:37,280


177
00:06:37,280 --> 00:06:39,120
几年后，

178
00:06:39,120 --> 00:06:41,600
汉斯安德烈亚卢利格在

179
00:06:41,600 --> 00:06:43,039
大学 系列

180
00:06:43,039 --> 00:06:45,280
嗯，我已经

181
00:06:45,280 --> 00:06:47,840
在信号处理社区中流行了它，

182
00:06:47,840 --> 00:06:51,360
并且已经在 2007 年左右，你

183
00:06:51,360 --> 00:06:54,479
在他的论文中看到了这些，嗯，

184
00:06:54,479 --> 00:06:56,720
是的，这些典型的结构

185
00:06:56,720 --> 00:06:58,560
，我们稍后将展示这些是

186
00:06:58,560 --> 00:07:00,080
卡尔曼滤波器，

187
00:07:00,080 --> 00:07:01,919
这也是特里斯坦所说的

188
00:07:01,919 --> 00:07:04,880
这些类型 结构，所以

189
00:07:04,880 --> 00:07:06,960
嗯，这

190
00:07:06,960 --> 00:07:08,639
就是我们想要用我们的语言做的是将

191
00:07:08,639 --> 00:07:10,800


192
00:07:10,800 --> 00:07:13,039
来自神经科学界的启发灵感的主动推理

193
00:07:13,039 --> 00:07:14,319


194
00:07:14,319 --> 00:07:16,639
结合起来，并将其与

195
00:07:16,639 --> 00:07:18,240
我们在信号处理和

196
00:07:18,240 --> 00:07:20,560
信息论中关于因子图的知识结合起来，

197
00:07:20,560 --> 00:07:24,639
并使用这些工具来 为了实现这一点，

198
00:07:24,639 --> 00:07:26,560
所以今天

199
00:07:26,560 --> 00:07:29,199
我们有两个演示文稿，一个是

200
00:07:29,199 --> 00:07:30,479
来自 uh 行的文本，内容是

201
00:07:30,479 --> 00:07:33,120
关于如何通过

202
00:07:33,120 --> 00:07:35,360
forney lab forney lab 进行消息传递 是

203
00:07:35,360 --> 00:07:36,800
我们写的工具箱，

204
00:07:36,800 --> 00:07:38,160
嗯，你

205
00:07:38,160 --> 00:07:40,960
知道名字当然是指福尼，

206
00:07:40,960 --> 00:07:42,720
嗯，泰国人将展示如何

207
00:07:42,720 --> 00:07:45,120
使用这个工具箱进行积极的影响，

208
00:07:45,120 --> 00:07:47,280
然后我们也在开发一个新版本，

209
00:07:47,280 --> 00:07:49,680
它被称为反应式消息传递，

210
00:07:49,680 --> 00:07:51,520
dmitry 是主要的 那里的人和

211
00:07:51,520 --> 00:07:53,280


212
00:07:53,280 --> 00:07:55,280
dimitri 我也会谈谈这个

213
00:07:55,280 --> 00:07:57,360
，这就是我的全部，

214
00:07:57,360 --> 00:07:59,680
嗯，我会把它还给你，丹，或者，呃，你

215
00:07:59,680 --> 00:08:00,800


216
00:08:00,800 --> 00:08:02,960
可以继续你的偏好是什么，

217
00:08:02,960 --> 00:08:03,840
我将

218
00:08:03,840 --> 00:08:06,720
停止分享我的屏幕，

219
00:08:06,720 --> 00:08:08,400


220
00:08:08,400 --> 00:08:10,720
非常有趣，非常感谢 对于

221
00:08:10,720 --> 00:08:12,479
上下文，

222
00:08:12,479 --> 00:08:14,400
很高兴听到

223
00:08:14,400 --> 00:08:16,560
作者对

224
00:08:16,560 --> 00:08:18,879
您提出的一般性观点以及如何

225
00:08:18,879 --> 00:08:20,960
以非常具体的方式应用它的任何反思，

226
00:08:20,960 --> 00:08:22,319
因为您提出了

227
00:08:22,319 --> 00:08:24,960
我们一直在谈论的大量话题，例如

228
00:08:24,960 --> 00:08:27,440
一种统一方法的简单性以及

229
00:08:27,440 --> 00:08:29,759
持续优化

230
00:08:29,759 --> 00:08:31,520
问题和从

231
00:08:31,520 --> 00:08:33,599
大自然中汲取灵感的挑战如此伟大的事情我认为我们

232
00:08:33,599 --> 00:08:35,440
可以直接跳到

233
00:08:35,440 --> 00:08:36,880


234
00:08:36,880 --> 00:08:38,719
你们都喜欢的演示文稿中，

235
00:08:38,719 --> 00:08:40,640
然后我会去啊 d 并尝试

236
00:08:40,640 --> 00:08:42,000
分享我的屏幕，

237
00:08:42,000 --> 00:08:44,880
看看

238
00:08:46,130 --> 00:08:49,189
是否可行

239
00:08:53,279 --> 00:08:56,160


240
00:08:56,160 --> 00:08:58,800


241
00:09:00,720 --> 00:09:02,080


242
00:09:02,080 --> 00:09:03,839


243
00:09:03,839 --> 00:09:05,600


244
00:09:05,600 --> 00:09:07,200
好了，我们走了，

245
00:09:07,200 --> 00:09:09,440
看起来不错

246
00:09:09,440 --> 00:09:11,920
，我们一切都

247
00:09:11,920 --> 00:09:14,160
很好，再次感谢您邀请我们，您可以

248
00:09:14,160 --> 00:09:15,440
点击离开吗？我将做一些

249
00:09:15,440 --> 00:09:17,040
介绍，抱歉，它说您正在

250
00:09:17,040 --> 00:09:19,040
共享您的屏幕，您可以隐藏

251
00:09:19,040 --> 00:09:21,600
那个小小的 jitsi 东西，

252
00:09:21,600 --> 00:09:23,600
嗯，它已经消失了，

253
00:09:23,600 --> 00:09:25,040
谢谢

254
00:09:25,040 --> 00:09:26,880
嗯，是的，我将简要

255
00:09:26,880 --> 00:09:28,560
介绍如何

256
00:09:28,560 --> 00:09:30,320
在主动推理的背景下使用 phony lab 进行消息传递，

257
00:09:30,320 --> 00:09:32,800


258
00:09:32,800 --> 00:09:34,480
并为这次演讲提供一点动力

259
00:09:34,480 --> 00:09:37,040
，嗯，这是

260
00:09:37,040 --> 00:09:39,360
我们感兴趣的情况 因此，

261
00:09:39,360 --> 00:09:42,000
我们有某种环境，

262
00:09:42,000 --> 00:09:43,600
并且我们有一个

263
00:09:43,600 --> 00:09:45,360
在该环境中运行的环境过程，

264
00:09:45,360 --> 00:09:47,680
我们希望开发一个具有

265
00:09:47,680 --> 00:09:49,760
某种目的或在该环境中执行某些有目的的

266
00:09:49,760 --> 00:09:53,120
任务

267
00:09:53,120 --> 00:09:54,959
的代理，并且允许代理发送

268
00:09:54,959 --> 00:09:56,640
d 对环境的操作并

269
00:09:56,640 --> 00:09:58,880
操纵该环境，它将

270
00:09:58,880 --> 00:10:02,160
接收观察结果

271
00:10:02,160 --> 00:10:04,320
，在环境过程中，有

272
00:10:04,320 --> 00:10:05,519
一些

273
00:10:05,519 --> 00:10:08,320
函数 rt 在那里运行，它

274
00:10:08,320 --> 00:10:10,000
可能是我们运行的模拟，我们

275
00:10:10,000 --> 00:10:11,760
与之交互，或者它甚至可能是一个

276
00:10:11,760 --> 00:10:14,079
真实世界的过程 当然，我们

277
00:10:14,079 --> 00:10:16,640
并不真正知道 rt 在现实世界中运行的是什么，

278
00:10:16,640 --> 00:10:19,120
并且不知何故，我们想

279
00:10:19,120 --> 00:10:21,680
构建一个在那个世界中做某事的代理，

280
00:10:21,680 --> 00:10:23,279


281
00:10:23,279 --> 00:10:26,640
那么你从哪里开始呢？

282
00:10:26,800 --> 00:10:29,360
这是 1970 年代 conant 和 ashby 的这篇论文

283
00:10:29,360 --> 00:10:31,040


284
00:10:31,040 --> 00:10:32,480
和 他们有一个有趣的定理

285
00:10:32,480 --> 00:10:33,600
，即系统的

286
00:10:33,600 --> 00:10:36,000
每个好的调节器都必须

287
00:10:36,000 --> 00:10:39,040
是该系统的模型，

288
00:10:39,040 --> 00:10:39,920
因此

289
00:10:39,920 --> 00:10:41,519
这实际上意味着，如果您想

290
00:10:41,519 --> 00:10:43,120
构建一个

291
00:10:43,120 --> 00:10:44,839
调节或

292
00:10:44,839 --> 00:10:47,839
操纵我们系统环境的代理，

293
00:10:47,839 --> 00:10:51,920
那么我们必须对该系统进行建模，

294
00:10:51,920 --> 00:10:53,600
以便

295
00:10:53,600 --> 00:10:55,920
我们是一名工程师，我们从事

296
00:10:55,920 --> 00:10:57,839
构建模型的业务，

297
00:10:57,839 --> 00:11:00,880
准确地说是生成模型

298
00:11:00,880 --> 00:11:03,120
，这个模型代表了我们对

299
00:11:03,120 --> 00:11:04,160


300
00:11:04,160 --> 00:11:05,920
观察结果如何

301
00:11:05,920 --> 00:11:09,839
从我们的操作中得出的

302
00:11:09,839 --> 00:11:12,160
信念 由函数 f 表示，它

303
00:11:12,160 --> 00:11:15,839
是 y 的函数 观察值

304
00:11:15,839 --> 00:11:17,839
控制 u

305
00:11:17,839 --> 00:11:20,560
以及一些潜在状态隐藏

306
00:11:20,560 --> 00:11:23,440
变量

307
00:11:23,440 --> 00:11:25,440
x 充当

308
00:11:25,440 --> 00:11:29,160
观察值和控制之间的中间体

309
00:11:30,160 --> 00:11:31,760
现在

310
00:11:31,760 --> 00:11:34,000
向前推理是一回事，

311
00:11:34,000 --> 00:11:36,160
但最终我们要做的是观察

312
00:11:36,160 --> 00:11:38,640
事物 然后提出将

313
00:11:38,640 --> 00:11:41,600
我们引导到有利状态的控制

314
00:11:41,600 --> 00:11:42,959
，这就是

315
00:11:42,959 --> 00:11:44,880
自由能原理

316
00:11:44,880 --> 00:11:47,519
和主动推理的想法出现的地方，

317
00:11:47,519 --> 00:11:49,440
所以如果我们

318
00:11:49,440 --> 00:11:51,360
想看到这是假设，如果

319
00:11:51,360 --> 00:11:53,600
我们想建立一个有目的的代理，

320
00:11:53,600 --> 00:11:55,440
那么 我们可以

321
00:11:55,440 --> 00:11:58,240
通过最小化意外的自由能来做到这一点，

322
00:11:58,240 --> 00:12:00,240


323
00:12:00,240 --> 00:12:02,320
因此我们想要构建一个避免意外的代理，

324
00:12:02,320 --> 00:12:05,040
并且我们可以

325
00:12:05,040 --> 00:12:07,600
对该环境进行贝叶斯推断，

326
00:12:07,600 --> 00:12:09,600
因此我们必须为代理构建某种自由

327
00:12:09,600 --> 00:12:11,200
能函数

328
00:12:11,200 --> 00:12:13,680
来优化

329
00:12:13,680 --> 00:12:16,720
和 通过动作和控制的持续时间推断

330
00:12:16,720 --> 00:12:19,540


331
00:12:19,540 --> 00:12:20,959
[音乐]

332
00:12:20,959 --> 00:12:23,760
，我们将能量函数定义为

333
00:12:23,760 --> 00:12:26,240


334
00:12:26,240 --> 00:12:28,160
我们拥有的生成模型

335
00:12:28,160 --> 00:12:29,600
和 s 之间的 kl 分歧

336
00:12:29,600 --> 00:12:32,959
我们假设我们在这里

337
00:12:32,959 --> 00:12:35,839
定义 q t

338
00:12:36,000 --> 00:12:38,240
并最小化这个能量泛函的某种近似后验

339
00:12:38,240 --> 00:12:40,160
将允许我们

340
00:12:40,160 --> 00:12:44,560
从观察到控制向后推理

341
00:12:45,360 --> 00:12:48,720
，这是一种普遍的想法

342
00:12:48,720 --> 00:12:50,320
，

343
00:12:50,320 --> 00:12:52,480
并且假设我有选择

344
00:12:52,480 --> 00:12:53,360


345
00:12:53,360 --> 00:12:55,680
，例如一个大的 我

346
00:12:55,680 --> 00:12:57,760
想做的选择是我如何选择我的模型我

347
00:12:57,760 --> 00:12:59,600
如何

348
00:12:59,600 --> 00:13:01,760


349
00:13:01,760 --> 00:13:03,839
以对我有用的方式选择我的 f

350
00:13:03,839 --> 00:13:06,399
以及我如何选择我的 qut

351
00:13:06,399 --> 00:13:08,320
我如何选择它的因式分解

352
00:13:08,320 --> 00:13:09,440


353
00:13:09,440 --> 00:13:13,040
以便我可以制作我的 推论

354
00:13:13,120 --> 00:13:14,160
，

355
00:13:14,160 --> 00:13:17,360
这个过程是一种反复试验的事情

356
00:13:17,360 --> 00:13:19,120


357
00:13:19,120 --> 00:13:20,800
，嗯，

358
00:13:20,800 --> 00:13:22,480
作为一名工程师，我当然想建立

359
00:13:22,480 --> 00:13:24,959
我可能能做到的最好的模型，

360
00:13:24,959 --> 00:13:26,959
但是我如何才能

361
00:13:26,959 --> 00:13:28,720
通过反复试验的过程尽快完成

362
00:13:28,720 --> 00:13:30,959
我是最好的标记

363
00:13:30,959 --> 00:13:34,199
最好的模型

364
00:13:34,560 --> 00:13:36,800
，这就是模型

365
00:13:36,800 --> 00:13:39,199
设计周期的想法出现的地方

366
00:13:39,199 --> 00:13:41,839
，这再次被 david

367
00:13:41,839 --> 00:13:43,120
bly

368
00:13:43,120 --> 00:13:45,440
在他的论文中流行起来，在 2014 年建立计算

369
00:13:45,440 --> 00:13:47,600
评论重复

370
00:13:47,600 --> 00:13:49,760
，他提出了一个循环，其中

371
00:13:49,760 --> 00:13:52,240
工程师提出了一个模型

372
00:13:52,240 --> 00:13:54,320
，然后你想用这个模型

373
00:13:54,320 --> 00:13:56,480
推断你感兴趣的给定

374
00:13:56,480 --> 00:13:58,079
数据的数量

375
00:13:58,079 --> 00:13:59,600
，如果你已经推断出这样的模型

376
00:13:59,600 --> 00:14:01,279
，你想批评它，

377
00:14:01,279 --> 00:14:02,720
并根据

378
00:14:02,720 --> 00:14:04,560
你评估过的性能，

379
00:14:04,560 --> 00:14:07,680
你想重申重建

380
00:14:07,680 --> 00:14:08,800
你的模型

381
00:14:08,800 --> 00:14:09,839


382
00:14:09,839 --> 00:14:10,720
再次推断

383
00:14:10,720 --> 00:14:12,959
，看看它的表现

384
00:14:12,959 --> 00:14:14,639
如何，直到你满意

385
00:14:14,639 --> 00:14:16,959


386
00:14:16,959 --> 00:14:19,680


387
00:14:19,680 --> 00:14:21,440


388
00:14:21,440 --> 00:14:24,079


389
00:14:24,079 --> 00:14:27,040


390
00:14:27,120 --> 00:14:29,279
为止 我们希望变得灵活，我们希望

391
00:14:29,279 --> 00:14:31,760
使事情自动化，

392
00:14:31,760 --> 00:14:34,000
并且提出模型建议本身是

393
00:14:34,000 --> 00:14:35,040


394
00:14:35,040 --> 00:14:37,440
您作为工程师必须做的事情，

395
00:14:37,440 --> 00:14:38,800
您必须提出一个

396
00:14:38,800 --> 00:14:40,320


397
00:14:40,320 --> 00:14:44,079
关于您认为世界如何运作的建议，

398
00:14:44,079 --> 00:14:45,920
但是一旦您拥有了

399
00:14:45,920 --> 00:14:48,959
其他一切 可以自动化

400
00:14:48,959 --> 00:14:50,800
您可以通过概率编程推断这些数量

401
00:14:50,800 --> 00:14:52,480
您可以

402
00:14:52,480 --> 00:14:55,920
评估自由能作为模型性能的衡量标准

403
00:14:55,920 --> 00:14:57,360


404
00:14:57,360 --> 00:14:59,040
[音乐]

405
00:14:59,040 --> 00:15:00,399
并

406
00:15:00,399 --> 00:15:03,120
自动执行此循环 l 是

407
00:15:03,120 --> 00:15:05,360
为在实践中有用的代理提出模型建议的关键，

408
00:15:05,360 --> 00:15:07,519
因此您希望

409
00:15:07,519 --> 00:15:08,639
尽快完成此过程，

410
00:15:08,639 --> 00:15:10,160


411
00:15:10,160 --> 00:15:11,760
这就是为什么我们选择特定方法的原因，

412
00:15:11,760 --> 00:15:14,079
我们选择矢量图

413
00:15:14,079 --> 00:15:16,240
来表示我们的分解模型，

414
00:15:16,240 --> 00:15:17,680
因为

415
00:15:17,680 --> 00:15:20,000
在图中您 可以进行操作 您

416
00:15:20,000 --> 00:15:22,560
可以添加节点 删除节点 您可以

417
00:15:22,560 --> 00:15:24,839
非常快速地重新连接事物

418
00:15:24,839 --> 00:15:26,959
，一旦您有了模型的图形

419
00:15:26,959 --> 00:15:29,040
表示，您就可以

420
00:15:29,040 --> 00:15:31,440
在该图上进行消息传递

421
00:15:31,440 --> 00:15:34,399
以自动化推理

422
00:15:34,399 --> 00:15:36,720
，您甚至可以通过本地贡献评估自由能

423
00:15:36,720 --> 00:15:38,839
这

424
00:15:38,839 --> 00:15:41,920
就是我们选择

425
00:15:41,920 --> 00:15:43,519
图形表示的原因，也是

426
00:15:43,519 --> 00:15:45,440
我们想要进行消息传递的原因，因为我们

427
00:15:45,440 --> 00:15:47,440
想要快速设计模型，

428
00:15:47,440 --> 00:15:51,680
以便我们现在可以设计有效的代理

429
00:15:52,639 --> 00:15:54,880
这些

430
00:15:54,880 --> 00:15:57,279
图表如何正确工作如何构建

431
00:15:57,279 --> 00:15:58,639
有效的代理 图形或它看起来像什么，

432
00:15:58,639 --> 00:16:00,560


433
00:16:00,560 --> 00:16:03,040
因此我们选择模型的特定表示

434
00:16:03,040 --> 00:16:04,560


435
00:16:04,560 --> 00:16:06,880
，这是一个示例，其中我们有

436
00:16:06,880 --> 00:16:09,120
五个变量的生成模型 x1

437
00:16:09,120 --> 00:16:10,959
到 x5

438
00:16:10,959 --> 00:16:15,759
，我们有三个因子 f a b 和 c

439
00:16:15,759 --> 00:16:18,079
，右图

440
00:16:18,079 --> 00:16:20,240
是该模型的图形表示

441
00:16:20,240 --> 00:16:21,279


442
00:16:21,279 --> 00:16:23,440
，您可以看到边对应

443
00:16:23,440 --> 00:16:25,680
于变量，节点

444
00:16:25,680 --> 00:16:28,560
对应于向量

445
00:16:28,560 --> 00:16:31,360
，边连接到

446
00:16:31,360 --> 00:16:32,399


447
00:16:32,399 --> 00:16:34,560
向量在参数中的节点，所以在这里你

448
00:16:34,560 --> 00:16:37,040
看到节点 fa 很好地连接了边 x1 和

449
00:16:37,040 --> 00:16:39,759
x2，这是因为 x1 和 x2

450
00:16:39,759 --> 00:16:42,160
是 fa 的参数，

451
00:16:42,160 --> 00:16:45,519
对于 fb 和 fc

452
00:16:46,800 --> 00:16:48,079
现在

453
00:16:48,079 --> 00:16:50,639
我们如何在这个图中进行推理

454
00:16:50,639 --> 00:16:53,680
所以假设我们 观察

455
00:16:53,680 --> 00:16:56,480
由这个小实心方块表示的 x5

456
00:16:56,480 --> 00:16:58,399


457
00:16:58,399 --> 00:17:00,560
，我们想要计算我们对 x2 的信念，

458
00:17:00,560 --> 00:17:02,800
给定 x5

459
00:17:02,800 --> 00:17:05,359
，你做得好你边缘化

460
00:17:05,359 --> 00:17:07,199
一切

461
00:17:07,199 --> 00:17:09,119
，边缘化我的意思是你整合

462
00:17:09,119 --> 00:17:10,959


463
00:17:10,959 --> 00:17:12,559
除你感兴趣的变量之外的所有变量，

464
00:17:12,559 --> 00:17:14,319
所以 接受 x2，

465
00:17:14,319 --> 00:17:16,559
你把所有东西都整合出来，然后你

466
00:17:16,559 --> 00:17:20,640
添加这个约束，你现在观察 x5

467
00:17:20,640 --> 00:17:23,199
如果你有一个大模型，

468
00:17:23,199 --> 00:17:25,599
那么这个整合变得非常

469
00:17:25,599 --> 00:17:28,319
麻烦，因为这就是

470
00:17:28,319 --> 00:17:30,480
你在这里 fo 你的变量要

471
00:17:30,480 --> 00:17:32,559
积分

472
00:17:32,559 --> 00:17:33,520
所以

473
00:17:33,520 --> 00:17:35,679
这个房间这个积分空间

474
00:17:35,679 --> 00:17:37,840
如果你想天真地做这个真的会爆炸

475
00:17:37,840 --> 00:17:40,320


476
00:17:40,320 --> 00:17:43,039
但是你可以很聪明

477
00:17:43,039 --> 00:17:45,120
你可以

478
00:17:45,120 --> 00:17:47,640


479
00:17:47,640 --> 00:17:49,919
根据

480
00:17:49,919 --> 00:17:52,080
它们各自的

481
00:17:52,080 --> 00:17:54,480
术语重新洗牌这些积分例如

482
00:17:54,480 --> 00:17:57,600
这个积分超过 x5

483
00:17:57,600 --> 00:18:00,000
好吧，只有一个因素 x5

484
00:18:00,000 --> 00:18:01,440
是一个参数，

485
00:18:01,440 --> 00:18:03,520
所以我可以使用分配规则

486
00:18:03,520 --> 00:18:06,960
将这个积分带入内部，

487
00:18:07,280 --> 00:18:09,840
以便我将这些积分分成

488
00:18:09,840 --> 00:18:14,120
更小的部分，这些部分是可管理的

489
00:18:14,320 --> 00:18:16,400
，这就是消息传递来自

490
00:18:16,400 --> 00:18:17,200


491
00:18:17,200 --> 00:18:19,919
消息传递的地方

492
00:18:19,919 --> 00:18:22,559
逐个解决这些集成，

493
00:18:22,559 --> 00:18:25,520
因此我可以首先在这里集成 x

494
00:18:25,520 --> 00:18:27,520
x one，例如

495
00:18:27,520 --> 00:18:28,559
，

496
00:18:28,559 --> 00:18:31,280
正如我们所说，它总结了

497
00:18:31,280 --> 00:18:33,840
这个橙色框内的所有信息，它给了我们一条

498
00:18:33,840 --> 00:18:35,919
消息，这里的第一条消息退出了

499
00:18:35,919 --> 00:18:38,480
这个橙色框，

500
00:18:38,480 --> 00:18:40,320
然后它可以继续 底部，所以

501
00:18:40,320 --> 00:18:43,120
积分出 x5

502
00:18:43,120 --> 00:18:45,840
，我得到第二条消息

503
00:18:45,840 --> 00:18:48,160
，我可以

504
00:18:48,160 --> 00:18:50,559
在计算第三条消息时使用第二条消息，

505
00:18:50,559 --> 00:18:52,880
所以 是您

506
00:18:52,880 --> 00:18:56,080
获得嵌套解决方案方法的方式

507
00:18:56,080 --> 00:18:58,240
，在该方法中我

508
00:18:58,240 --> 00:18:59,600
在计算消息三时使用消息二的解决方案

509
00:18:59,600 --> 00:19:01,760


510
00:19:01,760 --> 00:19:03,679
，您会看到最后

511
00:19:03,679 --> 00:19:05,600
这两个

512
00:19:05,600 --> 00:19:08,320
碰撞消息在 x2 边缘的乘积

513
00:19:08,320 --> 00:19:10,000
会给我

514
00:19:10,000 --> 00:19:12,480
我的比例信念我

515
00:19:12,480 --> 00:19:14,960


516
00:19:14,960 --> 00:19:19,280
在 x2 上的比例后验给定我所观察到的，

517
00:19:21,120 --> 00:19:24,400
所以举一个特定节点的小例子，

518
00:19:24,400 --> 00:19:27,679


519
00:19:27,679 --> 00:19:30,320
这里的工作原理是一个等式约束节点

520
00:19:30,320 --> 00:19:32,080
，我们用

521
00:19:32,080 --> 00:19:33,120
它

522
00:19:33,120 --> 00:19:34,640
作为约束

523
00:19:34,640 --> 00:19:36,320


524
00:19:36,320 --> 00:19:38,400
来约束

525
00:19:38,400 --> 00:19:41,280
相邻边上的信念是 等于

526
00:19:41,280 --> 00:19:43,840
um，

527
00:19:43,840 --> 00:19:45,440
如果我们在这里进行数学运算，它们将遵循，

528
00:19:45,440 --> 00:19:46,559


529
00:19:46,559 --> 00:19:47,520


530
00:19:47,520 --> 00:19:48,880
这就是节点函数的

531
00:19:48,880 --> 00:19:51,200
样子，所以我说好吧，它是

532
00:19:51,200 --> 00:19:53,200
三个变量 x y 和 z 的函数

533
00:19:53,200 --> 00:19:55,679
，我将 z 约束

534
00:19:55,679 --> 00:19:58,960
为 x 和 我将 z 也限制为 y，

535
00:19:58,960 --> 00:20:00,000
所以

536
00:20:00,000 --> 00:20:01,760
如果我将这两个限制为相同，那么 x 也将是 y，

537
00:20:01,760 --> 00:20:03,840


538
00:20:03,840 --> 00:20:05,679
所以让我们看看我们是否可以

539
00:20:05,679 --> 00:20:08,640
基于此导出消息，

540
00:20:08,880 --> 00:20:09,760
所以

541
00:20:09,760 --> 00:20:11,520
如果我想将信息汇总

542
00:20:11,520 --> 00:20:13,360
到这个橙色框中，

543
00:20:13,360 --> 00:20:14,960
我 可以使用子产品规则，

544
00:20:14,960 --> 00:20:16,799
我有两条消息

545
00:20:16,799 --> 00:20:18,320
从左边进来，从底部

546
00:20:18,320 --> 00:20:20,880
消息一和消息 2。

547
00:20:20,880 --> 00:20:23,280
我乘以

548
00:20:23,280 --> 00:20:24,799
相等节点的节点函数，我现在想

549
00:20:24,799 --> 00:20:27,760
执行这个集成

550
00:20:27,760 --> 00:20:29,360


551
00:20:29,360 --> 00:20:31,280


552
00:20:31,280 --> 00:20:32,880
用除法积分代替这个节点函数

553
00:20:32,880 --> 00:20:34,720
，然后我可以使用

554
00:20:34,720 --> 00:20:36,240
shift 属性

555
00:20:36,240 --> 00:20:37,200


556
00:20:37,200 --> 00:20:39,600
将 x

557
00:20:39,600 --> 00:20:41,440
和 y

558
00:20:41,440 --> 00:20:43,840
的参数替换为 z 的参数，

559
00:20:43,840 --> 00:20:47,120
所以我在这里所做的基本上是

560
00:20:47,120 --> 00:20:49,360
说我可以通过乘法来计算这条消息

561
00:20:49,360 --> 00:20:51,919
三

562
00:20:51,919 --> 00:20:53,440
现在从左侧和底部传入的两条消息

563
00:20:53,440 --> 00:20:55,280


564
00:20:55,280 --> 00:20:56,799
如果您稍微眯起眼睛

565
00:20:56,799 --> 00:20:58,799
看，呃，您通过眼睛看，

566
00:20:58,799 --> 00:21:00,799
您可以在这里识别出

567
00:21:00,799 --> 00:21:03,919
一个比例基本规则，

568
00:21:03,919 --> 00:21:06,320
所以基本上您可以说如果

569
00:21:06,320 --> 00:21:08,000
消息三 这里代表我的

570
00:21:08,000 --> 00:21:09,360
后验，

571
00:21:09,360 --> 00:21:11,919
然后消息一个可以代表我之前的

572
00:21:11,919 --> 00:21:15,440
一个消息，我的可能性

573
00:21:15,440 --> 00:21:17,280
，然后我有一个成比例的后验

574
00:21:17,280 --> 00:21:19,520
消息三，然后我可以传递给

575
00:21:19,520 --> 00:21:21,520
我的 mod 的其余部分 el

576
00:21:21,520 --> 00:21:23,200
和这个节点也经常

577
00:21:23,200 --> 00:21:24,880
用于将

578
00:21:24,880 --> 00:21:28,000
来自左侧和底部

579
00:21:29,120 --> 00:21:31,840


580
00:21:34,320 --> 00:21:36,480


581
00:21:36,480 --> 00:21:38,320
的信息

582
00:21:38,320 --> 00:21:42,240


583
00:21:42,240 --> 00:21:43,760


584
00:21:43,760 --> 00:21:46,400
进行组合 已经派生

585
00:21:46,400 --> 00:21:49,200
到 uh into phony lab 的规则，这基本上是

586
00:21:49,200 --> 00:21:50,880


587
00:21:50,880 --> 00:21:53,679
一个软件问题编程

588
00:21:53,679 --> 00:21:55,360
套件

589
00:21:55,360 --> 00:21:57,520
，可以为您执行调度和

590
00:21:57,520 --> 00:22:00,240
此消息计算，

591
00:22:00,240 --> 00:22:01,760
因此您不必考虑

592
00:22:01,760 --> 00:22:03,280
太多如何重新分配这些

593
00:22:03,280 --> 00:22:06,240
积分以及如何推导

594
00:22:06,240 --> 00:22:10,400
嗯，对于特定节点有很多更新，

595
00:22:10,960 --> 00:22:13,280
所以

596
00:22:13,280 --> 00:22:15,520
我们可以

597
00:22:15,520 --> 00:22:17,280


598
00:22:17,280 --> 00:22:19,919
在设计周期的那一侧自动化呃

599
00:22:19,919 --> 00:22:22,320


600
00:22:23,200 --> 00:22:24,840
现在

601
00:22:24,840 --> 00:22:27,120
其他任何关于这个的问题，因为

602
00:22:27,120 --> 00:22:28,880
我正在快速完成这个，

603
00:22:28,880 --> 00:22:30,240
什么 我接下来要做的是有点

604
00:22:30,240 --> 00:22:32,320
想通过一个例子，

605
00:22:32,320 --> 00:22:34,240
所以也许这是一个自然的点

606
00:22:34,240 --> 00:22:36,880
，人们有问题，他们

607
00:22:36,880 --> 00:22:38,880
可以阻止我并认为嘿你

608
00:22:38,880 --> 00:22:41,440
要走了 g 在这里快速，

609
00:22:41,440 --> 00:22:43,600
我认为看到这个例子会很好

610
00:22:43,600 --> 00:22:45,280
，然后我们在

611
00:22:45,280 --> 00:22:47,039
实时聊天中有一些问题，也欢迎任何人

612
00:22:47,039 --> 00:22:49,120
添加更多，

613
00:22:49,120 --> 00:22:52,158
好吧，确定，

614
00:22:52,400 --> 00:22:54,480
所以你如何

615
00:22:54,480 --> 00:22:56,640
在积极的推理环境中在实践中做到这一点所以 这

616
00:22:56,640 --> 00:22:58,080
是一个小例子，它被称为

617
00:22:58,080 --> 00:23:00,559
贝叶斯恒温器

618
00:23:00,559 --> 00:23:02,960
，我们有一个环境环境，

619
00:23:02,960 --> 00:23:03,760


620
00:23:03,760 --> 00:23:05,840
所以我们在左边有一个热源

621
00:23:05,840 --> 00:23:08,000
，我们有一辆可以

622
00:23:08,000 --> 00:23:09,600
四处移动的小汽车，它可以远离

623
00:23:09,600 --> 00:23:11,520
热源，也可以朝 热源

624
00:23:11,520 --> 00:23:13,679


625
00:23:13,679 --> 00:23:16,400
现在相对于热源的位置

626
00:23:16,400 --> 00:23:19,120
是我们所说的 x

627
00:23:19,120 --> 00:23:20,799
，在每个位置都有一个

628
00:23:20,799 --> 00:23:22,799
特定的温度

629
00:23:22,799 --> 00:23:23,679
um

630
00:23:23,679 --> 00:23:25,120
，我们在特定位置测量的温度

631
00:23:25,120 --> 00:23:29,600
是我们所说的 y

632
00:23:29,679 --> 00:23:31,600
，我们倾向于处于

633
00:23:31,600 --> 00:23:33,440
温度 四

634
00:23:33,440 --> 00:23:35,440
y 四 我不知道这是我们现在选择的东西

635
00:23:35,440 --> 00:23:37,600


636
00:23:37,600 --> 00:23:39,360
我们通过

637
00:23:39,360 --> 00:23:41,279
向左或向右移动来控制这辆车 我们的控制

638
00:23:41,279 --> 00:23:43,440
这是我们向左

639
00:23:43,440 --> 00:23:45,360
或向右移动的速度 它被称为

640
00:23:45,360 --> 00:23:47,520
u

641
00:23:47,840 --> 00:23:50,880
所以这是我们的环境 nt

642
00:23:50,880 --> 00:23:54,320
并且我们想要为此建立一个模型，

643
00:23:54,320 --> 00:23:56,240
因此

644
00:23:56,240 --> 00:23:57,919
在主动干扰中，我们想要

645
00:23:57,919 --> 00:23:59,760
做的是

646
00:23:59,760 --> 00:24:01,840
我们想要

647
00:24:01,840 --> 00:24:05,039
从我们想要控制的状态进行推理

648
00:24:05,039 --> 00:24:07,600
，我们必须

649
00:24:07,600 --> 00:24:09,679
在当前时间应用该电流

650
00:24:09,679 --> 00:24:12,080
以获得 在未来

651
00:24:12,080 --> 00:24:13,679
所以我们想要做的是我们想要

652
00:24:13,679 --> 00:24:16,000
从当前

653
00:24:16,000 --> 00:24:17,360
时间 t

654
00:24:17,360 --> 00:24:18,400
向前推理到

655
00:24:18,400 --> 00:24:21,120
某个时间范围 big t

656
00:24:21,120 --> 00:24:22,880
并且

657
00:24:22,880 --> 00:24:25,200
在未来我们想要考虑

658
00:24:25,200 --> 00:24:27,200
智能体将如何移动

659
00:24:27,200 --> 00:24:29,120
以及我们希望该智能体在哪里 在

660
00:24:29,120 --> 00:24:32,960
那个时候和最后，我们将希望

661
00:24:32,960 --> 00:24:35,760
处于 4 的温度

662
00:24:35,760 --> 00:24:37,200
，这是一个状态空间模型，它

663
00:24:37,200 --> 00:24:41,520
代表了我们对这个代理将如何

664
00:24:41,520 --> 00:24:42,880


665
00:24:42,880 --> 00:24:44,320


666
00:24:44,320 --> 00:24:46,480
在世界中移动的信念，

667
00:24:46,480 --> 00:24:48,720
所以在时间 t 我们有一个观察

668
00:24:48,720 --> 00:24:51,200
到 特定的温度

669
00:24:51,200 --> 00:24:55,360
，也许我们已经做了一个动作

670
00:24:55,360 --> 00:24:56,960
，

671
00:24:56,960 --> 00:24:59,600
我们

672
00:24:59,600 --> 00:25:02,159
说当前状态 xt 与

673
00:25:02,159 --> 00:25:03,840
之前的状态和动作相关，我们

674
00:25:03,840 --> 00:25:06,559
通过添加所以基本上 ut 这里

675
00:25:06,559 --> 00:25:08,320
是我们添加到当前

676
00:25:08,320 --> 00:25:09,600
位置的

677
00:25:09,600 --> 00:25:12,880
速度 时间  一步，然后我们

678
00:25:12,880 --> 00:25:14,640


679
00:25:14,640 --> 00:25:17,039
通过添加它并应用

680
00:25:17,039 --> 00:25:19,520
一些高斯噪声得到我们的下一个位置，所

681
00:25:19,520 --> 00:25:21,279
以我们有一个状态转换，它是这

682
00:25:21,279 --> 00:25:23,520
个加法的，有责

683
00:25:23,520 --> 00:25:25,600
任说我想向左移动或向

684
00:25:25,600 --> 00:25:28,880
右移动四个

685
00:25:28,880 --> 00:25:30,559
然后我们添加一些高斯噪声说

686
00:25:30,559 --> 00:25:33,039
好的我们有点不确定

687
00:25:33,039 --> 00:25:34,799
这个代理在环境中如何移动

688
00:25:34,799 --> 00:25:35,919


689
00:25:35,919 --> 00:25:38,159
我们对此有一个想法但是让我们添加

690
00:25:38,159 --> 00:25:40,080
一些变体以

691
00:25:40,080 --> 00:25:43,760
解释一些不确定性

692
00:25:43,760 --> 00:25:45,520
然后我们在这里说这个 垂直

693
00:25:45,520 --> 00:25:47,520
线，如果我们

694
00:25:47,520 --> 00:25:49,600
有一个观察

695
00:25:49,600 --> 00:25:52,159
或如果我们有一个位置，那么它

696
00:25:52,159 --> 00:25:55,840
与温度的观察有关

697
00:25:55,840 --> 00:25:56,960


698
00:25:56,960 --> 00:25:59,279


699
00:25:59,279 --> 00:26:01,440


700
00:26:01,440 --> 00:26:03,200


701
00:26:03,200 --> 00:26:05,200
来源，那么我的温度

702
00:26:05,200 --> 00:26:06,720


703
00:26:06,720 --> 00:26:09,120
将以负一的斜率下降

704
00:26:09,120 --> 00:26:11,200
，这是一个非常粗略的猜测，

705
00:26:11,200 --> 00:26:12,880
在现实世界中会有一个非常好的

706
00:26:12,880 --> 00:26:14,640
温度梯度，它可能

707
00:26:14,640 --> 00:26:16,799
会像

708
00:26:16,799 --> 00:26:19,360
会非常缓慢地向下移动一样移动，

709
00:26:19,360 --> 00:26:21,840
但是 我们只是说，嘿，我们真的不

710
00:26:21,840 --> 00:26:24,400
知道那是什么让

711
00:26:24,400 --> 00:26:26,159
我们粗略猜测一下，我们相信这是我们的

712
00:26:26,159 --> 00:26:27,760
生成模型

713
00:26:27,760 --> 00:26:29,520


714
00:26:29,520 --> 00:26:32,400


715
00:26:32,400 --> 00:26:33,919
关于

716
00:26:33,919 --> 00:26:36,559
这一点，让我们再次添加

717
00:26:36,559 --> 00:26:39,600
一些高斯噪声

718
00:26:39,600 --> 00:26:41,679
，现在我将其扩展

719
00:26:41,679 --> 00:26:43,919
到未来，所以我说得好，我

720
00:26:43,919 --> 00:26:45,760
相信未来我的

721
00:26:45,760 --> 00:26:48,240
环境也将

722
00:26:48,240 --> 00:26:50,480
根据这一点发展，

723
00:26:50,480 --> 00:26:51,360
但

724
00:26:51,360 --> 00:26:53,520
我也有一些关于我想去哪里的想法

725
00:26:53,520 --> 00:26:55,360


726
00:26:55,360 --> 00:26:58,720
和这个 是黄金先验出现的地方，

727
00:26:58,720 --> 00:27:00,960
它将我未来

728
00:27:00,960 --> 00:27:03,200
对温度的观察限制在这个

729
00:27:03,200 --> 00:27:06,240
期望的温度四左右

730
00:27:06,240 --> 00:27:08,080
，然后我说这里有一些额外的

731
00:27:08,080 --> 00:27:11,200
噪音，嗯，

732
00:27:11,200 --> 00:27:13,360
我想在四左右，它

733
00:27:13,360 --> 00:27:15,360
不一定是完全正确的 但我

734
00:27:15,360 --> 00:27:18,240
想非常确定，嗯，

735
00:27:18,240 --> 00:27:21,360
在时间 t 加 1 时，我将在 4 岁左右，我将

736
00:27:21,360 --> 00:27:22,480


737
00:27:22,480 --> 00:27:24,080
继续留在那里

738
00:27:24,080 --> 00:27:25,039
直到

739
00:27:25,039 --> 00:27:28,080
未来的某个时候，

740
00:27:30,320 --> 00:27:33,200
现在我们有了再生模型

741
00:27:33,200 --> 00:27:35,200
，

742
00:27:35,200 --> 00:27:37,279
我们可以定义我们的能量函数，

743
00:27:37,279 --> 00:27:39,360
我们可以 n

744
00:27:39,360 --> 00:27:41,919
通过在该图上

745
00:27:41,919 --> 00:27:44,960
传递消息来解决能量泛函问题，我们将这些消息传递给

746
00:27:44,960 --> 00:27:46,480
我们的下一个控件，

747
00:27:46,480 --> 00:27:49,360
因为我们有兴趣从下一次 um 中推断

748
00:27:49,360 --> 00:27:52,480
我们接下来要做的事情

749
00:27:52,480 --> 00:27:55,279


750
00:27:55,600 --> 00:27:57,679
，这是我们可以做消息的地方

751
00:27:57,679 --> 00:27:59,600
通过我们可以总结

752
00:27:59,600 --> 00:28:02,720
我们

753
00:28:02,720 --> 00:28:04,159
从过去获得的所有信息，因此这将是

754
00:28:04,159 --> 00:28:06,240
对代理当前状态的估计，

755
00:28:06,240 --> 00:28:07,679


756
00:28:07,679 --> 00:28:09,600
并且会因我们对未来的信念而产生偏见，

757
00:28:09,600 --> 00:28:11,279
即我们想去哪里

758
00:28:11,279 --> 00:28:12,240


759
00:28:12,240 --> 00:28:14,799
，这将影响或决定

760
00:28:14,799 --> 00:28:17,039
我们现在或下一次将采取哪些控制措施

761
00:28:17,039 --> 00:28:18,640


762
00:28:18,640 --> 00:28:21,520


763
00:28:21,600 --> 00:28:24,640
所有细节

764
00:28:24,640 --> 00:28:26,559
都在 2019 年的这篇论文中进行了描述，

765
00:28:26,559 --> 00:28:28,880


766
00:28:28,880 --> 00:28:31,039


767
00:28:34,080 --> 00:28:35,600
您还可以看到我们如何

768
00:28:35,600 --> 00:28:37,440


769
00:28:37,440 --> 00:28:40,000
在动作感知循环中应用它

770
00:28:40,000 --> 00:28:42,240
以及类似的事情，

771
00:28:42,240 --> 00:28:43,520
因为 您必须在每次 t 时都这样做，

772
00:28:43,520 --> 00:28:44,960


773
00:28:44,960 --> 00:28:46,799
因为您的状态估计会

774
00:28:46,799 --> 00:28:48,159
改变单词会根据您的

775
00:28:48,159 --> 00:28:49,760
操作而改变，因此您

776
00:28:49,760 --> 00:28:51,600
每次都必须为 wha 重新计算一个新操作

777
00:28:51,600 --> 00:28:54,719
你接下来要做，

778
00:28:55,120 --> 00:28:57,600
嗯，这是

779
00:28:57,600 --> 00:28:59,360
现在的主要想法，当然我们不想

780
00:28:59,360 --> 00:29:01,120


781
00:29:01,120 --> 00:29:03,679
手工做这一切，所以我们想要做的

782
00:29:03,679 --> 00:29:07,200
就是我们想要使用一个工具，

783
00:29:07,679 --> 00:29:09,039
所以 现在

784
00:29:09,039 --> 00:29:10,960
我将展示一个小演示，

785
00:29:10,960 --> 00:29:12,880
你将如何

786
00:29:12,880 --> 00:29:15,360
使用公式概率

787
00:29:15,360 --> 00:29:17,520
编程工具来实现这个，

788
00:29:17,520 --> 00:29:19,840
所以让我们看看我是否可以

789
00:29:19,840 --> 00:29:22,480
打开我们的小演示，所以

790
00:29:22,480 --> 00:29:24,320
这实际上是可读的，或者我应该

791
00:29:24,320 --> 00:29:25,520
放大更多

792
00:29:25,520 --> 00:29:27,279


793
00:29:27,279 --> 00:29:30,640
吗？ 可以再放大一点，

794
00:29:32,720 --> 00:29:35,440
也许像

795
00:29:35,440 --> 00:29:37,840
这样 嗯，是的，我可以调整大小

796
00:29:37,840 --> 00:29:39,360


797
00:29:39,360 --> 00:29:41,520


798
00:29:41,520 --> 00:29:42,880


799
00:29:42,880 --> 00:29:46,159


800
00:29:48,640 --> 00:29:52,000


801
00:29:52,000 --> 00:29:55,279


802
00:29:55,440 --> 00:29:58,080
这是我们

803
00:29:58,080 --> 00:29:59,919
对环境本身的定义，所以这

804
00:29:59,919 --> 00:30:01,279
就是现实世界，

805
00:30:01,279 --> 00:30:03,039
我们有这个温度

806
00:30:03,039 --> 00:30:05,120
梯度，这是一个非常好的函数

807
00:30:05,120 --> 00:30:07,840
，非常平滑的函数

808
00:30:07,840 --> 00:30:09,039
，在热源处我们的

809
00:30:09,039 --> 00:30:10,640
温度为 100

810
00:30:10,640 --> 00:30:12,960
，

811
00:30:12,960 --> 00:30:14,880
它会

812
00:30:14,880 --> 00:30:18,410
随着 与来自热源的位置

813
00:30:18,410 --> 00:30:20,240
[音乐]

814
00:30:20,240 --> 00:30:21,679
所以 t 他是一个真实的世界，我们并不真正

815
00:30:21,679 --> 00:30:23,360
知道这一点，所以这是我们

816
00:30:23,360 --> 00:30:25,279
将用这个

817
00:30:25,279 --> 00:30:28,640
非常粗糙的负一来近似的世界，然后

818
00:30:28,640 --> 00:30:31,279
我们将看看这是否适用于它

819
00:30:31,279 --> 00:30:33,360
现在这是我美妙的 ascii 艺术

820
00:30:33,360 --> 00:30:35,600
现在已经调整

821
00:30:35,600 --> 00:30:38,880
了我刚刚在幻灯片中展示

822
00:30:38,880 --> 00:30:40,559


823
00:30:40,559 --> 00:30:42,960
的

824
00:30:42,960 --> 00:30:44,480


825
00:30:44,480 --> 00:30:45,919


826
00:30:45,919 --> 00:30:48,399


827
00:30:48,399 --> 00:30:50,799
模型的大小 所以嗯，这里我们有我们的

828
00:30:50,799 --> 00:30:53,679
观察状态控制

829
00:30:53,679 --> 00:30:56,720
，我们定义了一个

830
00:30:56,720 --> 00:30:59,200
关于 t 减一的先验信念，所以我们去过哪里

831
00:30:59,200 --> 00:31:01,120
，我们要说的是高斯

832
00:31:01,120 --> 00:31:05,039
，有一些平均值和一些方差

833
00:31:05,039 --> 00:31:07,440
，然后每次

834
00:31:07,440 --> 00:31:11,039
从 嗯，从一到地平线，

835
00:31:11,039 --> 00:31:12,320
我们将有一个关于控制的先验信念，

836
00:31:12,320 --> 00:31:15,840
它基本上说好

837
00:31:15,840 --> 00:31:18,240
当我说好的时候我可以做什么

838
00:31:18,240 --> 00:31:19,039


839
00:31:19,039 --> 00:31:20,159


840
00:31:20,159 --> 00:31:22,640
我有一个关于控制的高乔先验

841
00:31:22,640 --> 00:31:24,480
，

842
00:31:24,480 --> 00:31:26,159
平均值为零

843
00:31:26,159 --> 00:31:28,480
我会 在那里替换，然后

844
00:31:28,480 --> 00:31:31,279
可能会有一些差异

845
00:31:31,279 --> 00:31:32,880
，嗯，

846
00:31:32,880 --> 00:31:34,960
他 我说得好，我有我的代理位置，

847
00:31:34,960 --> 00:31:37,600
它与我的控制

848
00:31:37,600 --> 00:31:38,399


849
00:31:38,399 --> 00:31:39,919


850
00:31:39,919 --> 00:31:41,120


851
00:31:41,120 --> 00:31:42,880


852
00:31:42,880 --> 00:31:44,640


853
00:31:44,640 --> 00:31:46,880


854
00:31:46,880 --> 00:31:48,480


855
00:31:48,480 --> 00:31:50,480


856
00:31:50,480 --> 00:31:52,640


857
00:31:52,640 --> 00:31:54,399
有关

858
00:31:54,399 --> 00:31:56,000
温度梯度

859
00:31:56,000 --> 00:31:58,880
乘以当前状态，还有

860
00:31:58,880 --> 00:32:00,640
一些精度

861
00:32:00,640 --> 00:32:03,200
守恒精度

862
00:32:03,200 --> 00:32:06,320
，这代表了我之前的目标，

863
00:32:06,320 --> 00:32:09,120
所以请注意，我还没有真正在这里输入任何

864
00:32:09,120 --> 00:32:12,320
具体值，但我只是

865
00:32:12,320 --> 00:32:14,399
为实际统计数据和

866
00:32:14,399 --> 00:32:16,880
值设置了占位符

867
00:32:16,880 --> 00:32:18,480
因为我的算法的实际推导

868
00:32:18,480 --> 00:32:20,480
并不依赖于

869
00:32:20,480 --> 00:32:23,120
统计数据，它只是

870
00:32:23,120 --> 00:32:27,799
我们可以稍后输入的东西，

871
00:32:28,240 --> 00:32:29,760
所以这就是我想要做的建立一个

872
00:32:29,760 --> 00:32:31,919
自由能函数，而虚假

873
00:32:31,919 --> 00:32:33,679
实验室实际上只是

874
00:32:33,679 --> 00:32:36,720
基本上是四行代码，

875
00:32:36,720 --> 00:32:39,279
所以这个立体

876
00:32:39,279 --> 00:32:42,559
分解定义了我对 q 的分解，

877
00:32:42,559 --> 00:32:44,240
说嗯，

878
00:32:44,240 --> 00:32:46,960
我将在 en 上有

879
00:32:46,960 --> 00:32:50,640
一个联合变分分布

880
00:32:50,640 --> 00:32:52,880
um 轮胎图

881
00:32:52,880 --> 00:32:54,559
我并没有真正将它

882
00:32:54,559 --> 00:32:55,840
细分为结构

883
00:32:55,840 --> 00:32:57,760
分解为一些人熟悉的结构分解

884
00:32:57,760 --> 00:32:59,279
，

885
00:32:59,279 --> 00:33:01,440
嗯，但只是说好吧，我只是

886
00:33:01,440 --> 00:33:03,039
将变分

887
00:33:03,039 --> 00:33:05,919
分布的立体分解作为我的整个图，

888
00:33:05,919 --> 00:33:08,640
而不仅仅是

889
00:33:08,640 --> 00:33:11,120
我可以推导出的一个命令 一种消息传递算法

890
00:33:11,120 --> 00:33:14,080
，将所有消息传播到

891
00:33:14,080 --> 00:33:16,320
控制 u2，这

892
00:33:16,320 --> 00:33:18,159
是下一个

893
00:33:18,159 --> 00:33:21,039
时间步 t 加一的控制

894
00:33:21,039 --> 00:33:23,039
，我想评估我的自由能，所以

895
00:33:23,039 --> 00:33:24,799
同时也给我

896
00:33:24,799 --> 00:33:27,840
一个我可以执行的算法

897
00:33:27,840 --> 00:33:31,439
为了评估我的自由能

898
00:33:31,919 --> 00:33:35,279
，这条线会将其转换

899
00:33:35,279 --> 00:33:36,320
为

900
00:33:36,320 --> 00:33:38,320
两个源代码，然后我可以将其加载到

901
00:33:38,320 --> 00:33:41,120
我的环境中

902
00:33:41,200 --> 00:33:43,519
，它的作用是为我们构建一个

903
00:33:43,519 --> 00:33:46,480
消息传递算法，

904
00:33:46,480 --> 00:33:48,559
所以这就是

905
00:33:48,559 --> 00:33:50,159
执行消息的代码 传递我们的

906
00:33:50,159 --> 00:33:51,200
图表

907
00:33:51,200 --> 00:33:53,120
，在这里你可以看到它

908
00:33:53,120 --> 00:33:54,640


909
00:33:54,640 --> 00:33:57,039
通过一些产品规则和其他规则计算所有这些消息

910
00:33:57,039 --> 00:33:58,559
，我们已经预先导出并且我们

911
00:33:58,559 --> 00:34:01,279
已经在 fornilab

912
00:34:01,279 --> 00:34:03,039
和 您可以看到这些消息它们

913
00:34:03,039 --> 00:34:05,360
依赖于统计数据，因此这是

914
00:34:05,360 --> 00:34:07,679
例如

915
00:34:07,679 --> 00:34:09,520
我们先前

916
00:34:09,520 --> 00:34:11,280
过度状态的平均值和先前过度状态的方差

917
00:34:11,280 --> 00:34:13,839


918
00:34:14,079 --> 00:34:15,599
，我们还有其他消息依赖

919
00:34:15,599 --> 00:34:18,000
于先前消息

920
00:34:18,000 --> 00:34:19,359
的方式，就像我解释消息

921
00:34:19,359 --> 00:34:21,199
传递

922
00:34:21,199 --> 00:34:23,839
和这个 在这种情况下构建一个包含 26 条消息的完整列表

923
00:34:23,839 --> 00:34:27,599


924
00:34:27,599 --> 00:34:29,918
，最后我们对

925
00:34:29,918 --> 00:34:32,079
边际信念感兴趣，因此后

926
00:34:32,079 --> 00:34:35,040
边际信念关于例如

927
00:34:35,040 --> 00:34:36,480
或控制

928
00:34:36,480 --> 00:34:38,399
，您可以通过将消息相乘来获得这些信念

929
00:34:38,399 --> 00:34:40,879
，例如得到

930
00:34:40,879 --> 00:34:43,199
一个新信念 在下面的控制中，

931
00:34:43,199 --> 00:34:44,560
您将

932
00:34:44,560 --> 00:34:48,639
消息 9 和 25 相乘，

933
00:34:48,639 --> 00:34:50,719
并且您还可以从

934
00:34:50,719 --> 00:34:52,560
过去的介绍中的一个小介绍中认识到这一点

935
00:34:52,560 --> 00:34:54,239
，在该介绍中，您在边缘有冲突的消息

936
00:34:54,239 --> 00:34:56,239
，您将这些消息相乘以获得

937
00:34:56,239 --> 00:34:58,400
您的后验信念

938
00:34:58,400 --> 00:34:59,920
，这就是我们最终返回

939
00:34:59,920 --> 00:35:03,720
的内容，这就是我们 '感兴趣，

940
00:35:06,160 --> 00:35:07,760
所以这是该算法的执行，请

941
00:35:07,760 --> 00:35:08,960


942
00:35:08,960 --> 00:35:10,640
注意我们已经在这里制定了完整的

943
00:35:10,640 --> 00:35:12,160
时间表，

944
00:35:12,160 --> 00:35:14,800
它们可能非常复杂 rsome

945
00:35:14,800 --> 00:35:17,119
可能是很长很长的计划，

946
00:35:17,119 --> 00:35:19,599
因此加载和执行可能会很昂贵

947
00:35:19,599 --> 00:35:21,359


948
00:35:21,359 --> 00:35:22,800
，dimitri 有解决方案

949
00:35:22,800 --> 00:35:25,359
，他会在一分钟内解释，

950
00:35:25,359 --> 00:35:27,520
所以我很高兴

951
00:35:27,520 --> 00:35:29,119
制定计划

952
00:35:29,119 --> 00:35:32,400
，嗯，dimitri 没有 这么多，呃

953
00:35:32,400 --> 00:35:34,560
，他试图找到呃

954
00:35:34,560 --> 00:35:36,160
为他们找到解决方案摆脱他们，

955
00:35:36,160 --> 00:35:37,680
因为最终这将是

956
00:35:37,680 --> 00:35:38,800
最快

957
00:35:38,800 --> 00:35:40,400
的，因为最终

958
00:35:40,400 --> 00:35:41,839
没有真正没有食谱的时间表，

959
00:35:41,839 --> 00:35:44,880
而只是根据给你的任何东西做饭

960
00:35:44,880 --> 00:35:47,440


961
00:35:49,920 --> 00:35:51,599
所以现在我们在实践中执行这个算法

962
00:35:51,599 --> 00:35:52,800
所以这是我们想要

963
00:35:52,800 --> 00:35:55,520
执行的每个时间步的

964
00:35:55,520 --> 00:35:57,599


965
00:35:57,599 --> 00:35:59,119


966
00:35:59,119 --> 00:36:01,359


967
00:36:01,359 --> 00:36:04,240


968
00:36:04,240 --> 00:36:06,720
动作感知循环 在这种情况下，这是

969
00:36:06,720 --> 00:36:09,040
将动作发送到实际的现实

970
00:36:09,040 --> 00:36:11,200
世界或模拟世界

971
00:36:11,200 --> 00:36:13,680
，我们从中得到的是

972
00:36:13,680 --> 00:36:15,680
观察结果

973
00:36:15,680 --> 00:36:18,079
，从我们的动作观察结果中，我们想

974
00:36:18,079 --> 00:36:20,640


975
00:36:20,960 --> 00:36:22,640
推断出我们的新动作

976
00:36:22,640 --> 00:36:24,320
，并返回

977
00:36:24,320 --> 00:36:26,560
自由能的

978
00:36:26,560 --> 00:36:28,240


979
00:36:28,240 --> 00:36:30,160
变化 d 然后为下一步做准备，所以在

980
00:36:30,160 --> 00:36:31,920
每一步中，我们都会向实际执行的环境提出一个动作，

981
00:36:31,920 --> 00:36:34,160
我们

982
00:36:34,160 --> 00:36:35,839
观察一个新的结果

983
00:36:35,839 --> 00:36:37,920
，我们推断出新的动作，

984
00:36:37,920 --> 00:36:41,680
嗯，我们评估我们在

985
00:36:41,680 --> 00:36:44,319
该动作上做得如何

986
00:36:46,480 --> 00:36:48,480
，然后你会得到很好的情节 像

987
00:36:48,480 --> 00:36:50,160
这样，所以

988
00:36:50,160 --> 00:36:52,480
这是我们的代理的速度，

989
00:36:52,480 --> 00:36:54,240
我们从零开始，你可以看到它

990
00:36:54,240 --> 00:36:56,960
非常快速地向右移动

991
00:36:56,960 --> 00:36:57,920


992
00:36:57,920 --> 00:36:59,920
，然后

993
00:36:59,920 --> 00:37:02,240
它也向后移动一点点，

994
00:37:02,240 --> 00:37:05,200
直到末端或多或少到达一个静止点

995
00:37:05,200 --> 00:37:06,839


996
00:37:06,839 --> 00:37:09,680
您实际上可以在这里

997
00:37:09,680 --> 00:37:11,119
看到它的作用，所以它从 20 的温度开始，

998
00:37:11,119 --> 00:37:13,359


999
00:37:13,359 --> 00:37:15,920
然后它非常迅速地移动到

1000
00:37:15,920 --> 00:37:17,760
远离热源的地方，

1001
00:37:17,760 --> 00:37:20,560
它超过了它的标记

1002
00:37:20,560 --> 00:37:22,560
，然后它实际上又回到了它，然后

1003
00:37:22,560 --> 00:37:23,920
它稳定在这个所需

1004
00:37:23,920 --> 00:37:26,320
的 4 温度附近 嗯，我们已经按照

1005
00:37:26,320 --> 00:37:30,480
我们的目标先验进行了编码，

1006
00:37:31,839 --> 00:37:34,400
那么为什么我们

1007
00:37:34,400 --> 00:37:36,480
的环境模型并不完美呢？

1008
00:37:36,480 --> 00:37:39,119
我们有这个非常粗略的负

1009
00:37:39,119 --> 00:37:40,560
负一

1010
00:37:40,560 --> 00:37:43,040
um 估计值，而在现实世界中，这是一个非常

1011
00:37:43,040 --> 00:37:46,240
好的平滑亲属

1012
00:37:46,240 --> 00:37:47,280


1013
00:37:47,280 --> 00:37:51,680
d 具有这种钟形的复杂函数，

1014
00:37:51,680 --> 00:37:54,000
所以即使

1015
00:37:54,000 --> 00:37:55,599
我们的环境生成模型

1016
00:37:55,599 --> 00:37:57,200
并不

1017
00:37:57,200 --> 00:37:59,520
完美，最终我们通过稍微超调来支付那笔费用，

1018
00:37:59,520 --> 00:38:01,599
但

1019
00:38:01,599 --> 00:38:04,880
我们仍然能够达到我们的

1020
00:38:04,880 --> 00:38:06,560
在四度的温度下达到理想状态，

1021
00:38:06,560 --> 00:38:07,440
所以最后

1022
00:38:07,440 --> 00:38:10,720
它工作得很好

1023
00:38:10,800 --> 00:38:12,240
，你还可以看到代理的自由

1024
00:38:12,240 --> 00:38:14,880
能也随着

1025
00:38:14,880 --> 00:38:16,880
时间的推移而减少，所以我们从一千左右开始，

1026
00:38:16,880 --> 00:38:19,680
所以这里的比例是对数的

1027
00:38:19,680 --> 00:38:22,640
，它减少了很多 很快，我们的

1028
00:38:22,640 --> 00:38:24,720
总和值

1029
00:38:24,720 --> 00:38:27,040
相当低，然后我们有

1030
00:38:27,040 --> 00:38:29,359
一些噪音，会引起一些

1031
00:38:29,359 --> 00:38:32,320
意想不到的变化或一些意想不到的

1032
00:38:32,320 --> 00:38:34,079


1033
00:38:34,079 --> 00:38:36,079
惊喜，这就是为什么你在这里有这些小

1034
00:38:36,079 --> 00:38:38,240
涟漪这些小涟漪

1035
00:38:38,240 --> 00:38:39,760
但最后我们正在最大限度地减少自由能 而且

1036
00:38:39,760 --> 00:38:41,920
它正在急剧下降，

1037
00:38:41,920 --> 00:38:43,440
所以我们实际上有这个自由能量

1038
00:38:43,440 --> 00:38:47,079
最小化剂

1039
00:38:47,200 --> 00:38:48,079


1040
00:38:48,079 --> 00:38:50,880
嗯，是的，这

1041
00:38:50,880 --> 00:38:53,200
就是我所拥有的故事

1042
00:38:53,200 --> 00:38:55,759
和演示

1043
00:38:56,880 --> 00:39:00,320
，非常棒谢谢你 您非常好，我们

1044
00:39:00,320 --> 00:39:03,520
可以打开屏幕共享或不问

1045
00:39:03,520 --> 00:39:05,040
一些实时聊天中的问题，

1046
00:39:05,040 --> 00:39:07,040
并给人们几秒钟的时间

1047
00:39:07,040 --> 00:39:08,720
输入更多内容，所以

1048
00:39:08,720 --> 00:39:10,160
我将先跳入

1049
00:39:10,160 --> 00:39:12,320
问题，

1050
00:39:12,320 --> 00:39:14,480
让我停止我的屏幕截图

1051
00:39:14,480 --> 00:39:16,640
很棒 所以我们仍然在分享屏幕

1052
00:39:16,640 --> 00:39:19,280
故事，嗯，我们只看到了 jitsies，所以

1053
00:39:19,280 --> 00:39:21,119
只需在 jitsi 中再次单击屏幕共享按钮

1054
00:39:21,119 --> 00:39:23,599
，

1055
00:39:25,440 --> 00:39:27,599
太棒了，谢谢，所以第一个

1056
00:39:27,599 --> 00:39:29,359


1057
00:39:29,359 --> 00:39:31,920
问题来自 john，john 写道，

1058
00:39:31,920 --> 00:39:34,320
如果图表，因子图方法如何工作

1059
00:39:34,320 --> 00:39:36,960
事先不知道

1060
00:39:36,960 --> 00:39:41,079
结构 结构学习

1061
00:39:43,040 --> 00:39:44,720


1062
00:39:44,720 --> 00:39:46,800


1063
00:39:46,800 --> 00:39:49,520


1064
00:39:49,520 --> 00:39:51,839


1065
00:39:52,079 --> 00:39:54,240


1066
00:39:54,240 --> 00:39:55,520


1067
00:39:55,520 --> 00:39:57,520


1068
00:39:57,520 --> 00:39:59,599
是可能的 自动化

1069
00:39:59,599 --> 00:40:01,599
图本身的结构学习，

1070
00:40:01,599 --> 00:40:02,880
但是那里有很多挑战，

1071
00:40:02,880 --> 00:40:04,400
所以你如何参数化这个图

1072
00:40:04,400 --> 00:40:07,520
结构，或者你

1073
00:40:07,520 --> 00:40:08,960
如何做你如何做到这一点实际上是正确的

1074
00:40:08,960 --> 00:40:12,560
s 您在图表方面的搜索空间

1075
00:40:12,560 --> 00:40:14,240


1076
00:40:14,240 --> 00:40:15,920
如果您

1077
00:40:15,920 --> 00:40:18,160
没有为您的图表提供正确的节点函数，您如何学习节点函数，所以

1078
00:40:18,160 --> 00:40:19,760
这些都是非常困难的问题

1079
00:40:19,760 --> 00:40:21,200
，您没有直接的

1080
00:40:21,200 --> 00:40:23,040
答案

1081
00:40:23,040 --> 00:40:24,800
，所以这就是 为什么

1082
00:40:24,800 --> 00:40:27,040


1083
00:40:27,040 --> 00:40:27,920
设计

1084
00:40:27,920 --> 00:40:29,359
周期中的这个实际模型设计步骤本身

1085
00:40:29,359 --> 00:40:31,440
仍然是一种创造性的过程，

1086
00:40:31,440 --> 00:40:33,359
有一个工程师必须

1087
00:40:33,359 --> 00:40:34,880
提出一个模型

1088
00:40:34,880 --> 00:40:36,560
，作为一名工程师

1089
00:40:36,560 --> 00:40:38,400
，如果你没有，你还必须考虑如何调整该模型

1090
00:40:38,400 --> 00:40:40,240
对它感到满意，

1091
00:40:40,240 --> 00:40:42,160
所以如果在

1092
00:40:42,160 --> 00:40:44,400
你很好地运行你的代理之后自由能仍然很高，那么

1093
00:40:44,400 --> 00:40:45,760
你的模型出现了问题，

1094
00:40:45,760 --> 00:40:46,720
它不能准确

1095
00:40:46,720 --> 00:40:48,960
表示环境是什么

1096
00:40:48,960 --> 00:40:50,720
，然后

1097
00:40:50,720 --> 00:40:53,599
你可以调整一下，你现在如何调整

1098
00:40:53,599 --> 00:40:55,040
它 仍然只是反复试验

1099
00:40:55,040 --> 00:40:57,280
所以也许你可以说好吧我认为

1100
00:40:57,280 --> 00:40:58,640
这里仍然有一些我可以

1101
00:40:58,640 --> 00:41:00,640
改进的东西也许删除一个节点也许

1102
00:41:00,640 --> 00:41:03,598
模型太复杂

1103
00:41:04,130 --> 00:41:05,440
[音乐]

1104
00:41:05,440 --> 00:41:08,880
但是结构本身运行是嗯

1105
00:41:08,880 --> 00:41:10,800
它是一些东西 g 那

1106
00:41:10,800 --> 00:41:12,560
也是它可以解决的，所以

1107
00:41:12,560 --> 00:41:15,599
有一些方法，比如嵌套

1108
00:41:15,599 --> 00:41:17,359
模型比较和类似的事情

1109
00:41:17,359 --> 00:41:19,280
，你可以做事实上的图表，所以你可以

1110
00:41:19,280 --> 00:41:20,800
例如如果你有一个嵌套模型

1111
00:41:20,800 --> 00:41:22,880
计算野蛮迪基比率，然后是

1112
00:41:22,880 --> 00:41:25,440
那种 基于此修剪你的模型

1113
00:41:25,440 --> 00:41:27,440
，所以你可以做这些事情

1114
00:41:27,440 --> 00:41:29,040
来找到一个复杂的模型，看看你

1115
00:41:29,040 --> 00:41:31,759
可以剪掉什么，

1116
00:41:32,480 --> 00:41:34,000
但是添加到那个模型仍然

1117
00:41:34,000 --> 00:41:35,440
很困难，所以一旦你把它剪掉

1118
00:41:35,440 --> 00:41:37,680
了，你如何添加是的，我我

1119
00:41:37,680 --> 00:41:39,040
我不是真的不知道，所以这是一个

1120
00:41:39,040 --> 00:41:41,200
很好的问题，嗯，我没有一个非常

1121
00:41:41,200 --> 00:41:43,040
直接的问题，你可以

1122
00:41:43,040 --> 00:41:46,319
从我的嘎嘎声中切换，所以是的，

1123
00:41:46,800 --> 00:41:49,839
也许我可以说点什么，嗯，

1124
00:41:49,839 --> 00:41:52,960
我的意思是我完全同意

1125
00:41:52,960 --> 00:41:55,200
我的意思是，一般来说，

1126
00:41:55,200 --> 00:41:57,520
当你设计一个

1127
00:41:57,520 --> 00:41:59,520
系统或信号处理系统时，你

1128
00:41:59,520 --> 00:42:00,839
必须设计

1129
00:42:00,839 --> 00:42:03,119
结构，你必须估计

1130
00:42:03,119 --> 00:42:05,520
参数，然后你必须正确推断

1131
00:42:05,520 --> 00:42:08,480
状态，状态变化非常快，

1132
00:42:08,480 --> 00:42:11,359
它会导致一个通用滤波器，

1133
00:42:11,359 --> 00:42:13,040
这非常

1134
00:42:13,040 --> 00:42:15,599
出色地 在因子图中已知，

1135
00:42:15,599 --> 00:42:17,920
那么下一阶段将是我们是否也可以

1136
00:42:17,920 --> 00:42:20,800
长期学习参数

1137
00:42:20,800 --> 00:42:23,200
，我们的效应图现在可以很好地做到这一点

1138
00:42:23,200 --> 00:42:24,240


1139
00:42:24,240 --> 00:42:27,040
生物学的下一阶段我的意思是

1140
00:42:27,040 --> 00:42:29,280
我们知道该结构在

1141
00:42:29,280 --> 00:42:31,440
更长的时间内也是警觉的

1142
00:42:31,440 --> 00:42:33,920
，所以 目前这

1143
00:42:33,920 --> 00:42:37,040
在公式中不起作用你可以比较像我

1144
00:42:37,040 --> 00:42:39,119
说的测试如果你有两个例子你可以

1145
00:42:39,119 --> 00:42:41,359
比较自由能并

1146
00:42:41,359 --> 00:42:43,119
选择最好的

1147
00:42:43,119 --> 00:42:45,359
但我们正在努力这就是我的

1148
00:42:45,359 --> 00:42:47,280
意思是我们再次领先

1149
00:42:47,280 --> 00:42:49,599
来自卡尔关于贝叶斯模型缩减的想法，

1150
00:42:49,599 --> 00:42:51,920
但是如何在

1151
00:42:51,920 --> 00:42:54,400
因子图中实现它是一个研究项目，所以

1152
00:42:54,400 --> 00:42:55,839
我们正在

1153
00:42:55,839 --> 00:42:58,160
努力解决这个问题，我不确定

1154
00:42:58,160 --> 00:43:00,560
它会在哪里结束，但这就是我们的目标

1155
00:43:00,560 --> 00:43:02,640
你有 phd 职位，所以你

1156
00:43:02,640 --> 00:43:04,799


1157
00:43:05,920 --> 00:43:07,920
也要把它带回到

1158
00:43:07,920 --> 00:43:08,640


1159
00:43:08,640 --> 00:43:10,640
汽车达到最佳

1160
00:43:10,640 --> 00:43:13,040
温度的例子，就像你每小时都

1161
00:43:13,040 --> 00:43:14,720
注意到自由能有一个颠簸，

1162
00:43:14,720 --> 00:43:16,960
然后你回到绘图

1163
00:43:16,960 --> 00:43:18,640
板，然后 你去 向

1164
00:43:18,640 --> 00:43:20,800
那个区域那辆车上的人

1165
00:43:20,800 --> 00:43:23,200
询问每小时发生的事情，或者我们

1166
00:43:23,200 --> 00:43:24,960
确实需要包含其他信息来源，

1167
00:43:24,960 --> 00:43:28,000
但是您拥有的模型可以

1168
00:43:28,000 --> 00:43:30,480
完成它的工作，因此您可以包含

1169
00:43:30,480 --> 00:43:32,400
房间的墙纸和其他功能

1170
00:43:32,400 --> 00:43:35,040
但这就是这种艺术和

1171
00:43:35,040 --> 00:43:36,720
工程科学，这就是为什么

1172
00:43:36,720 --> 00:43:39,599
工作总是很有趣的原因，因为

1173
00:43:39,599 --> 00:43:41,280
在研究中，这就像让我们

1174
00:43:41,280 --> 00:43:42,640
完成分析，

1175
00:43:42,640 --> 00:43:45,200
但确实存在整个模型嵌入其中的循环，

1176
00:43:45,200 --> 00:43:46,240


1177
00:43:46,240 --> 00:43:48,160


1178
00:43:48,160 --> 00:43:50,400
这有助于我们始终关注

1179
00:43:50,400 --> 00:43:52,160
那些

1180
00:43:52,160 --> 00:43:54,160
排除我们当前模型捕获的

1181
00:43:54,160 --> 00:43:56,319
模式

1182
00:43:56,319 --> 00:43:57,839
这里只是

1183
00:43:57,839 --> 00:44:00,960
聊天中的第二个问题

1184
00:44:00,960 --> 00:44:03,119


1185
00:44:03,119 --> 00:44:05,680
如果此示例中的目标温度

1186
00:44:05,680 --> 00:44:08,079
未事先定义，因子图

1187
00:44:08,079 --> 00:44:09,920
方法

1188
00:44:09,920 --> 00:44:11,440
如何工作 比结构

1189
00:44:11,440 --> 00:44:13,599
学习如何再次出现偏好和目标

1190
00:44:13,599 --> 00:44:16,319
导向是一个

1191
00:44:16,319 --> 00:44:19,440
很好的问题，

1192
00:44:19,920 --> 00:44:20,960
所以

1193
00:44:20,960 --> 00:44:22,560
这种

1194
00:44:22,560 --> 00:44:24,240
问题很好地涉及到谁

1195
00:44:24,240 --> 00:44:25,359
ts 目标

1196
00:44:25,359 --> 00:44:28,560
或你如何设定目标，

1197
00:44:29,680 --> 00:44:30,640
所以

1198
00:44:30,640 --> 00:44:32,560
是

1199
00:44:32,560 --> 00:44:34,560
的，简单的答案很好，它是一个

1200
00:44:34,560 --> 00:44:36,880
工程师，它定义了

1201
00:44:36,880 --> 00:44:39,359
这个，嗯，但它也可以是一个更高级别的

1202
00:44:39,359 --> 00:44:40,319
代理

1203
00:44:40,319 --> 00:44:42,640
，进行推理并设定他的

1204
00:44:42,640 --> 00:44:44,960
目标，

1205
00:44:45,040 --> 00:44:47,599
这样你就会得到一种

1206
00:44:47,599 --> 00:44:49,280
乌龟 从某种意义上说，一直

1207
00:44:49,280 --> 00:44:51,520
争论下去，你可以

1208
00:44:51,520 --> 00:44:53,760
一层一层地一层

1209
00:44:53,760 --> 00:44:55,760
一层地设置目标和其他层

1210
00:44:55,760 --> 00:44:58,560
作为该层的目标等等等等，

1211
00:44:58,560 --> 00:44:59,760


1212
00:44:59,760 --> 00:45:03,280
所以这将如何在实践中发挥作用

1213
00:45:03,280 --> 00:45:06,160
嗯，是的，这仍然是

1214
00:45:06,160 --> 00:45:08,240
积极的研究 领域

1215
00:45:08,240 --> 00:45:10,240
嗯，

1216
00:45:10,240 --> 00:45:11,920
但最终它应该归结为

1217
00:45:11,920 --> 00:45:14,400
最小化自由能

1218
00:45:14,400 --> 00:45:16,720
，所以这就是

1219
00:45:16,720 --> 00:45:18,720
我们想要的中心主题 我们想要最小化

1220
00:45:18,720 --> 00:45:19,920
自由能

1221
00:45:19,920 --> 00:45:21,760
我们通过感知来做到 我们通过模型

1222
00:45:21,760 --> 00:45:22,880


1223
00:45:22,880 --> 00:45:26,480
学习来做到 目标

1224
00:45:26,480 --> 00:45:28,480
应该通过最小化自由能量来驱动，

1225
00:45:28,480 --> 00:45:30,240
所以你应该

1226
00:45:30,240 --> 00:45:32,240
选择最小化能量的

1227
00:45:32,240 --> 00:45:33,680


1228
00:45:33,680 --> 00:45:34,800


1229
00:45:34,800 --> 00:45:36,640


1230
00:45:36,640 --> 00:45:38,879
目标

1231
00:45:41,280 --> 00:45:44,640
你是

1232
00:45:44,640 --> 00:45:47,119
怎么做的

1233
00:45:47,119 --> 00:45:48,560
数据库

1234
00:45:48,560 --> 00:45:50,960
或大型数据集

1235
00:45:50,960 --> 00:45:52,640
是可以扩展或已经

1236
00:45:52,640 --> 00:45:54,319
集成以处理那种

1237
00:45:54,319 --> 00:45:56,160
经验数据的

1238
00:45:56,160 --> 00:45:58,319
东西，或者

1239
00:45:58,319 --> 00:45:59,760
我认为这取决于你所说

1240
00:45:59,760 --> 00:46:03,119
的大型数据集是什么意思，

1241
00:46:03,119 --> 00:46:04,000
嗯，

1242
00:46:04,000 --> 00:46:04,800
所以

1243
00:46:04,800 --> 00:46:06,640
当我听到大型数据集时，我通常会

1244
00:46:06,640 --> 00:46:09,200
想到 大数据之类的东西

1245
00:46:09,200 --> 00:46:11,200


1246
00:46:11,200 --> 00:46:13,359
嗯所以

1247
00:46:13,359 --> 00:46:16,800
这个工具箱是专门为动态建模而构建的，

1248
00:46:16,800 --> 00:46:18,240


1249
00:46:18,240 --> 00:46:19,359
所以现在

1250
00:46:19,359 --> 00:46:20,880


1251
00:46:20,880 --> 00:46:23,440
你的数据中有很多特征，但它是信号

1252
00:46:23,440 --> 00:46:25,359
处理，所以数据可能会很快进入

1253
00:46:25,359 --> 00:46:27,280


1254
00:46:27,280 --> 00:46:28,720
，你有一个模型 这些数据

1255
00:46:28,720 --> 00:46:30,319
会随着时间而变化，

1256
00:46:30,319 --> 00:46:31,119
所以

1257
00:46:31,119 --> 00:46:33,200
从这个意义上说，你想要快速进行处理

1258
00:46:33,200 --> 00:46:35,119
，所以你想要很多你想要的

1259
00:46:35,119 --> 00:46:37,599
速度，它是基于

1260
00:46:37,599 --> 00:46:39,599
速度

1261
00:46:39,599 --> 00:46:41,760
处理而不是体积处理，

1262
00:46:41,760 --> 00:46:43,839
例如其他问题编程

1263
00:46:43,839 --> 00:46:47,119
工具箱非常擅长，比如 um

1264
00:46:47,119 --> 00:46:49,359
by torch 和

1265
00:46:49,359 --> 00:46:51,599


1266
00:46:51,599 --> 00:46:53,359


1267
00:46:53,359 --> 00:46:56,640
如果你有大量

1268
00:46:56,640 --> 00:46:58,400
的数据并且你

1269
00:46:58,400 --> 00:47:00,880
有一个你想要的 iid 模型，那么你可以使用所有很棒的工具箱。

1270
00:47:00,880 --> 00:47:03,040


1271
00:47:03,040 --> 00:47:04,960
如果

1272
00:47:04,960 --> 00:47:06,720
我们谈论大数据，

1273
00:47:06,720 --> 00:47:08,720
你

1274
00:47:08,720 --> 00:47:11,599


1275
00:47:11,599 --> 00:47:14,640
想适应我们的感觉

1276
00:47:14,640 --> 00:47:17,760


1277
00:47:17,760 --> 00:47:19,040
传递将成为

1278
00:47:19,040 --> 00:47:21,520


1279
00:47:22,240 --> 00:47:26,319
这类数据集的炸弹

1280
00:47:26,640 --> 00:47:31,520
还有

1281
00:47:31,520 --> 00:47:34,079
一些我们真正尝试构建这些

1282
00:47:34,079 --> 00:47:36,480
工具箱来构建积极影响

1283
00:47:36,480 --> 00:47:38,640
代理的想法以及您只需将这些

1284
00:47:38,640 --> 00:47:40,800
代理置于他们采取行动的环境中的想法

1285
00:47:40,800 --> 00:47:44,000
他们选择自己的数据，

1286
00:47:44,000 --> 00:47:47,119
因此我们并没有真正

1287
00:47:47,119 --> 00:47:49,040
尝试构建一个工具箱，该工具箱非常

1288
00:47:49,040 --> 00:47:51,359
擅长仅针对固定集合数据库进行机器学习，

1289
00:47:51,359 --> 00:47:54,160


1290
00:47:54,160 --> 00:47:56,720
而是我们尝试构建

1291
00:47:56,720 --> 00:47:58,319
模型，

1292
00:47:58,319 --> 00:48:01,119
比如说可以适应

1293
00:48:01,119 --> 00:48:03,119
并可以采取行动的动态模型 这

1294
00:48:03,119 --> 00:48:06,559
可以实时处理流数据，

1295
00:48:06,559 --> 00:48:09,359
并且从这个意义上说，如果你等待

1296
00:48:09,359 --> 00:48:11,599
足够长的时间，是的，有很多数据

1297
00:48:11,599 --> 00:48:13,760
流过它，

1298
00:48:13,760 --> 00:48:16,880
但它是由你生成的，或者

1299
00:48:16,880 --> 00:48:19,119
至少受到代理本身的影响，

1300
00:48:19,119 --> 00:48:21,200


1301
00:48:21,200 --> 00:48:23,839
我们不这样做' 吨 尝试

1302
00:48:23,839 --> 00:48:29,200
针对大型固定数据库进行优化，而不是仅

1303
00:48:29,200 --> 00:48:32,559
针对环境中的流式数据进行优化，

1304
00:48:32,559 --> 00:48:34,480
这是一个非常有趣的点，因为

1305
00:48:34,480 --> 00:48:36,640
有很多时间相关的任务，

1306
00:48:36,640 --> 00:48:39,040
例如自动驾驶，这就像

1307
00:48:39,040 --> 00:48:42,160
好的，这里有 500 TB 的视频，

1308
00:48:42,160 --> 00:48:43,839
或者现在给我最好的

1309
00:48:43,839 --> 00:48:45,280


1310
00:48:45,280 --> 00:48:48,800
时间快照中的可能得分，而且

1311
00:48:48,800 --> 00:48:50,400
每次使用主动

1312
00:48:50,400 --> 00:48:52,319
推理代理时，我们总是

1313
00:48:52,319 --> 00:48:54,880
在循环中包含动作和策略选择

1314
00:48:54,880 --> 00:48:56,480
，所以

1315
00:48:56,480 --> 00:48:58,400
我们将如何处理它，

1316
00:48:58,400 --> 00:49:00,319
但这就是为什么来自

1317
00:49:00,319 --> 00:49:02,640
生物系统的灵感变得如此 重要的是，

1318
00:49:02,640 --> 00:49:04,559
这有点像当人们进展顺利时

1319
00:49:04,559 --> 00:49:06,960
，大脑必须具有这种处理

1320
00:49:06,960 --> 00:49:09,040
能力，然后如果它是一个灯泡

1321
00:49:09,040 --> 00:49:10,559
或这种硅胶

1322
00:49:10,559 --> 00:49:11,839
计算机，它会占用这么多

1323
00:49:11,839 --> 00:49:14,160
能量，所以效率是这样的，

1324
00:49:14,160 --> 00:49:16,640
但它是

1325
00:49:16,640 --> 00:49:18,720
以我们习惯看到的计算机类型为基础，

1326
00:49:18,720 --> 00:49:20,800
而不是从

1327
00:49:20,800 --> 00:49:22,800
已经存在的东西开始，然后寻找存在

1328
00:49:22,800 --> 00:49:24,160


1329
00:49:24,160 --> 00:49:26,480
于 t 中的答案 帽子，而不是我们如何制造

1330
00:49:26,480 --> 00:49:28,800
低功率晶体管，以便我们可以

1331
00:49:28,800 --> 00:49:31,040
将它们放入大脑中

1332
00:49:31,040 --> 00:49:31,920
如此

1333
00:49:31,920 --> 00:49:34,559
棒的话题我想我们已经为下一次演示做好了准备

1334
00:49:34,559 --> 00:49:37,680


1335
00:49:39,440 --> 00:49:41,599


1336
00:49:41,599 --> 00:49:45,839


1337
00:49:47,920 --> 00:49:52,400
现在看起来不错，

1338
00:49:52,400 --> 00:49:56,800
所以您现在可以看到我的幻灯片了

1339
00:49:56,800 --> 00:49:59,119


1340
00:49:59,119 --> 00:50:02,000


1341
00:50:02,000 --> 00:50:04,319


1342
00:50:04,319 --> 00:50:06,400


1343
00:50:06,400 --> 00:50:08,880


1344
00:50:08,880 --> 00:50:11,200
吗 主动推理解决方案的未来愿景

1345
00:50:11,200 --> 00:50:14,079
fornilab.jl 更像是

1346
00:50:14,079 --> 00:50:15,680
成熟的

1347
00:50:15,680 --> 00:50:18,800
框架，它可以工作，反应式 mp 是

1348
00:50:18,800 --> 00:50:22,720
我们目前的研究项目

1349
00:50:22,720 --> 00:50:24,400
，我们将从一个问题开始，

1350
00:50:24,400 --> 00:50:25,520


1351
00:50:25,520 --> 00:50:27,359
什么是反应式消息

1352
00:50:27,359 --> 00:50:28,400
破坏

1353
00:50:28,400 --> 00:50:29,839
，

1354
00:50:29,839 --> 00:50:31,920
在大多数意义上它是 相同的消息

1355
00:50:31,920 --> 00:50:34,960
作为公式传递，但

1356
00:50:34,960 --> 00:50:37,680
在反应范式中重新实现，所以基本上色情实验室

1357
00:50:37,680 --> 00:50:39,760
中传统方法的主要问题

1358
00:50:39,760 --> 00:50:40,960


1359
00:50:40,960 --> 00:50:43,760
是为了

1360
00:50:43,760 --> 00:50:45,839
对我们的模型进行推理 我们需要提前创建这个

1361
00:50:45,839 --> 00:50:48,480
消息的影子，

1362
00:50:48,480 --> 00:50:50,720
所以我们需要预先分析我们的图表，我们

1363
00:50:50,720 --> 00:50:53,119
需要基本上分析所有内容，

1364
00:50:53,119 --> 00:50:55,200
我们需要在每次更改图表结构时都这样做

1365
00:50:55,200 --> 00:50:57,200


1366
00:50:57,200 --> 00:51:00,480
，如果图表很大，这个图表分析

1367
00:51:00,480 --> 00:51:02,319
时间和 阴影创建可能需要

1368
00:51:02,319 --> 00:51:04,240
很多额外的时间

1369
00:51:04,240 --> 00:51:07,280
，这可能不是一个大问题，但作为

1370
00:51:07,280 --> 00:51:09,200
一名工程师，您可能想要测试

1371
00:51:09,200 --> 00:51:11,359
很多模型，直到您

1372
00:51:11,359 --> 00:51:14,079
对性能以及这些额外的延迟

1373
00:51:14,079 --> 00:51:16,079
和穿梭创建时间

1374
00:51:16,079 --> 00:51:19,680
感到满意为止 最后传递一些烦人和反应性的

1375
00:51:19,680 --> 00:51:21,520
消息使我们能够

1376
00:51:21,520 --> 00:51:24,400
消除这种预定义的阴影，

1377
00:51:24,400 --> 00:51:26,240
它还为我们提供了许多其他好处

1378
00:51:26,240 --> 00:51:30,400
和可能的未来研究方向，

1379
00:51:30,400 --> 00:51:32,880
因此

1380
00:51:32,880 --> 00:51:35,839
我们将图表投射到喜欢事件而不是固定阴影而不是固定阴影

1381
00:51:35,839 --> 00:51:37,760
-基于系统

1382
00:51:37,760 --> 00:51:39,520
，其中所有事物都可以对其邻居环境做出反应，

1383
00:51:39,520 --> 00:51:41,119


1384
00:51:41,119 --> 00:51:43,440
并且就消息传递而言，

1385
00:51:43,440 --> 00:51:45,920
节点对传入消息做出反应，

1386
00:51:45,920 --> 00:51:48,319
并且它还对我们参数的更新后边缘做出反应

1387
00:51:48,319 --> 00:51:50,800


1388
00:51:50,800 --> 00:51:53,760
d 整个模型变得被动我们

1389
00:51:53,760 --> 00:51:56,319
也可以对这个系统的变化做出反应

1390
00:51:56,319 --> 00:51:58,960
，基本上做我们想做的任何事情，所以我们

1391
00:51:58,960 --> 00:52:00,800
可以

1392
00:52:00,800 --> 00:52:04,800
根据新更新的后边际执行一些动作，

1393
00:52:04,800 --> 00:52:07,680
它也在消息中传递一个自然的

1394
00:52:07,680 --> 00:52:11,280
起点呃是我们的数据或

1395
00:52:11,280 --> 00:52:14,400
观察结果和 模型本身

1396
00:52:14,400 --> 00:52:18,559
会对我们的数据或先验数据的变化做出反应

1397
00:52:18,559 --> 00:52:20,319
，它也会相应地改变后验数据

1398
00:52:20,319 --> 00:52:23,040
，

1399
00:52:23,040 --> 00:52:26,480
所以在这里我概述

1400
00:52:26,480 --> 00:52:27,760
了主动消息被动

1401
00:52:27,760 --> 00:52:29,839
实现的一些额外好处，所以首先我们可以

1402
00:52:29,839 --> 00:52:32,400
概述生物学上的合理性，

1403
00:52:32,400 --> 00:52:34,480
因为在自然界中我们可能没有

1404
00:52:34,480 --> 00:52:36,800
任何预定义的调度程序，用于我们的

1405
00:52:36,800 --> 00:52:39,440
信息在我们大脑中的神经元上流动

1406
00:52:39,440 --> 00:52:41,520
，例如

1407
00:52:41,520 --> 00:52:43,920
，它们是由某种

1408
00:52:43,920 --> 00:52:46,960
化学（如物理学）驱动的，从某种意义上说，它

1409
00:52:46,960 --> 00:52:49,200
就像反应系统一样，它不断

1410
00:52:49,200 --> 00:52:52,240
适应环境的变化

1411
00:52:52,240 --> 00:52:55,599
，而且它仅在需要时才做出反应

1412
00:52:55,599 --> 00:52:57,359
就基于消息传递的

1413
00:52:57,359 --> 00:52:59,520
推理而言，如果它们不是，甚至可能不需要

1414
00:52:59,520 --> 00:53:02,400
对某些事件（例如某些消息）做出反应

1415
00:53:02,400 --> 00:53:05,760
非常重要

1416
00:53:05,760 --> 00:53:08,240
uh 一个固定的预定义阴影，

1417
00:53:08,240 --> 00:53:10,480
即使

1418
00:53:10,480 --> 00:53:13,280
您并不真的需要它们，您也必须进行所有计算

1419
00:53:13,280 --> 00:53:15,040


1420
00:53:15,040 --> 00:53:17,040


1421
00:53:17,040 --> 00:53:19,599


1422
00:53:19,599 --> 00:53:22,319
问题，

1423
00:53:22,319 --> 00:53:24,559
所以它支持数

1424
00:53:24,559 --> 00:53:26,800
十万个因子注释，甚至数百万个

1425
00:53:26,800 --> 00:53:29,040
是可能

1426
00:53:29,040 --> 00:53:30,559


1427
00:53:30,559 --> 00:53:32,800


1428
00:53:32,800 --> 00:53:35,359


1429
00:53:35,359 --> 00:53:38,559
的 已知线线性动力学

1430
00:53:38,559 --> 00:53:40,559
，想法是在这个例子中估计轿车

1431
00:53:40,559 --> 00:53:43,520
状态给定嘈杂的观察

1432
00:53:43,520 --> 00:53:45,520
我使用卡尔曼平滑

1433
00:53:45,520 --> 00:53:47,280
器和 50 000 个

1434
00:53:47,280 --> 00:53:49,680
观察值，这个模型包含

1435
00:53:49,680 --> 00:53:53,280
大约 150 000 个因子节点，

1436
00:53:53,280 --> 00:53:55,040
因此对这种

1437
00:53:55,040 --> 00:53:57,839
模型的贝叶斯推断在采样时是不可能的 基于

1438
00:53:57,839 --> 00:53:59,520
推理，

1439
00:53:59,520 --> 00:54:01,200
但通过响应式消息传递，

1440
00:54:01,200 --> 00:54:03,119
仅

1441
00:54:03,119 --> 00:54:06,480
在家用 macbook 笔记本电脑上只需大约 8 秒，

1442
00:54:06,480 --> 00:54:09,480


1443
00:54:10,559 --> 00:54:12,720
因此我们可以更进一步并制作

1444
00:54:12,720 --> 00:54:14,880
响应式系统 tem 健壮且能够容忍

1445
00:54:14,880 --> 00:54:17,760
某些情况，比如说失败的节点或丢失的

1446
00:54:17,760 --> 00:54:18,960
数据

1447
00:54:18,960 --> 00:54:21,760
，比如说失败的传感器

1448
00:54:21,760 --> 00:54:23,920
我们修复预定义的阴影如果发生

1449
00:54:23,920 --> 00:54:25,440
这种情况我们需要

1450
00:54:25,440 --> 00:54:27,200
从头开始做所有事情

1451
00:54:27,200 --> 00:54:29,280
我们需要重新创建我们的模型我们需要

1452
00:54:29,280 --> 00:54:31,839
再次制作一个阴影

1453
00:54:31,839 --> 00:54:34,240
，它会 只需要一些时间来

1454
00:54:34,240 --> 00:54:36,960
处理反应性消息，我们可能会

1455
00:54:36,960 --> 00:54:39,599
停止对一些丢失的数据

1456
00:54:39,599 --> 00:54:42,160
或传感器故障做出反应

1457
00:54:42,160 --> 00:54:44,160
，我们可以等待它们

1458
00:54:44,160 --> 00:54:46,160
再次可用，

1459
00:54:46,160 --> 00:54:48,319
从这个意义上说它非常强大，它

1460
00:54:48,319 --> 00:54:50,799
也让我们有机会改变

1461
00:54:50,799 --> 00:54:53,440
我们的图表 运行时的结构

1462
00:54:53,440 --> 00:54:55,440
并且仍然执行推理而不

1463
00:54:55,440 --> 00:54:57,920
停止

1464
00:54:58,880 --> 00:55:01,599
所以有一张幻灯片关于我们实际上

1465
00:55:01,599 --> 00:55:02,720
是如何做的，

1466
00:55:02,720 --> 00:55:04,799
我们在我们的实验室中使用 julia 的主要编程语言

1467
00:55:04,799 --> 00:55:07,920
大约一年

1468
00:55:07,920 --> 00:55:09,839
半我相信之前

1469
00:55:09,839 --> 00:55:11,440
我们在 julia 中编写了用于反应式编程的库，

1470
00:55:11,440 --> 00:55:13,599
所以它完全

1471
00:55:13,599 --> 00:55:15,359
仅在基于事件的系统的通用框架中与消息传递无关，

1472
00:55:15,359 --> 00:55:17,200


1473
00:55:17,200 --> 00:55:18,240


1474
00:55:18,240 --> 00:55:20,640
但这允许我们

1475
00:55:20,640 --> 00:55:24,160
稍后构建反应式 mp.jl 包

1476
00:55:24,160 --> 00:55:25,680
它

1477
00:55:25,680 --> 00:55:29,359
通过消息传递实现自由能最小化

1478
00:55:29,359 --> 00:55:31,599
我们还引入了graphpl.gel包

1479
00:55:31,599 --> 00:55:33,520
，它是一种高级且用户友好的

1480
00:55:33,520 --> 00:55:35,119
概率模型规范

1481
00:55:35,119 --> 00:55:38,640
语言，我们在演示中使用

1482
00:55:38,640 --> 00:55:41,040
嗯是的，我

1483
00:55:41,040 --> 00:55:43,119
想向您展示一个

1484
00:55:43,119 --> 00:55:45,119
示例 第二个

1485
00:55:45,119 --> 00:55:47,599
这样你就可以看到我的屏幕

1486
00:55:47,599 --> 00:55:49,119


1487
00:55:49,119 --> 00:55:53,040


1488
00:55:53,440 --> 00:55:56,799


1489
00:55:56,799 --> 00:55:58,240


1490
00:55:58,240 --> 00:56:02,759


1491
00:56:02,799 --> 00:56:04,960


1492
00:56:04,960 --> 00:56:07,599


1493
00:56:07,599 --> 00:56:10,720
了 是我们的例子，所以假设我们有

1494
00:56:10,720 --> 00:56:11,520
一些

1495
00:56:11,520 --> 00:56:14,240
移动的物体，呃，

1496
00:56:14,240 --> 00:56:16,079
它有一些隐藏状态，为了简单起见，我们只

1497
00:56:16,079 --> 00:56:18,400
假设我们知道它是线性动力学

1498
00:56:18,400 --> 00:56:21,200
，我们不知道我们

1499
00:56:21,200 --> 00:56:23,359
没有直接访问它的位置，但是

1500
00:56:23,359 --> 00:56:25,200
我们有一个嘈杂的观察 这个

1501
00:56:25,200 --> 00:56:26,480
移动物体

1502
00:56:26,480 --> 00:56:28,799
，我们希望

1503
00:56:28,799 --> 00:56:31,599
仅通过观察它的噪声测量来估计这个移动物体的真实位置

1504
00:56:31,599 --> 00:56:35,040


1505
00:56:35,040 --> 00:56:38,160
，我们可以使用线性多元

1506
00:56:38,160 --> 00:56:41,119
高斯状态空间模型，

1507
00:56:41,119 --> 00:56:44,000
比如方程看起来像这样这些 ar

1508
00:56:44,000 --> 00:56:46,480
等价的符号它们是相同的

1509
00:56:46,480 --> 00:56:48,960
，基本上在这里我们说，嗯，好吧，

1510
00:56:48,960 --> 00:56:52,400
我们在时间步 k 有一个状态 x

1511
00:56:52,400 --> 00:56:54,400
，它只取决于

1512
00:56:54,400 --> 00:56:55,920


1513
00:56:55,920 --> 00:56:58,400
通过一些线性算子 a 的前一个时间步，我们

1514
00:56:58,400 --> 00:57:00,880
还有一个高斯的过渡噪声

1515
00:57:00,880 --> 00:57:03,599
使用协方差矩阵 b 并且

1516
00:57:03,599 --> 00:57:06,000
我们的观察结果

1517
00:57:06,000 --> 00:57:07,200


1518
00:57:07,200 --> 00:57:10,319
基本上也被建模为具有

1519
00:57:10,319 --> 00:57:11,040


1520
00:57:11,040 --> 00:57:12,960
协方差矩阵 q 的高斯，

1521
00:57:12,960 --> 00:57:15,520
所以基本上这是我们的模型

1522
00:57:15,520 --> 00:57:17,599
，我们可以简单地从中创建一个因子

1523
00:57:17,599 --> 00:57:19,440
图，

1524
00:57:19,440 --> 00:57:21,040
并且您可以看到

1525
00:57:21,040 --> 00:57:22,240


1526
00:57:22,240 --> 00:57:25,359
我们的模型规范非常

1527
00:57:25,359 --> 00:57:27,760
类似于 上面定义的方程，

1528
00:57:27,760 --> 00:57:29,359
所以这里我们有

1529
00:57:29,359 --> 00:57:32,240
我们的状态 xk 并且它被建模为像

1530
00:57:32,240 --> 00:57:35,040
先前状态的高斯一样，其中一些

1531
00:57:35,040 --> 00:57:38,240
假设是已知的协方差矩阵

1532
00:57:38,240 --> 00:57:40,400
，这就是我们构建模型的方式，

1533
00:57:40,400 --> 00:57:42,400
并且在引擎盖下，这段

1534
00:57:42,400 --> 00:57:45,359
代码生成因子图

1535
00:57:45,359 --> 00:57:48,319
，我们可以 以后都可以使用

1536
00:57:48,319 --> 00:57:49,359
响应式

1537
00:57:49,359 --> 00:57:51,839
mp.jail api 来估计

1538
00:57:51,839 --> 00:57:54,000
我们系统的隐藏状态，但这是我们的示例，它

1539
00:57:54,000 --> 00:57:55,760
看起来有点不对劲，

1540
00:57:55,760 --> 00:57:59,119
可能是因为我放大了一点，

1541
00:57:59,119 --> 00:58:01,599
但没关系，我

1542
00:58:01,599 --> 00:58:04,400
相信 在这个例子中，我

1543
00:58:04,400 --> 00:58:07,119
对 500 个点执行了卡尔曼平滑器，我只是

1544
00:58:07,119 --> 00:58:08,720
将

1545
00:58:08,720 --> 00:58:10,480
这个移动对象的轨迹分解为

1546
00:58:10,480 --> 00:58:13,359
两个轴 x 轴和 y 轴

1547
00:58:13,359 --> 00:58:14,880
，我们可以看到

1548
00:58:14,880 --> 00:58:17,440


1549
00:58:17,440 --> 00:58:19,359
像我们系统的真实隐藏状态一样

1550
00:58:19,359 --> 00:58:21,599
正确预测的常见

1551
00:58:21,599 --> 00:58:23,200
平滑器 虽然我们的系统中有很多噪音，

1552
00:58:23,200 --> 00:58:25,440
所以这些蓝点就像

1553
00:58:25,440 --> 00:58:28,480
我们的嘈杂观察

1554
00:58:28,480 --> 00:58:31,440
，我们可以走得更远，

1555
00:58:31,440 --> 00:58:34,240
因为我们的系统是反应性的，我们

1556
00:58:34,240 --> 00:58:37,760
可以实时估计我们的状态，

1557
00:58:37,760 --> 00:58:38,799


1558
00:58:38,799 --> 00:58:41,839
所以这是我们的例子 让我尝试运行

1559
00:58:41,839 --> 00:58:43,839
它，

1560
00:58:43,839 --> 00:58:46,319
嗯，我希望它在我的计算机上看起来很流畅，

1561
00:58:46,319 --> 00:58:48,559
实际上非常流畅，

1562
00:58:48,559 --> 00:58:51,200
但我知道

1563
00:58:51,200 --> 00:58:53,520
录制可能不像屏幕共享那样流畅，

1564
00:58:53,520 --> 00:58:56,480
但在这个例子中，我们

1565
00:58:56,480 --> 00:58:58,559
看到的是，好的，我们有一个无限的

1566
00:58:58,559 --> 00:59:01,040
数据流 运动物体的蓝色

1567
00:59:01,040 --> 00:59:02,559
是真实的，红色是

1568
00:59:02,559 --> 00:59:05,440
估计的，我们可以看到，嗯，

1569
00:59:05,440 --> 00:59:07,760
是的，让我重新加载它，因为它

1570
00:59:07,760 --> 00:59:10,559
有点关闭

1571
00:59:10,720 --> 00:59:13,680
，我们可以看到

1572
00:59:13,920 --> 00:59:16,160
反应式 mp 能够执行和

1573
00:59:16,160 --> 00:59:18,640
贝叶斯推理 i  n 实时

1574
00:59:18,640 --> 00:59:21,359
，它实际上适应了

1575
00:59:21,359 --> 00:59:23,760
环境的变化，也改变

1576
00:59:23,760 --> 00:59:27,200
了当前估计状态的后验

1577
00:59:27,200 --> 00:59:28,559


1578
00:59:28,559 --> 00:59:30,480
，我们可以走得更远你可能会

1579
00:59:30,480 --> 00:59:32,880
注意到这里的这条橙色线现在只是

1580
00:59:32,880 --> 00:59:35,520
不活动的，但我们也可以

1581
00:59:35,520 --> 00:59:38,640
结合

1582
00:59:38,640 --> 00:59:41,440
这个模型的预测，所以 我们可以只是我们可以

1583
00:59:41,440 --> 00:59:44,160
扩展一点我们的图表

1584
00:59:44,160 --> 00:59:47,280
，我们也可以像这样预测我们系统的未来状态，

1585
00:59:47,280 --> 00:59:49,119


1586
00:59:49,119 --> 00:59:50,240


1587
00:59:50,240 --> 00:59:52,799
所以现在在这个例子中，我

1588
00:59:52,799 --> 00:59:55,119
实时进行贝叶斯推理，我

1589
00:59:55,119 --> 00:59:57,760
还预测我的系统的未来状态，

1590
00:59:57,760 --> 01:00:00,160
比如橙色

1591
01:00:00,160 --> 01:00:02,319
和 你可以看到预测也

1592
01:00:02,319 --> 01:00:04,960
适应了新的观察

1593
01:00:04,960 --> 01:00:08,240
，是的，它基本上改变了

1594
01:00:08,240 --> 01:00:09,520


1595
01:00:09,520 --> 01:00:12,720
它对未来状态的未来信念，

1596
01:00:12,720 --> 01:00:14,559
嗯，是的，

1597
01:00:14,559 --> 01:00:16,720
让我停止它并继续

1598
01:00:16,720 --> 01:00:19,439
演示，

1599
01:00:21,040 --> 01:00:23,119
所以嗯，

1600
01:00:23,119 --> 01:00:25,040
是的，我将

1601
01:00:25,040 --> 01:00:27,200
谈论当反应性消息传递

1602
01:00:27,200 --> 01:00:30,000
可用时 实际上它已经在工作了，

1603
01:00:30,000 --> 01:00:32,480
我们有一个完全工作的稳定

1604
01:00:32,480 --> 01:00:34,480
反手和 api，用于精确和

1605
01:00:34,480 --> 01:00:36,799
变分贝叶斯推理，我们也

1606
01:00:36,799 --> 01:00:39,280
支持期望传播，但是 在

1607
01:00:39,280 --> 01:00:44,079
api 还不稳定所以它可能会改变

1608
01:00:44,079 --> 01:00:46,799
我们现在只支持

1609
01:00:46,799 --> 01:00:48,960
来自指数族的共轭模型

1610
01:00:48,960 --> 01:00:50,799
我们支持

1611
01:00:50,799 --> 01:00:53,680
变化优化过程的额外约束，

1612
01:00:53,680 --> 01:00:55,599
例如形式或分解

1613
01:00:55,599 --> 01:00:56,880
约束，

1614
01:00:56,880 --> 01:00:59,440
所以 Rocket.jl 库它自然

1615
01:00:59,440 --> 01:01:01,280
支持无限数据流，

1616
01:01:01,280 --> 01:01:03,599
例如来自互联网 或者来自一些

1617
01:01:03,599 --> 01:01:05,280
传感器

1618
01:01:05,280 --> 01:01:07,680
和框架本身能够处理

1619
01:01:07,680 --> 01:01:09,280
丢失的数据，

1620
01:01:09,280 --> 01:01:10,480
但是这个

1621
01:01:10,480 --> 01:01:14,960
api 在这里还不稳定

1622
01:01:16,079 --> 01:01:17,040


1623
01:01:17,040 --> 01:01:19,520
，我们对这个平台的一些未来计划，

1624
01:01:19,520 --> 01:01:22,400
所以我们想扩展它以

1625
01:01:22,400 --> 01:01:24,720
支持非共轭模型，

1626
01:01:24,720 --> 01:01:26,960
基本上外国实验室已经支持

1627
01:01:26,960 --> 01:01:28,079
它

1628
01:01:28,079 --> 01:01:30,319
我们只需要小心地将

1629
01:01:30,319 --> 01:01:32,160
所有可用的现有功能

1630
01:01:32,160 --> 01:01:35,599
从外国实验室移植到反应式 mp

1631
01:01:35,599 --> 01:01:37,680
，我们还希望与

1632
01:01:37,680 --> 01:01:39,440


1633
01:01:39,440 --> 01:01:42,960
7 月社区

1634
01:01:43,520 --> 01:01:45,359
反应式消息传递中存在的其他概率编程库集成，这使我们有

1635
01:01:45,359 --> 01:01:47,280
机会

1636
01:01:47,280 --> 01:01:50,480
尝试集成并行推理

1637
01:01:50,480 --> 01:01:52,079
和反应 图的不同部分

1638
01:01:52,079 --> 01:01:53,920
同时使用类似

1639
01:01:53,920 --> 01:01:57,280
的多核功能 对于我们的 CPU

1640
01:01:57,280 --> 01:01:58,079
呃，

1641
01:01:58,079 --> 01:01:59,839
我们想扩展

1642
01:01:59,839 --> 01:02:02,640
图形 ppl 以支持模块化模型

1643
01:02:02,640 --> 01:02:04,880
规范，不幸的是，

1644
01:02:04,880 --> 01:02:07,839


1645
01:02:08,960 --> 01:02:11,200
反应式消息传递自然也不可能

1646
01:02:11,200 --> 01:02:13,039
让我们有机会

1647
01:02:13,039 --> 01:02:15,280
在不同数据

1648
01:02:15,280 --> 01:02:19,280
流具有不同更新率的情况下运行推理，

1649
01:02:19,280 --> 01:02:21,359
嗯

1650
01:02:21,359 --> 01:02:22,960
，我在说什么

1651
01:02:22,960 --> 01:02:25,520
关于鲁棒性的一开始，但

1652
01:02:25,520 --> 01:02:27,920
也很有趣，我们可以将它推到多远

1653
01:02:27,920 --> 01:02:30,319
，也许可以

1654
01:02:30,319 --> 01:02:32,480


1655
01:02:32,480 --> 01:02:35,039
根据自由能在运行时自动调整模型的图形结构，

1656
01:02:35,039 --> 01:02:37,520


1657
01:02:38,000 --> 01:02:39,839
但这就像一个研究项目，我们

1658
01:02:39,839 --> 01:02:41,520
真的不知道它是否可能

1659
01:02:41,520 --> 01:02:43,599


1660
01:02:43,599 --> 01:02:45,440
现在，我们对

1661
01:02:45,440 --> 01:02:47,280


1662
01:02:47,280 --> 01:02:49,359
基于消息传递的算法

1663
01:02:49,359 --> 01:02:50,960
和自由能最小

1664
01:02:50,960 --> 01:02:53,520
化可视化的交互式可视化有了一些想法

1665
01:02:53,520 --> 01:02:56,400
，最终我们计划

1666
01:02:56,400 --> 01:02:58,799
将这个新平台作为公式的稳定

1667
01:02:58,799 --> 01:03:01,280
版本发布，可能

1668
01:03:01,280 --> 01:03:03,200
在 2.0 中

1669
01:03:03,200 --> 01:03:05,280
，这基本上就是我

1670
01:03:05,280 --> 01:03:07,039
想向您展示的一切 在我的幻灯片中，

1671
01:03:07,039 --> 01:03:08,319
感谢您的关注，

1672
01:03:08,319 --> 01:03:12,079
我很乐意回答您的问题

1673
01:03:13,760 --> 01:03:16,640
非常棒的第一个问题是是否有

1674
01:03:16,640 --> 01:03:18,680
关于这个 reactivemp.jl 的论文，

1675
01:03:18,680 --> 01:03:22,720
或者它是如何

1676
01:03:22,720 --> 01:03:25,760
工作的，但它正在进行中，所以

1677
01:03:25,760 --> 01:03:27,920
它不公开，但

1678
01:03:27,920 --> 01:03:30,240
我们正在努力，所以

1679
01:03:30,240 --> 01:03:31,920
最终会有关于

1680
01:03:31,920 --> 01:03:33,599
我将描述的所有这些方法的论文

1681
01:03:33,599 --> 01:03:36,960
它是如何工作的以及我们如何使用它，所以是的，我的

1682
01:03:36,960 --> 01:03:39,039
意思是，当然，如果有人给我们写

1683
01:03:39,039 --> 01:03:41,599
一封电子邮件，想要一份早期的论文副本，

1684
01:03:41,599 --> 01:03:44,240
我很乐意分享它，如果它

1685
01:03:44,240 --> 01:03:45,599
保持

1686
01:03:45,599 --> 01:03:49,359
机密，我很乐意分享它

1687
01:03:49,520 --> 01:03:50,799


1688
01:03:50,799 --> 01:03:51,920


1689
01:03:51,920 --> 01:03:54,559
可能对其他作者来说非常有趣的发展，

1690
01:03:54,559 --> 01:03:55,760
比如

1691
01:03:55,760 --> 01:03:56,799


1692
01:03:56,799 --> 01:03:58,480


1693
01:03:58,480 --> 01:04:01,839
福尼实验室的其他时代，

1694
01:04:01,839 --> 01:04:02,799
嗯

1695
01:04:02,799 --> 01:04:05,440
，我们是如何接触到这种反应式

1696
01:04:05,440 --> 01:04:07,200
编程范式的，而且

1697
01:04:07,200 --> 01:04:09,039
看起来你在实验室里做了很多关于反应式编程的基础

1698
01:04:09,039 --> 01:04:10,480
工作

1699
01:04:10,480 --> 01:04:13,039


1700
01:04:13,039 --> 01:04:14,400
是 只是在 julia

1701
01:04:14,400 --> 01:04:17,119
实现或更概念化的

1702
01:04:17,119 --> 01:04:19,599
基础上，

1703
01:04:19,599 --> 01:04:20,559
嗯，

1704
01:04:20,559 --> 01:04:22,559
是的，我们实际上做了很多

1705
01:04:22,559 --> 01:04:24,720
工作来支持 julia 中的响应式编程，

1706
01:04:24,720 --> 01:04:28,559
基本上 julia 就像一门年轻的

1707
01:04:28,559 --> 01:04:30,960
语言，它没有

1708
01:04:30,960 --> 01:04:33,839
l 拥有运行

1709
01:04:33,839 --> 01:04:36,960
基于响应式系统的良好能力，所以基本上我们

1710
01:04:36,960 --> 01:04:39,599
从头开始构建它

1711
01:04:39,599 --> 01:04:42,640
是的，但是我们使用了很多呃，

1712
01:04:42,640 --> 01:04:43,760
比如说我们有经验

1713
01:04:43,760 --> 01:04:46,240
的其他编程语言的想法

1714
01:04:46,240 --> 01:04:50,240


1715
01:04:53,200 --> 01:04:55,119
我的意思是我知道积极影响

1716
01:04:55,119 --> 01:04:57,200
社区呃

1717
01:04:57,200 --> 01:05:00,559
matlab 和 matlab 非常棒，

1718
01:05:00,559 --> 01:05:02,160


1719
01:05:02,160 --> 01:05:05,280
但如果你真的想要实时

1720
01:05:05,280 --> 01:05:09,119
处理流数据，那么 julia

1721
01:05:09,119 --> 01:05:10,720
是一个非常

1722
01:05:10,720 --> 01:05:13,839
好的选择，因为

1723
01:05:13,839 --> 01:05:16,480
从用户的角度来看，julia 几乎具有 matlab 的语法，

1724
01:05:16,480 --> 01:05:17,680


1725
01:05:17,680 --> 01:05:19,039


1726
01:05:19,039 --> 01:05:21,520
但开箱即用它几乎

1727
01:05:21,520 --> 01:05:23,119
和

1728
01:05:23,119 --> 01:05:25,920
c 所以这是一个更好的组合，

1729
01:05:25,920 --> 01:05:27,680
如果你从事工程并且你

1730
01:05:27,680 --> 01:05:29,280
真的想要构建

1731
01:05:29,280 --> 01:05:31,599
实时运行的系统，你

1732
01:05:31,599 --> 01:05:34,640
想要制作演示，并且 julia 是一种更好的

1733
01:05:34,640 --> 01:05:37,920
语言，嗯，dimitri 还使用

1734
01:05:37,920 --> 01:05:41,760
了 julia 中的一些非常先进的东西

1735
01:05:41,760 --> 01:05:43,280
它被称为多次调度，但它

1736
01:05:43,280 --> 01:05:44,720
是什么并不重要

1737
01:05:44,720 --> 01:05:46,960
，但它非常先进

1738
01:05:46,960 --> 01:05:48,160
，它

1739
01:05:48,160 --> 01:05:51,359
在 matlab 中不可用，但它

1740
01:05:51,359 --> 01:05:53,760
对于我们所做的事情非常有用

1741
01:05:53,760 --> 01:05:55,520


1742
01:05:55,520 --> 01:05:59,039
工具箱

1743
01:05:59,039 --> 01:06:01,599
如果您查看图表和

1744
01:06:01,599 --> 01:06:04,240
传递它的

1745
01:06:04,240 --> 01:06:05,680
消息，

1746
01:06:05,680 --> 01:06:07,839


1747
01:06:07,839 --> 01:06:09,359
它似乎是

1748
01:06:09,359 --> 01:06:11,680


1749
01:06:11,680 --> 01:06:14,880


1750
01:06:14,880 --> 01:06:18,640
这样的 .net，它很棒，但它

1751
01:06:18,640 --> 01:06:21,200
不是一个真正的实时工具箱，

1752
01:06:21,200 --> 01:06:24,799
嗯，据我们所知

1753
01:06:24,799 --> 01:06:26,400
，目前对我们来说竞争并不多，

1754
01:06:26,400 --> 01:06:28,079


1755
01:06:28,079 --> 01:06:30,240
不是我们的工具箱非常先进

1756
01:06:30,240 --> 01:06:31,359
，但

1757
01:06:31,359 --> 01:06:33,680
我没有看到 很多人在

1758
01:06:33,680 --> 01:06:36,720
做这个我看到很多人在

1759
01:06:36,720 --> 01:06:38,799
做多车采样，但是多车

1760
01:06:38,799 --> 01:06:41,359
采样不适用于

1761
01:06:41,359 --> 01:06:43,920
系统的大小和

1762
01:06:43,920 --> 01:06:45,680
我们想要通过主动推理来处理的实时数据流，我们

1763
01:06:45,680 --> 01:06:48,480


1764
01:06:48,480 --> 01:06:50,079
正在使用 我们想要

1765
01:06:50,079 --> 01:06:53,119
采取行动并影响我们的数据的系统

1766
01:06:53,119 --> 01:06:55,359
所以这是一个实时系统

1767
01:06:55,359 --> 01:06:56,240


1768
01:06:56,240 --> 01:06:59,119
嗯所以我们必须去

1769
01:06:59,119 --> 01:07:01,520
想要真正扩大我们必须去

1770
01:07:01,520 --> 01:07:02,640


1771
01:07:02,640 --> 01:07:05,039
构建一个真正高质量的专业

1772
01:07:05,039 --> 01:07:06,640
工具箱

1773
01:07:06,640 --> 01:07:09,599
来自动化消息传递我希望

1774
01:07:09,599 --> 01:07:12,160
这个 将是呃这些工具箱之一

1775
01:07:12,160 --> 01:07:13,839
，希望也将是其他

1776
01:07:13,839 --> 01:07:15,280
工具箱，但是

1777
01:07:15,280 --> 01:07:18,400
是的，这就是为什么我们正在做这个

1778
01:07:18,400 --> 01:07:21,760
非常有趣的答案

1779
01:07:21,760 --> 01:07:23,440


1780
01:07:23,440 --> 01:07:25,119


1781
01:07:25,119 --> 01:07:27,200
，数学和编程和计算机

1782
01:07:27,200 --> 01:07:28,880
科学方面之间的对话，然后是主动

1783
01:07:28,880 --> 01:07:32,559
推理方面，就像

1784
01:07:32,559 --> 01:07:34,240
每个人都有什么 侧面有所贡献，因为听起来

1785
01:07:34,240 --> 01:07:36,240


1786
01:07:36,240 --> 01:07:38,480
主动推理的一些实时见解有点

1787
01:07:38,480 --> 01:07:40,319
传播回算法的设计

1788
01:07:40,319 --> 01:07:42,559
，然后

1789
01:07:42,559 --> 01:07:44,319
我们看到了两个方向，所以

1790
01:07:44,319 --> 01:07:46,480
这对你们每个人或每个人来说可能是如何发挥作用的

1791
01:07:46,480 --> 01:07:48,880


1792
01:07:49,359 --> 01:07:52,720
也可以

1793
01:07:52,720 --> 01:07:54,960
从

1794
01:07:54,960 --> 01:07:57,200


1795
01:07:57,200 --> 01:07:59,039


1796
01:07:59,039 --> 01:08:02,000
我的角度回答这个问题

1797
01:08:02,000 --> 01:08:03,359


1798
01:08:03,359 --> 01:08:05,920


1799
01:08:05,920 --> 01:08:07,440


1800
01:08:07,440 --> 01:08:10,400
当然，它也反映

1801
01:08:10,400 --> 01:08:13,200
了我们对软件的设计选择，

1802
01:08:13,200 --> 01:08:16,158
所以有点，但有时

1803
01:08:16,158 --> 01:08:18,640
很难将这种高级

1804
01:08:18,640 --> 01:08:21,040
数学思想与实际相适应

1805
01:08:21,040 --> 01:08:22,560
实施

1806
01:08:22,560 --> 01:08:25,120
，而且很难使其

1807
01:08:25,120 --> 01:08:26,799
高效，

1808
01:08:26,799 --> 01:08:28,960
所以

1809
01:08:31,359 --> 01:08:34,319
是的，我们不是，呃，我们还没有完成

1810
01:08:34,319 --> 01:08:37,040
这个，嗯，我的意思是工具箱

1811
01:08:37,040 --> 01:08:39,040
可供任何人使用，

1812
01:08:39,040 --> 01:08:41,198
所有漂亮的领域示例，

1813
01:08:41,198 --> 01:08:44,080
基本恒温器，井字游戏，

1814
01:08:44,080 --> 01:08:46,080
一切都有效 非常顺利，

1815
01:08:46,080 --> 01:08:48,318


1816
01:08:49,198 --> 01:08:51,519
我们的

1817
01:08:51,759 --> 01:08:54,158
希望是，通过响应式消息

1818
01:08:54,158 --> 01:08:55,679
传递，我们实际上

1819
01:08:55,679 --> 01:08:56,880
可以知道如何将其

1820
01:08:56,880 --> 01:08:59,359
扩展到严肃的

1821
01:08:59,359 --> 01:09:00,719


1822
01:09:00,719 --> 01:09:02,560
应用程序，我的意思是这是真实的，我的意思是我们是

1823
01:09:02,560 --> 01:09:04,158
一个工程团队，我们想要

1824
01:09:04,158 --> 01:09:06,799
构建真正做某事的系统

1825
01:09:06,799 --> 01:09:09,198
有用 我也在一家助听器公司工作，

1826
01:09:09,198 --> 01:09:12,640
所以我想构建实时

1827
01:09:12,640 --> 01:09:16,479
音频处理算法

1828
01:09:16,479 --> 01:09:17,359


1829
01:09:17,359 --> 01:09:18,960
，其他人可能想将它用于

1830
01:09:18,960 --> 01:09:21,439
机器人技术，所以

1831
01:09:21,439 --> 01:09:24,399
是的，但这不会

1832
01:09:24,399 --> 01:09:26,479
在实时模型中起作用，它不会

1833
01:09:26,479 --> 01:09:28,399
起作用

1834
01:09:28,399 --> 01:09:31,679
嗯 是的，所有的多卡或

1835
01:09:31,679 --> 01:09:33,600
其他东西都有

1836
01:09:33,600 --> 01:09:36,080
一点，所以这是我们的努力

1837
01:09:36,080 --> 01:09:38,560
，

1838
01:09:38,560 --> 01:09:40,560
这需要很长时间，因为这是非常

1839
01:09:40,560 --> 01:09:42,880
多学科的努力，我们

1840
01:09:42,880 --> 01:09:46,000
在我的小组中有一个数学家

1841
01:09:46,000 --> 01:09:47,279
和

1842
01:09:47,279 --> 01:09:49,120
神经 科学家和

1843
01:09:49,120 --> 01:09:51,359
计算机科学家，

1844
01:09:51,359 --> 01:09:53,439
因为这很困难

1845
01:09:53,439 --> 01:09:55,520
有很多不同的

1846
01:09:55,520 --> 01:09:57,199
专业

1847
01:09:57,199 --> 01:09:59,360
知识，你需要建立一个好的

1848
01:09:59,360 --> 01:10:02,880
工具箱来进行主动推理，

1849
01:10:02,880 --> 01:10:04,640
我认为因为这太难

1850
01:10:04,640 --> 01:10:06,159
了，就像

1851
01:10:06,159 --> 01:10:08,080


1852
01:10:08,080 --> 01:10:09,679
活跃

1853
01:10:09,679 --> 01:10:11,840
推理社区和

1854
01:10:11,840 --> 01:10:13,840
我们所做

1855
01:10:13,840 --> 01:10:15,840
的工程社区最感兴趣的是

1856
01:10:15,840 --> 01:10:18,560
解释生物系统正确

1857
01:10:18,560 --> 01:10:20,239
的能量原理和

1858
01:10:20,239 --> 01:10:21,840


1859
01:10:21,840 --> 01:10:24,000
作为生物学模型的主动推理

1860
01:10:24,000 --> 01:10:25,440
，我认为这很有趣，

1861
01:10:25,440 --> 01:10:26,960
因为虽然大自然有某种有效

1862
01:10:26,960 --> 01:10:28,840
地做事的方式，

1863
01:10:28,840 --> 01:10:30,800
嗯

1864
01:10:30,800 --> 01:10:32,719
，如果这是一个 模型，

1865
01:10:32,719 --> 01:10:34,320
然后将其用于工程也是一个好主意

1866
01:10:34,320 --> 01:10:36,000


1867
01:10:36,000 --> 01:10:37,920
，这是我们的建议，因此

1868
01:10:37,920 --> 01:10:40,000
我们采用

1869
01:10:40,000 --> 01:10:41,199
活跃推理社区中可用的想法

1870
01:10:41,199 --> 01:10:43,360
以及他们解释大脑

1871
01:10:43,360 --> 01:10:45,120
并思考大脑

1872
01:10:45,120 --> 01:10:47,120
并思考嘿，我们怎么能 采用这些

1873
01:10:47,120 --> 01:10:48,320
想法

1874
01:10:48,320 --> 01:10:49,120
并

1875
01:10:49,120 --> 01:10:53,440
使用它们来构建工程系统

1876
01:10:53,440 --> 01:10:56,320
，我认为这是主要

1877
01:10:56,320 --> 01:10:57,920
的 它之间的主要交互，

1878
01:10:57,920 --> 01:11:00,800
希望我们构建

1879
01:11:00,800 --> 01:11:02,719
社区也可以在他们的研究中使用的工具，

1880
01:11:02,719 --> 01:11:06,080
最终

1881
01:11:07,199 --> 01:11:09,520
让我想到的是，

1882
01:11:09,520 --> 01:11:11,840
它实际上是对一些

1883
01:11:11,840 --> 01:11:14,080
主要挑战的重新定义，比如将信号

1884
01:11:14,080 --> 01:11:16,000
处理视为实时事件或

1885
01:11:16,000 --> 01:11:16,800


1886
01:11:16,800 --> 01:11:18,960
行动

1887
01:11:18,960 --> 01:11:21,440
和未来数据之间的因果关系所有这些问题的重新

1888
01:11:21,440 --> 01:11:24,080
框架它

1889
01:11:24,080 --> 01:11:26,239
不像主动推理

1890
01:11:26,239 --> 01:11:27,600
算法

1891
01:11:27,600 --> 01:11:31,199
需要大量的矩阵呃

1892
01:11:31,199 --> 01:11:34,080
计算本身它们可能非常简单

1893
01:11:34,080 --> 01:11:35,760
但实际上是

1894
01:11:35,760 --> 01:11:38,480
在嵌入行动中重新框架 在

1895
01:11:38,480 --> 01:11:39,440


1896
01:11:39,440 --> 01:11:42,080
最终解决扩展的每一步中

1897
01:11:42,080 --> 01:11:44,000
一些扩展挑战

1898
01:11:44,000 --> 01:11:45,440
一些弹性挑战，因为就像

1899
01:11:45,440 --> 01:11:47,040


1900
01:11:47,040 --> 01:11:49,040
城市交通网络的弹性一样，他们

1901
01:11:49,040 --> 01:11:50,000
会进行

1902
01:11:50,000 --> 01:11:51,600
抽样，或者他们会采取一些

1903
01:11:51,600 --> 01:11:53,440
正在展开的动态过程，

1904
01:11:53,440 --> 01:11:55,520
然后尝试推出 一百万

1905
01:11:55,520 --> 01:11:58,080
次静态迭代，

1906
01:11:58,080 --> 01:12:00,080
所以它再次不是

1907
01:12:00,080 --> 01:12:01,360


1908
01:12:01,360 --> 01:12:02,880
循环内部的计算 必须

1909
01:12:02,880 --> 01:12:05,520
具有挑战性，这只是对

1910
01:12:05,520 --> 01:12:07,520
优先级操作的

1911
01:12:07,520 --> 01:12:08,960
重新

1912
01:12:08,960 --> 01:12:11,280
划分，最终走上了这些扩展和

1913
01:12:11,280 --> 01:12:14,400
实时容量的道路

1914
01:12:14,400 --> 01:12:16,640
是的，我喜欢

1915
01:12:16,640 --> 01:12:18,800
这个想法，嗯，也许我可以

1916
01:12:18,800 --> 01:12:20,560
在

1917
01:12:20,560 --> 01:12:22,800
我工作的背景下说些什么，因为我在

1918
01:12:22,800 --> 01:12:24,880
工作 基本上我是一名助听器

1919
01:12:24,880 --> 01:12:25,860
工程师，我从事

1920
01:12:25,860 --> 01:12:27,120
[音乐]工作

1921
01:12:27,120 --> 01:12:29,120
，如果你问助听器工程师

1922
01:12:29,120 --> 01:12:31,040
信号处理工程师，那么

1923
01:12:31,040 --> 01:12:32,480
你

1924
01:12:32,480 --> 01:12:34,320
的任务是什么，我们的任务是建立最好的

1925
01:12:34,320 --> 01:12:36,400
助听器算法

1926
01:12:36,400 --> 01:12:37,600
，

1927
01:12:37,600 --> 01:12:39,600


1928
01:12:39,600 --> 01:12:41,920
那么会发生

1929
01:12:41,920 --> 01:12:44,159
什么 助听器客户去

1930
01:12:44,159 --> 01:12:46,719
商店购买助听器通常

1931
01:12:46,719 --> 01:12:48,640
很高兴然后出去然后

1932
01:12:48,640 --> 01:12:50,880
两周后坐在餐厅里我

1933
01:12:50,880 --> 01:12:52,400
无法理解

1934
01:12:52,400 --> 01:12:54,960
她的谈话伙伴因为

1935
01:12:54,960 --> 01:12:57,520
有噪音而且这是出乎意料的

1936
01:12:57,520 --> 01:13:00,480
而且她无能为力

1937
01:13:00,480 --> 01:13:02,960
因为 你不能要求助听器客户

1938
01:13:02,960 --> 01:13:05,199


1939
01:13:05,199 --> 01:13:06,560


1940
01:13:06,560 --> 01:13:08,480
摆弄助听器参数，所以如果

1941
01:13:08,480 --> 01:13:09,760
这种情况

1942
01:13:09,760 --> 01:13:11,679
发生几次，

1943
01:13:11,679 --> 01:13:13,760
那么她会扔掉或者她把

1944
01:13:13,760 --> 01:13:16,400
助听器放在抽屉里，这个呃

1945
01:13:16,400 --> 01:13:19,199
事实上，大约 10% 20% 的

1946
01:13:19,199 --> 01:13:20,880
助听器最终都放在抽屉里，它们非常

1947
01:13:20,880 --> 01:13:21,910
昂贵，而且

1948
01:13:21,910 --> 01:13:23,520
[Music]

1949
01:13:23,520 --> 01:13:24,400
20

1950
01:13:24,400 --> 01:13:27,040
最终没有被使用，这是一个非常

1951
01:13:27,040 --> 01:13:28,960
可悲的统计数据，

1952
01:13:28,960 --> 01:13:31,040
所以

1953
01:13:31,040 --> 01:13:32,960
你可以把它转过来，说

1954
01:13:32,960 --> 01:13:35,040
好吧，什么是真正的助听器 设计

1955
01:13:35,040 --> 01:13:36,560
问题 真正的助听器设计

1956
01:13:36,560 --> 01:13:39,280
问题是派人带着任何助听器出去，

1957
01:13:39,280 --> 01:13:41,440
但是当

1958
01:13:41,440 --> 01:13:43,679
她在餐厅里的现场不开心时你会

1959
01:13:43,679 --> 01:13:46,320


1960
01:13:46,320 --> 01:13:48,320
怎么做，我们想要建立一个代理

1961
01:13:48,320 --> 01:13:49,360
，

1962
01:13:49,360 --> 01:13:52,080
然后她只需拍打她的手腕跑道

1963
01:13:52,080 --> 01:13:54,080
我很高兴，现在这个代理需要

1964
01:13:54,080 --> 01:13:55,679
采取行动并为她提供新的

1965
01:13:55,679 --> 01:13:58,239
参数设置，这

1966
01:13:58,239 --> 01:14:00,719
对她来说是最有趣的，并且和和

1967
01:14:00,719 --> 01:14:02,239
以及

1968
01:14:02,239 --> 01:14:04,480
在信息搜索

1969
01:14:04,480 --> 01:14:07,040
和目标驱动的金裂之间的最佳折衷让

1970
01:14:07,040 --> 01:14:08,719
她听得很开心

1971
01:14:08,719 --> 01:14:10,320


1972
01:14:10,320 --> 01:14:12,960
从我的角度来看，现在的设计

1973
01:14:12,960 --> 01:14:16,159
只是建立一个代理，当她不开心时会

1974
01:14:16,159 --> 01:14:18,800
采取行动提出助听器建议

1975
01:14:18,800 --> 01:14:20,800


1976
01:14:20,800 --> 01:14:22,320
，如果她是

1977
01:14:22,320 --> 01:14:24,159
对的，她不开心，然后听到

1978
01:14:24,159 --> 01:14:25,920
混合建议说不，那

1979
01:14:25,920 --> 01:14:28,000
不好 gent 提出了另一个建议

1980
01:14:28,000 --> 01:14:30,159
，没关系，这更好，然后

1981
01:14:30,159 --> 01:14:32,159
我们继续前进，也许一周后

1982
01:14:32,159 --> 01:14:35,600
同样的事件，这种情况不断进行，

1983
01:14:35,600 --> 01:14:38,719
但至少有

1984
01:14:38,719 --> 01:14:41,120
一个程序可以继续前进，

1985
01:14:41,120 --> 01:14:44,000
随着时间的推移不断改进，

1986
01:14:44,000 --> 01:14:45,360
所以这才

1987
01:14:45,360 --> 01:14:48,159
是真正的 设计的事情

1988
01:14:48,159 --> 01:14:52,239
是c2中的现场动作，

1989
01:14:52,239 --> 01:14:53,600
这与

1990
01:14:53,600 --> 01:14:56,000
当前正在发生的事情非常不同，助听器

1991
01:14:56,000 --> 01:14:58,159
工程师坐在办公桌前

1992
01:14:58,159 --> 01:15:01,920
，模型不在环境中，

1993
01:15:01,920 --> 01:15:04,400
所以这是一个范式转变

1994
01:15:04,400 --> 01:15:07,760
和主动推理 代理

1995
01:15:07,760 --> 01:15:09,679
也许可以实现这一点，

1996
01:15:09,679 --> 01:15:10,960


1997
01:15:10,960 --> 01:15:12,640
我真的可以

1998
01:15:12,640 --> 01:15:14,560
为

1999
01:15:14,560 --> 01:15:16,719
信号处理设计之类

2000
01:15:16,719 --> 01:15:18,400


2001
01:15:18,400 --> 01:15:19,920
的东西创建

2002
01:15:19,920 --> 01:15:21,679
一个转折点吗

2003
01:15:21,679 --> 01:15:23,520


2004
01:15:23,520 --> 01:15:25,440


2005
01:15:25,440 --> 01:15:27,040
不仅用于信号处理，

2006
01:15:27,040 --> 01:15:29,120
还用于不同的工程

2007
01:15:29,120 --> 01:15:31,120
学科

2008
01:15:31,120 --> 01:15:32,960
，这就是为什么我认为随着时间的推移，你会

2009
01:15:32,960 --> 01:15:35,280
看到越来越多的人来自不同的领域

2010
01:15:35,280 --> 01:15:37,360


2011
01:15:37,360 --> 01:15:41,040
nt 领域对这个 uh

2012
01:15:41,040 --> 01:15:42,480
主动推理和自由能

2013
01:15:42,480 --> 01:15:43,920
原理

2014
01:15:43,920 --> 01:15:47,360
uh even uh

2015
01:15:47,360 --> 01:15:49,199
non 不是神经科学家对，但

2016
01:15:49,199 --> 01:15:50,840
工程师是的，

2017
01:15:50,840 --> 01:15:54,159
是的，我们希望如此，这真的

2018
01:15:54,159 --> 01:15:56,560
让我想起了务实的转变

2019
01:15:56,560 --> 01:15:58,159
，这有点像

2020
01:15:58,159 --> 01:15:59,920
工程师和哲学家的马蹄铁理论

2021
01:15:59,920 --> 01:16:01,600


2022
01:16:01,600 --> 01:16:04,239
经常

2023
01:16:04,239 --> 01:16:06,080
以不同的方式谈论实用主义不同的社区

2024
01:16:06,080 --> 01:16:07,600
不同的

2025
01:16:07,600 --> 01:16:09,520
工具现在有一种方法可以缩小

2026
01:16:09,520 --> 01:16:12,719
这种差距，或者至少在

2027
01:16:12,719 --> 01:16:14,560
其中绘制出一些关于

2028
01:16:14,560 --> 01:16:16,640


2029
01:16:16,640 --> 01:16:18,880
真正激进主义角色的见解 设计

2030
01:16:18,880 --> 01:16:22,400
科学的预期设计科学与

2031
01:16:22,400 --> 01:16:24,080
接受或离开它的哲学

2032
01:16:24,080 --> 01:16:26,400
或有待开发的工具包

2033
01:16:26,400 --> 01:16:28,480


2034
01:16:28,480 --> 01:16:30,000
可能在使用工具包五年或

2035
01:16:30,000 --> 01:16:31,280
五年哲学之后很有趣，然后你

2036
01:16:31,280 --> 01:16:33,360
对工具包感到好奇，

2037
01:16:33,360 --> 01:16:34,640
所以一个

2038
01:16:34,640 --> 01:16:36,320
问题是

2039
01:16:36,320 --> 01:16:38,480
如何做 这些图解释了

2040
01:16:38,480 --> 01:16:41,280
时间上的深度模型，这些模型是如何

2041
01:16:41,280 --> 01:16:42,800
指定的，

2042
01:16:42,800 --> 01:16:43,920
或者是

2043
01:16:43,920 --> 01:16:46,080
什么使图有什么不同，

2044
01:16:46,080 --> 01:16:48,400
因为 e 它只是在计算

2045
01:16:48,400 --> 01:16:50,000
您提供的示例中要采取的下一步行动，

2046
01:16:50,000 --> 01:16:52,400


2047
01:16:53,120 --> 01:16:55,920
也许伙计们，您可以再次展示您的图表

2048
01:16:55,920 --> 01:16:58,640
如何表示

2049
01:16:58,640 --> 01:17:00,560
未来，以及您如何为其添加时间

2050
01:17:00,560 --> 01:17:02,560
厚度，例如，

2051
01:17:02,560 --> 01:17:05,760
如果您有的话 有一个

2052
01:17:06,320 --> 01:17:07,280
像

2053
01:17:07,280 --> 01:17:10,400
椅子屏幕这样的图表是的，

2054
01:17:12,800 --> 01:17:14,239
如果你有这样的图表，那么

2055
01:17:14,239 --> 01:17:15,600
你如何添加时间厚度，

2056
01:17:15,600 --> 01:17:17,840


2057
01:17:17,920 --> 01:17:20,080
例如，这只是添加

2058
01:17:20,080 --> 01:17:21,120
层，

2059
01:17:21,120 --> 01:17:22,400


2060
01:17:22,400 --> 01:17:25,920
所以这里显示的是一层

2061
01:17:25,920 --> 01:17:27,280
，这一层

2062
01:17:27,280 --> 01:17:28,320
它

2063
01:17:28,320 --> 01:17:30,960
在你知道的某个时钟时间起作用

2064
01:17:30,960 --> 01:17:33,840
观察是离散的，

2065
01:17:33,840 --> 01:17:34,960


2066
01:17:34,960 --> 01:17:36,960
但是您可能在此之上有一个层

2067
01:17:36,960 --> 01:17:38,960
，它以某种方式与下面的这一层相连，该层

2068
01:17:38,960 --> 01:17:40,239


2069
01:17:40,239 --> 01:17:42,080
在更高的时间尺度上起作用，

2070
01:17:42,080 --> 01:17:43,360


2071
01:17:43,360 --> 01:17:46,239
因此它发展得较慢，

2072
01:17:46,239 --> 01:17:48,239
但它调节或影响

2073
01:17:48,239 --> 01:17:49,440


2074
01:17:49,440 --> 01:17:52,000
例如此处的过渡模型

2075
01:17:52,000 --> 01:17:54,480
或观察的参数 在这里建立模型，

2076
01:17:54,480 --> 01:17:56,480
这样您就可以得到一个随时间变化的

2077
01:17:56,480 --> 01:17:58,800
观察模型，该模型

2078
01:17:58,800 --> 01:17:59,679


2079
01:17:59,679 --> 01:18:02,400
受较慢演化层的影响，

2080
01:18:02,400 --> 01:18:04,000
在此之上，您可以获得一个更

2081
01:18:04,000 --> 01:18:05,679
慢演化层，这就是

2082
01:18:05,679 --> 01:18:06,960
这就是

2083
01:18:06,960 --> 01:18:09,440
你可以建立层次结构的方式

2084
01:18:09,440 --> 01:18:10,640


2085
01:18:10,640 --> 01:18:13,120
，实际上

2086
01:18:13,120 --> 01:18:15,760
，我们小组中还有一个 pg 学生 ismael senos，他在这

2087
01:18:15,760 --> 01:18:17,280
方面做了一些非常有趣的工作

2088
01:18:17,280 --> 01:18:19,280
，他研究了你是如何

2089
01:18:19,280 --> 01:18:21,199
制作层次

2090
01:18:21,199 --> 01:18:24,480
高斯滤波器的，嗯

2091
01:18:24,480 --> 01:18:27,199
，你有一个顶部的层次高斯系统

2092
01:18:27,199 --> 01:18:29,679
层影响下面

2093
01:18:29,679 --> 01:18:31,280
层的转换模型的方差，

2094
01:18:31,280 --> 01:18:33,280


2095
01:18:33,280 --> 01:18:34,960


2096
01:18:34,960 --> 01:18:37,360
您可以看到您可以使用它对

2097
01:18:37,360 --> 01:18:40,960
非常自然的信号进行建模，

2098
01:18:40,960 --> 01:18:42,960
因此在自然界中，您

2099
01:18:42,960 --> 01:18:44,640
有随时间变化的信号，其中的

2100
01:18:44,640 --> 01:18:46,400
统计数据随时间变化

2101
01:18:46,400 --> 01:18:48,880
和统计数据 这些模型

2102
01:18:48,880 --> 01:18:50,800
是随时间变化的，

2103
01:18:50,800 --> 01:18:52,880
所以从这个意义上说，分层模型

2104
01:18:52,880 --> 01:18:54,560
对此非常有用，

2105
01:18:54,560 --> 01:18:56,719
当然，这

2106
01:18:56,719 --> 01:18:58,960
就是我们大脑的结构，

2107
01:18:58,960 --> 01:19:00,800
所以你再次

2108
01:19:00,800 --> 01:19:02,000
从大自然中获得灵感，

2109
01:19:02,000 --> 01:19:04,080
嗯，关于如何

2110
01:19:04,080 --> 01:19:07,360
构建我们的模型 至少在理论上尝试用矢量图构建

2111
01:19:07,360 --> 01:19:08,480
嗯

2112
01:19:08,480 --> 01:19:10,560


2113
01:19:10,560 --> 01:19:12,239
它们应该很

2114
01:19:12,239 --> 01:19:13,280
容易，

2115
01:19:13,280 --> 01:19:14,800
因为你可以连接它们你

2116
01:19:14,800 --> 01:19:17,120
可以连接层 r 最重要的是，

2117
01:19:17,120 --> 01:19:20,000
看看它的行为方式

2118
01:19:20,000 --> 01:19:21,760
，最终你的模型的复杂性

2119
01:19:21,760 --> 01:19:23,760
会变得非常高，你会

2120
01:19:23,760 --> 01:19:26,159
自动受到惩罚，所以

2121
01:19:26,159 --> 01:19:28,320


2122
01:19:28,320 --> 01:19:31,120
会给你的数据一个截止点，这将是

2123
01:19:31,120 --> 01:19:32,960
最佳的层数 你

2124
01:19:32,960 --> 01:19:34,400
需要为了解释你观察到的所有

2125
01:19:34,400 --> 01:19:35,679
变体

2126
01:19:35,679 --> 01:19:38,480


2127
01:19:39,520 --> 01:19:42,560
所以这就是我们如何看待

2128
01:19:42,560 --> 01:19:44,800
时间厚度

2129
01:19:44,800 --> 01:19:46,000
和

2130
01:19:46,000 --> 01:19:48,239
时间依赖性以及

2131
01:19:48,239 --> 01:19:50,719
像这样的动态模型

2132
01:19:50,719 --> 01:19:54,159
然后我可以分享我的屏幕也可以

2133
01:19:54,159 --> 01:19:56,719
肯定可以让我们看看

2134
01:19:56,719 --> 01:19:59,760
因为这个嗯 太棒了，

2135
01:19:59,760 --> 01:20:02,080
是的，

2136
01:20:02,400 --> 01:20:05,280
这是几年前一篇论文中的图表，

2137
01:20:05,280 --> 01:20:08,639
呃，在前沿，

2138
01:20:08,639 --> 01:20:11,520
嗯，它被称为我认为，呃，

2139
01:20:11,520 --> 01:20:13,440
深度时间模型检查因子

2140
01:20:13,440 --> 01:20:14,880
图或其他东西

2141
01:20:14,880 --> 01:20:17,360
，在这里你看到一个三层系统，我的

2142
01:20:17,360 --> 01:20:19,679
意思是现在不要打扰细节

2143
01:20:19,679 --> 01:20:21,840
但是在这里 你在顶层看到

2144
01:20:21,840 --> 01:20:24,800
基本上只有一个部分一个

2145
01:20:24,800 --> 01:20:26,400
时间步

2146
01:20:26,400 --> 01:20:28,639
，在顶层的那个时间步中，

2147
01:20:28,639 --> 01:20:29,600
你在中间件有

2148
01:20:29,600 --> 01:20:30,639
两个

2149
01:20:30,639 --> 01:20:33,520
观察或两个步骤

2150
01:20:33,520 --> 01:20:34,800


2151
01:20:34,800 --> 01:20:37,440
我需要嗯，是的，

2152
01:20:37,440 --> 01:20:40,159
我没有 不知道你能不能看到我的呃，

2153
01:20:40,159 --> 01:20:43,040
好吧，然后再说一次，

2154
01:20:43,040 --> 01:20:44,880
假设第三层，每当中间

2155
01:20:44,880 --> 01:20:47,679
层提示迈出一步时，我们在这里有两个

2156
01:20:47,679 --> 01:20:50,400
步骤，所以每一层都有更精细的

2157
01:20:50,400 --> 01:20:52,560


2158
01:20:52,560 --> 01:20:55,440
粒度，所以我们可以构建

2159
01:20:55,440 --> 01:20:57,600
分层的

2160
01:20:57,600 --> 01:21:01,280
呃模型真的和呃，所以我们也在这样做

2161
01:21:01,280 --> 01:21:04,480
，呃，我的意思也是，如果

2162
01:21:04,480 --> 01:21:05,520


2163
01:21:05,520 --> 01:21:07,679
你看我们网站上的一些论文，

2164
01:21:07,679 --> 01:21:10,080
你会发现很多婴儿都使用

2165
01:21:10,080 --> 01:21:12,400
来自 chris matisse 的分层高斯滤波器

2166
01:21:12,400 --> 01:21:15,120
我们' 已经实现

2167
01:21:15,120 --> 01:21:16,239
了，

2168
01:21:16,239 --> 01:21:19,040
但是

2169
01:21:19,040 --> 01:21:20,719
我的意思是你也可以这样做以获得积极的

2170
01:21:20,719 --> 01:21:23,280
影响，比如呃，看起来

2171
01:21:23,280 --> 01:21:24,159


2172
01:21:24,159 --> 01:21:26,960
像这样，呃，

2173
01:21:26,960 --> 01:21:30,000
thomas pyre 在他的一些论文中也有这样的图表

2174
01:21:30,000 --> 01:21:32,960


2175
01:21:33,760 --> 01:21:35,840
非常有趣，我们看到很多

2176
01:21:35,840 --> 01:21:38,239
相同的 像 g

2177
01:21:38,239 --> 01:21:39,440
d b

2178
01:21:39,440 --> 01:21:41,040
这样的变量，我们可以它

2179
01:21:41,040 --> 01:21:43,520
是主动推理的一种不同表示，所以

2180
01:21:43,520 --> 01:21:44,960
是的，

2181
01:21:44,960 --> 01:21:46,800
这也可以

2182
01:21:46,800 --> 01:21:49,520
追溯到早期的前沿论文，什么

2183
01:21:49,520 --> 01:21:52,000
是大的等价物

2184
01:21:52,000 --> 01:21:55,679
或类似

2185
01:21:55,679 --> 01:21:57,440
从

2186
01:21:57,440 --> 01:21:59,120
福尼因子的密封映射 图表，

2187
01:21:59,120 --> 01:22:01,040
因为可能有一些广泛

2188
01:22:01,040 --> 01:22:03,120
的应用

2189
01:22:03,120 --> 01:22:05,520
领域几乎可以热交换

2190
01:22:05,520 --> 01:22:07,760
这个底层，

2191
01:22:07,760 --> 01:22:09,679
所以

2192
01:22:09,679 --> 01:22:12,480
一般来说贝叶斯图与

2193
01:22:12,480 --> 01:22:14,480
因子图与

2194
01:22:14,480 --> 01:22:17,599
该级别的其他主题的等价性

2195
01:22:21,120 --> 01:22:23,520
我认为是外国风格的矢量图

2196
01:22:23,520 --> 01:22:26,320
或 二分图或北京网络

2197
01:22:26,320 --> 01:22:27,920
它们并没有真正的不同

2198
01:22:27,920 --> 01:22:29,760
它们可以被使用，因为

2199
01:22:29,760 --> 01:22:31,840
它们只是

2200
01:22:31,840 --> 01:22:34,159
分解模型的表示，

2201
01:22:34,159 --> 01:22:37,120
并且您表示的方式

2202
01:22:37,120 --> 01:22:39,520
可能会影响您

2203
01:22:39,520 --> 01:22:41,440
对这些

2204
01:22:41,440 --> 01:22:43,280
模型的看法，例如，如果您选择 一个 4-install

2205
01:22:43,280 --> 01:22:45,199
有效的图形表示，它非常

2206
01:22:45,199 --> 01:22:47,120
适合信号处理，因为

2207
01:22:47,120 --> 01:22:49,120
您可以将这些消息视为

2208
01:22:49,120 --> 01:22:51,520
流过图形的信号，

2209
01:22:51,520 --> 01:22:53,840
因此对于我们工程师来说，

2210
01:22:53,840 --> 01:22:57,679
这是贝叶斯网络中非常直观的表示

2211
01:22:57,679 --> 01:23:00,880
，它更像

2212
01:23:00,880 --> 01:23:02,880
是模型表示本身

2213
01:23:02,880 --> 01:23:05,199
从这个意义上说更紧凑，你只有

2214
01:23:05,199 --> 01:23:06,719
可变的音符，你会看到它们

2215
01:23:06,719 --> 01:23:08,320
是如何相关的，所以它给你一个很好的想法

2216
01:23:08,320 --> 01:23:10,239
模型结构，

2217
01:23:10,239 --> 01:23:13,120
因此

2218
01:23:13,120 --> 01:23:16,000
快速浏览这样的模型会非常好

2219
01:23:16,000 --> 01:23:17,120
，然后你就有了一个例如

2220
01:23:17,120 --> 01:23:19,120
二分图，它还显示了

2221
01:23:19,120 --> 01:23:21,120
变量之间的关系，作为介于 um 之间的

2222
01:23:21,120 --> 01:23:22,960
另一种

2223
01:23:22,960 --> 01:23:25,520
矢量节点

2224
01:23:25,520 --> 01:23:27,440
，它会给你一个 更

2225
01:23:27,440 --> 01:23:29,280
详细地说明这些是如何连接的，

2226
01:23:29,280 --> 01:23:31,120
并让您有空间很好地讨论

2227
01:23:31,120 --> 01:23:32,719
这些变量之间的关系

2228
01:23:32,719 --> 01:23:35,280


2229
01:23:35,280 --> 01:23:39,440
，所以最后它们是等价的，

2230
01:23:39,520 --> 01:23:41,760
您可以采用一个模型并

2231
01:23:41,760 --> 01:23:45,760
以三种不同的方式表示它，也许更多，

2232
01:23:46,159 --> 01:23:48,560
但我认为 它确实会影响

2233
01:23:48,560 --> 01:23:49,920
你的思维方式

2234
01:23:49,920 --> 01:23:52,320
或你对这些模型的看法，所以

2235
01:23:52,320 --> 01:23:54,559
嗯

2236
01:23:55,840 --> 01:23:56,960
，

2237
01:23:56,960 --> 01:23:58,560
这通常会在写

2238
01:23:58,560 --> 01:24:00,239
论文时出现

2239
01:24:00,239 --> 01:24:01,679
，然后你必须想好什么

2240
01:24:01,679 --> 01:24:03,520
是我的想法的最佳代表

2241
01:24:03,520 --> 01:24:04,639


2242
01:24:04,639 --> 01:24:06,239
有时它是关于预算图

2243
01:24:06,239 --> 01:24:07,520
有时它是一个 视觉网络

2244
01:24:07,520 --> 01:24:10,159
有时是为了安装照片，

2245
01:24:10,159 --> 01:24:11,120


2246
01:24:11,120 --> 01:24:14,800
嗯，这取决于你的故事，是的，

2247
01:24:14,800 --> 01:24:16,320
希望

2248
01:24:16,320 --> 01:24:18,480
我能找到，尽管我的意思是

2249
01:24:18,480 --> 01:24:21,120
当我们考虑系统和整体时，我的意思

2250
01:24:21,120 --> 01:24:23,040
是 等式如果你在

2251
01:24:23,040 --> 01:24:24,159
论文中读到

2252
01:24:24,159 --> 01:24:26,880
或者如果你把它写下来，嗯，

2253
01:24:26,880 --> 01:24:28,880
如果你画给我，它会给我更多的

2254
01:24:28,880 --> 01:24:31,280
洞察力，如果我画出图表，它会给出更多的洞察力，

2255
01:24:31,280 --> 01:24:32,480
并且

2256
01:24:32,480 --> 01:24:33,760
有一个 x

2257
01:24:33,760 --> 01:24:36,000


2258
01:24:36,000 --> 01:24:37,920


2259
01:24:37,920 --> 01:24:40,480
，图表之间必须有一个精确的对应关系 和方程，

2260
01:24:40,480 --> 01:24:42,960
如果你画图然后

2261
01:24:42,960 --> 01:24:45,040
写下方程，没有

2262
01:24:45,040 --> 01:24:47,360
对应的x轴，所以你从中学习，

2263
01:24:47,360 --> 01:24:50,000
你基本上你知道

2264
01:24:50,000 --> 01:24:52,000
必须有一个精确的对应关系，

2265
01:24:52,000 --> 01:24:53,600
基本上你经常发现你

2266
01:24:53,600 --> 01:24:56,239
您的方程式或图表中有错误，

2267
01:24:56,239 --> 01:24:57,920


2268
01:24:57,920 --> 01:25:00,000
但我认为

2269
01:25:00,000 --> 01:25:03,600
最终目标是最终目标

2270
01:25:03,600 --> 01:25:07,120
是使工具箱成为工具箱，

2271
01:25:07,120 --> 01:25:09,199
让我们说让社区设计

2272
01:25:09,199 --> 01:25:12,639
自己的积极影响力代理以及

2273
01:25:12,639 --> 01:25:13,679
我

2274
01:25:13,679 --> 01:25:15,520
所设想的 像simulink这样的东西

2275
01:25:15,520 --> 01:25:18,000
我不确定或labview我

2276
01:25:18,000 --> 01:25:20,080
不确定人们是否熟悉

2277
01:25:20,080 --> 01:25:21,280
但是嗯

2278
01:25:21,280 --> 01:25:23,120
这些是图形模型你想要

2279
01:25:23,120 --> 01:25:26,080
实际上也以图形方式定义它们

2280
01:25:26,080 --> 01:25:27,920
并且你想要一个带有注释的调色板

2281
01:25:27,920 --> 01:25:29,679
并且只是

2282
01:25:29,679 --> 01:25:32,320
dra  w你的图表，说这是我的模型

2283
01:25:32,320 --> 01:25:34,639
，现在开始运行

2284
01:25:34,639 --> 01:25:36,159
你不想担心

2285
01:25:36,159 --> 01:25:37,840
推理在

2286
01:25:37,840 --> 01:25:39,600
根依赖传递应该由

2287
01:25:39,600 --> 01:25:40,880


2288
01:25:40,880 --> 01:25:43,199
工具箱的设计者完成，但你

2289
01:25:43,199 --> 01:25:46,080
应该只考虑你的

2290
01:25:46,080 --> 01:25:49,360
图形结构 这就是呃

2291
01:25:49,360 --> 01:25:52,880
和这个，然后用鼠标将它连接

2292
01:25:52,880 --> 01:25:54,880
到

2293
01:25:54,880 --> 01:25:57,440
计算机的麦克风或相机上

2294
01:25:57,440 --> 01:25:59,920
，也许

2295
01:25:59,920 --> 01:26:01,760
你知道

2296
01:26:01,760 --> 01:26:05,280
机器人工具箱中还有连接器，然后

2297
01:26:05,280 --> 01:26:07,600
它应该就可以了

2298
01:26:07,600 --> 01:26:09,199
，这将是 bob ross 图表

2299
01:26:09,199 --> 01:26:11,519


2300
01:26:11,920 --> 01:26:13,520
就是你想要设计的方式我认为是

2301
01:26:13,520 --> 01:26:15,280
对

2302
01:26:15,280 --> 01:26:17,840


2303
01:26:17,840 --> 01:26:19,679


2304
01:26:19,679 --> 01:26:21,600


2305
01:26:21,600 --> 01:26:24,239


2306
01:26:24,480 --> 01:26:26,719


2307
01:26:26,719 --> 01:26:29,199
的 等式，然后

2308
01:26:29,199 --> 01:26:31,520
可能从笔和纸到

2309
01:26:31,520 --> 01:26:33,280
编程语言再到图形

2310
01:26:33,280 --> 01:26:35,440
表示，然后进行

2311
01:26:35,440 --> 01:26:37,120
交叉检查，就像

2312
01:26:37,120 --> 01:26:38,800
您反向翻译语言

2313
01:26:38,800 --> 01:26:41,120
时一样 锁定两个单词

2314
01:26:41,120 --> 01:26:42,800
相互映射的位置，你知道

2315
01:26:42,800 --> 01:26:44,239
你已经制作了一张地图，但是如果你处于这个

2316
01:26:44,239 --> 01:26:46,719
无限循环中，你就会迷失在

2317
01:26:46,719 --> 01:26:49,760
单词空间中，所以当你

2318
01:26:49,760 --> 01:26:52,639
像这样跨部门移动时，或者 跨模态

2319
01:26:52,639 --> 01:26:53,520


2320
01:26:53,520 --> 01:26:55,440
分析，计算机上的模拟

2321
01:26:55,440 --> 01:26:57,840
，然后是图形

2322
01:26:57,840 --> 01:26:59,679
，它将动作

2323
01:26:59,679 --> 01:27:02,159
嵌入到其他可能被视为

2324
01:27:02,159 --> 01:27:03,440
知识

2325
01:27:03,440 --> 01:27:05,840
产品的事物中，推理的产物，然后

2326
01:27:05,840 --> 01:27:07,520
是最终的动作

2327
01:27:07,520 --> 01:27:10,239
，这是一个类似的谬误，以

2328
01:27:10,239 --> 01:27:12,719
训练动态过程 快照

2329
01:27:12,719 --> 01:27:13,920
然后期望它会

2330
01:27:13,920 --> 01:27:15,840
实时工作，所以就像将

2331
01:27:15,840 --> 01:27:17,760
实时流程

2332
01:27:17,760 --> 01:27:20,159
嵌入到知识的生产中，

2333
01:27:20,159 --> 01:27:24,000
是的，是的，我们

2334
01:27:24,000 --> 01:27:25,679


2335
01:27:25,679 --> 01:27:28,080


2336
01:27:28,080 --> 01:27:30,800
很重要 是的，是的，

2337
01:27:30,800 --> 01:27:34,400
是的，一个普遍的问题只是

2338
01:27:34,400 --> 01:27:36,239
关于分解，

2339
01:27:36,239 --> 01:27:37,679
所以

2340
01:27:37,679 --> 01:27:40,000


2341
01:27:40,000 --> 01:27:41,920
我们进行分解的方式是从我们的

2342
01:27:41,920 --> 01:27:44,880
直觉开始，寻找残差或

2343
01:27:44,880 --> 01:27:47,520
如何分解模型的所有方法

2344
01:27:47,520 --> 01:27:51,600
我们找到一个

2345
01:27:53,440 --> 01:27:55,440
可行的吗是的有两种分解

2346
01:27:55,440 --> 01:27:57,440
有一个分解假设

2347
01:27:57,440 --> 01:27:59,440
在生成

2348
01:27:59,440 --> 01:28:02,560
模型中是我们绘制的图表

2349
01:28:02,560 --> 01:28:06,639
所以我的意思是让我们说大多数人

2350
01:28:06,639 --> 01:28:10,719
呃或最常见的模型是这些

2351
01:28:10,719 --> 01:28:13,440


2352
01:28:13,440 --> 01:28:16,239
这些马尔可夫模型对

2353
01:28:16,239 --> 01:28:18,880
你保留一个当前状态，

2354
01:28:18,880 --> 01:28:20,639
总结

2355
01:28:20,639 --> 01:28:22,239
过去

2356
01:28:22,239 --> 01:28:25,120
发生的

2357
01:28:25,120 --> 01:28:27,440


2358
01:28:27,440 --> 01:28:29,760


2359
01:28:29,760 --> 01:28:30,960


2360
01:28:30,960 --> 01:28:33,440
一切 过去，您只记得您的

2361
01:28:33,440 --> 01:28:34,560
状态

2362
01:28:34,560 --> 01:28:36,159
，然后您确实进行了新的

2363
01:28:36,159 --> 01:28:39,040
观察，您将信息结合起来，

2364
01:28:39,040 --> 01:28:40,560
形成了新的状态

2365
01:28:40,560 --> 01:28:42,639
，依此类推，因此隐藏的马尔可夫

2366
01:28:42,639 --> 01:28:44,760
模型

2367
01:28:44,760 --> 01:28:47,600
palmdps 所有这些模型都具有相同的

2368
01:28:47,600 --> 01:28:49,199
结构，这些这些

2369
01:28:49,199 --> 01:28:51,360
微观结构，因此用于

2370
01:28:51,360 --> 01:28:53,440
生成 这些动态

2371
01:28:53,440 --> 01:28:54,560
系统的模型

2372
01:28:54,560 --> 01:28:56,400
然后还有第二个问题，如果我们

2373
01:28:56,400 --> 01:28:58,719
现在进行推理，

2374
01:28:58,719 --> 01:29:02,400
嗯，嗯，是的，那么通常就是

2375
01:29:02,400 --> 01:29:04,880
我们所说的平均场屁股

2376
01:29:04,880 --> 01:29:07,040
选择变分后验，但

2377
01:29:07,040 --> 01:29:08,639


2378
01:29:08,639 --> 01:29:11,920
在结构化的绿色字段上也有变体，

2379
01:29:11,920 --> 01:29:14,239
所以你

2380
01:29:14,239 --> 01:29:17,520
仍然可以决定是否希望你的后

2381
01:29:17,520 --> 01:29:19,920
验更加结构化，或者说

2382
01:29:19,920 --> 01:29:22,880
比生成模型更加分解，

2383
01:29:22,880 --> 01:29:24,480


2384
01:29:24,480 --> 01:29:27,040
但最后是的，

2385
01:29:27,040 --> 01:29:29,120
它是 一个提案，

2386
01:29:29,120 --> 01:29:30,159
呃，

2387
01:29:30,159 --> 01:29:33,120
你就运行它，如果你有另一个

2388
01:29:33,120 --> 01:29:35,040
提案，你就运行它，

2389
01:29:35,040 --> 01:29:38,000
自由能最低

2390
01:29:38,000 --> 01:29:40,800
的那个获胜，嗯，没错，挑战

2391
01:29:40,800 --> 01:29:44,000
是自动化这个过程，

2392
01:29:44,000 --> 01:29:45,840
从

2393
01:29:45,840 --> 01:29:47,600
假设更差的结构到

2394
01:29:47,600 --> 01:29:49,920
更好的结构 结构

2395
01:29:49,920 --> 01:29:52,159
只是没有

2396
01:29:52,159 --> 01:29:55,840
通过实时消息传递来最小化而不

2397
01:29:55,840 --> 01:29:57,600
停止整个过程进行

2398
01:29:57,600 --> 01:29:59,040
分析

2399
01:29:59,040 --> 01:30:01,520
正确它应该继续向右移动

2400
01:30:01,520 --> 01:30:04,080
它应该只是结构适应

2401
01:30:04,080 --> 01:30:06,239
应该像状态估计它只是

2402
01:30:06,239 --> 01:30:08,560
随着时间的推移不断移动没有

2403
01:30:08,560 --> 01:30:10,719
重置

2404
01:30:10,719 --> 01:30:12,719
也许有 有点

2405
01:30:12,719 --> 01:30:15,120


2406
01:30:15,360 --> 01:30:19,120
像做梦的舞台，

2407
01:30:19,120 --> 01:30:22,480
但主要时间在继续

2408
01:30:22,480 --> 01:30:24,239
，这就是挑战，我们不

2409
01:30:24,239 --> 01:30:26,560
知道在 我们的工厂课程，但是是的

2410
01:30:26,560 --> 01:30:27,840
，

2411
01:30:27,840 --> 01:30:28,719
我的意思是

2412
01:30:28,719 --> 01:30:31,280
我们有一个高清学生，他目前

2413
01:30:31,280 --> 01:30:32,840
正在研究这个问题，

2414
01:30:32,840 --> 01:30:36,560
是的，就像作为一名工程师一样

2415
01:30:36,560 --> 01:30:38,320


2416
01:30:38,320 --> 01:30:40,400


2417
01:30:40,400 --> 01:30:42,560
关于

2418
01:30:42,560 --> 01:30:44,880
你的生成模型的分解，

2419
01:30:44,880 --> 01:30:47,040
你认为呃每个因素

2420
01:30:47,040 --> 01:30:49,440
都代表一个先验分布或

2421
01:30:49,440 --> 01:30:50,960
条件分布，这就是

2422
01:30:50,960 --> 01:30:53,440
你如何建立你的模型

2423
01:30:53,440 --> 01:30:55,040
，你从哪里开始

2424
01:30:55,040 --> 01:30:57,520
，它从你

2425
01:30:57,520 --> 01:31:01,600
相信世界如何产生

2426
01:31:01,600 --> 01:31:03,520
这种意义上的观察开始 你想想

2427
01:31:03,520 --> 01:31:05,760


2428
01:31:05,760 --> 01:31:07,760
环境的因果结构是什么，你

2429
01:31:07,760 --> 01:31:10,159
可能对物理学是如何工作的，

2430
01:31:10,159 --> 01:31:13,040
或者

2431
01:31:13,040 --> 01:31:15,760
你的环境中的状态如何转变，

2432
01:31:15,760 --> 01:31:17,280
或者至少你如何

2433
01:31:17,280 --> 01:31:19,040
相信这种转变，这就是你开始的地方

2434
01:31:19,040 --> 01:31:20,080


2435
01:31:20,080 --> 01:31:22,159
，你认为很好

2436
01:31:22,159 --> 01:31:24,960
也许让我们尝试一个非常粗略的音符

2437
01:31:24,960 --> 01:31:27,120
，例如在我的演讲中减去一个，让我们

2438
01:31:27,120 --> 01:31:28,719
在这里尝试一下，因为我真的不

2439
01:31:28,719 --> 01:31:30,400
知道我想在那里放什么，但我没有

2440
01:31:30,400 --> 01:31:33,440
o 放点东西，让我们尝试一下

2441
01:31:33,440 --> 01:31:35,840
，看看它是如何工作的，它模拟

2442
01:31:35,840 --> 01:31:39,199
了我

2443
01:31:39,520 --> 01:31:42,639
相信世界是如何运作的，这就是你开始的方式

2444
01:31:42,639 --> 01:31:44,639
，然后你开始好好思考我

2445
01:31:44,639 --> 01:31:46,639
实际上对它了解得更多我对它的方式

2446
01:31:46,639 --> 01:31:48,960
不满意 模型

2447
01:31:48,960 --> 01:31:51,760
提出了这个模型是如何工作的，嗯，我

2448
01:31:51,760 --> 01:31:55,120
可以改变这个减一，例如

2449
01:31:55,120 --> 01:31:57,280
用一些更

2450
01:31:57,280 --> 01:31:59,280
复杂的东西，因为我知道物理学，我

2451
01:31:59,280 --> 01:32:00,320
知道

2452
01:32:00,320 --> 01:32:01,679
这些，嗯

2453
01:32:01,679 --> 01:32:03,920
，温度如何与距离

2454
01:32:03,920 --> 01:32:06,960
相结合，我可以在

2455
01:32:06,960 --> 01:32:08,560
um 中构建它 这就是你提出第二个

2456
01:32:08,560 --> 01:32:09,920
提案的方式

2457
01:32:09,920 --> 01:32:12,560
，它总是受到

2458
01:32:12,560 --> 01:32:14,320
你如何相信

2459
01:32:14,320 --> 01:32:17,600
世界的因果结构

2460
01:32:17,600 --> 01:32:19,440


2461
01:32:19,440 --> 01:32:21,040


2462
01:32:21,040 --> 01:32:22,560


2463
01:32:22,560 --> 01:32:25,280
的启发 你的

2464
01:32:25,280 --> 01:32:27,040
环境

2465
01:32:27,040 --> 01:32:28,239
，

2466
01:32:28,239 --> 01:32:30,480
好吧，如果你真的很优秀，

2467
01:32:30,480 --> 01:32:32,320
如果你有一个优秀的模型，那么你

2468
01:32:32,320 --> 01:32:34,480
可以找到一些

2469
01:32:34,480 --> 01:32:35,920
在最先进的基础上改进的东西，

2470
01:32:35,920 --> 01:32:39,600
因为你总是可以改进，

2471
01:32:39,600 --> 01:32:41,120
只要找到一些东西 ng 在这个意义上给你一个

2472
01:32:41,120 --> 01:32:42,880
更低的自由能或更好的模型

2473
01:32:42,880 --> 01:32:44,960
性能

2474
01:32:44,960 --> 01:32:46,400
，你可以继续调整和

2475
01:32:46,400 --> 01:32:47,679
调整

2476
01:32:47,679 --> 01:32:48,800


2477
01:32:48,800 --> 01:32:50,800
这些模型和这些分解

2478
01:32:50,800 --> 01:32:51,760
和

2479
01:32:51,760 --> 01:32:54,960
类似的东西，

2480
01:32:56,880 --> 01:32:58,000
是的，

2481
01:32:58,000 --> 01:32:59,360


2482
01:32:59,360 --> 01:33:00,639


2483
01:33:00,639 --> 01:33:03,440
已经描述了自由能最小化，或者只是作为

2484
01:33:03,440 --> 01:33:05,280
对不同模型进行排名的一种方式 作为

2485
01:33:05,280 --> 01:33:06,880
在这些多个不同方面的必要条件，

2486
01:33:06,880 --> 01:33:09,840
我们如何知道

2487
01:33:09,840 --> 01:33:11,920
自由能最小化正在使

2488
01:33:11,920 --> 01:33:13,199
策略

2489
01:33:13,199 --> 01:33:14,480


2490
01:33:14,480 --> 01:33:16,880
具有弹性，是否有

2491
01:33:16,880 --> 01:33:18,800
一种类似于局部

2492
01:33:18,800 --> 01:33:20,639
优化的方法被困

2493
01:33:20,639 --> 01:33:22,560
在更大的优化空间

2494
01:33:22,560 --> 01:33:24,400
中的某个地方 自由

2495
01:33:24,400 --> 01:33:26,639
能最小化的途径，

2496
01:33:26,639 --> 01:33:28,560
使系统就像崩溃

2497
01:33:28,560 --> 01:33:29,920
一样，我们会更快地到达那里让我们

2498
01:33:29,920 --> 01:33:31,760
加速，然后系统会

2499
01:33:31,760 --> 01:33:32,880
出现

2500
01:33:32,880 --> 01:33:35,120
某种一次性故障

2501
01:33:35,120 --> 01:33:38,000
我只是想知道一个指标怎么能

2502
01:33:38,000 --> 01:33:40,639
是一个你知道的数字 并且

2503
01:33:40,639 --> 01:33:43,120
可以排序它如何评估这种

2504
01:33:43,120 --> 01:33:44,639
完全不同的

2505
01:33:44,639 --> 01:33:48,639
国际象棋策略或驱动

2506
01:33:48,840 --> 01:33:50,639
方法最后它只是

2507
01:33:50,639 --> 01:33:52,719
概率论和 概率

2508
01:33:52,719 --> 01:33:55,360
也只是一个数字

2509
01:33:55,360 --> 01:33:57,760
，它的能量

2510
01:33:57,760 --> 01:33:59,760
类型近似于你的证据，这是

2511
01:33:59,760 --> 01:34:01,760
根据你

2512
01:34:01,760 --> 01:34:04,800
观察数据的模型的概率，所以如果你制作的

2513
01:34:04,800 --> 01:34:07,920
模型可以为你提供最好的证据，

2514
01:34:07,920 --> 01:34:10,239
那么这对你来说是一个很好的解释

2515
01:34:10,239 --> 01:34:12,480
数据，

2516
01:34:12,480 --> 01:34:15,040
所以最后只是

2517
01:34:15,040 --> 01:34:16,639
你尝试做

2518
01:34:16,639 --> 01:34:19,600
近似概率论

2519
01:34:19,600 --> 01:34:20,639


2520
01:34:20,639 --> 01:34:22,080
，然后自由

2521
01:34:22,080 --> 01:34:25,360
能被绑定到你的证据上，

2522
01:34:25,360 --> 01:34:27,120
它还考虑了

2523
01:34:27,120 --> 01:34:28,960
这个后发散项，它

2524
01:34:28,960 --> 01:34:29,920


2525
01:34:29,920 --> 01:34:32,320
表示你为近似贝叶斯推理付出的代价，

2526
01:34:32,320 --> 01:34:35,120


2527
01:34:35,120 --> 01:34:37,600
所以它有 它有两个部分，它有

2528
01:34:37,600 --> 01:34:40,320
嗯模型证据部分

2529
01:34:40,320 --> 01:34:43,119
，它有后发散部分

2530
01:34:43,119 --> 01:34:47,119
，两者都发挥作用一个说好的，嗯，

2531
01:34:47,119 --> 01:34:48,400
这

2532
01:34:48,400 --> 01:34:51,040
是我的解决方案的质量，它是

2533
01:34:51,040 --> 01:34:52,320


2534
01:34:52,320 --> 01:34:53,040


2535
01:34:53,040 --> 01:34:54,960
你的模型解释你观察到的数据的程度，

2536
01:34:54,960 --> 01:34:57,040
你可以得到 你可以得到一个数字

2537
01:34:57,040 --> 01:34:59,840
来表示惊喜或负

2538
01:34:59,840 --> 01:35:02,239
对数模态证据

2539
01:35:02,239 --> 01:35:03,600
，你有立体发散的另一部分

2540
01:35:03,600 --> 01:35:05,040
，这

2541
01:35:05,040 --> 01:35:07,040
很好，这就是价格和信息

2542
01:35:07,040 --> 01:35:08,800
n 你为这个近似值付费，

2543
01:35:08,800 --> 01:35:11,119
你也可以在上面加上一个

2544
01:35:11,119 --> 01:35:12,239
数字，

2545
01:35:12,239 --> 01:35:13,840
它只是一个你评估的混乱版本，

2546
01:35:13,840 --> 01:35:15,600


2547
01:35:15,600 --> 01:35:17,920
然后你把这两个相加，你

2548
01:35:17,920 --> 01:35:20,239
得到一个数字，

2549
01:35:20,239 --> 01:35:22,559


2550
01:35:22,880 --> 01:35:24,880
嗯，所以问题是一个数字如何

2551
01:35:24,880 --> 01:35:26,639


2552
01:35:26,639 --> 01:35:29,199
代表

2553
01:35:29,199 --> 01:35:31,840
一切就质量而言，

2554
01:35:31,840 --> 01:35:33,520
您可能关心的

2555
01:35:33,520 --> 01:35:36,080
事情与您的模型预测

2556
01:35:36,080 --> 01:35:39,600
或评估观察结果的能力不同

2557
01:35:39,600 --> 01:35:42,480
，然后如果您关心其他事情，

2558
01:35:42,480 --> 01:35:43,440


2559
01:35:43,440 --> 01:35:45,440
那么

2560
01:35:45,440 --> 01:35:47,280
是的，那么您可能会使用不同的

2561
01:35:47,280 --> 01:35:48,400
数字，

2562
01:35:48,400 --> 01:35:52,800
但是在我们的意义上是 我们

2563
01:35:52,800 --> 01:35:54,000
在我们的工作中

2564
01:35:54,000 --> 01:35:56,400
是的，我们有点

2565
01:35:56,400 --> 01:35:57,440
呃，

2566
01:35:57,440 --> 01:35:59,199
我们想要这种贝叶斯

2567
01:35:59,199 --> 01:36:00,400
质量衡量标准

2568
01:36:00,400 --> 01:36:01,199
是的，

2569
01:36:01,199 --> 01:36:02,400
我不知道这是否真的回答了你的

2570
01:36:02,400 --> 01:36:04,480
问题，但它是它仍然是一个很好的

2571
01:36:04,480 --> 01:36:06,159
问题它是嗯

2572
01:36:06,159 --> 01:36:08,239
它有点是 自由能或

2573
01:36:08,239 --> 01:36:10,400
你得到的那个数字足够

2574
01:36:10,400 --> 01:36:11,360
正确

2575
01:36:11,360 --> 01:36:13,920
，这就是这背后的原因

2576
01:36:13,920 --> 01:36:16,159
，概率论说是的，但如果

2577
01:36:16,159 --> 01:36:17,600
你在实践中应用它，那么你

2578
01:36:17,600 --> 01:36:19,520
可能关心其他你关心

2579
01:36:19,520 --> 01:36:21,840
的事情 任何人在你知道多少错误之前生存下来，

2580
01:36:21,840 --> 01:36:23,520
你知道

2581
01:36:23,520 --> 01:36:27,199
你有多少错误，你

2582
01:36:27,199 --> 01:36:29,840
从某事中获利，如果你

2583
01:36:29,840 --> 01:36:31,600
关心这一点，那么你应该把

2584
01:36:31,600 --> 01:36:33,520
它作为一个绩效指标，

2585
01:36:33,520 --> 01:36:36,880
我认为是对的，我的意思是，

2586
01:36:36,880 --> 01:36:39,360
嗯，能量当然有

2587
01:36:39,360 --> 01:36:42,639
在

2588
01:36:42,639 --> 01:36:45,920
复杂性减去准确性

2589
01:36:45,920 --> 01:36:48,880
和和惊喜减去 uh

2590
01:36:48,880 --> 01:36:51,520
减去 kl 散度

2591
01:36:51,520 --> 01:36:54,239
um 中有很多分解但是

2592
01:36:54,239 --> 01:36:54,960


2593
01:36:54,960 --> 01:36:56,560
我不确定我是否正确解释了这个问题

2594
01:36:56,560 --> 01:36:58,320
但是如果你说你

2595
01:36:58,320 --> 01:37:00,560
怎么知道它

2596
01:37:00,560 --> 01:37:02,880
在实践中做得很好 在现场，

2597
01:37:02,880 --> 01:37:05,679
你不正确，

2598
01:37:05,679 --> 01:37:07,040


2599
01:37:07,040 --> 01:37:10,320
嗯，

2600
01:37:10,320 --> 01:37:12,800
你唯一能说的就是，我的意思

2601
01:37:12,800 --> 01:37:15,119
是系统做什么它会寻找

2602
01:37:15,119 --> 01:37:17,280
一个最小化自由能的配置，

2603
01:37:17,280 --> 01:37:19,280
但你不知道你不

2604
01:37:19,280 --> 01:37:21,040
知道什么 如果我们没有模拟那个模型，你不知道是否有另一个

2605
01:37:21,040 --> 01:37:23,119
模型会做得更好

2606
01:37:23,119 --> 01:37:26,000
，那么我们不知道

2607
01:37:26,000 --> 01:37:27,600
，

2608
01:37:27,600 --> 01:37:29,679
嗯，唯一的学习机会

2609
01:37:29,679 --> 01:37:30,639


2610
01:37:30,639 --> 01:37:34,480
就是产生错误，所以嗯，

2611
01:37:34,480 --> 01:37:37,119
这是真正改进模型的唯一方法

2612
01:37:37,119 --> 01:37:38,480
是真的

2613
01:37:38,480 --> 01:37:42,000
嗨 确实，嗯，假设

2614
01:37:42,000 --> 01:37:43,520
它不起作用的情况

2615
01:37:43,520 --> 01:37:45,280
，然后你需要调整你的

2616
01:37:45,280 --> 01:37:47,280
参数，

2617
01:37:47,280 --> 01:37:49,520
而且随着时间的推移，你必须构建更多的

2618
01:37:49,520 --> 01:37:50,800
结构，

2619
01:37:50,800 --> 01:37:52,239
所以是的，嗯，

2620
01:37:52,239 --> 01:37:53,920
我的意思是建立一个好的系统是一个

2621
01:37:53,920 --> 01:37:55,520
过程，

2622
01:37:55,520 --> 01:37:57,679
对，这不仅仅是一个

2623
01:37:57,679 --> 01:38:00,000
问题

2624
01:38:00,000 --> 01:38:01,600
如果你

2625
01:38:01,600 --> 01:38:02,400
只是

2626
01:38:02,400 --> 01:38:04,400
建立一个系统并且它完全

2627
01:38:04,400 --> 01:38:06,159
正常工作，那么你必须非常

2628
01:38:06,159 --> 01:38:07,280
幸运，

2629
01:38:07,280 --> 01:38:09,040
这就是

2630
01:38:09,040 --> 01:38:11,119
这个轨道之间的主动

2631
01:38:11,119 --> 01:38:13,600
影响描述的是一个朝着更好系统的过程，

2632
01:38:13,600 --> 01:38:15,520


2633
01:38:15,520 --> 01:38:18,000
但不是

2634
01:38:18,000 --> 01:38:19,440
它没有描述一个

2635
01:38:19,440 --> 01:38:21,600
不会制造的系统 错误 事实上，它

2636
01:38:21,600 --> 01:38:23,840
需要学习错误

2637
01:38:23,840 --> 01:38:27,040
，它描述了这个过程

2638
01:38:27,040 --> 01:38:30,000
很棒的点 这是一种操作

2639
01:38:30,000 --> 01:38:32,080
洞察力，如果你在测试中获得 100 分

2640
01:38:32,080 --> 01:38:35,119
，就像某件事

2641
01:38:35,119 --> 01:38:38,159
在最好的情况下比

2642
01:38:38,159 --> 01:38:40,400
在最坏的情况下提供的信息少，你就是你

2643
01:38:40,400 --> 01:38:43,280
走错了路，嗯，然后它

2644
01:38:43,280 --> 01:38:45,360
让我想起了一家杂货店，是

2645
01:38:45,360 --> 01:38:46,960
不是我们

2646
01:38:46,960 --> 01:38:49,520
根据一种衡量标准对不同的对象进行排名，

2647
01:38:49,520 --> 01:38:51,600
不是真的，这就像寻找平衡

2648
01:38:51,600 --> 01:38:53,280
策略

2649
01:38:53,280 --> 01:38:54,080


2650
01:38:54,080 --> 01:38:55,760
偏好，这就是

2651
01:38:55,760 --> 01:38:56,639
所有这些假设，例如

2652
01:38:56,639 --> 01:38:58,320
分解和平均场，

2653
01:38:58,320 --> 01:39:00,000
并且不能保证每次都给您最好的

2654
01:39:00,000 --> 01:39:02,400
对象，并且仍然存在

2655
01:39:02,400 --> 01:39:04,560
现实世界的随机性和

2656
01:39:04,560 --> 01:39:06,080
杂货店改变的能力，

2657
01:39:06,080 --> 01:39:08,639
就像它不是结束一样 在这个故事中，

2658
01:39:08,639 --> 01:39:10,000
它实际上只是

2659
01:39:10,000 --> 01:39:12,880
一个过程中的一种实践，它

2660
01:39:12,880 --> 01:39:14,560
具有反应

2661
01:39:14,560 --> 01:39:17,360
图和生物

2662
01:39:17,360 --> 01:39:20,080
系统的一些特征，是的，是的

2663
01:39:20,080 --> 01:39:22,960


2664
01:39:22,960 --> 01:39:24,840


2665
01:39:24,840 --> 01:39:27,520


2666
01:39:27,520 --> 01:39:28,800


2667
01:39:28,800 --> 01:39:31,040
随时欢迎您

2668
01:39:31,040 --> 01:39:33,199
作为参与者加入或展示，

2669
01:39:33,199 --> 01:39:35,360
如果您有任何最终意见，您可以

2670
01:39:35,360 --> 01:39:36,639


2671
01:39:36,639 --> 01:39:38,080
很好地记录下来，

2672
01:39:38,080 --> 01:39:41,199
很高兴来到这里，

2673
01:39:41,199 --> 01:39:43,600
如果我们有新的东西，我们很乐意

2674
01:39:43,600 --> 01:39:45,760
回来我 认为这是一个很棒的

2675
01:39:45,760 --> 01:39:49,520
精彩节目，或者显示它是一个

2676
01:39:49,520 --> 01:39:52,239
论坛或任何它的正确名称，

2677
01:39:52,239 --> 01:39:54,000
但我真的很喜欢它，我们真的很

2678
01:39:54,000 --> 01:39:56,000
喜欢成为它的一部分

2679
01:39:56,000 --> 01:39:58,320
，非常感谢

2680
01:39:58,320 --> 01:40:00,320
一些讨论 那里也有一些值得深思的东西，

2681
01:40:00,320 --> 01:40:01,520
这是一个非常酷的

2682
01:40:01,520 --> 01:40:03,679
好问题，每次有机会

2683
01:40:03,679 --> 01:40:05,840
展示是的，

2684
01:40:05,840 --> 01:40:06,639
很好，

2685
01:40:06,639 --> 01:40:11,320
好吧，直到下次再见

