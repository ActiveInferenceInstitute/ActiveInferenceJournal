SPEAKER_01:
All right.

Hello.

This is Active Inference Model Stream 11.1.

We're with Hadi Vafayi.

We'll be discussing the recent paper, Poisson Variational Autoencoder.

There'll be a presentation and a discussion.

So thank you to you.


SPEAKER_00:
all right thanks for having me um all right i'm excited to tell you about this new work that we did along with jake who's my postdoc mentor and deckel who's a phd student in our lab so the big picture motivation behind this work is that we think we're going to understand the brain through the study of brain-like artificial neural networks

But why do we think this way?

So, all right, think about a dream experiment where we recorded every single neuron in the brain of many animals doing complicated tasks in their natural environments.

We also have electron microscopy connectome of every single neuron, and then learning dynamics is available to us as well.

We know everything about those brains.

This experiment is very difficult.

It's probably going to be impossible for the next, I don't know, 50 million years.

But if we had that data, the challenge is we don't even know what to do with that kind of data set.

So the idea is that we're going to use ANNs as computational models of the brain to generate knowledge and theories and computational models to be able to analyze that kind of data whenever they're available.

So that's the motivation.

But there's a challenge here.

So if you want to use ANNs to study the brain, you better make them brain-like.

Because as the cliche saying goes, all models are wrong, but some are useful.

And the degree of usefulness of these ANNs corresponds to how brain-like they are.

And in this particular work, I'm going to show you what I mean by brain-like.

This word could mean many different things to different people, but I have a very specific meaning in mind, which I will tell you about.

And in this work, Arvo focuses on models of visual perception.

So we're going to build an ANN model that perceives visual stimuli, and we're going to make it brain-like.

That's the whole idea.

So if you wanna build brain-like models, you better draw inspiration from neuroscience.

And the idea is that we want to narrow down our search space because the space of all ANNs is huge.

And these are the specific, there are three inspirations that we're gonna rely on.

Perception as inference, rate coding, and predictive coding.

I'm gonna describe each of these separately.

First, let's start by this.

All right, so there's this idea that perception involves two components.

There's this external component that is provided to us by the sensory data, for example, the photons that land on your retina.

And there's this internal component.

You have some subjective experience by living this world that gives rise to prior expectations that is combined with the sensory data to give rise to perceptions.

And this idea is not really new.

You can trace it back to over a thousand years ago by Alhausen.

He mentioned vision occurs in the brain rather than the eyes, and he was the first to discuss the subjective elements of perception.

And also more famously, Helmholtz said perceptions are best guess as to what is in the world, given our current sensory evidence and our prior experience.

the current sensory evidence is just this external component and prior experience is the internal component let me give you an example so this is known as the ames room illusion we see this image and we immediately think that oh this must be a giant man and this must be a really short man but in reality um

there's a bit different explanation.

So this room is designed in a very specific way to give rise to this illusion.

So we usually think rooms are rectangular, like this dashed line over here.

But this room is not.

And the sensory data that is coming from person A on this corner

is consistent with two different possible explanations one explanation that the room is rectangular and the person is short and the other explanation that the actual explanation is that the room is not rectangular the person standing far behind person a

And that's why we see it as short.

But because we have this prior expectation built in in our brain by living in this world where every room or most rooms we encounter are rectangular, we immediately just default to this explanation that, oh, yeah, this person must be short.

So that's the idea.

Our prior expectations can actually trick us into perceiving things that are not true.

And you can actually formalize this using mathematics of Bayesian probability.

Here I'm going to introduce you very briefly to the idea of a generative model.

Imagine you have some latent variable z that you can sample from, from the prior p of z, and then condition some likelihood function based on whatever you sampled, and then sample some observation x. So x could be an image, z could be some abstract latent variable.

Now, within this context, it's interesting to ask, if I saw some observation, some image x, what are the likely causes underlying generation of x?

And that's the reverse direction.

So we have inference, where we want to

compute this Bayesian posterior P of Z given X, which according to Bayes' rule is proportional to these terms.

And I'll explain what they are.

So inference goes in the reverse direction from the image to the underlying cause of that image.

And now let's actually relate this back to that quote earlier from Helmholtz.

So he says, perceptions are best guess.

That's the posterior over here.

as to what is in the world given our current sensory evidence that's the likelihood function and our prior experience and that's the blue over here so um

We think, or the theory of perception as inference, states that that's really what's going on in the brain.

When you show an image to the brain, the brain thinks, what latent configuration likely caused my current observation?

And in order to answer that, we need to compute a posterior distribution over some latent causes given the observation.

This is the essence of perception as inference.

next thing is rate coding and this idea is okay how do biological neurons communicate and store information we know that neurons produce all or non-action potentials or we call them spike and the first evidence that neurons use so rate coding is the idea that neurons encode information in the rate of these spikes

And this goes back to all the way to 1920s, where Adrian and Zetterman build amplifiers to be able to measure spikes.

And they show that if you apply some stimulus to some neurons, their firing rate increases and in a proportional way to the magnitude of that stimulus.

And this type of figure, you can see it in many other different neuroscience papers.

Here they have some weight that is hanging from the muscle.

But you can actually, this situation happens when you show a stimulus and record from visual neurons or play a sound and record from auditory neurons and so on.

So the idea is that there's a baseline firing rate or number of spikes per second.

And then whenever some stimulus is shown to the brain, the firing rate increases, which encodes or represents the presence of that stimulus.

This is the idea of rate coding.

We're going to put this in our model.

Last, the idea of predictive coding.

The summary is that brains can be thought of as prediction machines.

This is the first sentence that this beautiful review by Andy Clark starts, that the abstract starts by saying this, basically.

And the summary of the idea is that the brain contains an internal model of the environment.

The brain uses this internal model to predict or anticipate sensory inputs.

And then when the sensory inputs actually are received by the brain, they're compared to the predictions.

And then there are some errors, of course, because even though we live in a predictable world, it's not fully predictable.

There's always some things that the brain is going to miss, and those are the errors.

And these errors are propagated up the cortical hierarchy to update and maintain this internal model.

And this predictive coding idea and perception as inference, they're overlapping concepts, but ultimately they're distinct.

And we're going to put all of these in our models.

Here are some references if you are interested.

If you combine these three ideas, it narrows down your search space to this model, which we call Poisson Variational Autoencoder.

The Poisson part comes from rate coding because in computational neuroscience, there's a long history of modeling the observed spike counts from real biological neurons using the Poisson distribution conditioned on some rate variable.

The variational autoencoder part comes from perception as inference, because if you actually formulate what Helmholtz said in modern Bayesian terms, it turns out that these architectures, variational autoencoders, exactly optimize for that loss.

So that's why they're very, very similar.

And then down the line, I'll show you how predictive coding is incorporated in this model.

Okay, but before telling you about Poisson variational autoencoder, I should tell you what is a DAE, a variational autoencoder.

So the architecture has two components in the simplest DAEs.

There's some input, it could be an image, and it gets encoded.

by this encoder network, or you can refer to it as inference recognition.

You can use these interchangeably to infer some latents or infer some posterior distribution conditioned on x. And then you can sample from the posterior and decode, map this latent back to the observation.

And the idea is that when you are encoding this image into some set of Latents Z, this encoding process should be good enough.

The Latents should contain enough information about the input image such that you can actually reconstruct it back.

That's the idea.

And that's what the word autoencoder means, because you're mapping some inputs to itself.

And, you know, VAs can have different forms.

But the last function is you want to actually just do posterior inference.

And this is what the posterior is, p of z given x proportional to this.

And what we want to do is approximate this true but intractable posterior with some q, which we are going to refer to this as approximate posterior.

And we're going to parameterize it with some theta and learn those parameters such that this term here is minimized.

This is the KL divergence of Q and P. You can think of it, if Q is identical to P, this term is going to be zero.

But if Q is different from P, it's going to be non-zero, a positive value.

And actually, if you just do some math and arrange some terms, you end up with this loss.

I'm not going to derive this because this is pretty standard.

You can look up any tutorial or blog post on VAEs, and they're going to explain this.

But what we end up with is this term called evidence lower bound or ELBO, which has two components.

So the first component is this expectation over Q log of P of X given Z. And if you think about this, it's like it maps some latents to observations.

And we want to maximize this term.

So we are going to refer to this first term as the reconstruction term because it will have a high value if your reconstruction is good.

And there's this other term.

Now, another KL term emerges, but this time between the approximate posterior, E of Z given X, and the prior, which is different than this.

And we're going to just refer to this as KL term.

And it's called evidence lower bound because this relationship holds.

Elbow is always less than or equal log probability.

This is called model evidence.

That's why evidence lower bound.

It's a lower bound on model evidence.

And if you actually multiply ELBO by minus one, it turns out that this is exactly the variation of free energy, which is larger than surprisal, which is negative log P. And this variation of free energy is exactly the same thing as it appears in Fristonian free energy principle.

So, okay, via ELAS, we're going to maximize ELBO or equivalently minimize variation of free energy.

Now let's talk about how do you actually, let's get a little more specific.

So we're going to build a Gaussian VAE.

I should have mentioned that, you know, that the first of probability distributions, all the prior posterior likelihood, that's up to the practitioner.

You have, you know, you have freedom to choose any distribution you want.

But most of the literature in VAEs is actually just using Gaussians for those distributions.

Our contribution is we're going to replace Gaussians with Poisson.

But let's actually just understand what Gaussian VAEs are about.

OK, so both prior and posteriors are Gaussians.

The prior is chosen to be a fixed standard Gaussian with zero mean and unit variance.

And this is, again, another choice.

You can actually learn the prior, but in standard VAEs, there's no learnable parameter.

It's just a fixed distribution.

And the posterior is parameterized with some mean and variance that is produced by the encoder network.

And if you just

compute the KL term, this is what you get.

Again, I'm not gonna derive this because it's pretty standard at this point.

And from this closed form solution to the KL term, you can see that it will be zero, then mu is zero and sigma is one.

that means the posterior collapses the prior this is known as posterior collapse so if they're identical of course their divergence is going to be minimized which is equal to zero and um

operationally this is what happens when you have a gaussian ga so you give it and present an image to the encoder and it spits out some mean and variance vectors and it's red that means it's parameterized by the encoder network and so on and then you construct this posterior distribution this is the same as q of z given x and then you sample some latent from it

distribution and then you map this sample blatant back to its reconstruction

And this is what happens during the forward pass.

But you want to be able to compute the loss.

You want to take this x hat and compare it to x and compute gradients, update your parameters.

But it's impossible to do it if you actually just sample from this posterior.

And to circumvent this problem, the original VAE paper

introduced the reparameterization trick.

So instead of sampling from this distribution, which is your posterior, you can sample noise from some unit Gaussian, and then compute z as mu plus epsilon times sigma.

It turns out that sampling from this distribution and this operation, they're exactly identical, but this is better because now you can actually compute gradients and use back propagation to learn your network's parameters.

So what we're going to do is we're going to replace these Gaussians with Poisson because of the rate coding idea.

That's the inspiration.

And in order to make this VAE work, we need to do two things.

First of all, we need to introduce an equivalent reparameterization trick for the Poisson case.

We also need to compute the KL term.

We're going to do both of those in the next few slides.

All right, so as I mentioned,

Now we just take the prior and posterior.

We're going to replace Gaussians with Poisson.

And so Gaussians need both mean and variance.

You have to define both a mean and a variance to have a Gaussian distribution.

But for Poisson, you only need one number.

That's just the rate parameter.

And this is the PDF of a Poisson distribution.

Give me a rate, and I have this distribution.

So we have this prior rate and the posterior rate, which depends on X. And this could be any general, you can learn the prior rates, you can output some generic posterior rate.

But here is where we add the predictive coding assumption.

we say that, okay, look, let's call the prior rates just R and interpret those as some representation units that are just maintaining a prediction or anticipation of what is coming, what kind of sensory information is coming their way.

And then let's assume that the posterior rates are actually just the modulation of those existing rates.

So we just say, take R, and the encoder only computes some quantity.

We call it delta R. That is a function of the specific stimulus shown to the encoder.

And then you obtain the posterior rates by multiplying these two together.

And this is just an illustration of the idea.

So you have this input.

It is processed by some encoder to produce delta r. And it is understood that this delta r is going to interact multiplicatively with existing prior rates.

And then once you have this multiplication, now you have your posterior distribution.

This is your approximate posterior.

And then once you sample from this,

you're going to get discrete pipe counts.

because now you have Poisson.

In the Gaussian case, you would get continuous values, but now we're going to get discrete integers, which is illustrated over here.

Like for example, let's say we have five neurons in the latent space.

We sample from this posterior.

We have a vector of 1, 3, 0, 0, 1.

So we take that vector, we pass it through the encoder, and the encoder learns to map it back to whatever image that was shown.

And these are all learnable parameters.

So the decoder network, the encoder network, and the prior rates, they're all learnable parameters.

So I want to emphasize there's like a bunch of difference between Poisson and Gaussian VAEs.

The first difference is, okay, it's Poisson, it's not Gaussian.

The other difference is prior is learned.

And then the last difference is that the...

These prior rates are parameters that are shared between both the prior and the approximate posterior.

Now let's talk about the Poisson reparameterization trick.

We want to be able to, when we sample event counts or spike counts from this Poisson distribution, we want to be able to differentiate through this operation.

So how can we do that?

In order to show you the intuition behind our reprimetization trick, let's actually focus on the process that generates event counts.

So if z is some event count that is distributed according to Poisson, we know that

there are some inter-event intervals that are distributed according to this exponential distribution.

What delta t is, is that suppose one event has happened, how long do you have to wait until you observe another event?

Those wait times, inter-event intervals, they're distributed according to this exponential distribution with parameter lambda.

And this is just a well-known property of Poisson distribution.

We're going to use this, we're going to exploit this fact to introduce our trick.

All right, so now suppose we want to actually just run this process, sample many times from this exponential distribution, and then in a finite window of observation time of one second, we want to see how many events would we get.

So when we sample from this exponential, maybe we get first wait time is delta t1.

So we wait this much until we observe the first event.

We sample again.

It takes this much time to observe the second event.

Again, third event.

But the fourth event doesn't really occur between 0 and 1, which is our previously defined observation time.

Therefore, this doesn't count.

So we have a total of three events because the sum of these three delta t's is less than 1.

So sampling these from exponential and then counting them like that, like we did, is equivalent to just sampling from Poisson and getting number 3 as our spike count.

So we can actually just sample these numbers in parallel from the exponential distribution.

We compute their cumulative sum.

which is visualized over here.

And we can just apply the thresholds and say, all right, whatever number of cumulative sums that there's less than one, let's take that as our spike count.

And here, which means we're going to have three events, and this is not going to count.

And any other delta Ts after this is not going to count because it's just going to add over here.

It extends beyond our wait time.

So again, we have total event counts of three.

It turns out that you can just take this and turn it into an algorithm.

So the input to the algorithm is just some rates.

are produced by the encoder network then we have we have to specify how many exponential samples that we want to generate there's a temperature that that controls the sharpness of the thresholding so if you want to threshold put a hard threshold of like anything less than one that's not going to work you have to approximate that with some sigmoid that's what we have over here

Okay, so that's our reparameterization trick.

And we hope that this trick, it can be used beyond the realm of VAEs.

For example, in spiking neural networks, people deal with this issue all the time.

It's really difficult to work with discrete stochastic variables.

So we're hoping that this algorithm will find applications elsewhere as well.

But now let's talk about the loss function derivation.

As a reminder, we have our prior given like this and the posterior given like this.

And our goal is to compute the KL term.

So let's first start by just the definition of the KL term.

For any distribution Q and P, the KL between Q and P is this expectation over Q of log of Q divided by P.

So far, this is just general definition, but now we're going to plug in the actual Poisson distributions that we have.

So just put that over here.

We define lambda to be r times delta r. It's just our posterior rate.

And this is what Poisson distribution looks like.

So just replace q and p.

And immediately we see that z factorials cancel, and we can actually just write this term as follows.

It's just log of lambda over r to the power z plus log of e to the minus lambda plus r. And then z comes down.

Lambda over r is delta r. So we're going to just end up with z log delta r. And log of e to the something is very simple.

It's just, you know, you bring the exponent down.

And in this entire expression, the only thing that has an expectation is Z. Everything else is a constant, so it comes out.

And the expectation of Z over Q is just the mean.

And the mean of Poisson distribution is just the rate.

So Z is going to be replaced by lambda, which is the rate of Q. And that's what we get here.

So R minus lambda plus lambda log delta R.

And again, you just take r, take it out, and it's like 1 minus delta r plus delta r log delta r. So we see that nicely by having, by virtue of choosing this kind of predictive coding-like assumptions, our KL term nicely factorizes to a term that depends on prior and another term that depends on the modulation that comes from the encoder.

and then we define this whole thing in parentheses to be f so that's f is one minus this plus whatever and if you plot it it looks like this so delta r is by definition always positive

It's greater than zero.

And if delta R is one, it says like, okay, do not modulate anything.

Let's just keep the prior rate.

Then this F becomes zero.

And if delta R is really large, you pay the cost of, you know, it really increases the magnitude of F of Y.

So, OK, so this KL term was just for one neuron.

If you have K statistically independent neurons, K being the dimensionality over a latent space, you can just easily extend this derivation to see that the KL term is just the sum of these terms.

And now this is the interesting part.

We're going to interpret this term as a metabolic cost term.

The reason is, the prior firing rates, they are positive values by definition.

And we ended up with some term, F, that also is positive by definition.

So you have a positive term multiplied by another positive term.

So this whole thing is just a positive value, and we want to minimize it.

And we can minimize this, for example, by just putting zeros in all of our prior rates.

All of these neurons are silent.

They're not doing anything.

And that's why we are interpreting this as a metabolic cost, because producing action potentials is a very metabolically costly operation.

The neurons in the brain, they don't want to fire action potentials unless it's absolutely necessary to encode some information or communicate something.

That's why this is very interesting that it just comes out of the math.

And if you just put everything together, this is just the loss of Poisson VAE.

The first term is the reconstruction term.

It's just the L2 norm of x input.

minus reconstruction.

This is like decoder network applied to one sample, which is drawn from the posterior.

So this is the reconstruction plus this term, which comes from the KL term.

And this is very curious because now we have some term that says reconstruct the image and another term that says do it while optimizing or minimizing neural resource use.

And this is reminiscent of sparse coding.

which I will introduce here.

So in 96, Olshausen and Field introduced sparse coding.

They said, OK, let's imagine there are some images x and some latent variable z, or let's say neural activation z in their case.

And let's assume that we represent these images as a linear sum of some basis elements from a dictionary phi.

While we're representing these images, let's also try to minimize the magnitude of neural activity, which is this L1 term over here, and just minimize this whole loss.

That'll give you sparse coding.

Sparse because if you apply this term, it's going to push a lot of these neural activities to zero.

It's going to give you a sparse activity vector.

And this really resembles

what we get from PVAE.

And in order to actually make this connection more clear, we just take this general decoder term that appears in the loss.

We also assume we have a linear decoder, just like sparse coding.

And it turns out, in that case, you have a closed form solution for the loss.

I'm not going to derive this.

It's in the paper, if you're curious.

But there is a closed form solution.

And in the actual, you know, full loss, there is this expectation value which you can compute.

It gives you this final loss.

And again, we see this correspondence nicely.

So there is one term that says faithfully represent images with some linear decoder.

And then there are two terms here, actually, as opposed to just one.

There are two terms that push your firing rates to low values.

So this diagonal of phi transpose phi is positive by definition and lambda is positive.

So this thing needs to minimize.

Therefore, it forces lambda to minimize.

And again, just a reminder that this is coming from the KL term and be interpreted as a metabolic cost.

OK, so let's just pause a little bit here.

We started from all those three neuroscience inspirations.

We said, we want to build a model that does, you know, perceives visual inputs.

We want to build in

perception as inference, rate coding, and predictive coding, all of those in the model.

It gave us the Poisson VAE idea.

We derived the loss, and we saw that it resembles sparse coding, so it's just gifted to us by the theory.

Now we want to test this.

We want to say, okay, the loss resembles sparse coding, but let's actually just train some models and see if we get sparse coding-like results.

That's what we're going to do next, the experiments.

Oh yeah, so this is the architecture of linear PVAE.

So you have

Again, some image is encoded into delta R multiplied by R to give you this posterior.

And importantly, now the decoder is just a linear layer.

That's what this is about.

And another important assumption that is central to sparse coding is that you have to have an over-complete latent space.

many more latent dimensions or many more neurons than you have pixels so m is the number of pixels of the input image k is your latent dimensionality now we're going to train this model and compare it to sparse coding

But also, in order to understand what components of the PVAE might reproduce sparse loading, we're going to compare it to alternative VAE models.

So we have discrete VAEs.

We have PVAE over here, which is what we introduced.

And we're going to use categorical VAE.

And there are continuous VAEs, Gaussian VAE, and Lock-Bus VAE.

And the reason we chose Laplace to include in this table is that people have shown before us that if you have a Laplace distributed prior, you can also get sparse coding-like results.

So we want to test which one of these models is actually more sparse coding-like, if you will.

And then we're going to compare to actual, you know, very well-established standard sparse coding algorithms.

One is the locally competitive algorithm from 2008.

It's a biologically inspired algorithm that optimizes the sparse coding loss.

And another algorithm is ISTA.

These are both very standard and well-established as well as the Gaussian.

So you're going to compare to a bunch of models.

So if you train this PVAE on linear PVAE on natural image patches, this is what we get.

These are the decoder weights.

And if you're in neuroscience, in visual neuroscience, you already know that these are

We refer to these as like Gabor patches, and these resemble the selectivity in the primary visual cortex of monkeys and mice and humans.

So this is very biology-like.

And for the first time, these types of Gabor patches, they emerge from the sparse coding models, which we were able to reproduce with PVAE.

And if I show you the other models,

It's not actually trivial, but let's go from left.

So we have Gaussian VAE over here.

I'm not sure if you can see, but there's a lot of noise and there's only like last three rows look, you know, they look like PCA and that's expected because a linear Gaussian VAE is theoretically equivalent to probabilistic PCA.

Now we have also Laplace VAE down here.

There are some Gabors that emerge from the Laplace VAE, but again, there's a lot of dead neurons, which I will define what dead neuron means, and I'm going to show how we quantify them.

But for now, let's just visually inspect these learned decoder rates.

This is the Poisson VAE, and this is the categorical VAE.

Categorical VAE is discrete, so it also learns some Gabors, but it's very limited.

that there's a lot of noisy elements and certain spatial frequencies are missing and certain orientations are missing as well from the categorical VAE.

And finally, in the last column, we have these results from the standard sparse coding algorithms.

These are the best, you know, game in town if you want to learn sparse coding like dictionary elements.

And we see that among the VAE models, Poisson VAE actually is the most similar one to these standard sparse coding algorithms.

So in conclusion, because both the loss function of a PVAE just emerged to resemble sparse coding, and also empirically we tested it and also learned sparse coding-like results,

we conclude that it actually contains sparse coding as a special case.

Why?

Because we made a linear decoder assumption.

So it's like PVAE can be general.

It could be anything.

It could be nonlinear encoder, nonlinear decoder.

But if you make the decoder linear and make the latent space overcomplete, you're going to recover sparse coding-like results.

okay so here's um how i quantify number of dead neurons this is just uh let me just first define what the posterior collapse is this is a big kind of prevalent issue in daes

when a latent dimension stops encoding information it's going to be always the posterior in that latent dimension is going to be identical to the prior so there's no deviation the KL term is very small or zero and that's how we measure dead neurons and here this dashed line shows the gap between the post the KL of

dead neurons and active neurons that's how we quantified and we found that for the pvae across three different data sets it consistently had much larger number of active neurons compared to lactose and gaussian vaes so it kind of automatically avoids this posterior collapse issue because of discreteness that's the main cause of this observation

okay so we want to actually do some other experiments um so far we just saw that if you start from those neuroscience inspirations you get a model that also you know recovers or reproduces some other neuroscience-like uh models results like sparse coding but now let's just um

be a little more general.

We want to evaluate PVAE in a general representation learning setting.

That's what this is about.

All right, so we want to test these unsupervised representations on a downstream classification task, and we use MNIST for that purpose.

We're going to compare all those four VAE models for this task.

The approach is that after the training is done, we extract encoder representations.

This means we push MNIST digits from the validation set through the encoder.

We extract the representations, and we're going to do things with those.

All right.

And then once you have these representations, sample a limited number of supervised labels.

So MNIST, they have labels.

We know each image of a digit has a label.

So it's a supervised data set.

But we're going to look at sub-samples, like very small samples of supervised subsets.

And the reason is that, you know, having labels is expensive.

So if a model can achieve good performance with a small subset of supervised labels is a good model.

That's the idea.

Then we're gonna apply k-nearest neighbor classifier to classify these digits.

And the idea of using KNN is that it's a non-parametric model.

So you don't need to learn anything on top of these representations.

And the output of a KNN classifier directly depends on the geometry of representation.

So it's gonna tell us something about if there's something fundamentally different about the geometry of representations in one of these VAEs like PDAE versus the others.

And then as a measure of success, we're going to report classification accuracy.

This is the results.

We have different latent dimensionalities.

We have different models.

There's a lot of details that I'm going to skip, but let me highlight just one thing.

So let's look at this number.

So for 10 latent dimensions with only 200 samples, the PVAE achieves accuracy of around 82%.

But Gaussian VAE requires five times that number, a thousand label samples to achieve a similar performance.

In this sense, we claim that PVAE is five times more sample efficient than the standard Gaussian VAE.

And across the board, it just outperforms all these other models, which shows that it learns useful representations that can be applied in downstream tasks.

Finally, let's quantify sparsity.

We're going to use this measure from Vinci and Gallant.

This is called lifetime sparsity.

Zi is the response to i-th stimulus, number of spikes in the Poisson VAE, and n is the total number of stimuli.

Just the intuition about this formula is that if a neuron only responds to a single stimulus and doesn't respond to any other stimuli, the sparsity score is going to be one.

And if the neuron or the latent dimension responds to all stimuli equally, then the sparsity score is going to be zero.

So zero means not sparse at all.

One means very sparse.

And we use that.

This is the y-axis, the lifetime sparsity of these different VAE models.

And on the x-axis, we have the reconstruction error and mean squared error.

We see that Poisson VAE is very sparse.

But because of that sparsity, it has larger reconstruction error compared to, let's say, Gaussian, which is down here.

And it turns out if you apply some ReLU to the Gaussian, it's going to increase the sparsity, but not as much as Poisson.

And then this curve over here came from fitting a sigmoid to a bunch of Poisson DAEs that were trained with different betas.

So if you remember, beta is a parameter that...

kind of changes the trade-off between the reconstruction term and the KL term.

So if you increase beta, you're going to get much sparser results, but at a cost of larger reconstruction errors.

And if you decrease the beta, you're going to get less sparse results, but better reconstruction.

So that kind of traces rate distortion trade-off.

Finally, one thing that we notice is that there's still a large amortization gap for the PoSAM DAE, and I'll explain what that means.

So if you compare Poisson VAE with those standard sparse coding algorithms, including LCA, which is this dark gray, and ISTA, which is this light gray, we see that they achieve the same level of sparsity roughly, but Poisson VAE still has a larger reconstruction error.

But what happened here?

Why is LCA much better than Poisson VAE?

So to test this, we thought that maybe the dictionary elements learned by Poisson VAE are pretty good, but the actual inference is not very good.

The encoder architecture is not doing a good job in inferring the activations.

So what we did is we took the Poisson VAE and we took, sorry,

The dictionary elements learned by the Poisson, we even applied LCA inference on those.

And that gave us these purple dots, which we also fit a sigmoid to.

And it turns out that you can actually just close the amortization gap by applying a better inference, which in this case is the LCA inference, to just bring this over here.

So the conclusion from this slide is that the Poisson VAE learns reasonable dictionary elements, but its encoder or the encoder architectures we tried in this paper, they weren't adequate and there was this large amortization gap that in the future work, we hope to kind of close this gap by building better encoders, maybe iterative encoders and so on.

OK, let's just conclude.

So we started from these three inspirations.

Perception as inference, rate coding, predictive coding.

It gave us this architecture.

And it's interesting for many reasons because, you know, Poisson VAE encodes its inputs in discrete spike counts.

Therefore, it's more biologically realistic.

And this metabolic cost term emerged in the model objective for free.

You didn't have to

put it by hand or anything and it actually revealed this connection to sparse coding which we verified empirically and then from a theoretical perspective it kind of unites all these different ideas like predictive coding rate coding sparse coding under the umbrella of bayesian inference which is nice

And then the takeaway message is that, if you draw inspiration from centuries of neuroscience research, combine it with modern machine learning, you might get a model that's more brain-like than alternatives.

And it outperforms alternatives in key aspects like sample efficiency.

All right.

This is all I had for the slides.

Now, if there are questions, you could go over there, or maybe I can show the code.


SPEAKER_01:
Thank you.

That was awesome.

Yeah.

How about the code?

And meanwhile, for people who are watching, write any questions, and then I'll ask them.

Thank you.


SPEAKER_00:
All right.

Yeah, so I actually haven't prepared anything specific to say about the code, but I'm just gonna riff through, you know, what exists.

Hopefully some people might find this inspiring.

Okay, so this code is actually not online right now.

It's not available, but because the paper is under review, but once the paper gets out, I'm gonna make this code publicly available.

So then maybe the more important part of the code is that you go in the code in the VAE, you have VAE.py,

which has all the implementations of different VAEs that we discussed in this talk.

So there's a base VAE that has all these different functions.

It encodes inputs.

You can have a convolutional encoder.

You can have a linear encoder, MLP encoder.

It's all implemented.

know same with decoder you have convolutional linear mlp it computes the loss which is just the nsc and you can also compute the exact loss when you have a linear decoder

So the KL loss is not implemented because we're gonna have specific instances of VAEs like Poisson VAE, Gaussian VAE, et cetera.

And they each have their own KL loss.

So that's not implemented over here in the base VAE and so on.

There's a bunch of different functions.

So let me just show you the actual implementations.

So Poisson VAE is over here.

the forward direction you have this this infer function that accepts x which is an image temperature and it computes so the self.log rate this is the prior rates these are parameters that are learned along with every other parameter and you have this log r then you have log dr dr is just a delta r that's the output of the encoder where you encode the image as an output you get log dr

And then, let's skip this part.

Then you compute, you make this distribution.

And just to remind yourself that dist is just plus on, which I will show you later.

It's defined somewhere else.

And then you make this distribution.

You provide the log rates.

This is the Nx.

If you remember from the reparameterization,

slide you have to provide how many exponential samples you're going to draw which you know it's it's adaptively computed somewhere else in the code i'll tell you where later you provide the temperature and then you have a distribution which you know this is going to be the infra function provides you with the distribution that's your approximate posterior

And then you sample from it and get spikes.

You decode those spikes, that's your reconstruction.

That's it.

There's other functions that I'm not gonna go, but maybe let's have a look at the KL term.

So you can easily understand this.

If you understood the slide deriving the KL term in theory, then you would understand this term.

Maybe I'll show you quickly the distributions.

So we have also this base distributions, which contains our implementation of the Poisson distribution and the reparameterization for it.

There we go, it's here.

Yeah, so you provide it with log rates in the initialization.

You provide the temperature, which is the thresholding temperature, number of exponential samples.

And the clamp is just basically says, if the rate is larger than e to the, you know, it applies a soft clamp, which is e to the disvalue.

So it applies an upper bound on the rates.

This is for the stability of training.

It's not very important.

But the important part is here, this function.

That's our reparameterization algorithm.

Okay, so first of all, you initialize this exponential distribution in this init function.

So you get log rates, apply the soft clamp, and then you define rates as this just exponentiate log rates plus this really tiny value so that it's non-zero.

Because if it's zero, then this exponential is going to raise an error.

It has to be slightly above zero.

So you define this exponential distribution, which takes the rate as input.

And here I'm just borrowing from PyTorch.

So this, if I go up, I'm importing, it's not over here.

I imported somewhere else, but basically, where is it?

This is the torch.distributions.

I'm just importing it as dist.

So this exponential is exactly PyTorch's implementation.

All right, once we initialize this self.x object, then we can actually just perform pre-parameterized sampling.

So x is just the first, you know, all those delta t's that I showed in the slide, these are your x's, and you have to sample n times.

And then you perform this cumulative sum to get the times, and then

If temperature is greater than zero, you have this soft indicator, which is just sigmoid.

If temperature was zero, then you would have this hard indicator, which is just times less than one.

If you take this operation, if you make it continuous, you will get this, basically.

That's the idea.

Once you have this indicator function, then you can sum them in the first dimension to get your spike counts.

All right, so that's for the Poisson, but I want to also mention

this continuous VAE because this is a more general implementation that you can use for any VAE that uses a continuous distribution.

In our case, we used Gaussian and Laplace, but you can actually take this implementation and easily build your own continuous VAE like Cauchy or any other distribution you like, as long as you can reparameterize it.

which a lot of PyTorch implementations, they have this function called RSample, which is a reference to a sample.

But again, this is a very similar idea.

You encode some features, take some X, encode it into this feature H. And then because for these continuous VAEs, you need both the mean, which is location, and the variance, which is log scale.

So you just divide H into two parts.

You get these parameters, and then you

you know, construct this posterior distribution and then

return it.

That's what infer does.

It always gives you the posterior distribution.

Once you have the posterior distribution, you can rsample or reparameterized sample to get your latency.

Ignore this part.

You can actually just apply an activation function.

This is the Gaussian plus ReLU that I kind of skipped that didn't really talk about it, but that's there.

And then you can decode and y as your reconstruction.

So this continuous VAE implementation is fairly complete.

You can, in order to build your own, that's all you have to do.

So just say, okay, I want to make a Gaussian VAE.

I'm gonna inherit continuous VAE object.

I'm gonna say, okay, it's soft that this should be normal.

That's it.

And for Laplace, again, you inherit the continuous VAE and just say the distribution should be Laplace.

And you can do this for any other continuous distribution.

Maybe that, you know, these are PyTorch's implementation.

So any continuous distribution implemented by PyTorch that has re-permit trace sampling, you can use this to build your own VAE.

And then we have this categorical, which I'm going to skip.

But we use the, again, PyTorch's implementation.

And OK, so this module defines VAEs.

And there's another module that trains them.

So let me just briefly go over that.

Again, there's a bunch of code that just defines base trainers.

There's a lot of details here that maybe not very interesting, but you have this trainer that accepts all these different VAE types, Poisson, Gaussian, categorical, Laplace, and it goes through, this is just one iteration.

There's a validation function, all of that, and

it's fairly complete so there's a bunch of arguments that you have to provide to be able to run this code but because i spend a lot of time to make it intuitive it's going to be just a single line if you want to train your own pvae you can just run that with a single line like you know train vae you specify the architecture in one string you specify the data set and

and the GPU that you want to train on.

And then you can actually do that if you want.

But yeah, this code is not available right now.

When I put it online, I'm going to make some documentation and put some scripts that make it easy and intuitive to just train your own model if you're interested.

There's a lot more, but I think at this point I'm going to stop here.

There's a bunch of other stuff that is secondary.

Yeah.


SPEAKER_01:
Awesome.

Okay.

While I crop back the screen, maybe just let's start with how did you get to this problem?

Were you pursuing Poisson distributions and this came up?

Or how did you kind of in your research path come to this approach?


SPEAKER_00:
Oh, so the real initial motivation is just we did another paper.

last year on a Gaussian VAE that was hierarchical.

And we found that we trained that Gaussian VAE, that Gaussian hierarchical VAE, on a motion data set.

And we found that it learned latent representations that were very aligned to real biological neurons from the monkey brain.

So we have another data set from

the dataset was they showed some moving dust monkeys and they recorded from their MT, which is a brain region that's, you know,

that is responsible for motion perception.

Anyway, we found that these VAEs actually have a really high chance of being brain-like.

And that gave us motivation to think about, OK, how we can make them even more brain-like.

So Gaussian VAEs just encode inputs in continuous values that are not constrained by any means.

But we know that that's not how brain works.

We know that neurons produce spikes.

That's how they communicate.

So we said like, okay, VAEs have potential, but how can we make them better?

That was really the initial motivation.


SPEAKER_01:
Awesome.

Well, just to kind of recap a little bit of how I saw this, often parameters in biological or cognitive modeling are modeled as continuously dynamically varying because there are certain simplifying assumptions.

However, the empirical data, be it neural spiking or events or like ants foraging, how do you bridge the discrete events

to the continuous and the um mathematical equivalence which is well known between the event arrival distribution with the prasad and the waiting time i saw that as a way that you implemented with the statistical methods to and also in doing so generalized like what was relevant for the base model for continuous or discrete

And then how can that be articulated with the statistical packages so that there's good course handles to explore these learning settings?


SPEAKER_00:
I think that's actually a very interesting and deep point.

Even though neurons communicate with spites or discrete action potentials,

when we are modeling them, you can actually think as, you know, the actual underlying dynamics could happen in a continuous space.

Like, for example, we have these log rates, you know, those log rates are continuous values between minus infinity and plus infinity, really.

I mean, even though in reality, it doesn't go that far, but

they're defined in if you have n neurons log rates are defined in rn right and then you can assume that the model is just doing some trajectory like the brain is doing going through some trajectory in that log rate space and in each given time you can actually take this that log rate and then map it to some posterior by computing the exponential of that to get the rates and then draw samples

And in that sense, you can actually see that a continuous underlying dynamical system can be mapped into a discrete observation through Poisson.

And also that every time point in the dynamics of the brain also corresponds to some posterior inference.

So these concepts, I think, can be nicely reconciled with this view.


SPEAKER_01:
yeah that was great and to kind of connect it to active inference and a little bit of the precursors there with spm statistical parametric mapping the whole setting is there's underlying neural activity

hidden state, external state, and then there's noise plus signal representing a static mapping between the hidden and the observable, what you had as X and Z. So that's like the partial observability situation.

And then that's the experimental situation.

but you don't get to observe neural rates.

So like in the SPM textbook and the kind of modeling, you model it with the predator-prey type models or with dynamical attractors, but you stay in the purely dynamical, and then that doesn't let you get to the rate coding.

But also people have integrated those models, however, in more of a two-step process rather than the one-step unified objective of the autoencoder model.


SPEAKER_00:
yeah so that's pretty interesting so because rate is in a sense the rate itself is a latent variable right we never observe it we it's a it's a made-up concept really by the theorists we say okay then if there is an underlying rate and that is producing these observed spikes

you know, in the brain, then you can actually try to infer the rates by observing many spikes over many trials and so on.

So in that sense, yeah, rate itself is a latent variable, but that maybe shouldn't go there because that like adds another layer


SPEAKER_01:
complexity well one question i had about rate was if you're going to model it you kind of can't get away from it as a underlying dynamical variable because there's going to be variability in delta t variance amongst arrival time so maybe it's a metronome but in the non-metronome case there's going to be kind of like faster and slower intervals so that's kind of a common filter

question, which is, or ARIMA or any time series, ultimately, how smoothly should you interpolate that?

Like with the splines, with what method will the data kind of have a relationship with a curve that has the smoother differential properties that ultimately allow the closed form solution and the simple algorithms?

Makes sense.

Okay, I'll see if anyone asks a question, but just one question now, and then I'll ask maybe one or two more.

Like, where do you see this being useful slash applied now?


SPEAKER_00:
So we are actually currently building based on this observation that there was a large amortization gap between Poisson VAE and this kind of relatively old sparse coding algorithm from 2008.

The one conclusion we drew from that is that, you know, we need iterative inference.

So right now the inference is just one pass.

You take one image,

You infer something, compute delta r, and then you just get the posterior.

But now suppose you have a sequence, you have a video rather than images, and you want to just keep iteratively making your inference better and better such that your posterior at time t informs your prior at time t plus 1.

That's very essential to Bayesian thinking.

So we're kind of right now developing that model.

And our hope, very long-term hope is that

when we add that component and maybe we add hierarchical structure to the latent space, then we get something that is truly brain-like and it reproduces what we've observed, what we've learned about visual processing in the last 50 years.

So if we get that model, then we can perform in silico experiments in it, learn something about brain-like visual processing and so on.

So that's kind of roughly the trajectory we imagine.


SPEAKER_01:
Awesome.

Is there anything else you want to add?

Otherwise, I think this was amazing on the theory and really seems useful with the sample efficiency, all these other features.


SPEAKER_00:
Yeah, I guess that's it.

Yeah.

Thanks for having me.

It was really fun.

Awesome.


SPEAKER_01:
Okay.

just read one comment from someone wrote great work thanks to active and agha hadi for sharing looking forward to find out what a different inference scheme could do the results and the effect it could have on the metabolic cost okay yeah thanks for the comment yeah cool all right thank you see you all right thank you bye