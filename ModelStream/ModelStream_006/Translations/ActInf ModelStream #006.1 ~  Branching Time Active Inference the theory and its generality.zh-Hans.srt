1
00:00:07,020 --> 00:00:10,080
大家好，欢迎大家，今天是

2
00:00:10,080 --> 00:00:13,559
2022 年 9 月 1 日。

3
00:00:13,559 --> 00:00:17,640
我们在模型流

4
00:00:17,640 --> 00:00:19,380
6.1 中，

5
00:00:19,380 --> 00:00:21,300
我们将讨论分支

6
00:00:21,300 --> 00:00:24,180
时间主动推理理论及其

7
00:00:24,180 --> 00:00:25,439
普遍性，

8
00:00:25,439 --> 00:00:27,260
我们将进行演示，

9
00:00:27,260 --> 00:00:31,080
然后进行讨论，谢谢

10
00:00:31,080 --> 00:00:33,300
Ali 和 Jacob 的加入以及其他任何

11
00:00:33,300 --> 00:00:36,059
人都可以在实时聊天中添加他们的问题，

12
00:00:36,059 --> 00:00:37,140


13
00:00:37,140 --> 00:00:40,860
不用多说 geophilia

14
00:00:40,860 --> 00:00:41,879
Champions

15
00:00:41,879 --> 00:00:44,040
，非常感谢您的加入，非常

16
00:00:44,040 --> 00:00:45,719


17
00:00:45,719 --> 00:00:48,000
感谢您，您好，非常感谢您的友好

18
00:00:48,000 --> 00:00:50,399
介绍，嗯，感谢您

19
00:00:50,399 --> 00:00:52,140
邀请我参加 今天我很

20
00:00:52,140 --> 00:00:54,180
高兴我有这个机会

21
00:00:54,180 --> 00:00:55,680
所以今天我将谈论

22
00:00:55,680 --> 00:00:58,680
分支时间主动推理

23
00:00:58,680 --> 00:01:00,059
嗯基本上它

24
00:01:00,059 --> 00:01:03,239
是该方法的真正不同版本

25
00:01:03,239 --> 00:01:05,700
第一个原因是 Dash 通过所以第二个

26
00:01:05,700 --> 00:01:08,880
使用比利时过滤第三

27
00:01:08,880 --> 00:01:12,420
个是 使用相信传播并

28
00:01:12,420 --> 00:01:15,540
允许模型包含多个

29
00:01:15,540 --> 00:01:18,540
观察结果和多个项目状态

30
00:01:18,540 --> 00:01:21,600
这项工作已经通过

31
00:01:21,600 --> 00:01:25,439
合作实现，我们已经l  ost Acosta Mike

32
00:01:25,439 --> 00:01:28,740
Josh 和 Hogwart Bowman

33
00:01:28,740 --> 00:01:30,659
所以首先我想

34
00:01:30,659 --> 00:01:33,360
谈谈动作感知周期，这

35
00:01:33,360 --> 00:01:37,700
是主动推理中的核心 ID，

36
00:01:39,860 --> 00:01:43,259
其次是

37
00:01:43,259 --> 00:01:46,020


38
00:01:46,020 --> 00:01:48,540
代理，例如，环境为代理提供观察

39
00:01:48,540 --> 00:01:50,700
环境图像

40
00:01:50,700 --> 00:01:52,860
，然后代理需要获取此

41
00:01:52,860 --> 00:01:56,159
输入并对其进行推理，

42
00:01:56,159 --> 00:01:58,020
入口过程的目标是

43
00:01:58,020 --> 00:02:00,479
提取高级铁状态，例如

44
00:02:00,479 --> 00:02:03,899
黑人在 X 和 Y 中

45
00:02:03,899 --> 00:02:06,060
的位置或 幽灵或任何

46
00:02:06,060 --> 00:02:08,038
可能相关的信息，

47
00:02:08,038 --> 00:02:10,500
然后基于这些状态，我们可以

48
00:02:10,500 --> 00:02:13,040
执行计划和动作选择

49
00:02:13,040 --> 00:02:16,020
以及动作选择它如何使

50
00:02:16,020 --> 00:02:18,300
动作执行可能

51
00:02:18,300 --> 00:02:20,819
向上的动作被馈送到其环境

52
00:02:20,819 --> 00:02:24,239
中产生另一个观察并且

53
00:02:24,239 --> 00:02:27,000
这个循环一直持续到 Trail

54
00:02:27,000 --> 00:02:29,400
Ends

55
00:02:29,400 --> 00:02:31,819
既然我们有了核心，

56
00:02:31,819 --> 00:02:34,560
那么北极推理的核心思想

57
00:02:34,560 --> 00:02:36,720
就是行动感知周期，我将

58
00:02:36,720 --> 00:02:38,580
在后面更多地谈论主动推理

59
00:02:38,580 --> 00:02:40,140
深度，

60
00:02:40,140 --> 00:02:42,360
所以基本上主动推理是关于

61
00:02:42,360 --> 00:02:46,200
一个代理人，它是一个代理人的

62
00:02:46,200 --> 00:02:49,319
模型，正如我所说的那样，

63
00:02:49,319 --> 00:02:51,959
观察在屏幕底部表示

64
00:02:51,959 --> 00:02:53,700


65
00:02:53,700 --> 00:02:56,700
，这些观察通过矩阵依赖于

66
00:02:56,700 --> 00:02:58,019
岛国，

67
00:02:58,019 --> 00:03:00,540
因此它是一个

68
00:03:00,540 --> 00:03:01,500
矩阵

69
00:03:01,500 --> 00:03:03,420


70
00:03:03,420 --> 00:03:05,700
为每个可能的拉丁状态提供观察分布，

71
00:03:05,700 --> 00:03:07,019


72
00:03:07,019 --> 00:03:10,140
我们还有 G 向量，它

73
00:03:10,140 --> 00:03:12,540
包含初始项目状态的先验参数，

74
00:03:12,540 --> 00:03:14,760


75
00:03:14,760 --> 00:03:17,879
以及 B 矩阵，它解释

76
00:03:17,879 --> 00:03:20,280
了环境的转换是如何

77
00:03:20,280 --> 00:03:23,760
工作的，所以基本上它解释了如何给定

78
00:03:23,760 --> 00:03:27,180
一个状态和一个动作我们

79
00:03:27,180 --> 00:03:28,080


80
00:03:28,080 --> 00:03:30,060
在时间 t 得到新状态加上一个

81
00:03:30,060 --> 00:03:33,720
我们正如我所说的，呃有一个动作或者这里

82
00:03:33,720 --> 00:03:37,680
是一个策略变量，这个动作

83
00:03:37,680 --> 00:03:40,440
变量或策略取决于

84
00:03:40,440 --> 00:03:42,959
称为伽玛的精度参数

85
00:03:42,959 --> 00:03:47,040
，正如我们将看到的影响 代理人

86
00:03:47,040 --> 00:03:49,500
的政策将是多么随机或确定性，

87
00:03:49,500 --> 00:03:52,200


88
00:03:52,200 --> 00:03:53,340
所以

89
00:03:53,340 --> 00:03:56,760
在这里我们看到如何

90
00:03:56,760 --> 00:03:57,959
定义先验行动，

91
00:03:57,959 --> 00:03:59,879
所以它取决于我所说的游戏

92
00:03:59,879 --> 00:04:02,400
参数 ter 是 并且它被定义

93
00:04:02,400 --> 00:04:05,239
为减去伽马的软最大函数

94
00:04:05,239 --> 00:04:07,980
Precision 参数

95
00:04:07,980 --> 00:04:10,140
乘以预期的自由能

96
00:04:10,140 --> 00:04:12,360
和特定策略的预期自由能

97
00:04:12,360 --> 00:04:15,239
基本上是

98
00:04:15,239 --> 00:04:18,060
所有未来时间步长的总和所以从 t 加 1

99
00:04:18,060 --> 00:04:19,858
这是 第一次

100
00:04:19,858 --> 00:04:23,040
进入大写团队的未来，这是一个时间范围

101
00:04:23,040 --> 00:04:24,479


102
00:04:24,479 --> 00:04:27,000
，对于每个时间步，预期自由

103
00:04:27,000 --> 00:04:29,220
能被定义为预期成本

104
00:04:29,220 --> 00:04:31,560
加小米

105
00:04:31,560 --> 00:04:34,020
股权预期成本是 K

106
00:04:34,020 --> 00:04:37,320
之间的差异作为预测性试验后

107
00:04:37,320 --> 00:04:39,360
或未来观察

108
00:04:39,360 --> 00:04:42,120
和 先验偏好但先验

109
00:04:42,120 --> 00:04:44,400
偏好定义

110
00:04:44,400 --> 00:04:48,600
了代理想要观察的观察结果，

111
00:04:48,600 --> 00:04:51,479
而预测后验定义了

112
00:04:51,479 --> 00:04:54,360
其观察的可能性有多大

113
00:04:54,360 --> 00:04:56,160
，因此我们要做的是最小化

114
00:04:56,160 --> 00:04:58,139
分布之间的散度，

115
00:04:58,139 --> 00:05:00,180
以便我们实际观察到我们

116
00:05:00,180 --> 00:05:01,979
学到的东西

117
00:05:01,979 --> 00:05:04,500
好的，第二项是

118
00:05:04,500 --> 00:05:07,320
关于似然映射的熵，呃，

119
00:05:07,320 --> 00:05:09,840
在一个状态的方向后验

120
00:05:09,840 --> 00:05:11,039
下，

121
00:05:11,039 --> 00:05:12,600
所以我说 g 关于定向

122
00:05:12,600 --> 00:05:15,060
后验，我会在一分钟内解释这是什么，

123
00:05:15,060 --> 00:05:17,160
呃，这

124
00:05:17,160 --> 00:05:19,139
是预期能量风险加

125
00:05:19,139 --> 00:05:21,600
歧义的定义，或者也称为

126
00:05:21,600 --> 00:05:24,120
每个溶解度的预期成本，

127
00:05:24,120 --> 00:05:26,280
所以我在这里展示了这个模型，这是一个更

128
00:05:26,280 --> 00:05:29,039
正式的定义，我们有一个

129
00:05:29,039 --> 00:05:32,039
联合所有的 模型中的变量我们

130
00:05:32,039 --> 00:05:34,680
看到策略取决于

131
00:05:34,680 --> 00:05:38,100
Precision 参数我们有

132
00:05:38,100 --> 00:05:41,539


133
00:05:43,759 --> 00:05:47,759
每个参数的 tonsor 的精度的伽玛分布所以

134
00:05:47,759 --> 00:05:51,360
a b 和 d 我们看到 s 确实

135
00:05:51,360 --> 00:05:53,220
取决于 D

136
00:05:53,220 --> 00:05:55,440
并且观察

137
00:05:55,440 --> 00:05:58,319
取决于状态 通过 a 矩阵

138
00:05:58,319 --> 00:06:00,600
和转换映射的 10 件事，

139
00:06:00,600 --> 00:06:02,100
我们有一个状态，它取决于

140
00:06:02,100 --> 00:06:04,979
先前的状态和 B 矩阵

141
00:06:04,979 --> 00:06:06,660
以及在环境中执行的动作

142
00:06:06,660 --> 00:06:09,300


143
00:06:09,300 --> 00:06:12,720
好吧，所以现在我们有了

144
00:06:12,720 --> 00:06:14,880
我们想要做的模型 一些观察

145
00:06:14,880 --> 00:06:17,460
我们希望能够计算概率中

146
00:06:17,460 --> 00:06:20,280
横向变量的后验信念，

147
00:06:20,280 --> 00:06:23,759
我们

148
00:06:23,759 --> 00:06:25,020
称之为计算后验

149
00:06:25,020 --> 00:06:26,580
分布

150
00:06:26,580 --> 00:06:28,380
我们通过一个称为推理的过程来做到这

151
00:06:28,380 --> 00:06:30,660
一点

152
00:06:30,660 --> 00:06:32,880
，例如，我们可以使用

153
00:06:32,880 --> 00:06:35,699
基于偏差定理的精确推理，因此这是

154
00:06:35,699 --> 00:06:38,759
一个复杂的后验等于

155
00:06:38,759 --> 00:06:41,280
先验乘以似然，然后我们

156
00:06:41,280 --> 00:06:43,860
使用证据进行归一化

157
00:06:43,860 --> 00:06:46,259
，基本上证据是 刚刚

158
00:06:46,259 --> 00:06:49,800
通过对所有拉丁变量 X 求和从分子中获得，

159
00:06:49,800 --> 00:06:53,520


160
00:06:53,520 --> 00:06:56,099
问题是当 X 是一个

161
00:06:56,099 --> 00:06:58,680
连续随机变量时，因为这个

162
00:06:58,680 --> 00:07:01,080
求和变成了一个积分，我们

163
00:07:01,080 --> 00:07:03,720
可能没有这个区间的解析解，

164
00:07:03,720 --> 00:07:05,639


165
00:07:05,639 --> 00:07:08,460
所以这种方法精确的推论会

166
00:07:08,460 --> 00:07:10,919
变得难以处理 因此，

167
00:07:10,919 --> 00:07:13,380
我们在使用 via snap inference 时所做的

168
00:07:13,380 --> 00:07:17,039
是，也许这个 Trooper

169
00:07:17,039 --> 00:07:19,380
立体声非常复杂，但我们将

170
00:07:19,380 --> 00:07:22,199
使用这个 Q 这个 viational 分布来近似它，

171
00:07:22,199 --> 00:07:24,060


172
00:07:24,060 --> 00:07:26,340
并尝试使

173
00:07:26,340 --> 00:07:28,199
这两个分布之间的 Divergence 尽可能接近，

174
00:07:28,199 --> 00:07:30,840
所以在这里 我们有 trooper

175
00:07:30,840 --> 00:07:32,460
stereo on your writer 在这里我们有

176
00:07:32,460 --> 00:07:34,020
一个例子

177
00:07:34,020 --> 00:07:37,380
说明定向后验如何

178
00:07:37,380 --> 00:07:41,160
适合 在

179
00:07:41,160 --> 00:07:43,259
主动推理的背景下，红色的真实后验

180
00:07:43,259 --> 00:07:45,180
方向性分布定义

181
00:07:45,180 --> 00:07:47,780
如下，因此它是一个联合分布，

182
00:07:47,780 --> 00:07:50,160
尽管

183
00:07:50,160 --> 00:07:52,259
模型的所有电子变量，我们正在做我们所说

184
00:07:52,259 --> 00:07:54,419
的平均场近似

185
00:07:54,419 --> 00:07:57,060
，这意味着所有变量在

186
00:07:57,060 --> 00:07:59,039
这个 假设分布是

187
00:07:59,039 --> 00:08:01,560
独立的，因此

188
00:08:01,560 --> 00:08:05,819
pi a b d 和 Gamma

189
00:08:05,819 --> 00:08:07,979
参数不再依赖，我们做了一个小例外

190
00:08:07,979 --> 00:08:11,879
，状态仍然取决于

191
00:08:11,879 --> 00:08:13,199
策略点

192
00:08:13,199 --> 00:08:15,780
好吧，这就是违规分布的定义

193
00:08:15,780 --> 00:08:17,520


194
00:08:17,520 --> 00:08:18,840
，现在我们有了 virational

195
00:08:18,840 --> 00:08:21,360
分布和生成模型我们

196
00:08:21,360 --> 00:08:23,879
可以定义biational Primitive 所以

197
00:08:23,879 --> 00:08:25,919
违背自由能的目标

198
00:08:25,919 --> 00:08:28,379
是确保

199
00:08:28,379 --> 00:08:30,720
近似post child 使我们的

200
00:08:30,720 --> 00:08:32,880
变分分布保持

201
00:08:32,880 --> 00:08:35,339
尽可能接近super style 并且

202
00:08:35,339 --> 00:08:38,219
它被定义为scale Divergence

203
00:08:38,219 --> 00:08:41,339
在近似问题和

204
00:08:41,339 --> 00:08:43,019
生成模型之间，

205
00:08:43,019 --> 00:08:45,480
这也是通过样式自由能

206
00:08:45,480 --> 00:08:48,060


207
00:08:48,060 --> 00:08:51,060
在机器学习中被称为负证据下界或肘部，

208
00:08:51,060 --> 00:08:53,279
它分解为

209
00:08:53,279 --> 00:08:56,399
两个直观的项所以这

210
00:08:56,399 --> 00:08:58,860
是能量的线型我将它分解为

211
00:08:58,860 --> 00:09:00,240


212
00:09:00,240 --> 00:09:02,880
近似和真实

213
00:09:02,880 --> 00:09:05,220
后验之间的 K 散度这是

214
00:09:05,220 --> 00:09:06,899
使近似的项 booster 将

215
00:09:06,899 --> 00:09:09,360
尽可能好地达到真正的后验

216
00:09:09,360 --> 00:09:12,180
，这里我们有证据，但

217
00:09:12,180 --> 00:09:13,680
相对于

218
00:09:13,680 --> 00:09:15,480
我们正在优化的 viational 分布，它是一个常数，

219
00:09:15,480 --> 00:09:18,600
所以是的，Via

220
00:09:18,600 --> 00:09:20,519
Sharp Energy 是第一项的代理，

221
00:09:20,519 --> 00:09:23,839


222
00:09:24,180 --> 00:09:26,899
好吧 所以

223
00:09:26,899 --> 00:09:30,480
传递的是一种推理算法，

224
00:09:30,480 --> 00:09:32,760
基本上它是基于所谓

225
00:09:32,760 --> 00:09:34,680
的毯子标记所以假设我们

226
00:09:34,680 --> 00:09:37,200
想要计算图形模型

227
00:09:37,200 --> 00:09:39,899
中一个特定节点的虚拟后验，

228
00:09:39,899 --> 00:09:42,240


229
00:09:42,240 --> 00:09:45,380
国家表达的意思是

230
00:09:45,380 --> 00:09:48,360
说这个节点 a 仅取决于

231
00:09:48,360 --> 00:09:49,980
它的毛毯标记，

232
00:09:49,980 --> 00:09:52,620
更具体地说，它取决于

233
00:09:52,620 --> 00:09:56,160
a 的孩子，所以这里 D 和 C

234
00:09:56,160 --> 00:09:59,100
它取决于 a 在这里 f

235
00:09:59,100 --> 00:10:02,459
和 g 的平衡 并且在 a 的共同平衡中

236
00:10:02,459 --> 00:10:06,180
，例如这张图片中的 e 和 B，

237
00:10:06,180 --> 00:10:08,820
以及这个宏毯子所说的，

238
00:10:08,820 --> 00:10:10,740
我们只需要知道

239
00:10:10,740 --> 00:10:12,839
马尔可夫括号内变量的值

240
00:10:12,839 --> 00:10:14,880
就可以对 a 进行推理

241
00:10:14,880 --> 00:10:17,640
，

242
00:10:17,640 --> 00:10:20,459
这有点 对这个问题有更正式的

243
00:10:20,459 --> 00:10:22,740
观点，

244
00:10:22,740 --> 00:10:26,459
所以这里我们有

245
00:10:26,459 --> 00:10:30,180
一个随机变量的最优振动分布，

246
00:10:30,180 --> 00:10:33,779
所以这可能是例如 a

247
00:10:33,779 --> 00:10:36,320
，右边的查询为我们

248
00:10:36,320 --> 00:10:39,420
提供了这个呃

249
00:10:39,420 --> 00:10:41,579
后验的解析解，我们看到它只

250
00:10:41,579 --> 00:10:44,220
取决于 在节点本身上，它的父母，

251
00:10:44,220 --> 00:10:48,180
它的孩子和cobalance

252
00:10:48,180 --> 00:10:50,820
，这就是我们需要知道的全部

253
00:10:50,820 --> 00:10:52,399
嗯好吧所以为什么

254
00:10:52,399 --> 00:10:55,800
说消息位来自这个

255
00:10:55,800 --> 00:10:57,560


256
00:10:57,560 --> 00:11:02,160
物理解决方案分解成的消息，这些消息

257
00:11:02,160 --> 00:11:05,040
加在一起形成变分

258
00:11:05,040 --> 00:11:06,600
后验

259
00:11:06,600 --> 00:11:09,180
这里我们可以看到 基本上来自父母的第一条消息

260
00:11:09,180 --> 00:11:11,100
在这里我们

261
00:11:11,100 --> 00:11:13,920
可以看到每一章的一条消息以及

262
00:11:13,920 --> 00:11:15,860
我们所做的，所有这些消息

263
00:11:15,860 --> 00:11:19,200
将被添加以形成参数

264
00:11:19,200 --> 00:11:21,899
近似加部落

265
00:11:21,899 --> 00:11:25,019
这是一个实际的例子，基本上

266
00:11:25,019 --> 00:11:27,300
我们试图对

267
00:11:27,300 --> 00:11:29,519
随机变量 y 施加影响，所以我们想计算

268
00:11:29,519 --> 00:11:31,740


269
00:11:31,740 --> 00:11:33,899
um 的参数分布，就像 y 的后验

270
00:11:33,899 --> 00:11:36,540
分布一样

271
00:11:36,540 --> 00:11:38,100
，我们这样做的方法是发送

272
00:11:38,100 --> 00:11:40,740
消息 从父母一直

273
00:11:40,740 --> 00:11:43,320
通过随机变量 y

274
00:11:43,320 --> 00:11:46,079
和孩子

275
00:11:46,079 --> 00:11:49,019
和组件的相同事情，每次我们

276
00:11:49,019 --> 00:11:51,360
到达因子节点时，我们组合

277
00:11:51,360 --> 00:11:53,579
输入消息并将结果转发

278
00:11:53,579 --> 00:11:55,800
给 y

279
00:11:55,800 --> 00:11:57,540
当我们收到所有消息时，

280
00:11:57,540 --> 00:11:59,940
我们只是添加它们 在一起，这

281
00:11:59,940 --> 00:12:02,160
为我们提供了 y 上的违规分布参数，

282
00:12:02,160 --> 00:12:04,800


283
00:12:04,800 --> 00:12:07,380
所以这是买家的钻石，这

284
00:12:07,380 --> 00:12:09,060
基本上是我们在法国使用的算法，

285
00:12:09,060 --> 00:12:10,500


286
00:12:10,500 --> 00:12:13,260
现在我将谈论 multicarage

287
00:12:13,260 --> 00:12:15,360
研究，这是

288
00:12:15,360 --> 00:12:18,120
一种我们用来展望未来的规划算法 进入

289
00:12:18,120 --> 00:12:21,779
未来并估计每个产品的质量，

290
00:12:21,779 --> 00:12:23,940


291
00:12:23,940 --> 00:12:26,160
所以在此之前我只想

292
00:12:26,160 --> 00:12:29,279
介绍社区指数的概念

293
00:12:29,279 --> 00:12:31,320
嗯，所以在这里我们可以看到树的根，

294
00:12:31,320 --> 00:12:33,720
它是当前时间步的状态

295
00:12:33,720 --> 00:12:35,160


296
00:12:35,160 --> 00:12:38,080
，然后从那里我们看到

297
00:12:38,080 --> 00:12:38,579
[音乐]

298
00:12:38,579 --> 00:12:39,480
嗯

299
00:12:39,480 --> 00:12:42,540
，我们在未来没有，它

300
00:12:42,540 --> 00:12:45,360
由索引序列索引，

301
00:12:45,360 --> 00:12:47,100
例如这里有一个序列

302
00:12:47,100 --> 00:12:49,800
大小为 1 的序列，它只包含

303
00:12:49,800 --> 00:12:52,380
索引 uh one 的动作，

304
00:12:52,380 --> 00:12:55,079
所以这是一个状态，在采取

305
00:12:55,079 --> 00:12:56,399
实际

306
00:12:56,399 --> 00:12:58,200


307
00:12:58,200 --> 00:13:00,360


308
00:13:00,360 --> 00:13:03,060
动作之后，然后这里我们有执行动作 1 后跟动作 2 的状态。

309
00:13:03,060 --> 00:13:05,519
这些索引称为多索引

310
00:13:05,519 --> 00:13:07,380
因为我们是由几个指标组成的，

311
00:13:07,380 --> 00:13:09,180
这些指标

312
00:13:09,180 --> 00:13:11,880
在这里代表可以采取的行动，

313
00:13:11,880 --> 00:13:14,880
所以既然我们记住了这一点，我

314
00:13:14,880 --> 00:13:17,279
就可以讨论多元说明性研究，

315
00:13:17,279 --> 00:13:19,680
所以多元文化研究的

316
00:13:19,680 --> 00:13:22,560
结构分为四个步骤，首先我们

317
00:13:22,560 --> 00:13:24,779
有选择步骤，我们从这里开始

318
00:13:24,779 --> 00:13:28,019
根节点并计算 UCT 标准，

319
00:13:28,019 --> 00:13:30,540
所以这只是我能

320
00:13:30,540 --> 00:13:33,000
记住的每个轨道的真实值

321
00:13:33,000 --> 00:13:36,360
，然后我们选择

322
00:13:36,360 --> 00:13:38,339
实际具有最高速度值

323
00:13:38,339 --> 00:13:41,639
的节点，例如它可能是 S1，所以 t

324
00:13:41,639 --> 00:13:43,560
在采取行动

325
00:13:43,560 --> 00:13:45,480
之后，我们可以计算

326
00:13:45,480 --> 00:13:48,000
出每个子节点的速度，也许这个

327
00:13:48,000 --> 00:13:50,760
节点将是最高值，

328
00:13:50,760 --> 00:13:53,040
一旦我们到达左节点，

329
00:13:53,040 --> 00:13:55,680
我们就可以进入第二阶段

330
00:13:55,680 --> 00:13:57,480
，即扩展

331
00:13:57,480 --> 00:13:59,940
子节点 这个节点和每个孩子

332
00:13:59,940 --> 00:14:02,699
我们要做的只是

333
00:14:02,699 --> 00:14:06,660
模拟这个节点的一些排除规则

334
00:14:06,660 --> 00:14:08,940
我正在计算这个节点的平均预期

335
00:14:08,940 --> 00:14:11,220
频率

336
00:14:11,220 --> 00:14:13,980
一旦我们有了这个就有第四个基础

337
00:14:13,980 --> 00:14:17,399
，它是关于更新的预期

338
00:14:17,399 --> 00:14:21,060
有限度 uh 的祖先，

339
00:14:21,060 --> 00:14:22,500
我们刚刚

340
00:14:22,500 --> 00:14:25,139
扩展了一些访问，因为我们

341
00:14:25,139 --> 00:14:27,240
想探索过去没有探索过的树的一部分，

342
00:14:27,240 --> 00:14:30,839


343
00:14:30,839 --> 00:14:32,820
所以我们需要跟踪

344
00:14:32,820 --> 00:14:36,240
每个分支被分解了多少次好吧

345
00:14:36,240 --> 00:14:39,240
所以这就是计划的算法

346
00:14:39,240 --> 00:14:41,399
，我现在已经介绍

347
00:14:41,399 --> 00:14:44,220
了讨论第一种方法所需的背景

348
00:14:44,220 --> 00:14:46,620
，即分支时间活跃的

349
00:14:46,620 --> 00:14:51,000
婴儿与双侧按摩人员，

350
00:14:51,000 --> 00:14:54,240
所以首先我们需要 为了定义模型，它

351
00:14:54,240 --> 00:14:56,579
基本上分为两部分，第一部分

352
00:14:56,579 --> 00:14:57,740


353
00:14:57,740 --> 00:15:01,019
代表过去和现在，

354
00:15:01,019 --> 00:15:02,880
它基本上是一个部分可观察的

355
00:15:02,880 --> 00:15:04,800
微观决策过程，

356
00:15:04,800 --> 00:15:06,480
如果说我们有

357
00:15:06,480 --> 00:15:09,480
依赖于状态的观察结果，这

358
00:15:09,480 --> 00:15:11,279
是带有矩阵的

359
00:15:11,279 --> 00:15:14,519
我们在那里有动作变量

360
00:15:14,519 --> 00:15:16,320


361
00:15:16,320 --> 00:15:19,079
，正如我所说的

362
00:15:19,079 --> 00:15:21,860
那样，我们有状态所以我说的电机正在

363
00:15:21,860 --> 00:15:24,480
添加，就像它由 a

364
00:15:24,480 --> 00:15:27,120
矩阵参数化一样，转换像往常一样

365
00:15:27,120 --> 00:15:30,060
由 B 度量参数化，我们

366
00:15:30,060 --> 00:15:32,040
这里也有

367
00:15:32,040 --> 00:15:34,380
Z 向量，它定义了 a 先

368
00:15:34,380 --> 00:15:37,740
于初始离子状态，所以这是

369
00:15:37,740 --> 00:15:41,100
来自标准的人工，然后

370
00:15:41,100 --> 00:15:43,980
新颖之处在于我们基本上每次都在扩展

371
00:15:43,980 --> 00:15:46,880
未来，

372
00:15:46,880 --> 00:15:50,040
所以我们没问题，所以我们有

373
00:15:50,040 --> 00:15:52,740
这个模型然后我们进行积极的，比如

374
00:15:52,740 --> 00:15:55,800
um multi-carot 研究，每次 我们

375
00:15:55,800 --> 00:15:57,240
想扩展节点我们所做的

376
00:15:57,240 --> 00:15:59,339
我们将向生成模型添加一些部分

377
00:15:59,339 --> 00:16:01,199
，例如，

378
00:16:01,199 --> 00:16:03,779
如果我们想添加

379
00:16:03,779 --> 00:16:05,940
生成 v 的这一部分 olume 我们将添加

380
00:16:05,940 --> 00:16:08,220
一个转换映射

381
00:16:08,220 --> 00:16:11,579
B 这将添加一个随机变量 呃在

382
00:16:11,579 --> 00:16:15,300
这里它就像 S12 然后我们将

383
00:16:15,300 --> 00:16:17,880
使用似然图添加相关的观察

384
00:16:17,880 --> 00:16:19,980


385
00:16:19,980 --> 00:16:21,959
所以这就是我们在数学上扩展生成

386
00:16:21,959 --> 00:16:23,699
模型的方式

387
00:16:23,699 --> 00:16:25,920
这是定义的 像这样

388
00:16:25,920 --> 00:16:29,100
所以我们在这里看到模型中

389
00:16:29,100 --> 00:16:31,920
所有变量的生成模型我们在模型

390
00:16:31,920 --> 00:16:34,320
的参数上有原始先验

391
00:16:34,320 --> 00:16:38,100
所以 A B 和 G

392
00:16:38,100 --> 00:16:40,980
矩阵状态有时类型为零取决于

393
00:16:40,980 --> 00:16:43,639
D 每个观察取决于相关的状态

394
00:16:43,639 --> 00:16:47,699
到它和一个矩阵

395
00:16:47,699 --> 00:16:50,399
，然后我们对动作进行先验分布，

396
00:16:50,399 --> 00:16:53,459
这取决于一些数据

397
00:16:53,459 --> 00:16:55,500
参数，我们先对其进行除法

398
00:16:55,500 --> 00:16:56,699
，

399
00:16:56,699 --> 00:16:59,759
谢谢，好吧，然后状态像

400
00:16:59,759 --> 00:17:01,620
往常一样取决于先前的状态

401
00:17:01,620 --> 00:17:04,380
和先前的动作以及 B

402
00:17:04,380 --> 00:17:05,880
矩阵，它定义了转换

403
00:17:05,880 --> 00:17:07,980
概率，

404
00:17:07,980 --> 00:17:11,640
所以这是在 GP 版本上，就像

405
00:17:11,640 --> 00:17:16,559
模型的 GP 部分一样，这是一个

406
00:17:16,559 --> 00:17:19,439
树生命结构，它随着

407
00:17:19,439 --> 00:17:21,559
规划的进行而扩展

408
00:17:21,559 --> 00:17:25,799
所以它是一组

409
00:17:25,799 --> 00:17:29,220
在模型中扩展的所有多指标，

410
00:17:29,220 --> 00:17:31,980
例如，如果我回到这里，

411
00:17:31,980 --> 00:17:34,679
我们会看到已经扩展了三个多

412
00:17:34,679 --> 00:17:37,080
指标，

413
00:17:37,080 --> 00:17:39,780
所以我

414
00:17:39,780 --> 00:17:42,960
等于多指标是激进分子说的

415
00:17:42,960 --> 00:17:44,220
两个

416
00:17:44,220 --> 00:17:48,179
和多索引呃一个一个

417
00:17:48,179 --> 00:17:50,100
好吧，现在对于每个军事

418
00:17:50,100 --> 00:17:52,500
索引，我们向通用模型添加一个

419
00:17:52,500 --> 00:17:55,799
转换和似然

420
00:17:55,799 --> 00:17:58,080
映射，这正是我们

421
00:17:58,080 --> 00:18:00,480
对战利品索引集中的每个索引所做的，

422
00:18:00,480 --> 00:18:04,340
我们已经扩展了我们

423
00:18:05,900 --> 00:18:09,140
在未来，

424
00:18:09,660 --> 00:18:12,900
所以现在我们需要

425
00:18:12,900 --> 00:18:15,840
我们需要在一个环境中测试这种方法

426
00:18:15,840 --> 00:18:17,580
，现在我们将

427
00:18:17,580 --> 00:18:20,520
在迷宫环境中测试它

428
00:18:20,520 --> 00:18:24,660
，这里是迷宫的出口，

429
00:18:24,660 --> 00:18:27,840
这里是起始位置

430
00:18:27,840 --> 00:18:30,720
，然后是优先偏好 这些

431
00:18:30,720 --> 00:18:32,760
项目将是我们

432
00:18:32,760 --> 00:18:35,340
离出口越近，观众越快乐

433
00:18:35,340 --> 00:18:37,020


434
00:18:37,020 --> 00:18:39,840
所以这里我们的距离为零

435
00:18:39,840 --> 00:18:43,020
一一二三四

436
00:18:43,020 --> 00:18:45,120
嗯一个非常重要的特征

437
00:18:45,120 --> 00:18:47,340
是先前的偏好

438
00:18:47,340 --> 00:18:51,120
飞越 四，所以这里我们有

439
00:18:51,120 --> 00:18:53,520
一个三，这里我们有

440
00:18:53,520 --> 00:18:56,700
四个距离，我们没有像

441
00:18:56,700 --> 00:19:00,000
五六七八，我们有四个，这个

442
00:19:00,000 --> 00:19:03,240
产生的是一个蓝色单元格，这个

443
00:19:03,240 --> 00:19:05,580
蓝色侧面的蓝色单元格实际上是一个

444
00:19:05,580 --> 00:19:08,220
局部最小值，如果不小心，代理可能会被

445
00:19:08,220 --> 00:19:10,860
卡住

446
00:19:10,860 --> 00:19:12,720
，避免这个局部最小值的方法

447
00:19:12,720 --> 00:19:13,980
将能够计划

448
00:19:13,980 --> 00:19:16,860
最终到未来，看看

449
00:19:16,860 --> 00:19:19,799
奖励路径实际上是这条路径

450
00:19:19,799 --> 00:19:21,600
，注释是导致

451
00:19:21,600 --> 00:19:23,820
局部最小值，所以这基本上是一个

452
00:19:23,820 --> 00:19:26,280
挑战，我们正在将呃添加到

453
00:19:26,280 --> 00:19:28,320
任务中

454
00:19:28,320 --> 00:19:30,780
，这里我们可以看到，所以这里

455
00:19:30,780 --> 00:19:32,400
基本上是正在扩展的树的图示

456
00:19:32,400 --> 00:19:34,919
，这里我们

457
00:19:34,919 --> 00:19:37,320
有结果表，我们看到随着我们

458
00:19:37,320 --> 00:19:39,720
增加

459
00:19:39,720 --> 00:19:43,620
我们从被困在局部最小值内的代理开始的计划迭代次数，

460
00:19:43,620 --> 00:19:46,799
因此永远不会

461
00:19:46,799 --> 00:19:49,440
达到代理的限制，该代理

462
00:19:49,440 --> 00:19:52,140
基本上表现正常，其中

463
00:19:52,140 --> 00:19:55,919
零设置顶部的 100

464
00:19:55,919 --> 00:19:58,320
接下来我们需要比较部分

465
00:19:58,320 --> 00:20:00,539
时间活跃的人我 参考

466
00:20:00,539 --> 00:20:02,100
之前激活的最先进技术

467
00:20:02,100 --> 00:20:03,659
加上

468
00:20:03,659 --> 00:20:06,480
，基本上我们设计了一个环境，

469
00:20:06,480 --> 00:20:09,000
在这个环境中，为了让代理能够

470
00:20:09,000 --> 00:20:12,299
解决它，它必须计划三五，

471
00:20:12,299 --> 00:20:15,840
然后八时间进入未来

472
00:20:15,840 --> 00:20:18,480
以积极影响发生的事情是

473
00:20:18,480 --> 00:20:20,460
它能够正确解决

474
00:20:20,460 --> 00:20:23,280
two plus 任务，但随后发生的事情是

475
00:20:23,280 --> 00:20:25,260
，因为它必须评估未来的策略

476
00:20:25,260 --> 00:20:27,539


477
00:20:27,539 --> 00:20:29,220
数量随着

478
00:20:29,220 --> 00:20:31,740
它必须为最后

479
00:20:31,740 --> 00:20:34,980
一个最大的压碎计划的次数呈指数增长

480
00:20:34,980 --> 00:20:36,780


481
00:20:36,780 --> 00:20:39,299
um 环境如何与我们的方法一样，

482
00:20:39,299 --> 00:20:41,220
这是完全相同的事情，

483
00:20:41,220 --> 00:20:42,900
我们再次增加

484
00:20:42,900 --> 00:20:44,880
计划迭代的次数，我们看到

485
00:20:44,880 --> 00:20:48,000
代理变得能够一直排序

486
00:20:48,000 --> 00:20:48,720


487
00:20:48,720 --> 00:20:51,720
并且不会崩溃，因为它

488
00:20:51,720 --> 00:20:54,480
能够在 聪明的时尚

489
00:20:54,480 --> 00:20:56,580
所有可能的政策空间使用

490
00:20:56,580 --> 00:20:59,400
multi-carot 研究

491
00:20:59,400 --> 00:21:01,500
这是

492
00:21:01,500 --> 00:21:05,340
bti 和主动输入之间的一个非球形比较

493
00:21:05,340 --> 00:21:07,500
现在我想在这个 sl 中做什么 ide 是

494
00:21:07,500 --> 00:21:09,780
在演示中比较它们，就像在隐含类方面一样，

495
00:21:09,780 --> 00:21:11,400
这更具

496
00:21:11,400 --> 00:21:13,260
理论性，

497
00:21:13,260 --> 00:21:15,480
所以基本上这里每个圆

498
00:21:15,480 --> 00:21:17,159
对应于状态的分类

499
00:21:17,159 --> 00:21:19,740
分布，这

500
00:21:19,740 --> 00:21:21,900
意味着要存储这些圆中的一个，我们

501
00:21:21,900 --> 00:21:24,780
需要存储状态的数量，所以

502
00:21:24,780 --> 00:21:26,460
所以一些参数

503
00:21:26,460 --> 00:21:28,919
等于状态值的数量好吧所以如果我们

504
00:21:28,919 --> 00:21:30,960
有一个采用三个值的状态我们

505
00:21:30,960 --> 00:21:35,120
需要存储三个参数

506
00:21:35,159 --> 00:21:38,520
然后对于未来的每个时间步

507
00:21:38,520 --> 00:21:42,360
我们需要存储一个更多的参数一个

508
00:21:42,360 --> 00:21:44,039
分类当 谈到主动

509
00:21:44,039 --> 00:21:47,520
推理，我们还

510
00:21:47,520 --> 00:21:48,960
需要为每个可能的人存储一个更多的类别，

511
00:21:48,960 --> 00:21:51,240
因此总的复杂性

512
00:21:51,240 --> 00:21:53,460
类别等于策略

513
00:21:53,460 --> 00:21:57,000
数量乘以时间步数，直到

514
00:21:57,000 --> 00:21:58,500
时间 Horizo​​n

515
00:21:58,500 --> 00:22:00,360
乘以我们需要的参数数量

516
00:22:00,360 --> 00:22:01,980


517
00:22:01,980 --> 00:22:03,299


518
00:22:03,299 --> 00:22:07,080
现在在最坏的情况下为每个分类分布

519
00:22:07,080 --> 00:22:09,360
存储 BCI 需要存储所以首先要说的

520
00:22:09,360 --> 00:22:11,940
是 bti 不存储每个

521
00:22:11,940 --> 00:22:14,520
可能的组合 它使用

522
00:22:14,520 --> 00:22:16,980
生成模型的树结构来

523
00:22:16,980 --> 00:22:19,380
只存储

524
00:22:19,380 --> 00:22:22,200
过去和现在的一个分布，所以在过去和现在的

525
00:22:22,200 --> 00:22:24,179
第一个时间步

526
00:22:24,179 --> 00:22:27,419
，然后如果我们扩展所有

527
00:22:27,419 --> 00:22:30,179
的交易，那么它将去存储

528
00:22:30,179 --> 00:22:34,080
呃行动的数量 计时器的力量

529
00:22:34,080 --> 00:22:36,539
是负 G

530
00:22:36,539 --> 00:22:38,940
所以这当然仍然是指数的，

531
00:22:38,940 --> 00:22:42,360
因为那里有这个变化，

532
00:22:42,360 --> 00:22:44,760
但实际上我们从来没有扩大

533
00:22:44,760 --> 00:22:46,799
整个交易所以我们所做的

534
00:22:46,799 --> 00:22:49,320
可能是我们会扩大这个这个这个和

535
00:22:49,320 --> 00:22:51,360
这个 但不是另外两个所以在

536
00:22:51,360 --> 00:22:53,820
实践中这个算法的真正复杂性等级与

537
00:22:53,820 --> 00:22:57,000


538
00:22:57,000 --> 00:22:59,159
我们正在制作的扩展数量成

539
00:22:59,159 --> 00:23:01,340
线性关系

540
00:23:03,620 --> 00:23:06,539
不需要像标准职业一样多的存储空间

541
00:23:06,539 --> 00:23:09,960


542
00:23:09,960 --> 00:23:13,080
现在我们想要我想谈谈

543
00:23:13,080 --> 00:23:14,520
第二种方法 基于

544
00:23:14,520 --> 00:23:16,380
贝叶斯过滤，

545
00:23:16,380 --> 00:23:20,340
所以首先什么是偏差和过滤良好的

546
00:23:20,340 --> 00:23:22,559
好处是一种推理算法，它

547
00:23:22,559 --> 00:23:24,240
从一个简单的生成模型开始，该

548
00:23:24,240 --> 00:23:25,679
模型具有

549
00:23:25,679 --> 00:23:29,220
我们实际知道的状态和观察值

550
00:23:29,220 --> 00:23:31,679
我们正在做的观察，

551
00:23:31,679 --> 00:23:34,620
我们也知道先验状态

552
00:23:34,620 --> 00:23:36,720
和可能性是什么，然后我们可以

553
00:23:36,720 --> 00:23:38,280
例如

554
00:23:38,280 --> 00:23:41,400
使用小行星来计算

555
00:23:41,400 --> 00:23:44,820
给定一些观察的状态的后验

556
00:23:44,820 --> 00:23:46,860
，我们是的，一旦我们就这样完成它

557
00:23:46,860 --> 00:23:47,880


558
00:23:47,880 --> 00:23:51,860
有一个状态的后验，

559
00:23:53,039 --> 00:23:56,159
我们可以将它用作经验先验，

560
00:23:56,159 --> 00:23:59,159
所以这是我们的经验先验，我们

561
00:23:59,159 --> 00:24:01,460
也

562
00:24:01,460 --> 00:24:03,659
知道引导我们进入下一个

563
00:24:03,659 --> 00:24:05,279
时间步长的转移概率，

564
00:24:05,279 --> 00:24:07,679
因此我们可以使用此信息

565
00:24:07,679 --> 00:24:08,820
以及我们正在采取的行动 实际上

566
00:24:08,820 --> 00:24:11,159
在环境中执行以计算

567
00:24:11,159 --> 00:24:13,380


568
00:24:13,380 --> 00:24:15,840
时间步骤一的状态的预测后验，给定

569
00:24:15,840 --> 00:24:18,360
我们刚刚执行的操作 u0 和

570
00:24:18,360 --> 00:24:20,220
我们之前进行的观察

571
00:24:20,220 --> 00:24:22,620
以及完成此操作的方式只是通过

572
00:24:22,620 --> 00:24:24,659
执行基础和

573
00:24:24,659 --> 00:24:26,760
预测 就像转换映射一样，

574
00:24:26,760 --> 00:24:29,820
所以对 s0 的维度进行平均

575
00:24:29,820 --> 00:24:32,279


576
00:24:32,279 --> 00:24:34,980
，然后进行另一个观察，

577
00:24:34,980 --> 00:24:36,659
我们可以只

578
00:24:36,659 --> 00:24:38,400
使用我们从之前的

579
00:24:38,400 --> 00:24:41,400
预测步骤中获得的预测后通道 现在

580
00:24:41,400 --> 00:24:42,080


581
00:24:42,080 --> 00:24:45,120
，根据这个新的观察，对 S1 进行 um

582
00:24:45,120 --> 00:24:47,460


583
00:24:47,460 --> 00:24:50,340
整合证据，然后

584
00:24:50,340 --> 00:24:52,440
通过转换映射进行预测 um 的这两个步骤

585
00:24:52,440 --> 00:24:54,179
将根据需要迭代多次

586
00:24:54,179 --> 00:24:56,179
，

587
00:24:56,179 --> 00:24:59,039
因此这导致我们采用我想要的第二种方法

588
00:24:59,039 --> 00:25:00,900
今天展示的是

589
00:25:00,900 --> 00:25:02,820
使用贝叶斯过滤的分支时间主动推理，

590
00:25:02,820 --> 00:25:04,860


591
00:25:04,860 --> 00:25:07,140
所以首先我们不再存储

592
00:25:07,140 --> 00:25:09,720


593
00:25:09,720 --> 00:25:11,700
过去对状态的观察，因为

594
00:25:11,700 --> 00:25:14,159
我们需要的所有信息都存储

595
00:25:14,159 --> 00:25:16,679
在对初始状态的信念中，

596
00:25:16,679 --> 00:25:18,960
例如古兰经

597
00:25:18,960 --> 00:25:22,679
时间戳状态 作为一个强大的时间步，

598
00:25:22,679 --> 00:25:25,559
好的，所以我们有一个观察尝试，

599
00:25:25,559 --> 00:25:27,480
我们可以执行证据步骤的整合，

600
00:25:27,480 --> 00:25:31,200
以获得关于

601
00:25:31,200 --> 00:25:34,740
时间步 T 的状态的信念，然后我们可以

602
00:25:34,740 --> 00:25:37,140
对

603
00:25:37,140 --> 00:25:39,600
我们想要扩展的每个孩子进行前向预测

604
00:25:39,600 --> 00:25:41,640
例如，也许我们会计算这个

605
00:25:41,640 --> 00:25:44,460
，然后计算这个，依此类推

606
00:25:44,460 --> 00:25:46,559
，如果多元文化处于扩展

607
00:25:46,559 --> 00:25:49,260
此图表的状态，那么我们将向前

608
00:25:49,260 --> 00:25:51,659
预测 ion 以及这一点并

609
00:25:51,659 --> 00:25:54,419
扩展其相关观察，

610
00:25:54,419 --> 00:25:57,480
所以这是主要思想所以

611
00:25:57,480 --> 00:25:59,640
这里真正唯一的区别是我们

612
00:25:59,640 --> 00:26:01,620
甚至没有更多的偏离可观察到

613
00:26:01,620 --> 00:26:04,559
过去缺乏决策过程

614
00:26:04,559 --> 00:26:06,320
我们只有

615
00:26:06,320 --> 00:26:08,700
放大时间步并且我们是 还将

616
00:26:08,700 --> 00:26:11,100
推理算法从

617
00:26:11,100 --> 00:26:15,840
违规传递更改为 bazel patreon

618
00:26:15,840 --> 00:26:18,720
，这是通用模型的更正式定义

619
00:26:18,720 --> 00:26:21,120
，因此我们可以

620
00:26:21,120 --> 00:26:22,400
在这里看到

621
00:26:22,400 --> 00:26:25,440


622
00:26:25,440 --> 00:26:28,200
初始下降的可能性和先验夸大这里是示例

623
00:26:28,200 --> 00:26:31,620
团队，然后

624
00:26:31,620 --> 00:26:33,720


625
00:26:33,720 --> 00:26:37,080
是每个未来状态的每个呃 和观察或

626
00:26:37,080 --> 00:26:38,820
每个例程都说我们已经

627
00:26:38,820 --> 00:26:40,679
扩展了我们有

628
00:26:40,679 --> 00:26:42,059
似然映射和

629
00:26:42,059 --> 00:26:45,799
转换映射

630
00:26:45,900 --> 00:26:49,860
在性能方面与之相关我们在这里比较

631
00:26:49,860 --> 00:26:51,960
使用 Biogen 过滤的聚束时间主动推理

632
00:26:51,960 --> 00:26:55,679
到相同的算法

633
00:26:55,679 --> 00:26:57,900
所以 btai 但是不同时间的

634
00:26:57,900 --> 00:27:01,559
人和我们 看到对于相同的任务，其中一个

635
00:27:01,559 --> 00:27:03,299
正在以

636
00:27:03,299 --> 00:27:06,179
大约分钟级的数量级执行，因此

637
00:27:06,179 --> 00:27:08,460
ar 在 4 到 7 分钟之间发现了 4

638
00:27:08,460 --> 00:27:10,380
分钟，其中一位其他

639
00:27:10,380 --> 00:27:13,380
表演者的速度在 2 到 11 秒之间，

640
00:27:13,380 --> 00:27:14,340


641
00:27:14,340 --> 00:27:16,860
所以这种性能的提升

642
00:27:16,860 --> 00:27:19,740
基本上是通过

643
00:27:19,740 --> 00:27:20,659


644
00:27:20,659 --> 00:27:24,200
推理算法的变化实现的，

645
00:27:24,720 --> 00:27:27,480
但是现在我们想要做的是

646
00:27:27,480 --> 00:27:31,380
能够定义更多 不是

647
00:27:31,380 --> 00:27:34,559
每个时间点的一个观察和状态

648
00:27:34,559 --> 00:27:36,779
所以我们要做的是

649
00:27:36,779 --> 00:27:38,159
再次改变保险

650
00:27:38,159 --> 00:27:40,320
算法从

651
00:27:40,320 --> 00:27:42,600
优于过滤到相信

652
00:27:42,600 --> 00:27:45,199
传播

653
00:27:45,240 --> 00:27:47,940
所以什么是信念传播基本上

654
00:27:47,940 --> 00:27:51,240
信念传播是一种

655
00:27:51,240 --> 00:27:54,179
将函数作为输入的算法 在一些

656
00:27:54,179 --> 00:27:55,740
状态变量

657
00:27:55,740 --> 00:27:58,140
和这个函数上，我们知道它

658
00:27:58,140 --> 00:28:01,620
分解成一组 n 个因子，

659
00:28:01,620 --> 00:28:03,659
我们称之为 f i

660
00:28:03,659 --> 00:28:05,940
，问题是当我们边缘化所有其他随机数时，我们如何

661
00:28:05,940 --> 00:28:07,980
计算边际分布，就像

662
00:28:07,980 --> 00:28:11,700
国家在这个函数的边际上一样

663
00:28:11,700 --> 00:28:14,460


664
00:28:14,460 --> 00:28:18,659
可变的，除了一个 SM

665
00:28:18,659 --> 00:28:20,640
好吧所以我们想边缘化

666
00:28:20,640 --> 00:28:23,880
所有 SM 的分布

667
00:28:23,880 --> 00:28:25,860
和我相信传播

668
00:28:25,860 --> 00:28:28,860
解决的方式 这个任务基本上是

669
00:28:28,860 --> 00:28:30,600


670
00:28:30,600 --> 00:28:33,779
通过计算图传递消息，

671
00:28:33,779 --> 00:28:35,520
所以在图中我们有两种

672
00:28:35,520 --> 00:28:37,919
节点，我们有 Factor 节点，

673
00:28:37,919 --> 00:28:39,840
代表分布的因素，

674
00:28:39,840 --> 00:28:43,440
例如 F1，然后我们有随机

675
00:28:43,440 --> 00:28:45,919
变量，

676
00:28:45,960 --> 00:28:48,779
可能是 X1

677
00:28:48,779 --> 00:28:51,179
，我们可能有几个 所以 F2

678
00:28:51,179 --> 00:28:54,000
和 X2

679
00:28:54,000 --> 00:28:56,399
好吧，也许

680
00:28:56,399 --> 00:28:58,380
我们在两者之间有一个转换映射，

681
00:28:58,380 --> 00:28:59,520


682
00:28:59,520 --> 00:29:01,500
所以这是第二个，现在我们

683
00:29:01,500 --> 00:29:04,440
要做的是通过图形传递一些消息

684
00:29:04,440 --> 00:29:07,140
，所以当涉及到

685
00:29:07,140 --> 00:29:12,059
从节点 X 到实际节点的消息时

686
00:29:12,059 --> 00:29:14,520
所以那是因为我们这里还有一个

687
00:29:14,520 --> 00:29:16,559
我们要做的计算

688
00:29:16,559 --> 00:29:19,679
输出消息只是乘以

689
00:29:19,679 --> 00:29:20,940


690
00:29:20,940 --> 00:29:24,059
来自其他箭头的输入消息，

691
00:29:24,059 --> 00:29:27,059
你知道这些箭头指向这个音符，我们

692
00:29:27,059 --> 00:29:29,220
只是乘以所有输入消息

693
00:29:29,220 --> 00:29:31,919
并输出 结果

694
00:29:31,919 --> 00:29:36,179
当涉及到来自某个因素的消息时

695
00:29:36,179 --> 00:29:39,059
，

696
00:29:39,059 --> 00:29:41,940
我们基本上

697
00:29:41,940 --> 00:29:46,559
将采用此关联

698
00:29:46,559 --> 00:29:49,260
到此因素节点的因素

699
00:29:49,260 --> 00:29:51,480
并将其乘以所有传入

700
00:29:51,480 --> 00:29:53,520
消息，因此我们采用所有 inco  ming

701
00:29:53,520 --> 00:29:56,039
消息并将它们乘以

702
00:29:56,039 --> 00:29:58,620
与该 Factor 节点关联的事实

703
00:29:58,620 --> 00:30:01,440
，然后我们将所有

704
00:30:01,440 --> 00:30:04,260
输入维度边缘化，以便消息

705
00:30:04,260 --> 00:30:07,740
的形状与此完全相同，

706
00:30:07,740 --> 00:30:10,679
输出为目标随机变量，

707
00:30:10,679 --> 00:30:13,020
所以这就是边缘化和

708
00:30:13,020 --> 00:30:15,000
说到 我们

709
00:30:15,000 --> 00:30:17,039


710
00:30:17,039 --> 00:30:20,520
对照片中的每一条信息都这样做，然后我们

711
00:30:20,520 --> 00:30:23,100
使用这些信息来计算

712
00:30:23,100 --> 00:30:26,220
边际值，这是这个算法的目标，

713
00:30:26,220 --> 00:30:28,260
我们这样做的方法是

714
00:30:28,260 --> 00:30:30,679
我们只获取所有输入信息

715
00:30:30,679 --> 00:30:33,659
并相乘 他们在一起，这

716
00:30:33,659 --> 00:30:36,059
给了我们

717
00:30:36,059 --> 00:30:39,840
我们想要的特定状态的边际分布，

718
00:30:39,840 --> 00:30:42,360
所以这导致我们在

719
00:30:42,360 --> 00:30:44,760
多因素分支时间活动上进行多模式，

720
00:30:44,760 --> 00:30:46,679
这是我们之前开发的最后一种方法，

721
00:30:46,679 --> 00:30:48,600


722
00:30:48,600 --> 00:30:50,340
能够更多地

723
00:30:50,340 --> 00:30:52,380
谈论这个 方法 我不得不引入

724
00:30:52,380 --> 00:30:55,140
时间风格的概念，

725
00:30:55,140 --> 00:30:58,620
所以最上面的工作幻灯片只是一组

726
00:30:58,620 --> 00:30:59,580
状态

727
00:30:59,580 --> 00:31:04,080
和观察，我们有 Estates 和所有

728
00:31:04,080 --> 00:31:05,760
观察

729
00:31:05,760 --> 00:31:08,100
，所以 t 这是一个板块旋转，它

730
00:31:08,100 --> 00:31:10,140
只是一直复制一个变量，或者

731
00:31:10,140 --> 00:31:11,159
随着时间的推移

732
00:31:11,159 --> 00:31:14,159
，然后我们有那些虚线，

733
00:31:14,159 --> 00:31:16,620
那些虚线所做的只是

734
00:31:16,620 --> 00:31:19,140
将观察连接

735
00:31:19,140 --> 00:31:21,840
到那边状态的一个子集，所以例如，

736
00:31:21,840 --> 00:31:24,059
也许我们有一个观察 这

737
00:31:24,059 --> 00:31:28,158
取决于阶段 1 和状态二

738
00:31:28,260 --> 00:31:30,659
然后也许我们也有观察

739
00:31:30,659 --> 00:31:32,700
但是这个观察 2 只取决于

740
00:31:32,700 --> 00:31:35,340
状态二所以它是虚线的原因

741
00:31:35,340 --> 00:31:37,380
是因为我们可以

742
00:31:37,380 --> 00:31:40,559
在状态和观察之间有一个路径稀疏映射

743
00:31:40,559 --> 00:31:42,480


744
00:31:42,480 --> 00:31:46,100
不必所有可能的连接

745
00:31:46,799 --> 00:31:50,880
都可以，两张幻灯片总产品幻灯片

746
00:31:50,880 --> 00:31:52,980
可以通过过渡

747
00:31:52,980 --> 00:31:55,860
映射连接，这些箭头是这些箭头，这个

748
00:31:55,860 --> 00:31:57,360
箭头的意思是完全相同的，但

749
00:31:57,360 --> 00:32:00,419
在两个时间步之间所以例如

750
00:32:00,419 --> 00:32:04,080
这个呃那边的状态 可以

751
00:32:04,080 --> 00:32:06,179
以任意方式将状态作为前一个时间步长，

752
00:32:06,179 --> 00:32:08,399
就像

753
00:32:08,399 --> 00:32:11,159
观察依赖于状态的任意

754
00:32:11,159 --> 00:32:13,260
子集一样，

755
00:32:13,260 --> 00:32:15,840
但这种表示有点

756
00:32:15,840 --> 00:32:17,820
在呈现整个生成模型时不切实际，

757
00:32:17,820 --> 00:32:20,159


758
00:32:20,159 --> 00:32:22,380
所以我们所做的是将这些顶部

759
00:32:22,380 --> 00:32:23,519
线尺寸表示

760
00:32:23,519 --> 00:32:28,080
为一个称为 t s t 的正方形，因此

761
00:32:28,080 --> 00:32:30,419
右上角的尺寸注意力和

762
00:32:30,419 --> 00:32:32,700
此处的背景是灰色的，因为

763
00:32:32,700 --> 00:32:35,220
顶部幻灯片中的观察是

764
00:32:35,220 --> 00:32:37,500
假设它们实际上被观察到，

765
00:32:37,500 --> 00:32:40,320
而在未来背景将

766
00:32:40,320 --> 00:32:42,960
是白色的，因为

767
00:32:42,960 --> 00:32:44,760
没有观察到观察，

768
00:32:44,760 --> 00:32:46,740
所以现在让我们抓住这个更紧凑的

769
00:32:46,740 --> 00:32:49,140
演示，我们可以展示

770
00:32:49,140 --> 00:32:51,419
生成模型，所以在这里我们看到

771
00:32:51,419 --> 00:32:52,919
初始时间步长

772
00:32:52,919 --> 00:32:56,039
，然后从那里我们 可以

773
00:32:56,039 --> 00:32:58,860
在

774
00:32:58,860 --> 00:33:03,000
多元文化研究要求我们的时候准确地扩展一些中性大小，所以我们

775
00:33:03,000 --> 00:33:04,500
从那里开始也许我们计算 UC

776
00:33:04,500 --> 00:33:07,980
标准这是最高的呃

777
00:33:07,980 --> 00:33:10,679
具有最高标准的节点所以

778
00:33:10,679 --> 00:33:12,419
我们基本上被要求扩展这些

779
00:33:12,419 --> 00:33:13,279
孩子

780
00:33:13,279 --> 00:33:15,899
，我们可以做 因此，仅使用

781
00:33:15,899 --> 00:33:17,539
前向预测

782
00:33:17,539 --> 00:33:20,039
来计算此处的状态，然后

783
00:33:20,039 --> 00:33:22,380
我们再次使用前向预测

784
00:33:22,380 --> 00:33:24,480
来预测 futu 重新

785
00:33:24,480 --> 00:33:27,120
观察再次与这个顶部的一个

786
00:33:27,120 --> 00:33:28,380
切片

787
00:33:28,380 --> 00:33:31,100
外部

788
00:33:35,480 --> 00:33:38,640
变量相关联，它是时间 T

789
00:33:38,640 --> 00:33:41,279
的时间大小的概率

790
00:33:41,279 --> 00:33:43,919
乘以所有未来

791
00:33:43,919 --> 00:33:46,200
时间控制大小的乘积好吧所以所有

792
00:33:46,200 --> 00:33:47,340
右上角的大小我们已经

793
00:33:47,340 --> 00:33:51,120
在 multi- 当前的研究

794
00:33:51,120 --> 00:33:54,659
每个观察都依赖于

795
00:33:54,659 --> 00:33:56,039
初始类型的幻灯片，所以这是

796
00:33:56,039 --> 00:33:58,440
最初几次这个观察

797
00:33:58,440 --> 00:34:00,360
取决于这个最顶层大小内的状态子集

798
00:34:00,360 --> 00:34:03,360
，因为

799
00:34:03,360 --> 00:34:05,940
我们在树的顶部，所以在

800
00:34:05,940 --> 00:34:09,839
时间步 T 处的状态 之后不依赖任何东西

801
00:34:09,839 --> 00:34:12,899
，对于未来的每个流行尺寸，

802
00:34:12,899 --> 00:34:15,780
我们仍然依赖

803
00:34:15,780 --> 00:34:18,540
于呃，我们仍然有一个事实，

804
00:34:18,540 --> 00:34:20,099
即观察取决于

805
00:34:20,099 --> 00:34:22,560
秒表幻灯片中的状态，但我们也

806
00:34:22,560 --> 00:34:25,079
有一个事实，即本主题中的状态

807
00:34:25,079 --> 00:34:28,079
幻灯片取决于

808
00:34:28,079 --> 00:34:30,060
前一个状态，就像当前顶部的幻灯片一样，

809
00:34:30,060 --> 00:34:31,619
所以例如

810
00:34:31,619 --> 00:34:33,899
这个右上角的状态大小

811
00:34:33,899 --> 00:34:37,739
一半平衡在这个顶部的一个切片里面

812
00:34:37,739 --> 00:34:39,659


813
00:34:39,659 --> 00:34:41,520
好吧 这是生成

814
00:34:41,520 --> 00:34:43,440
模型的定义

815
00:34:43,440 --> 00:34:46,500
方式 现在我们执行实例的方式是使用

816
00:34:46,500 --> 00:34:50,339
我们所说的 IP IP 算法 所以我

817
00:34:50,339 --> 00:34:53,520
代表推理，P 代表

818
00:34:53,520 --> 00:34:56,399
预测

819
00:34:56,399 --> 00:34:58,980
所以这张幻灯片是关于推理选项卡的

820
00:34:58,980 --> 00:35:01,560
，目标是计算

821
00:35:01,560 --> 00:35:05,160
在舞台后部 uh 初始

822
00:35:05,160 --> 00:35:07,740
像当前模板幻灯片

823
00:35:07,740 --> 00:35:09,900
鉴于观察我不打算

824
00:35:09,900 --> 00:35:11,820
通过这个推导但是

825
00:35:11,820 --> 00:35:13,440
如果你在 YouTube 上观看它你可以暂停视频

826
00:35:13,440 --> 00:35:15,000


827
00:35:15,000 --> 00:35:15,660


828
00:35:15,660 --> 00:35:18,300
嗯但是是的所以基本上我们做一些

829
00:35:18,300 --> 00:35:19,800
推导然后 我们获得了这个

830
00:35:19,800 --> 00:35:21,000
解决方案

831
00:35:21,000 --> 00:35:23,040
，它告诉我们将乘积

832
00:35:23,040 --> 00:35:25,980
用于所有玩家的所有电子映射

833
00:35:25,980 --> 00:35:28,260
，然后使用构建

834
00:35:28,260 --> 00:35:30,839
传播来实际边缘化

835
00:35:30,839 --> 00:35:34,140
这个功能

836
00:35:34,140 --> 00:35:36,599
，这正是我们要做的

837
00:35:36,599 --> 00:35:39,180
，我们在当前使用大传播

838
00:35:39,180 --> 00:35:41,160
时间戳所以如果我回到这里

839
00:35:41,160 --> 00:35:43,320
我们在这里有一些观察并且我们使用

840
00:35:43,320 --> 00:35:44,940
构建传播来计算

841
00:35:44,940 --> 00:35:49,079
初始拓扑中的状态

842
00:35:49,079 --> 00:35:52,320
所以这是 ISTE 的每个步骤 P

843
00:35:52,320 --> 00:35:53,820
是我们的兴趣所在，

844
00:35:53,820 --> 00:35:56,520


845
00:35:56,520 --> 00:35:59,339
每次多元文化研究告诉我们

846
00:35:59,339 --> 00:36:02,040
扩展通用模型的一部分时，我们都需要执行 p 步，

847
00:36:02,040 --> 00:36:03,540
所以我不会再次

848
00:36:03,540 --> 00:36:05,460
进行这种推导，但

849
00:36:05,460 --> 00:36:09,119
基本上 ID 是为了计算 鉴于我们在当前模板幻灯片中所做的观察，

850
00:36:09,119 --> 00:36:11,760
下一个组件大小的状态的后验

851
00:36:11,760 --> 00:36:13,980


852
00:36:13,980 --> 00:36:16,640


853
00:36:16,640 --> 00:36:19,440
所以在这里我们再次看到阳台

854
00:36:19,440 --> 00:36:22,320
我们对

855
00:36:22,320 --> 00:36:24,420


856
00:36:24,420 --> 00:36:27,300
我们想要的前五张幻灯片中的所有状态的父级进行某种总结

857
00:36:27,300 --> 00:36:29,700
来计算后验形式

858
00:36:29,700 --> 00:36:33,000
，这是我们知道的转换映射

859
00:36:33,000 --> 00:36:35,760
，这

860
00:36:35,760 --> 00:36:37,980
是来自先前样本大小的后验分布，

861
00:36:37,980 --> 00:36:39,720


862
00:36:39,720 --> 00:36:41,220
所以基本上我们所做的只是

863
00:36:41,220 --> 00:36:43,140
在这种情况下进行前向预测，

864
00:36:43,140 --> 00:36:45,960
采用我们可以做的转换级别的期望

865
00:36:45,960 --> 00:36:46,920


866
00:36:46,920 --> 00:36:49,320
这是舞台

867
00:36:49,320 --> 00:36:53,040
并暂停观察

868
00:36:53,040 --> 00:36:56,040
以便回到主图我们

869
00:36:56,040 --> 00:36:57,839
首先使用

870
00:36:57,839 --> 00:36:59,760
ISTEP 计算状态和初始几张幻灯片的后验

871
00:36:59,760 --> 00:37:01,859


872
00:37:01,859 --> 00:37:05,040
所以我 是 ISTEP 然后我们可以使用

873
00:37:05,040 --> 00:37:07,560
这些后验分布来

874
00:37:07,560 --> 00:37:11,280
计算未来状态的后验

875
00:37:11,280 --> 00:37:13,020
所以也许是这张

876
00:37:13,020 --> 00:37:15,540
双幻灯片中的状态然后我们可以

877
00:37:15,540 --> 00:37:17,099
再次使用关键步骤

878
00:37:17,099 --> 00:37:20,400
来计算

879
00:37:20,400 --> 00:37:22,320
对应的未来观察的分布

880
00:37:22,320 --> 00:37:24,180
到停止蝴蝶，我们将

881
00:37:24,180 --> 00:37:27,780
这样做或时间步长，就像

882
00:37:27,780 --> 00:37:29,579
我们希望在未来扩展的幻灯片的所有顶部一样

883
00:37:29,579 --> 00:37:32,180


884
00:37:33,060 --> 00:37:35,460
，接下来我们需要

885
00:37:35,460 --> 00:37:38,520
定义并持续这种方法的是

886
00:37:38,520 --> 00:37:40,920
预期的免费 发射所以基本上

887
00:37:40,920 --> 00:37:43,380
是我们要定义的地方

888
00:37:43,380 --> 00:37:46,079
首先将所有观察分组到

889
00:37:46,079 --> 00:37:48,480
遥远的子集中

890
00:37:48,480 --> 00:37:51,599
所以基本上o我是

891
00:37:51,599 --> 00:37:54,060
右上角大小索引中所有观察的集合

892
00:37:54,060 --> 00:37:57,720
通过静音这个离子

893
00:37:57,720 --> 00:38:00,919
好吧现在我们将解释

894
00:38:05,940 --> 00:38:08,220
一次 我们已经将这些观察结果

895
00:38:08,220 --> 00:38:10,320
分组为我们定义预期自由能的方式的子集，就像

896
00:38:10,320 --> 00:38:13,380


897
00:38:13,380 --> 00:38:16,380
所有可能

898
00:38:16,380 --> 00:38:20,220
的随机变量组的总和，所以每一个

899
00:38:20,220 --> 00:38:22,260
都将迭代那些

900
00:38:22,260 --> 00:38:23,460
和 th  en

901
00:38:23,460 --> 00:38:25,380
进入

902
00:38:25,380 --> 00:38:27,800
之前

903
00:38:31,560 --> 00:38:33,540
um 预测后风格过程

904
00:38:33,540 --> 00:38:34,740
观察之间的日历版本，

905
00:38:34,740 --> 00:38:36,480
所以这是风险术语，

906
00:38:36,480 --> 00:38:38,520
即将发生的事情和

907
00:38:38,520 --> 00:38:40,859
我们想要的事情之间的颜色版本

908
00:38:40,859 --> 00:38:43,500
，然后我们将

909
00:38:43,500 --> 00:38:45,900
计算每个观察的模糊性

910
00:38:45,900 --> 00:38:49,520
，即 通常定义

911
00:38:49,520 --> 00:38:53,579
为似然映射的预期熵，

912
00:38:53,579 --> 00:38:57,180
所以这个构建方程

913
00:38:57,180 --> 00:38:59,940
对于没有创建论文的人来说可能是新的，

914
00:38:59,940 --> 00:39:01,380


915
00:39:01,380 --> 00:39:04,859
但我们可以看一个特定的案例

916
00:39:04,859 --> 00:39:07,320
，这使得它更直观，

917
00:39:07,320 --> 00:39:09,359
基本上特定的案例就是当

918
00:39:09,359 --> 00:39:11,760
每个 子集对应

919
00:39:11,760 --> 00:39:15,599
于前五名中的一个观察值，在这种

920
00:39:15,599 --> 00:39:19,020
情况下，特定处理的预期能量

921
00:39:19,020 --> 00:39:21,000
因此对于一个特定的

922
00:39:21,000 --> 00:39:22,820
多指标

923
00:39:22,820 --> 00:39:26,520
只是特定观察值的风险

924
00:39:26,520 --> 00:39:27,859


925
00:39:27,859 --> 00:39:30,720
加上模糊性或特定

926
00:39:30,720 --> 00:39:32,820
观察值，所以我们仍然有模糊性

927
00:39:32,820 --> 00:39:36,000
加上风险

928
00:39:36,000 --> 00:39:37,619
和 现在我们需要

929
00:39:37,619 --> 00:39:39,480
嗯来展示一起测试这些

930
00:39:39,480 --> 00:39:42,000
方法所以比较分支

931
00:39:42,000 --> 00:39:44,040
时间和第二次机会与不同的

932
00:39:44,040 --> 00:39:46,380
时间 这种不过滤的测试

933
00:39:46,380 --> 00:39:48,420
和最后一种基于

934
00:39:48,420 --> 00:39:50,520
传播

935
00:39:50,520 --> 00:39:52,500
的方法我们将要这样做的方法是

936
00:39:52,500 --> 00:39:56,940
使用这五个数据集的方差，

937
00:39:56,940 --> 00:39:58,980


938
00:39:58,980 --> 00:40:01,079
基本上我们

939
00:40:01,079 --> 00:40:04,319
将环境表示为指南

940
00:40:04,319 --> 00:40:05,640
，

941
00:40:05,640 --> 00:40:07,920
所以我们可以这样做 环境我们有

942
00:40:07,920 --> 00:40:10,619
三种不同的形状我们有添加剂

943
00:40:10,619 --> 00:40:13,980
我们需要被拉向

944
00:40:13,980 --> 00:40:16,319
图像的右下角我们

945
00:40:16,319 --> 00:40:18,480
有正方形并且正方形需要被

946
00:40:18,480 --> 00:40:21,180
拉到

947
00:40:21,180 --> 00:40:23,160
图像

948
00:40:23,160 --> 00:40:25,940
的左下角因为有太多的

949
00:40:25,940 --> 00:40:29,880
位置 在 X 和 Y 中，我们所做的是

950
00:40:29,880 --> 00:40:34,380
进行某种形式的状态聚合，

951
00:40:34,380 --> 00:40:36,960
对于右左角和左上角的第八个第一个位置，

952
00:40:36,960 --> 00:40:39,180


953
00:40:39,180 --> 00:40:41,579


954
00:40:41,579 --> 00:40:43,500
如果形状位于这八个位置之一，

955
00:40:43,500 --> 00:40:45,780
我们将把它们聚合

956
00:40:45,780 --> 00:40:48,839
成一个状态 索引为 0。

957
00:40:48,839 --> 00:40:50,760
为此，它将在索引 1 中，然后

958
00:40:50,760 --> 00:40:53,400
依此类推，二三四加到

959
00:40:53,400 --> 00:40:56,760
19 的正方形，如果它伤害我们

960
00:40:56,760 --> 00:40:59,339
将分配这些州

961
00:40:59,339 --> 00:41:03,359
um 索引在 20 和 39 之间。

962
00:41:03,359 --> 00:41:05,579
和 s

963
00:41:05,579 --> 00:41:07,079
例如，我们所做的基本上是

964
00:41:07,079 --> 00:41:09,420
减少状态空间，以便其中

965
00:41:09,420 --> 00:41:11,460
一些方法仍然可以做一些事情，

966
00:41:11,460 --> 00:41:14,280
因为它们不够强大，

967
00:41:14,280 --> 00:41:16,380
无法解决整个

968
00:41:16,380 --> 00:41:17,960
um 状态空间，

969
00:41:17,960 --> 00:41:20,940
所以这里是我们比较

970
00:41:20,940 --> 00:41:23,640
金融表达和贝叶斯

971
00:41:23,640 --> 00:41:25,560
过滤的结果 最后一个是

972
00:41:25,560 --> 00:41:28,700
基于信念传播

973
00:41:28,819 --> 00:41:31,319
研究通过的，我们必须使用

974
00:41:31,319 --> 00:41:34,079
4 的粒度，这意味着

975
00:41:34,079 --> 00:41:36,900
像正方形大小一样的

976
00:41:36,900 --> 00:41:41,460
长度就像一个像正方形的 4x4 集，所以

977
00:41:41,460 --> 00:41:44,339
单元格的大小为 4  4

978
00:41:44,339 --> 00:41:46,260
，使用此设置，我们能够

979
00:41:46,260 --> 00:41:49,560
解决 96 次

980
00:41:49,560 --> 00:41:53,640
，

981
00:41:53,640 --> 00:41:54,420


982
00:41:54,420 --> 00:41:58,980
一次试验的 1 um 平均时间约为 5 秒

983
00:41:58,980 --> 00:42:02,339
，使用基本和过滤方法，

984
00:42:02,339 --> 00:42:04,859
我们能够降低到 2 的粒度

985
00:42:04,859 --> 00:42:07,920
，所以这次是单元格 有

986
00:42:07,920 --> 00:42:09,420
两个乘两个的大小

987
00:42:09,420 --> 00:42:12,119
，有了这个，我有了这个

988
00:42:12,119 --> 00:42:15,420
粒度，氢就能够

989
00:42:15,420 --> 00:42:19,740
解决时间的任务 98，

990
00:42:19,740 --> 00:42:21,180
而

991
00:42:21,180 --> 00:42:23,240
嗯，

992
00:42:23,339 --> 00:42:25,140
但问题是因为我们减小

993
00:42:25,140 --> 00:42:27,119
了颗粒的大小 事实上，我们还

994
00:42:27,119 --> 00:42:30,180
增加了舞台空间的大小，

995
00:42:30,180 --> 00:42:32,880
这会增加

996
00:42:32,880 --> 00:42:35,579
计算时间，这意味着

997
00:42:35,579 --> 00:42:37,319
每个预告片现在需要大约 17

998
00:42:37,319 --> 00:42:40,020
秒才能

999
00:42:40,020 --> 00:42:43,079
执行最后一种方法，可能我们使用的

1000
00:42:43,079 --> 00:42:46,020
事实是我们现在知道

1001
00:42:46,020 --> 00:42:48,000
分解 似然和过渡映射

1002
00:42:48,000 --> 00:42:51,599
，这使我们能够一直

1003
00:42:51,599 --> 00:42:54,420
下降到不像唯一一个很酷的范围，

1004
00:42:54,420 --> 00:42:56,040
所以我们现在能够

1005
00:42:56,040 --> 00:42:58,500
区分

1006
00:42:58,500 --> 00:43:02,640
图像内的每个 X 和 Y 位置，

1007
00:43:02,640 --> 00:43:05,040
并且通过这种粒度我们可以解决

1008
00:43:05,040 --> 00:43:07,200
这个任务非常完美，因为我们可以

1009
00:43:07,200 --> 00:43:08,760
利用

1010
00:43:08,760 --> 00:43:10,800
类似的分布分解，

1011
00:43:10,800 --> 00:43:13,859
我们比

1012
00:43:13,859 --> 00:43:15,780
以前的所有方法都快得多，我们可以

1013
00:43:15,780 --> 00:43:18,839
在大约 2.5 秒内解决这个任务，

1014
00:43:18,839 --> 00:43:21,480
所以我

1015
00:43:21,480 --> 00:43:24,180
只想说清楚一件事 在这里，因为这种

1016
00:43:24,180 --> 00:43:25,980
方法能够直接对

1017
00:43:25,980 --> 00:43:30,240
每个 y 位置建模，每个 Exposition

1018
00:43:30,240 --> 00:43:31,980
里面的每个形状，

1019
00:43:31,980 --> 00:43:34,740
就像你知道的形状

1020
00:43:34,740 --> 00:43:36,780
，环境显示的形状，什么是方向

1021
00:43:36,780 --> 00:43:38,460
像形状的可能方向

1022
00:43:38,460 --> 00:43:40,800
和/或尺度

1023
00:43:40,800 --> 00:43:42,960
um 这样基本上

1024
00:43:42,960 --> 00:43:45,900
每个形状都可以有不同的大小，

1025
00:43:45,900 --> 00:43:49,500
这个尺度 Dimension 表示所以

1026
00:43:49,500 --> 00:43:51,359
基本上这是

1027
00:43:51,359 --> 00:43:54,420
处理大约 700

1028
00:43:54,420 --> 00:43:57,740
000 个状态空间配置的可靠方法，

1029
00:43:57,740 --> 00:44:00,780
现在我们已经介绍了 结果并

1030
00:44:00,780 --> 00:44:03,480
表明这种方法接近

1031
00:44:03,480 --> 00:44:06,180
日常性能可以带来非常

1032
00:44:06,180 --> 00:44:08,640
好的性能但是现在我们如何

1033
00:44:08,640 --> 00:44:10,920
交易呃在这里我有一个非常小的

1034
00:44:10,920 --> 00:44:14,160
呃代码示例直接我正在

1035
00:44:14,160 --> 00:44:17,640
从环境中检索 a b

1036
00:44:17,640 --> 00:44:19,440
c 和 d 矩阵

1037
00:44:19,440 --> 00:44:21,200
C 矩阵

1038
00:44:21,200 --> 00:44:24,000
对称对应于

1039
00:44:24,000 --> 00:44:27,599
代理的先验偏好，正如我

1040
00:44:27,599 --> 00:44:29,700
已经多次说过的，a 对应

1041
00:44:29,700 --> 00:44:31,740
于可能性 a b 对应于

1042
00:44:31,740 --> 00:44:33,780
转换，是初始状态的先验

1043
00:44:33,780 --> 00:44:35,520


1044
00:44:35,520 --> 00:44:37,440
，然后我们将

1045
00:44:37,440 --> 00:44:40,980
创建 bti 三个 agents 只是通过

1046
00:44:40,980 --> 00:44:43,859
创建顶部的 wire slides Builder 告诉

1047
00:44:43,859 --> 00:44:45,900
他我们有一个动作，

1048
00:44:45,900 --> 00:44:49,260
称为下划线零，然后给它

1049
00:44:49,260 --> 00:44:50,760
数 该

1050
00:44:50,760 --> 00:44:52,380
指令可以采用的值

1051
00:44:52,380 --> 00:44:55,619
然后我们只需

1052
00:44:55,619 --> 00:44:57,420
为我们系统的每个状态添加一个状态所以 X

1053
00:44:57,420 --> 00:44:59,700
位置 y 位置形状比例和

1054
00:44:59,700 --> 00:45:02,220
方向我们提供作为第二个

1055
00:45:02,220 --> 00:45:05,040
参数 pack 是

1056
00:45:05,040 --> 00:45:08,099
状态试验的参数所以 现在在

1057
00:45:08,099 --> 00:45:10,079
我们的生成模型中我们有了系统的状态

1058
00:45:10,079 --> 00:45:11,640


1059
00:45:11,640 --> 00:45:14,099
然后我们需要

1060
00:45:14,099 --> 00:45:16,980
直接为每个阶段添加观察我们添加

1061
00:45:16,980 --> 00:45:19,619
一个不同的观察

1062
00:45:19,619 --> 00:45:23,040
通过矩阵依赖于这个状态

1063
00:45:23,040 --> 00:45:25,619
所以我们提供一个矩阵和父母列表

1064
00:45:25,619 --> 00:45:27,300


1065
00:45:27,300 --> 00:45:29,579
基本上我们

1066
00:45:29,579 --> 00:45:33,660
在通用模型中为每个状态添加一个观察

1067
00:45:33,660 --> 00:45:36,660
所以在最后一步之前

1068
00:45:36,660 --> 00:45:39,119
只是添加转换所以基本上对于

1069
00:45:39,119 --> 00:45:42,480
系统中的每个阶段我们说什么

1070
00:45:42,480 --> 00:45:44,940
是需要使用的 B 矩阵以及

1071
00:45:44,940 --> 00:45:47,339
什么是素数 此文本的父母，

1072
00:45:47,339 --> 00:45:50,160
例如，代理人在 X 中的位置

1073
00:45:50,160 --> 00:45:52,380
取决于

1074
00:45:52,380 --> 00:45:54,780
上一学期时间

1075
00:45:54,780 --> 00:45:56,460
步长的 X 中的发音以及正在

1076
00:45:56,460 --> 00:45:57,660
执行的操作

1077
00:45:57,660 --> 00:46:00,259
foreign

1078
00:46:00,319 --> 00:46:03,420
pr 模型中的 obabilities

1079
00:46:03,420 --> 00:46:05,700
和构建右上角尺寸之前的最后一步

1080
00:46:05,700 --> 00:46:08,339
只是定义我们的

1081
00:46:08,339 --> 00:46:10,800
先验偏好，因为在

1082
00:46:10,800 --> 00:46:12,599
显示数据集中我们需要应用我们

1083
00:46:12,599 --> 00:46:15,180
对 X Y 和

1084
00:46:15,180 --> 00:46:19,500
blob 形状的偏好我们所做的我们我们 说这里

1085
00:46:19,500 --> 00:46:22,020
是一个因素，所以这是观察的 X

1086
00:46:22,020 --> 00:46:24,300
个子集之一

1087
00:46:24,300 --> 00:46:26,160
，我们提供与之相关的三个矩阵

1088
00:46:26,160 --> 00:46:27,720
，

1089
00:46:27,720 --> 00:46:30,839
然后我们调用

1090
00:46:30,839 --> 00:46:33,300
刚刚返回顶部切片的函数构建

1091
00:46:33,300 --> 00:46:36,540
，我们创建一个 PCI 三映射代理

1092
00:46:36,540 --> 00:46:39,119
，它使用股票 价格幻灯片，我们

1093
00:46:39,119 --> 00:46:40,680
提供了一些

1094
00:46:40,680 --> 00:46:42,599
我们希望算法使用的计划迭代以及

1095
00:46:42,599 --> 00:46:44,760
交易者

1096
00:46:44,760 --> 00:46:49,140
探索与探索

1097
00:46:49,140 --> 00:46:52,640
表达式开发的探索常数

1098
00:46:52,800 --> 00:46:56,400
，这是

1099
00:46:56,400 --> 00:46:57,599
我们一直在开发的图形用户界面，

1100
00:46:57,599 --> 00:47:00,720
特别是在这里我们可以看到初始供应

1101
00:47:00,720 --> 00:47:03,780
呃 如果我们在软件中，我们

1102
00:47:03,780 --> 00:47:05,940
可以点击立场幻灯片，

1103
00:47:05,940 --> 00:47:08,220
查看所有状态变量的不同帖子样式，

1104
00:47:08,220 --> 00:47:11,099


1105
00:47:11,099 --> 00:47:13,619
我们也可以看到不同的

1106
00:47:13,619 --> 00:47:16,079
关于那些作为秒表样式的信息，所以

1107
00:47:16,079 --> 00:47:17,700
一直以来访问的

1108
00:47:17,700 --> 00:47:19,980
次数，然后我们可以使用

1109
00:47:19,980 --> 00:47:22,559
左侧右侧的按钮

1110
00:47:22,559 --> 00:47:25,200
基本上执行逐步的

1111
00:47:25,200 --> 00:47:27,300
multicarage 研究，所以会发生什么

1112
00:47:27,300 --> 00:47:29,579
在界面中，我们将

1113
00:47:29,579 --> 00:47:31,500
添加孩子

1114
00:47:31,500 --> 00:47:33,119
，然后我们将能够单击

1115
00:47:33,119 --> 00:47:35,760
这些孩子来探索

1116
00:47:35,760 --> 00:47:38,400
树木的那些部分，因此我们将来会获得

1117
00:47:38,400 --> 00:47:40,440
有关术语水滑梯的信息，

1118
00:47:40,440 --> 00:47:42,119


1119
00:47:42,119 --> 00:47:44,880
因此这是您可以使用的另一个工具

1120
00:47:44,880 --> 00:47:47,819
用于分析代理人的计划和信念

1121
00:47:47,819 --> 00:47:49,940


1122
00:47:49,940 --> 00:47:52,380
好的，所以我现在

1123
00:47:52,380 --> 00:47:53,640
已经完成了介绍不同的

1124
00:47:53,640 --> 00:47:55,380
方法，现在是我

1125
00:47:55,380 --> 00:47:58,079
结束本次介绍的时候了，

1126
00:47:58,079 --> 00:47:59,520
所以我们已经看到了三种不同的

1127
00:47:59,520 --> 00:48:01,859
方法，第一种是基于

1128
00:48:01,859 --> 00:48:04,500
bioslamic slash passing，显然

1129
00:48:04,500 --> 00:48:06,180
使用主动入口和Medical Art

1130
00:48:06,180 --> 00:48:07,200


1131
00:48:07,200 --> 00:48:11,119
研究第三个是基于业务的

1132
00:48:11,119 --> 00:48:13,980
，最后一个是基于IP

1133
00:48:13,980 --> 00:48:16,260
算法的，它是信念

1134
00:48:16,260 --> 00:48:19,920
传播和前向预测

1135
00:48:19,920 --> 00:48:23,579
的混合 s 的性能第一个所以 bti

1136
00:48:23,579 --> 00:48:27,480
vnp 基本上

1137
00:48:27,480 --> 00:48:29,280
比第二个慢，性能比第二个慢

1138
00:48:29,280 --> 00:48:31,619
，呃，性能比第三

1139
00:48:31,619 --> 00:48:33,859
个

1140
00:48:34,020 --> 00:48:37,140
好，但即使在性能方面的这种提高，

1141
00:48:37,140 --> 00:48:39,420
一种

1142
00:48:39,420 --> 00:48:41,040
方法到下一种方法仍然

1143
00:48:41,040 --> 00:48:43,680
有一些 我们可以解决的任务，例如，

1144
00:48:43,680 --> 00:48:48,059
我们如何解决基于图像的问题，

1145
00:48:48,059 --> 00:48:50,160
或者目前尚不清楚我们如何学习

1146
00:48:50,160 --> 00:48:51,660
生成模型的结构，

1147
00:48:51,660 --> 00:48:54,780
建模者必须提供

1148
00:48:54,780 --> 00:48:56,579
模型的描述，

1149
00:48:56,579 --> 00:48:58,740
但如果我们 可以

1150
00:48:58,740 --> 00:49:02,579
从数据中学习它，

1151
00:49:02,579 --> 00:49:05,220
而且现在我们基本上已经

1152
00:49:05,220 --> 00:49:08,760
为 like 提供了有用

1153
00:49:08,760 --> 00:49:12,240
的动作序列的动作，例如，如果我们

1154
00:49:12,240 --> 00:49:14,880
回到所描述的隔间，我们

1155
00:49:14,880 --> 00:49:17,520
可以想象一个任务，每次我们

1156
00:49:17,520 --> 00:49:20,700
走对它只是推动形状

1157
00:49:20,700 --> 00:49:22,619
右边一个位置，然后一个位置，然后一个位置，

1158
00:49:22,619 --> 00:49:24,480
但我们

1159
00:49:24,480 --> 00:49:27,480
一直在做的使计划可指导的

1160
00:49:27,480 --> 00:49:29,760
只是将所有这些动作

1161
00:49:29,760 --> 00:49:32,220
组合在一起，也许执行 l 就像总共八个

1162
00:49:32,220 --> 00:49:34,380
动作或可能总共四个动作，

1163
00:49:34,380 --> 00:49:37,619
但这有其局限性

1164
00:49:37,619 --> 00:49:39,960
，如果我们可以自动

1165
00:49:39,960 --> 00:49:41,700
运行这样的功能序列，那将非常好，

1166
00:49:41,700 --> 00:49:43,920


1167
00:49:43,920 --> 00:49:46,319
但这就是我想在这里说的是

1168
00:49:46,319 --> 00:49:48,720
糖霜，如果你

1169
00:49:48,720 --> 00:49:52,740
想在 介绍，是的，谢谢

1170
00:49:52,740 --> 00:49:54,859
，

1171
00:49:56,640 --> 00:49:59,760
谢谢你的介绍，确实很好地

1172
00:49:59,760 --> 00:50:03,140
利用了我们的反应，

1173
00:50:04,140 --> 00:50:05,520


1174
00:50:05,520 --> 00:50:08,460
非常有趣，有很多

1175
00:50:08,460 --> 00:50:11,760
材料和事情供我们讨论，

1176
00:50:11,760 --> 00:50:13,680
我将从一个一般性

1177
00:50:13,680 --> 00:50:16,200
问题开始，然后 Jacob 和 Ali

1178
00:50:16,200 --> 00:50:17,700
期待你们的问题，

1179
00:50:17,700 --> 00:50:20,760
只是为了了解一些背景

1180
00:50:20,760 --> 00:50:23,940
这个团队和你是如何

1181
00:50:23,940 --> 00:50:26,880
开始研究这个问题的？你是在

1182
00:50:26,880 --> 00:50:29,400
研究主动推理并对扩展感兴趣，

1183
00:50:29,400 --> 00:50:31,680
还是你在

1184
00:50:31,680 --> 00:50:34,319
不同的相邻领域工作并来到这个

1185
00:50:34,319 --> 00:50:35,640
算法

1186
00:50:35,640 --> 00:50:37,319
好吧所以也许我

1187
00:50:37,319 --> 00:50:39,180
应该说的一件事是我 我一直在开始，

1188
00:50:39,180 --> 00:50:41,040
就像我在肯特大学开始攻读博士学位一样

1189
00:50:41,040 --> 00:50:43,319
，

1190
00:50:43,319 --> 00:50:44,280
嗯，

1191
00:50:44,280 --> 00:50:47,700
基本上整个世界和 Marek，这

1192
00:50:47,700 --> 00:50:49,200
是

1193
00:50:49,200 --> 00:50:51,720
这个专业的两个微生物实验室 项目是我的主管，所以这

1194
00:50:51,720 --> 00:50:53,700
就是我们如何

1195
00:50:53,700 --> 00:50:56,460
通过我的博士学位一起工作并失去了 La Costa

1196
00:50:56,460 --> 00:50:59,220
是我一直与之合作的合作者，

1197
00:50:59,220 --> 00:51:01,440
因为我一直

1198
00:51:01,440 --> 00:51:03,900
在研究所的领域做一些演讲

1199
00:51:03,900 --> 00:51:06,240
神经科学的

1200
00:51:06,240 --> 00:51:09,359
嗯，加利福尼亚在哪里，那是

1201
00:51:09,359 --> 00:51:11,280
通过一个演讲，就像在

1202
00:51:11,280 --> 00:51:14,099
发音期间你知道他

1203
00:51:14,099 --> 00:51:16,500
对和我一起工作很感兴趣所以这

1204
00:51:16,500 --> 00:51:18,599
就是我开始与拉森阿

1205
00:51:18,599 --> 00:51:21,420
科斯塔和嗯所以及时应用

1206
00:51:21,420 --> 00:51:23,160
背景我来了 从

1207
00:51:23,160 --> 00:51:26,220
像学校这样的非常计算机科学的学校

1208
00:51:26,220 --> 00:51:29,760
进入编码，然后我到达

1209
00:51:29,760 --> 00:51:31,740
了肯特大学，在那里我开始

1210
00:51:31,740 --> 00:51:34,500
学习机器学习，这

1211
00:51:34,500 --> 00:51:36,599
是我开始获得一些

1212
00:51:36,599 --> 00:51:37,400


1213
00:51:37,400 --> 00:51:40,079
强化学习甚至积极

1214
00:51:40,079 --> 00:51:43,440
影响的经验，呃那个女人

1215
00:51:43,440 --> 00:51:45,599
最初和迈克尔一样，

1216
00:51:45,599 --> 00:51:48,960
嗯，我的两位老师和机器人

1217
00:51:48,960 --> 00:51:52,140
女士已经对主动

1218
00:51:52,140 --> 00:51:55,020
推理感兴趣，有一天当她

1219
00:51:55,020 --> 00:51:57,240
担任班级时，我出现了 说

1220
00:51:57,240 --> 00:51:59,040
得好，我会对一个副

1221
00:51:59,040 --> 00:52:00,839
项目感兴趣，当然这就是

1222
00:52:00,839 --> 00:52:03,960
一切开始的方式，之后我最终获得

1223
00:52:03,960 --> 00:52:06,240
了博士学位

1224
00:52:06,240 --> 00:52:09,300
，所以基本上都是我

1225
00:52:09,300 --> 00:52:10,920
来自机器学习我的地址

1226
00:52:10,920 --> 00:52:12,720
以及呃长话短说来自纯

1227
00:52:12,720 --> 00:52:16,260
数学和来自呃的东西，比如

1228
00:52:16,260 --> 00:52:19,020
神经科学和简单的人，

1229
00:52:19,020 --> 00:52:22,260
将营销从主题带到桌面，

1230
00:52:22,260 --> 00:52:24,780
非常好，谢谢，所以

1231
00:52:24,780 --> 00:52:27,119
我有更多的问题，但是

1232
00:52:27,119 --> 00:52:30,619
阿里如何首先提出一个问题

1233
00:52:31,700 --> 00:52:34,800
是的，嗯，首先非常

1234
00:52:34,800 --> 00:52:38,700
感谢你的呃 很棒的演讲，嗯，我

1235
00:52:38,700 --> 00:52:41,579
真的学到了很多，嗯

1236
00:52:41,579 --> 00:52:43,859
，如果我可以的话，我想发表一些评论，

1237
00:52:43,859 --> 00:52:47,220
嗯，也许还有一堆问题，

1238
00:52:47,220 --> 00:52:49,380
嗯，你很清楚主动

1239
00:52:49,380 --> 00:52:51,960
推理斜杠 fep 研究最近一直

1240
00:52:51,960 --> 00:52:54,900
在进行 在 um 基本上是两条

1241
00:52:54,900 --> 00:52:58,619
截然不同的路径 uh 理论工作

1242
00:52:58,619 --> 00:53:01,559
主要面向发展

1243
00:53:01,559 --> 00:53:03,599
基本的基本原则，

1244
00:53:03,599 --> 00:53:06,359
例如 uh Dalton 部门的

1245
00:53:06,359 --> 00:53:07,800
工作 Max 与 Randstad 及其

1246
00:53:07,800 --> 00:53:10,440
同事的发展来到 m  ind 和更

1247
00:53:10,440 --> 00:53:13,160
面向应用的研究也许与研究人员的

1248
00:53:13,160 --> 00:53:15,359


1249
00:53:15,359 --> 00:53:17,819
理论和实验

1250
00:53:17,819 --> 00:53:20,940
物理线之间的区别没有什么不同，呃，但我

1251
00:53:20,940 --> 00:53:22,980
不确定你是否同意我的看法，

1252
00:53:22,980 --> 00:53:26,119
但在我看来，可悲的是

1253
00:53:26,119 --> 00:53:28,020
面向应用的研究，

1254
00:53:28,020 --> 00:53:30,800
尤其是 至少与研究和理论方面相比，活动印记的工作和各种

1255
00:53:30,800 --> 00:53:33,240
算法实现

1256
00:53:33,240 --> 00:53:36,119
并没有获得

1257
00:53:36,119 --> 00:53:38,940
应有的认可，

1258
00:53:38,940 --> 00:53:41,460


1259
00:53:41,460 --> 00:53:44,579
我的意思是相关

1260
00:53:44,579 --> 00:53:47,780
出版文献的数量相对而言是以前关心的，

1261
00:53:47,780 --> 00:53:50,520
所以根据这种

1262
00:53:50,520 --> 00:53:52,140
情况，

1263
00:53:52,140 --> 00:53:54,780
你的行 在我看来，研究似乎

1264
00:53:54,780 --> 00:53:57,960
更大胆，收获也更

1265
00:53:57,960 --> 00:54:00,119
重要，所以我想对此表示

1266
00:54:00,119 --> 00:54:04,339
祝贺，但呃，你看，我是

1267
00:54:04,339 --> 00:54:07,380
科学和技术统一的忠实拥护者，所以

1268
00:54:07,380 --> 00:54:10,280
我的第一个问题是关于

1269
00:54:10,280 --> 00:54:14,480
你对呃可能性的看法

1270
00:54:14,480 --> 00:54:18,300
有点统一不同的统一

1271
00:54:18,300 --> 00:54:20,400


1272
00:54:20,400 --> 00:54:23,400
活动印记的不同算法实现，

1273
00:54:23,400 --> 00:54:26,000
例如你刚才提到的

1274
00:54:26,000 --> 00:54:28,260
自动 学习是生成模型的结构，

1275
00:54:28,260 --> 00:54:30,980


1276
00:54:30,980 --> 00:54:34,500
作为未来

1277
00:54:34,500 --> 00:54:36,960


1278
00:54:36,960 --> 00:54:39,480
和研究的

1279
00:54:39,480 --> 00:54:42,660
可能主题

1280
00:54:42,660 --> 00:54:44,700


1281
00:54:44,700 --> 00:54:46,859
如果我是正确的，请使用张量网络，

1282
00:54:46,859 --> 00:54:49,140
它概述

1283
00:54:49,140 --> 00:54:54,119
了该任务的一种有趣的受物理学启发的方法，但它

1284
00:54:54,119 --> 00:54:56,160
不包括对

1285
00:54:56,160 --> 00:54:59,400
任何分支时间的任何引用主动推理

1286
00:54:59,400 --> 00:55:00,960
论文可能是因为他们当时不

1287
00:55:00,960 --> 00:55:02,640
知道你的工作 他们的

1288
00:55:02,640 --> 00:55:05,700
写作，但这项工作在我看来是

1289
00:55:05,700 --> 00:55:07,319


1290
00:55:07,319 --> 00:55:10,680
与 btai 潜在整合的一个很好的候选者，

1291
00:55:10,680 --> 00:55:13,980
以克服你

1292
00:55:13,980 --> 00:55:16,559
刚才提到的一些限制呃或另一个最近的

1293
00:55:16,559 --> 00:55:19,619
例子呃可能是呃

1294
00:55:19,619 --> 00:55:23,280
sanish rolls paper deriving time

1295
00:55:23,280 --> 00:55:25,260
averaged active influence 从控制

1296
00:55:25,260 --> 00:55:28,200
原则 uh 这是试图

1297
00:55:28,200 --> 00:55:30,540
推导出一个无限的地平线

1298
00:55:30,540 --> 00:55:32,700
um 平均 uh

1299
00:55:32,700 --> 00:55:34,500
主动推理的惊喜公式

1300
00:55:34,500 --> 00:55:36,480
um 所以我真的很喜欢你的公司

1301
00:55:36,480 --> 00:55:38,700
对分支时间活动印记的不同变体的全面概述，

1302
00:55:38,700 --> 00:55:40,619


1303
00:55:40,619 --> 00:55:43,920
尤其是基准分析，

1304
00:55:43,920 --> 00:55:46,380
嗯，我知道你

1305
00:55:46,380 --> 00:55:48,359
在你的工作中描述了一个复杂的活动推理作为

1306
00:55:48,359 --> 00:55:50,940
分支时间活动兴趣的一个子集，

1307
00:55:50,940 --> 00:55:53,160
但不管这些都是

1308
00:55:53,160 --> 00:55:55,980
我刚才提到的具体例子我

1309
00:55:55,980 --> 00:55:59,640
想问 你如何看待 btai 的未来，因为

1310
00:55:59,640 --> 00:56:02,460
它可能与

1311
00:56:02,460 --> 00:56:04,339
主动推理实现的其他变体统一，

1312
00:56:04,339 --> 00:56:07,260
每个变体都有自己的优点

1313
00:56:07,260 --> 00:56:10,559
和缺点，以克服它们的

1314
00:56:10,559 --> 00:56:13,260
一些限制，而不

1315
00:56:13,260 --> 00:56:15,599
损害每个的优势消息

1316
00:56:15,599 --> 00:56:18,000
我的意思是 您

1317
00:56:18,000 --> 00:56:20,339
是否认为分支时间活动

1318
00:56:20,339 --> 00:56:24,359
印记有朝一日会

1319
00:56:24,359 --> 00:56:26,640
以某种方式将所有其他方法包含在一个真正

1320
00:56:26,640 --> 00:56:29,520
集成的框架中，

1321
00:56:29,520 --> 00:56:32,940
所以老实说，我并不完全

1322
00:56:32,940 --> 00:56:34,160


1323
00:56:34,160 --> 00:56:36,839
知道我是本章中唯一喜欢的部分 been

1324
00:56:36,839 --> 00:56:38,640
explored is a connection with launching

1325
00:56:38,640 --> 00:56:41,520
time active inference 一直活跃在

1326
00:56:41,520 --> 00:56:44,819
法国和复杂的入口，我

1327
00:56:44,819 --> 00:56:46,440
还没有 确实是根据发音来谈论的，

1328
00:56:46,440 --> 00:56:48,660
但我可以很快给出

1329
00:56:48,660 --> 00:56:51,900
我的工人的想法，这

1330
00:56:51,900 --> 00:56:53,880
是得出的结论

1331
00:56:53,880 --> 00:56:55,079


1332
00:56:55,079 --> 00:56:56,940
，基本上，

1333
00:56:56,940 --> 00:56:58,559
嗯，这实际上是

1334
00:56:58,559 --> 00:57:01,020
关于我们如何反向传播，

1335
00:57:01,020 --> 00:57:03,059
嗯，我称之为当地观众的

1336
00:57:03,059 --> 00:57:05,460
能量 基本上是

1337
00:57:05,460 --> 00:57:08,280
与

1338
00:57:08,280 --> 00:57:11,160
未来一个节点相关的能量的预期，

1339
00:57:11,160 --> 00:57:13,920
所以如果你在交易中向上传播这些能量，

1340
00:57:13,920 --> 00:57:16,079


1341
00:57:16,079 --> 00:57:16,740


1342
00:57:16,740 --> 00:57:18,660
就像多胡萝卜研究，它

1343
00:57:18,660 --> 00:57:20,819
基本上来自 bandman 方程

1344
00:57:20,819 --> 00:57:22,740
和

1345
00:57:22,740 --> 00:57:25,140
强化学习中的所有这类嗯文献

1346
00:57:25,140 --> 00:57:28,440
将落入你将

1347
00:57:28,440 --> 00:57:31,099
无法证明一种非常接近复杂印记的方法，

1348
00:57:31,099 --> 00:57:34,339
基本上是因为

1349
00:57:34,339 --> 00:57:37,200
复杂的推理也在

1350
00:57:37,200 --> 00:57:40,680
本曼方程中汲取了一些灵感，

1351
00:57:40,680 --> 00:57:43,440
只是将其应用于

1352
00:57:43,440 --> 00:57:45,240
预期的自由能而不是仅仅

1353
00:57:45,240 --> 00:57:48,599
获得奖励呃如果你向下

1354
00:57:48,599 --> 00:57:51,359
搜索传播那些

1355
00:57:51,359 --> 00:57:53,640
未来的本地成本那么你正在

1356
00:57:53,640 --> 00:57:55,859
有效地做的只是像计算一样

1357
00:57:55,859 --> 00:57:58,380
的路径 预期自由

1358
00:57:58,380 --> 00:58:00,960
能的积分，所以这将是主动

1359
00:58:00,960 --> 00:58:03,299
推理，只需将预期友谊的所有

1360
00:58:03,299 --> 00:58:06,000
未来时间开始的总和

1361
00:58:06,000 --> 00:58:08,700
作为一个伟大的，所以

1362
00:58:08,700 --> 00:58:10,140
这是复杂的推理，

1363
00:58:10,140 --> 00:58:11,940
这将对

1364
00:58:11,940 --> 00:58:14,339
你提到的其他方法产生积极影响，

1365
00:58:14,339 --> 00:58:16,440
我还没有 一直在

1366
00:58:16,440 --> 00:58:18,900
阅读这些论文，所以我有意识地

1367
00:58:18,900 --> 00:58:20,099
说明了这一点，

1368
00:58:20,099 --> 00:58:21,720
但是是的，我相信打卡时间

1369
00:58:21,720 --> 00:58:22,920
实际上是一个非常通用的

1370
00:58:22,920 --> 00:58:25,020
框架，所以可能

1371
00:58:25,020 --> 00:58:27,059
其中一些是相关的，但更多的

1372
00:58:27,059 --> 00:58:30,780
研究不是关于这个的，

1373
00:58:30,780 --> 00:58:32,400
谢谢 你

1374
00:58:32,400 --> 00:58:35,339
非常棒的评论雅各布你有什么

1375
00:58:35,339 --> 00:58:36,660
问题

1376
00:58:36,660 --> 00:58:39,960
是的再次感谢

1377
00:58:39,960 --> 00:58:41,760
非常棒的演讲并确定它

1378
00:58:41,760 --> 00:58:44,760
肯定解释了很多呃

1379
00:58:44,760 --> 00:58:48,720
事情我不理解

1380
00:58:48,720 --> 00:58:49,920
呃通过原始

1381
00:58:49,920 --> 00:58:51,059
论文

1382
00:58:51,059 --> 00:58:55,020
呃我 我想再次

1383
00:58:55,020 --> 00:58:56,940
回到学习生成模型不同组件的结构的问题，

1384
00:58:56,940 --> 00:58:59,400


1385
00:58:59,400 --> 00:59:01,140


1386
00:59:01,140 --> 00:59:03,059
嗯，在你的论文中你提到了你

1387
00:59:03,059 --> 00:59:04,920
我想使用

1388
00:59:04,920 --> 00:59:05,640


1389
00:59:05,640 --> 00:59:09,240
深度神经网络作为一般函数

1390
00:59:09,240 --> 00:59:11,940
逼近器来学习这个

1391
00:59:11,940 --> 00:59:13,559
状态空间表示，我

1392
00:59:13,559 --> 00:59:15,599
想知道你是否已经考虑过

1393
00:59:15,599 --> 00:59:19,079
神经网络

1394
00:59:19,079 --> 00:59:21,540
如何适应生成模型的工厂图

1395
00:59:21,540 --> 00:59:24,140
表示

1396
00:59:24,140 --> 00:59:27,540
，我想我 猜想也许

1397
00:59:27,540 --> 00:59:30,839
还有两种方法可以了解

1398
00:59:30,839 --> 00:59:32,760
这些不同组件的结构，

1399
00:59:32,760 --> 00:59:35,700
一种只是

1400
00:59:35,700 --> 00:59:37,079


1401
00:59:37,079 --> 00:59:39,299
幻灯片中的第一步，当您展示

1402
00:59:39,299 --> 00:59:41,760
模型的初始化类型时，呃

1403
00:59:41,760 --> 00:59:42,900
获取

1404
00:59:42,900 --> 00:59:46,200
A 和 B 张量

1405
00:59:46,200 --> 00:59:49,619
偏好和 um 之前的信念

1406
00:59:49,619 --> 00:59:54,000
有点用

1407
00:59:54,000 --> 00:59:55,740
深度神经网络替换那个步骤来学习

1408
00:59:55,740 --> 00:59:58,859
表示，但也许还有

1409
00:59:58,859 --> 01:00:02,339
另一个方面

1410
01:00:02,339 --> 01:00:05,059
um 你可以动态地改变

1411
01:00:05,059 --> 01:00:07,920
这些不同组件的维度，

1412
01:00:07,920 --> 01:00:10,559
就像亚洲人

1413
01:00:10,559 --> 01:00:12,299
接受观察一样 这

1414
01:00:12,299 --> 01:00:14,280
在张量的似然映射中没有被捕获，

1415
01:00:14,280 --> 01:00:16,260
或者它可能是一个

1416
01:00:16,260 --> 01:00:18,119
多智能体设置，其中 O 一个智能体

1417
01:00:18,119 --> 01:00:21,059
具有另一个智能体没有的功能，

1418
01:00:21,059 --> 01:00:24,200
并且需要通过观察来学习新的转换映射

1419
01:00:24,200 --> 01:00:29,760
呃所以嗯嗯

1420
01:00:29,760 --> 01:00:32,460
想知道你对此有何看法

1421
01:00:32,460 --> 01:00:33,540
以及

1422
01:00:33,540 --> 01:00:35,160
你认为这如何

1423
01:00:35,160 --> 01:00:37,740
与分支时间主动推理兼容

1424
01:00:37,740 --> 01:00:40,260
好吧那是什么 深度学习

1425
01:00:40,260 --> 01:00:42,180
um 领域是我认为非常有趣的

1426
01:00:42,180 --> 01:00:45,780
，应该使活跃的实习生能够

1427
01:00:45,780 --> 01:00:48,359
扩展到更复杂的任务，

1428
01:00:48,359 --> 01:00:50,579
最近，所以这篇论文还没有

1429
01:00:50,579 --> 01:00:52,980
发表，但我正在研究主动推理的深度学习

1430
01:00:52,980 --> 01:00:55,319
版本，所以现在

1431
01:00:55,319 --> 01:00:58,140
有 图片内没有分支时间，

1432
01:00:58,140 --> 01:00:59,339
所以没有更多的外卖

1433
01:00:59,339 --> 01:01:00,540
研究

1434
01:01:00,540 --> 01:01:02,720
，原因是因为

1435
01:01:02,720 --> 01:01:05,460


1436
01:01:05,460 --> 01:01:08,460
仅仅为了积极影响而让它工作已经非常困难，

1437
01:01:08,460 --> 01:01:10,380
嗯基本上我一直在审查

1438
01:01:10,380 --> 01:01:13,559
一些论文到 Etc 和呃然后我

1439
01:01:13,559 --> 01:01:15,960
提供 我自己实现了深度

1440
01:01:15,960 --> 01:01:19,440
主动入口，但例如

1441
01:01:19,440 --> 01:01:22,619
我谈到了显示数据集，但我

1442
01:01:22,619 --> 01:01:25,200


1443
01:01:25,200 --> 01:01:28,380
无法对这些应用程序产生深度主动影响

1444
01:01:28,380 --> 01:01:31,380
在这些环境中讨论这个

1445
01:01:31,380 --> 01:01:33,119
所以是的，我一直在

1446
01:01:33,119 --> 01:01:35,280
做一个关于这个领域的演示，呃，

1447
01:01:35,280 --> 01:01:37,559
但基本上

1448
01:01:37,559 --> 01:01:40,559
互联网上的一些实现包含错误，

1449
01:01:40,559 --> 01:01:42,839
嗯，是的，一些论文也

1450
01:01:42,839 --> 01:01:45,180
包含一些像我的意思是我不是 确定

1451
01:01:45,180 --> 01:01:46,920
是否可能是纸上的确切错误，那

1452
01:01:46,920 --> 01:01:49,619
是我不理解的，嗯，对于

1453
01:01:49,619 --> 01:01:52,020
另一个动物饲养员，我

1454
01:01:52,020 --> 01:01:54,420
无法回答我的问题，

1455
01:01:54,420 --> 01:01:55,500
嗯，所以基本上我想说的

1456
01:01:55,500 --> 01:01:57,180
是，我一直在努力资助深度

1457
01:01:57,180 --> 01:01:59,240
主动推理

1458
01:01:59,240 --> 01:02:00,900
令人惊讶

1459
01:02:00,900 --> 01:02:02,940
的是，至少要让它在这种环境下工作是相当困难的，

1460
01:02:02,940 --> 01:02:05,640


1461
01:02:05,640 --> 01:02:07,859
所以会有第一篇关于

1462
01:02:07,859 --> 01:02:10,619
分析深度神经

1463
01:02:10,619 --> 01:02:13,020
网络实际学习什么以及为什么

1464
01:02:13,020 --> 01:02:15,359
它在这种环境下失败的论文

1465
01:02:15,359 --> 01:02:17,760
，然后

1466
01:02:17,760 --> 01:02:20,160
嗯我想做的是 尝试应用

1467
01:02:20,160 --> 01:02:21,660
这个实现，我希望它是

1468
01:02:21,660 --> 01:02:22,920
正确的，

1469
01:02:22,920 --> 01:02:25,680
嗯，两个不同的任务，呃，最

1470
01:02:25,680 --> 01:02:27,780
特别喜欢目标游戏和

1471
01:02:27,780 --> 01:02:29,819
类似的东西，并尝试找出

1472
01:02:29,819 --> 01:02:32,280
是否有一些任务

1473
01:02:32,280 --> 01:02:34,859
是预期的 f  reemergy，你知道

1474
01:02:34,859 --> 01:02:35,940
有效

1475
01:02:35,940 --> 01:02:38,579
推理的实施实际上可以解决任务

1476
01:02:38,579 --> 01:02:41,280
，我在这个 um 上得到的参数初步结果

1477
01:02:41,280 --> 01:02:43,260


1478
01:02:43,260 --> 01:02:46,200
是，似乎有一些任务，

1479
01:02:46,200 --> 01:02:49,039
或者哪个深度主动

1480
01:02:49,039 --> 01:02:51,599
影响实际上

1481
01:02:51,599 --> 01:02:54,119
比例如 dqm 表现更好，它是

1482
01:02:54,119 --> 01:02:56,160
强化学习文献中的一个基准

1483
01:02:56,160 --> 01:03:00,180
，嗯，是的，它不是

1484
01:03:00,180 --> 01:03:03,599
一个简单的篮子，因为

1485
01:03:03,599 --> 01:03:06,420
当我在实施它时，它是相当具有挑战性的，

1486
01:03:06,420 --> 01:03:09,619
它更多地用于大型

1487
01:03:09,619 --> 01:03:12,960
深度学习方面，我认为我们

1488
01:03:12,960 --> 01:03:15,119
仍然需要做很多工作才能

1489
01:03:15,119 --> 01:03:17,819
做一些非常健壮的东西，可以

1490
01:03:17,819 --> 01:03:20,760


1491
01:03:20,760 --> 01:03:23,640
在类似的基准测试中击败更多标准的强化学习

1492
01:03:23,640 --> 01:03:26,819
，是的，结构学习的其他机会

1493
01:03:26,819 --> 01:03:28,740
我还不能，

1494
01:03:28,740 --> 01:03:31,200
就像我现在还没有研究过它，所以

1495
01:03:31,200 --> 01:03:33,119
我们需要更多的时间来考虑一个

1496
01:03:33,119 --> 01:03:35,280
更健壮的答案 对于你的问题

1497
01:03:35,280 --> 01:03:37,500
，是的，这基本上就是我

1498
01:03:37,500 --> 01:03:39,359
不得不说的，

1499
01:03:39,359 --> 01:03:41,760
感谢你的卓越

1500
01:03:41,760 --> 01:03:44,579
，这是演讲中一个非常引人注目的方面

1501
01:03:44,579 --> 01:03:47,160
是对计算复杂性的分析，

1502
01:03:47,160 --> 01:03:49,020


1503
01:03:49,020 --> 01:03:51,359
所以也许我们可以回到这个问题上，因为

1504
01:03:51,359 --> 01:03:53,280
这是我们想知道

1505
01:03:53,280 --> 01:03:56,099
并讨论过

1506
01:03:56,099 --> 01:03:58,799
几次的事情是的，你

1507
01:03:58,799 --> 01:04:01,460
用大 O 符号介绍了理论复杂性类

1508
01:04:01,460 --> 01:04:05,220
，然后还讨论了一些

1509
01:04:05,220 --> 01:04:09,059
实践方面

1510
01:04:09,059 --> 01:04:12,119
给定硬件上实际时钟时间的一部分并不能

1511
01:04:12,119 --> 01:04:15,299
完全确定

1512
01:04:15,299 --> 01:04:18,000
你运行它的语言或硬件，但提供了

1513
01:04:18,000 --> 01:04:20,640
理论复杂度类以及

1514
01:04:20,640 --> 01:04:23,460
一些运行时配置，所以我

1515
01:04:23,460 --> 01:04:26,660
很想听听一些

1516
01:04:26,660 --> 01:04:31,380
关于这个大 O 是如何做到的想法

1517
01:04:31,380 --> 01:04:34,440
计算复杂性分析

1518
01:04:34,440 --> 01:04:37,740
揭示了主动推理的不同变体

1519
01:04:37,740 --> 01:04:40,559
以及分支时间主动

1520
01:04:40,559 --> 01:04:44,579
推理，以及

1521
01:04:44,579 --> 01:04:49,260
在分析中对哪些实际计算资源征税

1522
01:04:49,260 --> 01:04:52,440
这是导致

1523
01:04:52,440 --> 01:04:55,200
您之前提到的崩溃的 ram 溢出

1524
01:04:55,200 --> 01:04:58,319
是 CPU 节流吗它会瘫痪吗

1525
01:04:58,319 --> 01:05:00,960
它需要临时文件，就像

1526
01:05:00,960 --> 01:05:03,180
理论上发生的计算

1527
01:05:03,180 --> 01:05:05,280
复杂性和指数 爆炸

1528
01:05:05,280 --> 01:05:07,980
然后在实践中将

1529
01:05:07,980 --> 01:05:10,020
促进这种分析

1530
01:05:10,020 --> 01:05:11,640
扩展

1531
01:05:11,640 --> 01:05:15,420
好吧所以首先像这种复杂性

1532
01:05:15,420 --> 01:05:17,700
分析

1533
01:05:17,700 --> 01:05:19,980
是根据存储所有参数所需的空间来完成

1534
01:05:19,980 --> 01:05:22,859
的，你知道

1535
01:05:22,859 --> 01:05:25,079
状态分布好吧所以 在这里，我们真正

1536
01:05:25,079 --> 01:05:27,359
感兴趣的是我需要多少空间

1537
01:05:27,359 --> 01:05:29,880
来存储状态的所有分布

1538
01:05:29,880 --> 01:05:32,039
，例如状态的所有后验

1539
01:05:32,039 --> 01:05:34,079
分布

1540
01:05:34,079 --> 01:05:37,020
，但是如果在标准

1541
01:05:37,020 --> 01:05:39,180
主动推理中发生的

1542
01:05:39,180 --> 01:05:41,640
事情是可用的策略数量 给

1543
01:05:41,640 --> 01:05:42,839
代理所以让我们假设我们有两个

1544
01:05:42,839 --> 01:05:44,280
动作

1545
01:05:44,280 --> 01:05:47,160
我们在这里有一个在这里好的动作

1546
01:05:47,160 --> 01:05:49,020
零动作在第一个时间

1547
01:05:49,020 --> 01:05:52,079
步骤这里有两个动作在第二个

1548
01:05:52,079 --> 01:05:54,660
时间步骤我们变形黑色策略

1549
01:05:54,660 --> 01:05:56,940
基本上代理可以

1550
01:05:56,940 --> 01:05:57,839
嗯

1551
01:05:57,839 --> 01:06:01,200
可以实际执行 它可以是零零零

1552
01:06:01,200 --> 01:06:05,579
一一零和一一，

1553
01:06:05,579 --> 01:06:07,440
这个类的数量基本上

1554
01:06:07,440 --> 01:06:10,920
每次都会乘以二，就像

1555
01:06:10,920 --> 01:06:12,660
在路上一样，因为

1556
01:06:12,660 --> 01:06:15,180
每次使用我们现在可以

1557
01:06:15,180 --> 01:06:16,559
为之前的每个过程再次点击每个动作

1558
01:06:16,559 --> 01:06:18,059


1559
01:06:18,059 --> 01:06:21,059
并且这种指数增长是非常

1560
01:06:21,059 --> 01:06:23,160
有问题

1561
01:06:23,160 --> 01:06:25,619
的，例如政策

1562
01:06:25,619 --> 01:06:27,839
社会成员

1563
01:06:27,839 --> 01:06:29,940


1564
01:06:29,940 --> 01:06:31,920
的先验这个定义

1565
01:06:31,920 --> 01:06:34,380
我们看到的政策的先验是为了 定义

1566
01:06:34,380 --> 01:06:36,720
政策的先验我们需要

1567
01:06:36,720 --> 01:06:38,640
混淆每个奖金的预期自由能，

1568
01:06:38,640 --> 01:06:40,500


1569
01:06:40,500 --> 01:06:42,240
但我们需要对它们的指数数量这样做，

1570
01:06:42,240 --> 01:06:45,119
因为呃

1571
01:06:45,119 --> 01:06:47,280
计时器没有应用增加

1572
01:06:47,280 --> 01:06:49,079
所以这是第一个问题

1573
01:06:49,079 --> 01:06:52,460
，也是

1574
01:06:52,460 --> 01:06:55,140
这个解释 指数

1575
01:06:55,140 --> 01:06:57,000
爆炸不限于

1576
01:06:57,000 --> 01:06:59,819
政策的数量，因为我们仍然记得好吧，

1577
01:06:59,819 --> 01:07:02,220
所以也许对于这个我需要去

1578
01:07:02,220 --> 01:07:04,200
嗯看看用于买方风格推断的变分

1579
01:07:04,200 --> 01:07:06,720
分布，

1580
01:07:06,720 --> 01:07:08,460
但我们看到这个

1581
01:07:08,460 --> 01:07:12,299
数字

1582
01:07:12,299 --> 01:07:15,960
就像 states 取决于策略，

1583
01:07:15,960 --> 01:07:19,260
所以对于每个策略，我们需要

1584
01:07:19,260 --> 01:07:22,680
存储一个状态的分布

1585
01:07:22,680 --> 01:07:25,079
，这又是一个问题，因为

1586
01:07:25,079 --> 01:07:26,880
有一个指数级的 policy

1587
01:07:26,880 --> 01:07:28,260
这意味着我们需要存储呈指数级

1588
01:07:28,260 --> 01:07:30,420
数量的

1589
01:07:30,420 --> 01:07:32,059


1590
01:07:32,059 --> 01:07:34,980
立体声，

1591
01:07:34,980 --> 01:07:37,380
所以这是在 um 标准 Arctic 推理中出现的那种问题，

1592
01:07:37,380 --> 01:07:38,579


1593
01:07:38,579 --> 01:07:39,960


1594
01:07:39,960 --> 01:07:42,299


1595
01:07:42,299 --> 01:07:45,539
policy 的数量呈指数级增长

1596
01:07:45,539 --> 01:07:48,359
，我们还需要存储

1597
01:07:48,359 --> 01:07:50,819
状态的分布 对于

1598
01:07:50,819 --> 01:07:53,119


1599
01:07:53,339 --> 01:07:55,619
现在启动时间主动

1600
01:07:55,619 --> 01:07:59,400
推理变得有用的每个时间步，它使用

1601
01:07:59,400 --> 01:08:00,960
一种结构，比如有一个图形

1602
01:08:00,960 --> 01:08:03,480
结构，以避免必须存储

1603
01:08:03,480 --> 01:08:05,339
每一个可能的组合

1604
01:08:05,339 --> 01:08:09,539
，呃，你知道时间步与策略

1605
01:08:09,539 --> 01:08:11,579
，所以

1606
01:08:11,579 --> 01:08:14,700
这两个我们看到了 线性增长

1607
01:08:14,700 --> 01:08:17,158
是因为我们只在

1608
01:08:17,158 --> 01:08:19,799
记忆

1609
01:08:19,799 --> 01:08:21,899
中为过去和现在的每个状态保留一个分布

1610
01:08:21,899 --> 01:08:24,299
，只有当它到达当前

1611
01:08:24,299 --> 01:08:27,000
时间步时，我们才开始想象

1612
01:08:27,000 --> 01:08:28,979
未来会发生什么

1613
01:08:28,979 --> 01:08:31,920
，这种增长仍然是指数级的，

1614
01:08:31,920 --> 01:08:34,500
就像我们 添加如果我们必须在未来探索

1615
01:08:34,500 --> 01:08:36,779
每一个可能的极地，

1616
01:08:36,779 --> 01:08:38,640
我们仍然会有指数

1617
01:08:38,640 --> 01:08:41,399
增长，但因为我们正在使用

1618
01:08:41,399 --> 01:08:43,620
multicarage 研究 h

1619
01:08:43,620 --> 01:08:46,380
基本上我们将只探索

1620
01:08:46,380 --> 01:08:48,120
少量的树

1621
01:08:48,120 --> 01:08:51,359
，这就是复杂性

1622
01:08:51,359 --> 01:08:55,500
从指数级变为线性级的地方，

1623
01:08:55,500 --> 01:08:57,299
相对于模型的扩展次数，

1624
01:08:57,299 --> 01:08:59,939
所以每次我们

1625
01:08:59,939 --> 01:09:02,698
在这个模型中扩展一个新分支时，我们需要

1626
01:09:02,698 --> 01:09:05,520
为这个呃未来时间戳存储一个更好的分类

1627
01:09:05,520 --> 01:09:08,100


1628
01:09:08,100 --> 01:09:10,819
，所以这

1629
01:09:10,819 --> 01:09:14,439
就是我们如何从指数

1630
01:09:14,439 --> 01:09:15,600
[Music]

1631
01:09:15,600 --> 01:09:18,060
复杂性加到

1632
01:09:18,060 --> 01:09:20,698
关于生成模型扩展数量的线性复杂性，

1633
01:09:20,698 --> 01:09:22,920


1634
01:09:22,920 --> 01:09:26,698
所以这是为了容量

1635
01:09:26,698 --> 01:09:28,679
就硬件而言，它基本上

1636
01:09:28,679 --> 01:09:30,899
只是在我自己的电脑上，呃，一些真正

1637
01:09:30,899 --> 01:09:34,859
关键的，呃，GPU 没有使用像这样的东西，

1638
01:09:34,859 --> 01:09:38,179
只是 CPU 基本上

1639
01:09:39,060 --> 01:09:41,640
非常有趣，在硬件

1640
01:09:41,640 --> 01:09:44,698
或实现方面，你在哪里

1641
01:09:44,698 --> 01:09:46,080
看到

1642
01:09:46,080 --> 01:09:49,979
python 或 Julia 中的包，比如 Forney

1643
01:09:49,979 --> 01:09:52,500
实验室和 传递正在开发的 Paradigm 的反应性消息，

1644
01:09:52,500 --> 01:09:56,100
或者你认为

1645
01:09:56,100 --> 01:09:59,460
gpus 像这样相关是

1646
01:09:59,460 --> 01:10:01,980
存储考虑什么类型的

1647
01:10:01,980 --> 01:10:04,320
缩放关系或在理论上和

1648
01:10:04,320 --> 01:10:07,080
练习计算的操作

1649
01:10:07,080 --> 01:10:09,360
方面而不是空间

1650
01:10:09,360 --> 01:10:11,420
需求是如何计算的，

1651
01:10:11,420 --> 01:10:15,239
所以首先要说的是

1652
01:10:15,239 --> 01:10:18,659
空间复杂性也与

1653
01:10:18,659 --> 01:10:20,159
时间相关，你知道计算

1654
01:10:20,159 --> 01:10:23,520
复杂性，因为例如

1655
01:10:23,520 --> 01:10:25,679
我在谈到

1656
01:10:25,679 --> 01:10:28,020


1657
01:10:28,020 --> 01:10:31,679
先验策略如果我们有

1658
01:10:31,679 --> 01:10:33,239
指数数量的产品，你

1659
01:10:33,239 --> 01:10:34,920
需要计算每个策略的预期自由能的指数数量，

1660
01:10:34,920 --> 01:10:36,900


1661
01:10:36,900 --> 01:10:39,960
所以当

1662
01:10:39,960 --> 01:10:41,640
涉及到后验时，当我们必须

1663
01:10:41,640 --> 01:10:44,100
存储 Via 样式后验时，同样的事情

1664
01:10:44,100 --> 01:10:45,600
它们的数量呈指数增长，

1665
01:10:45,600 --> 01:10:48,360
那么我们还需要计算它们，因此

1666
01:10:48,360 --> 01:10:50,400
这也将在解决方案中变得可提取，

1667
01:10:50,400 --> 01:10:52,080


1668
01:10:52,080 --> 01:10:55,980
并且在实施方面我

1669
01:10:55,980 --> 01:10:57,659
知道有人一直

1670
01:10:57,659 --> 01:11:00,780
在 Julia 开发电话实验室我一直在

1671
01:11:00,780 --> 01:11:02,100
提供我自己的实施 在

1672
01:11:02,100 --> 01:11:03,420
Python 中，

1673
01:11:03,420 --> 01:11:06,480
嗯，是的，这些是

1674
01:11:06,480 --> 01:11:10,800
uh gpus 方面的可能性，我想它们的用法

1675
01:11:10,800 --> 01:11:12,239


1676
01:11:12,239 --> 01:11:13,199


1677
01:11:13,199 --> 01:11:16,280
只有在等

1678
01:11:16,280 --> 01:11:18,600
轴测模型允许的情况下才会真正有用 对于

1679
01:11:18,600 --> 01:11:20,340
并行

1680
01:11:20,340 --> 01:11:23,760
化，例如 gpus

1681
01:11:23,760 --> 01:11:27,060
非常有用的一种情况是图像，因为图像中的每个

1682
01:11:27,060 --> 01:11:29,340
位置通常都可以

1683
01:11:29,340 --> 01:11:31,620
并行处理，

1684
01:11:31,620 --> 01:11:33,960
所以如果我们想要一个替代模型

1685
01:11:33,960 --> 01:11:35,880
，我不知道似然

1686
01:11:35,880 --> 01:11:37,679
映射购买旁边的 4 个像素

1687
01:11:37,679 --> 01:11:39,840
彼此就像图像中的一个补丁，我们

1688
01:11:39,840 --> 01:11:42,719
必须计算所有图像的所有后验，

1689
01:11:42,719 --> 01:11:45,300
那么

1690
01:11:45,300 --> 01:11:48,179
并行化的潜力非常大，

1691
01:11:48,179 --> 01:11:51,840
但是如果例如一条消息作为

1692
01:11:51,840 --> 01:11:53,640
对先前消息的依赖，

1693
01:11:53,640 --> 01:11:56,820
那么将只有一个

1694
01:11:56,820 --> 01:11:59,219
GPU 的一部分，它只是在等待输入

1695
01:11:59,219 --> 01:12:02,940
消息到达，所以基本上也有

1696
01:12:02,940 --> 01:12:05,040
限制，因为

1697
01:12:05,040 --> 01:12:08,040
一些分析解决方案需要

1698
01:12:08,040 --> 01:12:10,320
一些其他消息，所以在

1699
01:12:10,320 --> 01:12:13,140
整个依赖关系中存在一些依赖关系，

1700
01:12:13,140 --> 01:12:16,260
比如图形模型，

1701
01:12:16,260 --> 01:12:20,159
所以 使用 GPU 是的，但可能在

1702
01:12:20,159 --> 01:12:22,199
它有用的特定生成器模型中，

1703
01:12:22,199 --> 01:12:24,360
例如基于图像的生成

1704
01:12:24,360 --> 01:12:27,960
模型或者嗯，是的，如果我们有

1705
01:12:27,960 --> 01:12:30,600
一些东西可以打折 非常简单然后我

1706
01:12:30,600 --> 01:12:32,400
认为它不会

1707
01:12:32,400 --> 01:12:37,040
从 gpu 的并发症中获益很多

1708
01:12:37,560 --> 01:12:39,120
非常好

1709
01:12:39,120 --> 01:12:40,280


1710
01:12:40,280 --> 01:12:40,679


1711
01:12:40,679 --> 01:12:42,239


1712
01:12:42,239 --> 01:12:44,699
再次感谢 [音乐] um Ali 或 Jakob 如果你想要另一个

1713
01:12:44,699 --> 01:12:48,019
问题或者我可以问一个

1714
01:12:49,400 --> 01:12:53,040
是的我也想问一下

1715
01:12:53,040 --> 01:12:54,179
不同的

1716
01:12:54,179 --> 01:12:55,980
嗯

1717
01:12:55,980 --> 01:12:57,840
分支时间事故 Prince 未来可能的实施

1718
01:12:57,840 --> 01:12:59,460
因为

1719
01:12:59,460 --> 01:13:03,000
嗯 Daniel 和 Jacob 知道我

1720
01:13:03,000 --> 01:13:08,400
是 Julia 的忠实粉丝所以我想知道是否

1721
01:13:08,400 --> 01:13:11,040
有计划让珠宝

1722
01:13:11,040 --> 01:13:12,780
实施分支时间主动

1723
01:13:12,780 --> 01:13:15,179
推理因为我认为我们已经

1724
01:13:15,179 --> 01:13:18,960
有了 C  plus plus 和 python 如果我是

1725
01:13:18,960 --> 01:13:20,880
对的第一次分支时间

1726
01:13:20,880 --> 01:13:23,159
主动推理是在 C plus 中实现的，

1727
01:13:23,159 --> 01:13:26,400
而多模态推理是在

1728
01:13:26,400 --> 01:13:30,540
Python 中实现的那么未来的计划是什么

1729
01:13:30,540 --> 01:13:32,100
btai

1730
01:13:32,100 --> 01:13:35,580
的其他其他形式实现

1731
01:13:35,580 --> 01:13:36,659


1732
01:13:36,659 --> 01:13:39,120
所以现在我只是在计划 只

1733
01:13:39,120 --> 01:13:40,560
使用 Python

1734
01:13:40,560 --> 01:13:43,440
嗯，但我想

1735
01:13:43,440 --> 01:13:45,600
在 Julia 中报告它应该不会太难，只是现在我

1736
01:13:45,600 --> 01:13:48,420
没有使用语音

1737
01:13:48,420 --> 01:13:51,840
嗯，让我们分享一下，也为了

1738
01:13:51,840 --> 01:13:54,360
未来的可能性

1739
01:13:54,360 --> 01:13:56,760
打卡时间主动推理我一直

1740
01:13:56,760 --> 01:13:59,520
在尝试实现

1741
01:13:59,520 --> 01:14:01,800
一个倾斜算法

1742
01:14:01,800 --> 01:14:02,780
嗯

1743
01:14:02,780 --> 01:14:07,260
所以这是一个同时定位和

1744
01:14:07,260 --> 01:14:09,000
映射所以如果我们在

1745
01:14:09,000 --> 01:14:10,560
浏览它时创建这些环境的地图

1746
01:14:10,560 --> 01:14:12,840
所以这也是一种

1747
01:14:12,840 --> 01:14:17,179
可能性但是 在这个呃背景下，

1748
01:14:17,179 --> 01:14:20,699
基本上我打算以

1749
01:14:20,699 --> 01:14:22,620
指数方式进行，我们可以进行

1750
01:14:22,620 --> 01:14:24,480
依赖于

1751
01:14:24,480 --> 01:14:27,540
大量状态的观察，因此我们

1752
01:14:27,540 --> 01:14:30,179
需要的更像是一个条件

1753
01:14:30,179 --> 01:14:32,400
概率表，它存储为一

1754
01:14:32,400 --> 01:14:35,400
棵树，所以它在生物学上是

1755
01:14:35,400 --> 01:14:37,380
你的 可以鼓励使用条件

1756
01:14:37,380 --> 01:14:39,600
间概率表的规则，

1757
01:14:39,600 --> 01:14:41,460
例如你有一所学校，你有

1758
01:14:41,460 --> 01:14:45,300
一个给定 a 和 b 的 C 的概率，

1759
01:14:45,300 --> 01:14:48,420
那么也许如果 a 等于 1，

1760
01:14:48,420 --> 01:14:50,699
你想

1761
01:14:50,699 --> 01:14:53,880
在 B 上有一个分支，然后我们有 0

1762
01:14:53,880 --> 01:14:57,980
1。也许这个 是实数点 好的 9

1763
01:14:57,980 --> 01:15:01,320
好的 所以这意味着如果 a

1764
01:15:01,320 --> 01:15:04,020
等于 1 并且 B 等于 0 那么

1765
01:15:04,020 --> 01:15:06,239
a c 的概率分布

1766
01:15:06,239 --> 01:15:08,580
对于 0.9 英寸的第一个值将是 0.1

1767
01:15:08,580 --> 01:15:11,580
es代表第二个值，所以

1768
01:15:11,580 --> 01:15:14,280
基本上说这个想法是尽量

1769
01:15:14,280 --> 01:15:16,260
不代表整个表格，而是

1770
01:15:16,260 --> 01:15:18,719
选择一个树结构来取消

1771
01:15:18,719 --> 01:15:20,940
关于世界动态和

1772
01:15:20,940 --> 01:15:23,460
似然函数的规则

1773
01:15:23,460 --> 01:15:25,800
，然后挑战是能够

1774
01:15:25,800 --> 01:15:28,380
执行 来自这棵树的前向预测

1775
01:15:28,380 --> 01:15:31,500
，在法国也来自流

1776
01:15:31,500 --> 01:15:34,020
，所以这是另一张

1777
01:15:34,020 --> 01:15:35,760
可能集成在

1778
01:15:35,760 --> 01:15:39,020
um 中的图片，未来的 UI

1779
01:15:39,659 --> 01:15:42,179
肯定是贯穿很多这些讨论的主题，将

1780
01:15:42,179 --> 01:15:44,640


1781
01:15:44,640 --> 01:15:48,360
对象表示为树，然后取

1782
01:15:48,360 --> 01:15:50,820
树 turn or in the forest turn

1783
01:15:50,820 --> 01:15:53,699
seriously because the tree structure

1784
01:15:53,699 --> 01:15:55,800
allows us to

1785
01:15:55,800 --> 01:15:58,679
avoid redundancies and enable some new

1786
01:15:58,679 --> 01:16:01,380
types of analysis Jacob 你有

1787
01:16:01,380 --> 01:16:03,239
问题还是我可以问一个

1788
01:16:03,239 --> 01:16:06,000
是的 嗯 也许

1789
01:16:06,000 --> 01:16:10,440
嗯 继续 slam thread 我

1790
01:16:10,440 --> 01:16:12,659
想知道

1791
01:16:12,659 --> 01:16:15,000
你是否 're considering considering

1792
01:16:15,000 --> 01:16:18,000
application of Slam to the

1793
01:16:18,000 --> 01:16:20,880
um image classification problem and

1794
01:16:20,880 --> 01:16:25,140
perhaps the image classification

1795
01:16:25,140 --> 01:16:27,840
problems needs to be reframed to even fit

1796
01:16:27,840 --> 01:16:30,780
this 呃 w 首先是分支时间

1797
01:16:30,780 --> 01:16:32,520
主动推理方案，但整体

1798
01:16:32,520 --> 01:16:35,340
主动推理方案，因为

1799
01:16:35,340 --> 01:16:38,400
嗯，似乎整体主动印记

1800
01:16:38,400 --> 01:16:40,280


1801
01:16:40,280 --> 01:16:44,100
更适合这类

1802
01:16:44,100 --> 01:16:48,320
不断发展的问题，在这种情况下，

1803
01:16:48,320 --> 01:16:52,440
只要代理采取行动，生成过程就会发生变化，

1804
01:16:52,440 --> 01:16:54,659
而

1805
01:16:54,659 --> 01:16:56,880
图像分类问题

1806
01:16:56,880 --> 01:17:00,480
似乎更加静态，呃

1807
01:17:00,480 --> 01:17:02,040
至少在机器学习

1808
01:17:02,040 --> 01:17:03,719
方案中它

1809
01:17:03,719 --> 01:17:06,179
只是输入和输出，然后可能

1810
01:17:06,179 --> 01:17:10,380
呃一些错误

1811
01:17:10,380 --> 01:17:12,780
嗯通过网络传播回来

1812
01:17:12,780 --> 01:17:14,159


1813
01:17:14,159 --> 01:17:15,719
所以

1814
01:17:15,719 --> 01:17:18,060
我想知道你是怎么

1815
01:17:18,060 --> 01:17:19,679
想的 关于

1816
01:17:19,679 --> 01:17:20,400
um

1817
01:17:20,400 --> 01:17:23,880
image image classification with uh

1818
01:17:23,880 --> 01:17:27,000
active inference and overall just how

1819
01:17:27,000 --> 01:17:29,760
images can act

1820
01:17:29,760 --> 01:17:32,580
um as input in in

1821
01:17:32,580 --> 01:17:35,760
um dynamical environments

1822
01:17:35,760 --> 01:17:37,739
所以是的，再次感谢你的印象

1823
01:17:37,739 --> 01:17:39,060
，

1824
01:17:39,060 --> 01:17:41,040
嗯，所以基本上

1825
01:17:41,040 --> 01:17:43,560
像图像分类的事情是我们

1826
01:17:43,560 --> 01:17:45,540
不 有

1827
01:17:45,540 --> 01:17:47,640
你刚才提到的这种秒表结构，这使得

1828
01:17:47,640 --> 01:17:48,900
活跃在法国的引擎

1829
01:17:48,900 --> 01:17:51,540
很难成为 ap 从某种意义上说，这

1830
01:17:51,540 --> 01:17:54,239
有点像过渡映射

1831
01:17:54,239 --> 01:17:56,460
就像是某些东西中的身份函数，

1832
01:17:56,460 --> 01:17:57,540
比如

1833
01:17:57,540 --> 01:18:00,000
嗯，是的，考虑如何带来它有点困难，

1834
01:18:00,000 --> 01:18:02,520
但是

1835
01:18:02,520 --> 01:18:04,380
是的，因为每个时间步长都可以是一个

1836
01:18:04,380 --> 01:18:06,960
图像，例如 一个分类，

1837
01:18:06,960 --> 01:18:09,360
嗯，但我认为主动推理

1838
01:18:09,360 --> 01:18:11,760
并不真正适合

1839
01:18:11,760 --> 01:18:13,920


1840
01:18:13,920 --> 01:18:15,960
这样的分类模型，我认为它们就像分类模型，

1841
01:18:15,960 --> 01:18:18,179
就像你知道的任何共鸣或

1842
01:18:18,179 --> 01:18:20,580
任何更适合的东西，

1843
01:18:20,580 --> 01:18:21,900


1844
01:18:21,900 --> 01:18:24,659
基本上如果你必须应用主动

1845
01:18:24,659 --> 01:18:26,159
推理 它必须你

1846
01:18:26,159 --> 01:18:27,780
必须改变模型的结构

1847
01:18:27,780 --> 01:18:30,480
呃删除它是顶墙

1848
01:18:30,480 --> 01:18:32,699
呃过渡并且只是为了

1849
01:18:32,699 --> 01:18:36,300
观察，否则你将需要

1850
01:18:36,300 --> 01:18:39,000
某种动态或暴力，

1851
01:18:39,000 --> 01:18:41,760
比如 Atari 游戏黑色手册之类的

1852
01:18:41,760 --> 01:18:44,400
事物或诸如尽管环境

1853
01:18:44,400 --> 01:18:47,400
，在这种情况下，你可以模拟

1854
01:18:47,400 --> 01:18:50,640
环境的时间动态

1855
01:18:50,640 --> 01:18:52,440
，所以这里积极的影响真的

1856
01:18:52,440 --> 01:18:55,679
很有帮助，因为你可以 你知道

1857
01:18:55,679 --> 01:18:57,840
思考动作以及它们如何影响

1858
01:18:57,840 --> 01:19:00,960
过渡，你可以

1859
01:19:00,960 --> 01:19:03,540
拥有一个基本上可以压缩图像的编码器，

1860
01:19:03,540 --> 01:19:05,640
所以从技术上讲，你将拥有

1861
01:19:05,640 --> 01:19:08,699
一个图像，你将拥有

1862
01:19:08,699 --> 01:19:10,500
一个编码器网络，有点像通过

1863
01:19:10,500 --> 01:19:13,380
通道到编码器，它将产生 一个

1864
01:19:13,380 --> 01:19:16,199
参数，所以

1865
01:19:16,199 --> 01:19:18,960
状态分布的均值和方差，然后我们

1866
01:19:18,960 --> 01:19:21,000
将在那里有解码器，它

1867
01:19:21,000 --> 01:19:24,000


1868
01:19:24,000 --> 01:19:27,179
基本上从潜在变量产生另一个图像，

1869
01:19:27,179 --> 01:19:28,920
然后我们将在这里有一个过渡

1870
01:19:28,920 --> 01:19:30,120
网络

1871
01:19:30,120 --> 01:19:33,420
，它也是一个输出的数字网络

1872
01:19:33,420 --> 01:19:36,000


1873
01:19:36,000 --> 01:19:38,040
作为下一个时间步的状态分布的均值

1874
01:19:38,040 --> 01:19:39,060


1875
01:19:39,060 --> 01:19:41,040
和方差，是的，然后这里有另一个

1876
01:19:41,040 --> 01:19:43,080
用于未来图像的编码器和另一个

1877
01:19:43,080 --> 01:19:45,600
用于未来图像的解码器

1878
01:19:45,600 --> 01:19:48,480
，这些转换网络

1879
01:19:48,480 --> 01:19:50,280
基本上必须考虑

1880
01:19:50,280 --> 01:19:52,679
动作以及

1881
01:19:52,679 --> 01:19:54,840
预测下一个状态的状态，所以这就是

1882
01:19:54,840 --> 01:19:57,719
你需要创建

1883
01:19:57,719 --> 01:20:00,179
深度主动推理地址的架构

1884
01:20:00,179 --> 01:20:01,980
，我 我认为它更适合

1885
01:20:01,980 --> 01:20:03,960
动态环境，例如针对

1886
01:20:03,960 --> 01:20:07,199
身份或静态环境的攻击

1887
01:20:07,199 --> 01:20:09,120


1888
01:20:09,120 --> 01:20:11,400
，

1889
01:20:11,400 --> 01:20:13,679
如果我能对图像大满贯提出一些想法，那么应用它确实要复杂得多

1890
01:20:13,679 --> 01:20:15,020


1891
01:20:15,020 --> 01:20:18,900
关于静态

1892
01:20:18,900 --> 01:20:20,580
分析

1893
01:20:20,580 --> 01:20:24,060
和动态分析的非常有趣的观点

1894
01:20:24,060 --> 01:20:27,139
等等 我们可以伪

1895
01:20:27,139 --> 01:20:30,780
动态化图像分类任务的方法，

1896
01:20:30,780 --> 01:20:33,120
所以有几个选项，其中之一是

1897
01:20:33,120 --> 01:20:37,020
在大型图像数据库中导航，

1898
01:20:37,020 --> 01:20:39,480
因此可能选择

1899
01:20:39,480 --> 01:20:42,420
信息丰富的示例，用于在

1900
01:20:42,420 --> 01:20:44,580
大型经验图像数据库或

1901
01:20:44,580 --> 01:20:47,639
视频帧中进行训练，或者在

1902
01:20:47,639 --> 01:20:50,820
具有 AI 快速工程的动态反馈中进行训练

1903
01:20:50,820 --> 01:20:53,639
生成图像，然后将其

1904
01:20:53,639 --> 01:20:56,880
变成一个动态问题响应任务

1905
01:20:56,880 --> 01:21:00,420
，该任务将在跨图像的级别使用动力学，

1906
01:21:00,420 --> 01:21:02,580
但仍会

1907
01:21:02,580 --> 01:21:04,380
考虑整个图像，另一种方法

1908
01:21:04,380 --> 01:21:07,800
可能是建立在一些只关注注意力的 oculum

1909
01:21:07,800 --> 01:21:10,320
运动主动推理模型上

1910
01:21:10,320 --> 01:21:11,580


1911
01:21:11,580 --> 01:21:15,179
在少量

1912
01:21:15,179 --> 01:21:18,120
图像中可能会减少状态

1913
01:21:18,120 --> 01:21:20,040
空间或补偿 复杂性

1914
01:21:20,040 --> 01:21:24,179
很大，然后使

1915
01:21:24,179 --> 01:21:26,880
一些较低级别实体的动态与

1916
01:21:26,880 --> 01:21:29,699
眼球运动或

1917
01:21:29,699 --> 01:21:33,060
注意力的策略选择相关，然后将其

1918
01:21:33,060 --> 01:21:35,460
视为低级别的大满贯和

1919
01:21:35,460 --> 01:21:37,679
分类我正在看什么样的图像

1920
01:21:37,679 --> 01:21:40,020
作为较高级别 一个大满贯，

1921
01:21:40,020 --> 01:21:42,300
但政策

1922
01:21:42,300 --> 01:21:43,920
是在图像的哪些部分被扫描的水平上制定的，

1923
01:21:43,920 --> 01:21:45,179


1924
01:21:45,179 --> 01:21:46,560


1925
01:21:46,560 --> 01:21:48,900
是的，

1926
01:21:48,900 --> 01:21:50,760
对于其他

1927
01:21:50,760 --> 01:21:53,280
需要注册为任务的想法来说，这确实是一个非常好的设置，呃，

1928
01:21:53,280 --> 01:21:56,159
但确实会给你带来更多

1929
01:21:56,159 --> 01:21:58,800
，更适合 积极的影响

1930
01:21:58,800 --> 01:22:01,080
嗯非常有趣

1931
01:22:01,080 --> 01:22:03,780
我还想问一下

1932
01:22:03,780 --> 01:22:05,460


1933
01:22:05,460 --> 01:22:08,760
其他各种

1934
01:22:08,760 --> 01:22:11,639
积极提案所具有的两个模块或功能，它们

1935
01:22:11,639 --> 01:22:15,060
是模型的分层嵌套和

1936
01:22:15,060 --> 01:22:16,440
学习

1937
01:22:16,440 --> 01:22:20,520
那么嵌套和学习如何

1938
01:22:20,520 --> 01:22:22,739
影响理论和实现的

1939
01:22:22,739 --> 01:22:25,320
计算复杂性

1940
01:22:25,320 --> 01:22:29,159
所以我认为 我认为你真的可以

1941
01:22:29,159 --> 01:22:30,920
帮助但

1942
01:22:30,920 --> 01:22:34,980
使用活跃婴儿代理的计算复杂性，

1943
01:22:34,980 --> 01:22:37,800
例如一个想法 会是所以我

1944
01:22:37,800 --> 01:22:39,179
在谈论图像生成模型

1945
01:22:39,179 --> 01:22:41,100


1946
01:22:41,100 --> 01:22:44,280
呃想象你有一个图像

1947
01:22:44,280 --> 01:22:46,679
然后所以图像可以像它

1948
01:22:46,679 --> 01:22:48,659
有数百万可能的组合权利

1949
01:22:48,659 --> 01:22:50,219
就像不超过那个但

1950
01:22:50,219 --> 01:22:52,380
可能超过宇宙中的原子

1951
01:22:52,380 --> 01:22:56,060
但是你 可以

1952
01:22:56,060 --> 01:22:58,920
通过模仿

1953
01:22:58,920 --> 01:23:01,020
卷积神经网络的结构来做一点，也许你

1954
01:23:01,020 --> 01:23:04,560
可以在像素块上创建一个

1955
01:23:04,560 --> 01:23:06,360
生成世界，我们提取

1956
01:23:06,360 --> 01:23:08,760
例如不同的线模式，所以也许

1957
01:23:08,760 --> 01:23:12,120
呃水平线或对角线或

1958
01:23:12,120 --> 01:23:14,100
水平线，我们将有一个

1959
01:23:14,100 --> 01:23:16,080
你的层次结构的第一层

1960
01:23:16,080 --> 01:23:18,420
将提取这些信息然后

1961
01:23:18,420 --> 01:23:19,980
你会知道模式的

1962
01:23:19,980 --> 01:23:22,080
模式等等我认为你

1963
01:23:22,080 --> 01:23:23,760
可以创建

1964
01:23:23,760 --> 01:23:25,620
这个你知道的分类

1965
01:23:25,620 --> 01:23:28,800
分布但在 VR 其他模型中

1966
01:23:28,800 --> 01:23:30,540
基本上它是一个开始 你有

1967
01:23:30,540 --> 01:23:33,360
像素，然后你有小的边缘和

1968
01:23:33,360 --> 01:23:35,100
像这样的东西以及边缘的组合，

1969
01:23:35,100 --> 01:23:38,639
基本上一直到

1970
01:23:38,639 --> 01:23:40,620
拥有对象，

1971
01:23:40,620 --> 01:23:44,159
嗯，但这是

1972
01:23:44,159 --> 01:23:47,100
就实现而言非常复杂，我们

1973
01:23:47,100 --> 01:23:49,980
可能需要使用 GPU 进行

1974
01:23:49,980 --> 01:23:51,480
推理过程，因为会有

1975
01:23:51,480 --> 01:23:54,239
非常多的补丁，所以我们

1976
01:23:54,239 --> 01:23:56,540
需要加快训练速度，

1977
01:23:56,540 --> 01:23:59,280
但我仍然认为这是

1978
01:23:59,280 --> 01:24:02,520
减少的好方法 代理的状态空间，

1979
01:24:02,520 --> 01:24:05,100
因为如果您尝试

1980
01:24:05,100 --> 01:24:07,080
基本上将图像作为

1981
01:24:07,080 --> 01:24:09,000
标准主动影响代理的输入，您

1982
01:24:09,000 --> 01:24:12,000
将不得不像是的那样拥有更多

1983
01:24:12,000 --> 01:24:14,159
可能的图像和

1984
01:24:14,159 --> 01:24:15,659
宇宙中的编号或模式，甚至是

1985
01:24:15,659 --> 01:24:17,219
小图像的概率

1986
01:24:17,219 --> 01:24:21,320
所以 层次结构在这方面

1987
01:24:21,600 --> 01:24:23,699
真的很有帮助，所以你还有另一个问题，

1988
01:24:23,699 --> 01:24:26,520
除了呃，第二个方面是

1989
01:24:26,520 --> 01:24:29,159
关于学习的，例如，如果我们

1990
01:24:29,159 --> 01:24:31,500
随着树的继续更新我们的先验，

1991
01:24:31,500 --> 01:24:33,900
或者我们想考虑关于

1992
01:24:33,900 --> 01:24:37,860
先验的政策或其他类型的更新 我们

1993
01:24:37,860 --> 01:24:40,320
可能在其他设置中固定的不同参数

1994
01:24:40,320 --> 01:24:42,120


1995
01:24:42,120 --> 01:24:45,239
是的所以关于

1996
01:24:45,239 --> 01:24:48,719
嗯有可学习的祈祷要说的一件事是

1997
01:24:48,719 --> 01:24:51,300
在某些情况下这可能会出错

1998
01:24:51,300 --> 01:24:52,320
所以

1999
01:24:52,320 --> 01:24:55,020
我 如果你不喜欢，好吧，想象你有

2000
01:24:55,020 --> 01:24:57,620
观察

2001
01:24:58,320 --> 01:25:00,540
，你有国家，所以这些就是

2002
01:25:00,540 --> 01:25:03,000
观察，呃或抱歉，这是

2003
01:25:03,000 --> 01:25:05,639
国家，这将是观察，

2004
01:25:05,639 --> 01:25:08,100
所以三个可能的国家，两个可能的

2005
01:25:08,100 --> 01:25:10,139
观察，如果你从一个

2006
01:25:10,139 --> 01:25:14,100
犹太人层开始 是完全

2007
01:25:14,100 --> 01:25:15,960
统一的，所以也许参数在任何

2008
01:25:15,960 --> 01:25:17,699
地方都是一个

2009
01:25:17,699 --> 01:25:21,300
好吧，如果

2010
01:25:21,300 --> 01:25:24,060
你进行其中一项观察，

2011
01:25:24,060 --> 01:25:26,520
它就会给你尽可能多的

2012
01:25:26,520 --> 01:25:28,860
嗯，就像在她

2013
01:25:28,860 --> 01:25:31,620
的状态均匀分布中的进入过程一样，

2014
01:25:31,620 --> 01:25:34,199
因为里面的权重

2015
01:25:34,199 --> 01:25:37,199
矩阵基本上都是一个，所以对于

2016
01:25:37,199 --> 01:25:39,840
每个观察，没有真正的

2017
01:25:39,840 --> 01:25:42,300
类似状态，这将更有

2018
01:25:42,300 --> 01:25:44,520
可能基本上生成它

2019
01:25:44,520 --> 01:25:45,780
，这意味着推理过程

2020
01:25:45,780 --> 01:25:47,340
将有一个状态的均匀分布

2021
01:25:47,340 --> 01:25:50,940
，基本上

2022
01:25:50,940 --> 01:25:52,920
这是一个问题，因为你 最终

2023
01:25:52,920 --> 01:25:54,300


2024
01:25:54,300 --> 01:25:58,860
会像一个矩阵，其中可能某些

2025
01:25:58,860 --> 01:26:02,760
状态更有可能，但每个状态

2026
01:26:02,760 --> 01:26:04,080
不太可能产生不同的

2027
01:26:04,080 --> 01:26:06,360
观察结果 所以基本上

2028
01:26:06,360 --> 01:26:08,280
学习失败了，

2029
01:26:08,280 --> 01:26:10,199
因为

2030
01:26:10,199 --> 01:26:12,480
如果你再次发生，它就无法接受

2031
01:26:12,480 --> 01:26:14,580
所以如果你记得我们

2032
01:26:14,580 --> 01:26:18,000
更新参数的方式，它只是通过

2033
01:26:18,000 --> 01:26:20,040
计算

2034
01:26:20,040 --> 01:26:22,380
我们正在观察的状态观察对的数量

2035
01:26:22,380 --> 01:26:25,440
以及如果状态 被

2036
01:26:25,440 --> 01:26:27,300
观察到的总是像一个

2037
01:26:27,300 --> 01:26:30,360
点，比如三分之一，

2038
01:26:30,360 --> 01:26:33,420
例如它是一个均匀分布，那么

2039
01:26:33,420 --> 01:26:35,100
它将

2040
01:26:35,100 --> 01:26:36,840
同时计算所有状态的观察值的三分之一

2041
01:26:36,840 --> 01:26:38,820
，我们无法

2042
01:26:38,820 --> 01:26:42,199
确定哪些状态能够

2043
01:26:42,199 --> 01:26:44,159
产生这个观察是因为它们

2044
01:26:44,159 --> 01:26:46,500
都有可能产生这些

2045
01:26:46,500 --> 01:26:48,900
观察，所以会

2046
01:26:48,900 --> 01:26:51,659
发生什么，你无法

2047
01:26:51,659 --> 01:26:53,219
了解哪些状态产生哪些

2048
01:26:53,219 --> 01:26:55,440
观察只是在上面的

2049
01:26:55,440 --> 01:26:58,560
时间里计算一个状态已经出现但你不

2050
01:26:58,560 --> 01:27:00,719
知道关于观察

2051
01:27:00,719 --> 01:27:04,620
所以 这是一个有远见的案例，它

2052
01:27:04,620 --> 01:27:07,380
表明例如将矩阵与

2053
01:27:07,380 --> 01:27:09,900
导数和类似的东西相加可能

2054
01:27:09,900 --> 01:27:11,880
无法破坏环境的动态 nts

2055
01:27:11,880 --> 01:27:13,620
和环境的可能性，

2056
01:27:13,620 --> 01:27:14,760


2057
01:27:14,760 --> 01:27:18,480
所以也许拥有数字网络

2058
01:27:18,480 --> 01:27:21,780
可以避免这个问题，嗯，但是是的，这

2059
01:27:21,780 --> 01:27:23,880
似乎是一个真正的挑战，比如

2060
01:27:23,880 --> 01:27:26,219
学习电

2061
01:27:26,219 --> 01:27:29,639
影响模型中的参数似乎需要像

2062
01:27:29,639 --> 01:27:33,199
人类一样交叉给它一个初稿

2063
01:27:33,199 --> 01:27:35,719
如果模型能够运行，那么

2064
01:27:35,719 --> 01:27:39,480


2065
01:27:39,480 --> 01:27:42,239
当涉及到犹太国旗时，像这样的低温的可能性并不统一，

2066
01:27:42,239 --> 01:27:45,540


2067
01:27:45,540 --> 01:27:47,699
所以这是在积极影响中学习的挑战之一，

2068
01:27:47,699 --> 01:27:51,259


2069
01:27:53,460 --> 01:27:56,100
这是我们在

2070
01:27:56,100 --> 01:27:59,040
指定状态空间时遇到的问题 以及哪些

2071
01:27:59,040 --> 01:28:02,880
政策是可能的，这是一个

2072
01:28:02,880 --> 01:28:04,560
有趣的对话，因为它

2073
01:28:04,560 --> 01:28:07,699
让我们作为建模者参与

2074
01:28:07,699 --> 01:28:10,320
到模型中，

2075
01:28:10,320 --> 01:28:14,280
并帮助阐明我们在哪里设置

2076
01:28:14,280 --> 01:28:16,920
脚手架和约束条件

2077
01:28:16,920 --> 01:28:20,580
我们是什么信息我们

2078
01:28:20,580 --> 01:28:24,540
将那个代理放入什么流形来设置它

2079
01:28:24,540 --> 01:28:27,179
哦它是 在一些

2080
01:28:27,179 --> 01:28:29,520
超级本地上下文中滚下坡路，即使该本地

2081
01:28:29,520 --> 01:28:31,920
上下文在其状态空间中仍然是巨大的，

2082
01:28:31,920 --> 01:28:34,860
它可能仍然只是

2083
01:28:34,860 --> 01:28:37,620
就整体模型结构而言，这是冰山一角

2084
01:28:37,620 --> 01:28:40,080
，这并不是说我们

2085
01:28:40,080 --> 01:28:42,000
需要在实践中探索整体模型

2086
01:28:42,000 --> 01:28:45,659
结构，但理论上它

2087
01:28:45,659 --> 01:28:47,400
非常重要，或者我们可能只是

2088
01:28:47,400 --> 01:28:49,920
看看光在哪里，然后

2089
01:28:49,920 --> 01:28:51,659
把兔子放在帽子里做这些

2090
01:28:51,659 --> 01:28:54,060
以某种方式发挥作用的模型甚至可能

2091
01:28:54,060 --> 01:28:56,820
是确定性的，因为它们

2092
01:28:56,820 --> 01:28:59,940
在一开始就被告知了秘密，

2093
01:28:59,940 --> 01:29:02,059


2094
01:29:02,639 --> 01:29:04,159
嗯，

2095
01:29:04,159 --> 01:29:07,260
我还有一个嗯，

2096
01:29:07,260 --> 01:29:09,600
然后我会问你的问题，所以

2097
01:29:09,600 --> 01:29:10,800
嗯，

2098
01:29:10,800 --> 01:29:14,699
你并列和对比了三种

2099
01:29:14,699 --> 01:29:16,800
不同的方法，这三种方法是

2100
01:29:16,800 --> 01:29:19,080
传递

2101
01:29:19,080 --> 01:29:21,300
贝叶斯过滤和信念

2102
01:29:21,300 --> 01:29:22,620
传播的变分信息，

2103
01:29:22,620 --> 01:29:28,080
以及无论是用于教学还是实用

2104
01:29:28,080 --> 01:29:29,280
用途

2105
01:29:29,280 --> 01:29:32,420
，您认为这些不同的

2106
01:29:32,420 --> 01:29:37,320
方法在哪里有用或

2107
01:29:37,320 --> 01:29:38,940
专业

2108
01:29:38,940 --> 01:29:41,580
是的，它们在哪里更好，或者在哪里是

2109
01:29:41,580 --> 01:29:43,620
另一种的概括或特例

2110
01:29:43,620 --> 01:29:45,780


2111
01:29:45,780 --> 01:29:48,380
，例如

2112
01:29:48,380 --> 01:29:51,480
这样的方式 我们用偏见语言构建模型，

2113
01:29:51,480 --> 01:29:52,860
特别是我们

2114
01:29:52,860 --> 01:29:55,500
跟踪过去，每次我们

2115
01:29:55,500 --> 01:29:57,840
对内部进行新的观察

2116
01:29:57,840 --> 01:30:03,020
进入未来 所以让我也许就去这里

2117
01:30:03,840 --> 01:30:04,620


2118
01:30:04,620 --> 01:30:08,219
嗯 哦 不 是的 所以好吧 所以投资时间

2119
01:30:08,219 --> 01:30:09,960
表达例如我们保留

2120
01:30:09,960 --> 01:30:12,120
过去 这很有趣 因为

2121
01:30:12,120 --> 01:30:14,280
当你有生物化学家通过时你

2122
01:30:14,280 --> 01:30:16,620
也可以有落后的信息

2123
01:30:16,620 --> 01:30:18,840
这意味着当你得到 一个新的

2124
01:30:18,840 --> 01:30:21,659
观察，你将拥有一个

2125
01:30:21,659 --> 01:30:23,520
像状态相关联的网络

2126
01:30:23,520 --> 01:30:25,260
，将要发生的是，你

2127
01:30:25,260 --> 01:30:27,120
将收到这样

2128
01:30:27,120 --> 01:30:29,340
的消息，你还将收到时间倒退的消息

2129
01:30:29,340 --> 01:30:32,820
，这些消息

2130
01:30:32,820 --> 01:30:35,820
将使你能够完善你的

2131
01:30:35,820 --> 01:30:38,100
了解过去发生的事情，

2132
01:30:38,100 --> 01:30:42,480
所以这种重访的能力或者你

2133
01:30:42,480 --> 01:30:43,980
知道更新你对过去的理解

2134
01:30:43,980 --> 01:30:46,260
是非常

2135
01:30:46,260 --> 01:30:47,639
特定于各种时间按摩

2136
01:30:47,639 --> 01:30:50,280
传递算法的东西，并且不会出现

2137
01:30:50,280 --> 01:30:52,980
在例如盆地过滤中的基础和过滤

2138
01:30:52,980 --> 01:30:55,199
中 设置因为我们

2139
01:30:55,199 --> 01:30:59,880
只保持

2140
01:30:59,880 --> 01:31:02,880
当前随机可行的信念状态，当我们扩展

2141
01:31:02,880 --> 01:31:06,840
时就像它获得新的观察和

2142
01:31:06,840 --> 01:31:09,480
与之相关的新状态一样 我们只是

2143
01:31:09,480 --> 01:31:11,940
要执行预测以获得

2144
01:31:11,940 --> 01:31:13,440
后验，然后我们将

2145
01:31:13,440 --> 01:31:15,420
摆脱它，所以我们不能有那些

2146
01:31:15,420 --> 01:31:17,460
坏板消息

2147
01:31:17,460 --> 01:31:20,219
um 来解决你对过去状态的信念，

2148
01:31:20,219 --> 01:31:22,739
所以我们现在真的不能拥有

2149
01:31:22,739 --> 01:31:25,980
这种伪造的

2150
01:31:25,980 --> 01:31:27,780
能力 使用信念传播

2151
01:31:27,780 --> 01:31:31,260
算法，它在 ID 上非常类似于

2152
01:31:31,260 --> 01:31:33,659


2153
01:31:33,659 --> 01:31:35,520
在信念传播设置中使用信念传播所做的事情，

2154
01:31:35,520 --> 01:31:37,980
它只是一种更具可扩展性的

2155
01:31:37,980 --> 01:31:42,420
方法，它使人们能够拥有

2156
01:31:42,420 --> 01:31:45,540
不同的项目状态和不同的

2157
01:31:45,540 --> 01:31:48,199
观察，因为这种

2158
01:31:48,199 --> 01:31:51,360
ptibf 方法是 仅限于

2159
01:31:51,360 --> 01:31:55,560
一种观察和一种状态，如果

2160
01:31:55,560 --> 01:31:57,860
您有例如文本的 X 位置

2161
01:31:57,860 --> 01:32:01,560
中性应用程序作为

2162
01:32:01,560 --> 01:32:03,780
显示环境，那么您将

2163
01:32:03,780 --> 01:32:05,639
需要创建一个随机变量，该变量

2164
01:32:05,639 --> 01:32:07,080
对应于

2165
01:32:07,080 --> 01:32:09,480
这些 X 和 Y 位置的所有组合，所以也许它 将

2166
01:32:09,480 --> 01:32:11,820
是描述位置的随机可行的

2167
01:32:11,820 --> 01:32:14,820
，如果我们对

2168
01:32:14,820 --> 01:32:16,980
每个你知道的展览

2169
01:32:16,980 --> 01:32:19,380
和 Y 位置都有两个值，那么 al  l

2170
01:32:19,380 --> 01:32:22,139
组合将类似于或每个

2171
01:32:22,139 --> 01:32:25,920
值乘以所有密码

2172
01:32:25,920 --> 01:32:28,800
并且这与

2173
01:32:28,800 --> 01:32:30,420
许多变量成指数关系所以让我们假设我们

2174
01:32:30,420 --> 01:32:32,580
现在是可扩展的

2175
01:32:32,580 --> 01:32:34,739
并且这个变量可以采用两个

2176
01:32:34,739 --> 01:32:37,080
额外的值然后

2177
01:32:37,080 --> 01:32:38,460
组合的总数 这三个随机

2178
01:32:38,460 --> 01:32:40,739
变量中的

2179
01:32:40,739 --> 01:32:43,020
八个可能的组合基本上是

2180
01:32:43,020 --> 01:32:45,179
所有 X 和 Y 位置或两个

2181
01:32:45,179 --> 01:32:47,639
尺度可能性的 h 可能是尺度 1 和

2182
01:32:47,639 --> 01:32:48,900
尺度 2

2183
01:32:48,900 --> 01:32:51,239


2184
01:32:51,239 --> 01:32:53,520
如果你没有这种

2185
01:32:53,520 --> 01:32:55,620
能力有几个，这种指数增长变得完全神奇 observation 和

2186
01:32:55,620 --> 01:32:57,540
几个 States，因为你尝试建模

2187
01:32:57,540 --> 01:33:00,060
的 state 和 observation 的数量会增加

2188
01:33:00,060 --> 01:33:02,159


2189
01:33:02,159 --> 01:33:04,860
，这就是 Alexa 的

2190
01:33:04,860 --> 01:33:07,980


2191
01:33:07,980 --> 01:33:11,520
真正之处

2192
01:33:11,520 --> 01:33:13,440


2193
01:33:13,440 --> 01:33:16,800


2194
01:33:16,800 --> 01:33:20,760
Jacob 有什么结束性的

2195
01:33:20,760 --> 01:33:24,080
问题或想法

2196
01:33:26,400 --> 01:33:30,600
吗？好吧，你看，几个月前我看到了你的

2197
01:33:30,600 --> 01:33:32,460
作品

2198
01:33:32,460 --> 01:33:35,940
这让我非常兴奋，以至于

2199
01:33:35,940 --> 01:33:40,260
我读了你所有的五篇论文，嗯，这

2200
01:33:40,260 --> 01:33:44,219
是第五项权利，我的意思是，嗯，你

2201
01:33:44,219 --> 01:33:49,080
发表了五篇论文，

2202
01:33:49,080 --> 01:33:51,719
因为你经常看到

2203
01:33:51,719 --> 01:33:55,080
人们看到主动推理，呃

2204
01:33:55,080 --> 01:33:58,699
自由能原理作为呃基本上是

2205
01:33:58,699 --> 01:34:01,920
推测性的呃思考和努力

2206
01:34:01,920 --> 01:34:05,340
在实际应用中没有那么多的实用价值

2207
01:34:05,340 --> 01:34:09,600
所以在我看来呃

2208
01:34:09,600 --> 01:34:12,540
你的工作正如我提到的那样有一个非常

2209
01:34:12,540 --> 01:34:16,159
受欢迎的补充这个呃新生但

2210
01:34:16,159 --> 01:34:19,980
呈指数增长的感觉呃我

2211
01:34:19,980 --> 01:34:23,000
希望看到

2212
01:34:23,000 --> 01:34:26,219
未来分支

2213
01:34:26,219 --> 01:34:28,679
时间主动推理的更令人兴奋的发展，或者

2214
01:34:28,679 --> 01:34:29,580


2215
01:34:29,580 --> 01:34:33,360
你可能在未来想出的其他变体，

2216
01:34:33,360 --> 01:34:36,600
呃，呃，

2217
01:34:36,600 --> 01:34:39,420
从现在开始我一定会继续关注你的工作

2218
01:34:39,420 --> 01:34:41,940
非常感谢你

2219
01:34:41,940 --> 01:34:43,980
今天加入我们

2220
01:34:43,980 --> 01:34:46,139
哦 没问题谢谢你邀请

2221
01:34:46,139 --> 01:34:48,300
我我真的很兴奋我可以在这里展示

2222
01:34:48,300 --> 01:34:51,719
所以谢谢你的邀请

2223
01:34:51,719 --> 01:34:54,780
雅各布任何最后的想法

2224
01:34:54,780 --> 01:34:58,679
是的嗯嗯这是一个非常棒的礼物

2225
01:34:58,679 --> 01:35:02,880
离子和讨论呃

2226
01:35:02,880 --> 01:35:07,139
阿里也呃链接呃你的工作

2227
01:35:07,139 --> 01:35:10,800
几个月前而且呃让我非常

2228
01:35:10,800 --> 01:35:14,100
兴奋呃对于

2229
01:35:14,100 --> 01:35:17,639
主动推理建模的嗯未来

2230
01:35:17,639 --> 01:35:20,880
这是一个我们正在

2231
01:35:20,880 --> 01:35:24,840
讨论呃相当多的话题

2232
01:35:24,840 --> 01:35:27,840
在研究所和

2233
01:35:27,840 --> 01:35:30,540
嗯，我认为

2234
01:35:30,540 --> 01:35:33,500
这种方法可以减少

2235
01:35:33,500 --> 01:35:38,280


2236
01:35:38,280 --> 01:35:41,040


2237
01:35:41,040 --> 01:35:42,900
在越来越

2238
01:35:42,900 --> 01:35:46,139
复杂的状态空间中执行主动推理的计算成本，这

2239
01:35:46,139 --> 01:35:50,699
可能是真正

2240
01:35:50,699 --> 01:35:53,460
达到采用这些模型的最佳方式

2241
01:35:53,460 --> 01:35:55,139


2242
01:35:55,139 --> 01:35:57,719
在不同领域的不同所以是的，

2243
01:35:57,719 --> 01:35:58,679
我非常

2244
01:35:58,679 --> 01:36:01,619
感谢你非常感谢你今天的

2245
01:36:01,619 --> 01:36:04,800
加入而且我期待

2246
01:36:04,800 --> 01:36:09,000
阅读关于深度主动

2247
01:36:09,000 --> 01:36:11,280
推理深度分支时间活跃

2248
01:36:11,280 --> 01:36:14,179
实习生的论文当然谢谢

2249
01:36:14,179 --> 01:36:18,239
你不客气 随时回来，我们

2250
01:36:18,239 --> 01:36:20,639
肯定会观察

2251
01:36:20,639 --> 01:36:22,320


2252
01:36:22,320 --> 01:36:25,219
谢谢你肯定谢谢你

2253
01:36:25,219 --> 01:36:29,360
再见谢谢再见

2254
01:36:34,020 --> 01:36:36,440
完美

2255
01:36:36,659 --> 01:36:39,500
耶伟大的

2256
01:36:39,780 --> 01:36:42,500
辉煌

