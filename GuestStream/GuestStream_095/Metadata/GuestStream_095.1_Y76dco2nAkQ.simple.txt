SPEAKER_01:
hello and welcome everyone it's january 16th 2025 we're an active inference guest stream number 95.1 with rithvik prakhi discussing active inference for self-organizing multi-llm systems a bayesian thermodynamic approach to adaptation so rithvik thank you for joining looking forward to your presentation and sharing more and discussing so thank you to you


SPEAKER_00:
great thank you thank you daniel for having me um yeah so i'm gonna talk about kind of active inference for self-organizing multi-lm systems so basically making llm agents better with active inference

So to motivate the problem a little bit, current multi-LLM agents kind of have a lot of complex parameters.

For example, prompts, agent architecture, tool use, like these are things that you can't just kind of fix with hyperparameter optimization.

You have to find better, more intelligent ways to improve these in time.

And that's not really a thing right now.

um also another thing is that lms themselves are used as a vector f adaptation for the agent in many ways so for example in the voyager paper um llms are used to acquire new skills and then use those skills to explore the environment of minecraft further um

which is useful, but also quite limited.

And then the third thing is that there's no formalized mechanism of balancing the exploration exploitation trade off.

Right now it's kind of just using LLMs internal abilities to go about that, but there's no formalized mechanism and that kind of limits a lot of the potential.

Now, our solution is using active inference to kind of overcome a lot of these problems.

So the first thing is that the best possible prompt for different LLMs within the agent can be learned over time.

These things are something that we can figure out from the environment.

large we can do search to figure out what are the best new prompting techniques so we can test out different prompts to see which ones give better scores on certain metrics so these things can be learned over time and the active inference agent

can help with that because now the active inference agent becomes the vector of adaptation, allowing for real learning through belief updates and structural updates versus just solely in context adaptation, which is what LLMs can do.

So we're actually learning and we're actually adding information and updating beliefs within our model.

And Active Inference acts as a formalized mechanism to balance the explore-exploit boundary, allowing for a more principled understanding of uncertainty and also giving us the option to verify optimality, see if the path of selecting actions is actually an optimal one or not, which we can't do with LLMs directly.

So active inference works through a generative model.

And the generative model we typically use for active inference in discrete time is called the Partially Observable Markov Decision Process, POMDP.

That's Markov because

current states are only influenced directly by past states and it's partially observable as opposed to a regular MDP because of the agent doesn't have the ability to directly observe the states that must go through an observation, which allows it to update beliefs about the states without any direct observation of the states.

So within active inference, we have several matrices that we put into these POMDPs to encode the actual information that we're learning from the environment or that is contained within the environment.

So the first thing is the A matrix or the likelihood matrix.

This is basically just showing the relationships between the likelihood, showing the relationships between states and observations.

So what are the chances that this observation is related to this state or this state produces this type of observation?

The B matrix is showing the relationship between states at t plus 1 and states at t, time t. So basically, what is the probability that this state will occur at this time, given that this state occurred at a past time?

Now, the C matrix encodes the preferences of the active inference agent.

So for example, if some of the states that this model had was sunny weather and rainy weather, the C matrix would encode that the model likes sunny weather.

then the d matrix encodes the prior beliefs over states now the ultimate goal is to minimize surprise because surprise low surprise means that the model we have is actually a good representation of its environment but if we don't if we have high surprise that means we're not really understanding the environment well because every observation we're getting is surprising us so the goal is to minimize surprise and

However, the issue with just directly minimizing surprise, which is shown in this equation here as negative log of the probability over all observations, is that this is typically intractable when the state space gets really big and it grows exponentially.

So we can't directly minimize the surprise.

So we have to...

turn that into a new quantity that we can more easily approximate to instead of directly computing.

So this is how we derive variational free energy by doing a variety of steps from Bayes' theorem to get to this final equation.

Now, the variational free energy equation is constituted of two terms, the complexity term and the accuracy term.

So the complexity term is basically just showing us the difference between the distributions for the prior beliefs and the posterior beliefs.

And the accuracy term is just trying to show us how close

how well the observations that, how well the states that we're seeing and how well those observations align with the states that we're seeing or the states that we believe in.

So effectively the goal is to minimize the difference between our prior beliefs and posterior beliefs, and also to have our beliefs be as accurate as possible given the observations.

Now, the way this actually happens is a minimization process.

Like we said before, this is a quantity we want to approximate to.

So this equation right here, the DF over DQS, is just the partial derivative of free energy in terms of the posterior beliefs.

This first equation is just showing it in terms for one state factor.

And when we do this, we want the derivative to equal zero over time.

But in practice, what happens is we have a max number of iterations.

Once those max number of iterations are reached, or the change in variational for energy falls below a certain threshold, the optimization process stops, and we have our final posterior beliefs that have minimized the quantities we want to minimize.

This is the final posterior belief equation shown right here, basically just showing how

the final posterior beliefs will look, how they're influenced by the prior beliefs, and how they're influenced by the observations, the current state factor, and also the other state factors.

Now, the second quantity in active inference that we're trying to minimize is the expected free energy.

Now, this is related to policies and actions in future states, as opposed to variation of free energy, which is very in the present.

So expected free energy is made up of two terms, information gain and pragmatic value.

So information gain is just trying to show how much we expect to gain by doing a certain action.

So the way that transitions are determined is

they're conditioned on an action.

So if we do this action, what is the likely outcome?

So right here, we're saying, if we do this specific action, so a policy, if we execute the certain policy, what is the likelihood of having significant information gain?

If we have a lot of information gain, that means it's a useful action because it's highly informative and that's what we wanna optimize for.

So the second term is called pragmatic value, also known as expected utility.

This term is useful for comparing the expected observations to our preferred observations.

So as I said before, the C matrix is the one that encodes the preferred observations.

And since we have some idea of what the expected states are from the B matrix, we also have some idea of what the expected states are in the A matrix.

We can figure out what the expected observation should be as well.

And on those expected observations, we can do a computation with the C matrix to see how high the expected utility or the expected level of preferred observations exists in the action we're about to commit.

The final part we need for this paper, at least, is the A matrix updates.

So the A matrix is the, like I said before, the matrix that encodes the relationship between states and observations.

But in our specific implementation, the agent doesn't initially know exactly how the states mapped observations.

It's intended to learn that over time by getting in new observations.

So to do that, we need to have some mechanism to update it.

And this is the mechanism.

So we do a similar thing we did with variational free energy, where we take the derivative of variational free energy with respect to the modality or the A matrix with a certain modality.

And we basically compute that over time.

And then we take this equation, and then this equation turns into the final derived equation below.

This final derived equation below is just explaining how we should update the A matrix.

So the main updates are going to come from the outer product between the observation and the current belief.

So for example, if you have two states that are sunny and rainy, and the observation that you get is that it's sunny,

All we would do is update the aspect of the sunny part of the A matrix to say that we're getting an observation that's sunny, and then add those to the counts of the A matrix.

So getting to the actual specific work done,

So this whole generative model consists of three state factors.

So the first is prompt combinations.

The second is search states or search terms.

And the third is the info state.

And then there's seven observation modalities.

So the accuracy, relevance, and comprehensiveness observation modalities are directly tied to the prompt states.

The information relevance, information usefulness, and source quality modalities are directly related to the search state.

And then the infostate just has three modalities with an infostate observation modality and an infostate state factor.

So they're directly related to each other.

So that means any observation in the infostate modality is just a direct reflection of the state factor.

So this figure just shows the A matrices for each of these state factors and their relationship with the observation modality.

So the first three is just for the prompt quality matrix.

So this is basically just showing the relationship between the three quality metrics we described, the accuracy, relevance, and comprehensiveness, and the prompt states.

Now, initially, you see all these squares are just blue.

This is because the model has engaged in no learning.

It's starting with a complete blank slate and has no understanding of the environment in this specific case.

Now, the way the generative process actually works is that agents can select actions.

So they can either select prompt actions or search actions like we showed before.

These are the two controllable states.

Now, what a prompt action will do is it'll take a certain set of prompts that the agent selects.

It'll run them through the actual research agent that we're trying to optimize here.

It'll run them through an agent.

It'll give certain observations.

So as you can see, this kind of JSON structure here, what we're doing is we're using a chat 54 mini.

and that's just going to give us a score from 0.0 to 1.0 counting up by 0.1 on the three different metrics we need so for example if an agent selects a prompt action we first

run that prompt, run those set of prompts through the agent.

We get a final result.

On that final result, CheshDPoroMini will evaluate it and then give us three scores.

Those three scores will then get turned into an observation vector, and that observation vector will get passed back to the active inference agent to use as observation.

Now, this is the exact same process that happens for the search action as well, just with a different prompt.

So this is actually the prompt for the search action.

As you can see, we're telling Chats for Tea to return scores on info relevance, usefulness, and source quality.

Now, the info state is unique because it's determined purely by the amount of knowledge base.

So the way that knowledge base works is by the amount as search actions are carried out and more information is added to the knowledge base.

the info state goes from no knowledge to some knowledge to a high level of knowledge.

And those are observations that are directly getting passed from the environment to the agent.

So the agent doesn't actually have any encoding

of the information it's getting from the search actions all it knows is that there's some knowledge state coming from the environment and it's using that as a way to determine what to do next and what observations it prefers so yeah that's where that's where that's where that's coming from now for the results

This is the same figure I showed before, but now with learned environment mappings.

So as you can see, for the first three matrices, these are the prompts, the agent for each prompt has a distribution over what scores of expecting.

So for example, for the first prompt, it's going for eight and nine.

So it has a distribution saying it's most likely expecting, so this is the accuracy, this is the accuracy metric.

So saying that for prompt one, for prompt combination one, it's generally gonna expect an eight or a nine on the accuracy metric.

And it does that all the way through for all the prompts.

And it does the same thing for search as well.

So this is the info relevance metric.

So for example, it's saying that for prompt one, it's generally going to expect a score of 9 out of 10 or 0.9 out of 1.0 on the info relevance metric.

So kind of all that.

And then the info state metric is just concentrated around the second observation.

The second observation is just high info.

So like detailed information from the environment.

This is because the agent was running over 20 trials and once

and the info state metric gets to the knowledge base that we have gets to a high level pretty quickly.

And then so that the info state kind of just keeps getting observations about that it's in a high level of information, has high level of information and just keeps getting those observations.

So it's all concentrated around that observation specifically.

Now, one of the main points of this was to show how we could

show how we could go through the explore exploit trade-off really well by using active inference.

And this is kind of showing that.

So this is just some time series data from time step zero all the way to time step 80.

The red dots are search actions and the blue dots are prompt actions.

So as you can see, we have a preponderance of search actions in the initial stages because the agent is trying to learn the environment, trying to get more information

and stuff like that.

So it's trying to understand how prompts work, how prompting works.

And then towards the end, there's mainly search actions, or sorry, mainly prompt actions as the agent is testing these prompts to see if they work well or if they don't work well, kind of using the information it's gotten from the search actions.

Now, we know it's not actually using this.

It's more kind of a simulation.

It's using it in the sense that it knows that we already have a lot of information from the environment because of that info state observation it's getting.

So in conclusion, what we did here was that we had the model effectively learn the environment's generative process, mapping the observations to the hidden states.

We were able to simulate human-like exploratory behavior with active searching and testing multiple possibilities.

And then the main thing is that we were able to enhance the capability of LLMs as well as enhance the capability of Active Inference because we gave LLMs a formalized structure that they didn't have before to execute learning through.

And we gave Active Inference the ability to operate in high dimensional spaces by integrating LLMs

If we had to try to encode this functionality directly into the active inference agent, it would have been much more harder and much more complex than just having the LLM outsource everything to the LLM and have it do a lot of the work.

So we kind of had improvements on both ends through the system.

Now I just want to talk about some

some future directions for this.

So obviously the one big thing that this model doesn't have is encoding actual knowledge from the environment.

So as we perform search actions,

we're getting information about prompts, right?

So we're saying, so if we look up, what are the best ways to prompt for ChatGPT?

It'll say like tree of thought, chain of thought, blah, blah, blah, et cetera, et cetera.

But none of this information is actually getting encoded into the agent.

All that's happening is that there's an info state, right?

And it's using that info state to determine its future actions.

But it would be much more useful if the active inference agent actually knew

why certain prompts or certain prompt combinations were good based on the search actions, and then use that information directly to influence those actions.

So that would require some sort of hierarchical model, and making that would be a good feature direction for this.

Another thing is giving the agent the ability to dynamically expand its state space to not be constrained to a fixed set of prompts.

So here, what we did was we just had a fixed set of prompts for each part of the agent.

And obviously,

there's much more the space of possible prompts infinite space and there's there's a lot more we could explore if we weren't constrained by a fixed state space so expanding on that would be very useful and also the third thing would be to equip the agent with the ability to modify other complex parameters such as instead of just prompts maybe also be able to modify the architecture of the agent or the tools it's using and stuff like that

The eventual goal is to make a general kind of agent brain that has the capability to be plugged into any LLM agent and exhibit human levels of learning, modification, structure learning, and stuff like that.

So yeah, I think that's it.


SPEAKER_01:
Awesome.

Thank you for the presentation.

For those watching live, they can write questions while I'm just cropping and getting everything back.

Maybe share a little bit.

How did you come to this project?

Where are you at in your education and research and all of this?


SPEAKER_00:
Yeah, sure.

Well, I only found out about Active Inference maybe a year ago.

And kind of how I happened upon it is that

I wanted to kind of do this general idea that I just said, like the agent brain.

So, because I noticed that LLMs were pretty static and, or like LLM agents were pretty static and then humans had to directly go in and like, oh, let me fix this prompt or let me change the order of these two nodes and stuff like that.

And the same kind of, you know, LLMs themselves can do a lot of that improvement work, but it seemed like there was a big hole there that we could just fill by having some sort of self-organizing behavior.

And that's kind of how it happened upon Active Inference because it was this model-based.

So we were responsible for figuring out how to actually structure the generative model and the generative process that the agent was going to work with.

And it was very sample efficient, which I really liked because generally you don't get that many samples in a typical workload.

So for example, if we're using an agent in production, we wouldn't really be getting, unless it was being used at massive scale, we wouldn't be getting too many examples that we could work with to improve certain functions.

And the sample efficiency of Active Inference really kind of helps with that issue.

And then the other thing was the reinforcement learning, obviously, just having some aspect of being able to learn over time.

With LLMs, you can't really do that.

It's all in context.

And I'm suspicious that in context learning is, or just having information in context is enough to replicate the abilities that a reinforcement learning scheme can provide.

So that's kind of how I happened upon this and started looking into it.

I actually read the Thomas Parr Carl Friston textbook.

um on this and that's kind of how i got into it started doing some work and yeah kind of came to this


SPEAKER_01:
Cool.

Okay, I'm gonna read some questions from Arun Naranjan, a colleague at the Institute, and then any other questions in live chat, we'll see.

Okay, so thanks, Arun, for the awesome submitted questions.

All right.

What does it mean to ask an LLM for a numerical score of something?

Can we really convert the sampling of the next token's probability distribution of an LLM into a meaningful quantitative observation?


SPEAKER_00:
Hmm.

So it's, it's kind of a, um, the LLM observation is kind of a, uh, a prox maybe approximation or like, uh, kind of a,

maybe an easy way to do this basically.

So all we're doing is we're saying like, because the best text readers at this time in AI or text understanding machines kind of are LLMs.

Because the way this is working is that the LLMs are getting

just a bunch of text because the research agent is outputting a bunch of text, and the active inference agent directly can't really do much with this because language is a hard space to understand, and active inference would need a lot more improvements to be able to understand that space.

So basically, all we're doing is that we're kind of simplifying the complex state space of just the English language, and we're simplifying it into something the active inference agent can understand.

So what we're doing is that the LLM can understand language, and it can generate certain scores.

Obviously, the LLM scores aren't as useful or nuanced as a human scoring certain text would be.

So for example, if there's an essay competition, an LLM would probably be a much worse scorer for those essays in a consistent manner than a human would be.

because it's kind of hard to determine what the standards are but for something like this where the text is relatively simple um it's pretty easy for the lm to just say this is the score i'm giving to the text we give it certain like guidelines to follow when assigning scores so it just gives a certain score and that score is kind of a

basically a simplification of the state space of all possible languages to just three values that we can use to kind of help the active inference agent learn.

Now, ideally, it would just be the active inference agent directly digesting the language, but this is kind of an easy way to overcome that massive gap in complexity.


SPEAKER_01:
Yeah, great response.

I'll add a few comments.

you pointed right there that a longer term research agenda is like an active inference linguistics model using some kind of syntax and semantics on the natural language itself.

And so some kind of mega hierarchical model or something cool like that.

But in the meanwhile,

For specific purposes, we can take natural language expressions, use LLMs, especially with the JSON or structured output, and project them onto numerical lower dimensional state spaces, like how many bird species are mentioned in this paragraph.

only respond with a specific number three and then you have an a matrix that takes in as an observation the number of bird species observed and then maps to some other variable for the ecosystem or how many facts in this paragraph correspond to this circumstance and so then the active inference generative model can pick up

at the interface of the output of the structured llm return so it's it's a design pattern i think that's very rapidly emerging and it's exciting to see that that you're working on it because it really does bring together this mega parametric you know millions to billions of parameters high dimensional state spaces more generic architectures for llm and such

and then take the output sometimes crystallized down to just like a single scalar value or to a vector of numerical values pick up there with the more interpretable smaller and sample efficiency and direct belief updating and then just one more piece i'll say there's you can get an llm to give

uh quantitative or natural linguistic representation of its own uncertainty but then there's this kind of head-scratching moment where it's like well even if it says that it's 55 confident that is the most likely chain of tokens for it to say it's not a true introspection of its actual uncertainty

And so again, further down the road, that's a promising avenue for active inference models that can introspect and accurately have their own uncertainties.

However, in the meanwhile, this is one way that we can make the best of what exists today and what we can build tomorrow.

Exactly.


SPEAKER_00:
And one other thing I'll add is that what I'm trying to do as well is

LLMs can already do a lot, so kind of have LLMs do as much as possible, but also try to kind of like what I was saying before, like having the active infrastructure be able to encode the information itself from the environment, like add things to the active infrastructure over time and then offset some of the responsibility of the LLM so that

we're getting the actual interpretability of proper uncertainty estimation and all that stuff within the active inference agent without having to rely on the LLM.

But we can basically, if active inference is here and the LLM is doing all this, we can just

you know, move that gap over time as we develop more, but we're still getting the performance to start with.


SPEAKER_01:
That's kind of funny.

It makes me think of like a grass is always greener or some kind of compliment where for the LLMs, we might gain interpretability by projecting down to smaller states based models that have real quantitative variance estimators.

Whereas for active inference models, we can gain interpretability and accessibility by translating them out to natural language.


SPEAKER_00:
So, you know, yeah, yeah, that's a great way to put it.


SPEAKER_01:
Yeah, more tools better.

Okay, Arun asks the next question.

Over what timescales did your active inference plus LLM agent execute?

How did that change with the complexity of the questions asked?

What was the runtime dynamics?

How long does one full loop take?


SPEAKER_00:
Yeah, I mean, it's pretty short.

So it was 20, it was, it was about like 80, 80 time steps.

So kind of just 80, like 20 trials, four time steps for trial.

The time steps only were relevant to the info state, the info state, or information state, because the other two didn't really have any trends, transition dynamics.

But effectively, yeah, what it would just be is that for each time step, there would be some sort of action.

The LLM would run through all the stuff it had to run through for the agent.

So the research agent would run that we're trying to optimize, and then the evaluation on that result would run.

And then we would have that observation, and we'd put it back into the active inference model.

So that would be one full time step.

So that maybe took, in terms of actual time, to run the research agent, run the evaluation,

And then the active inference model itself, maybe each time step took like 10 seconds.

It was relatively quick, especially because we're using like 4.0 mini, which is like faster than something like 4.0 maybe.

And the active inference agent was like the state space was pretty small.

So it didn't take much time for the active inference agent to run as well.

So yeah.


SPEAKER_01:
Cool.

Yeah, I could see the latency of the LLM being a major determinant, whether you use kind of a smaller or a faster call, or whether you do something that that takes a bit to get chugging.

Okay, cool.

All right.

Arun's next question.

Did you actually get good answers to research questions you asked?


SPEAKER_00:
Well, the LM itself already worked.

Or the research engine itself already worked.

So it had certain prompts, and it would output something.

So for example, if I asked...

what give me give me like a report on coffee or something it'll go through the entire you know it was basically five aspects to the research agent it was um planning reviewing uh actually like or getting information from the internet answering the question and if there's like uh any issues with the answer then it would route back to the initial planning stage and then kind of go back from there

So the agent itself was already relatively good at getting answers, getting good answers or getting good reports on whatever question you asked.

Maybe the point of this was just to show that, because if you think about it in time, the prompts will become worse and worse every time, because prompting techniques get better.

Well, they'll get worse and worse in the sense that our knowledge of how to prompt increases, for example.

We initially used to only think about step-by-step prompting.

That was the max of what prompting could be.

Now we have so many different techniques.

We have a tree of thought, chain of thought, a react framework, blah, blah, blah.

There's like so many different techniques.

And if we had started in like 2023 with just the step by step prompting and we as a human didn't go back in there and fix it ourselves, then we would just be stuck with those bad prompts compared to where the literature is at right now.

So the idea was that, well, for this was a fixed state space with just like, it was like five prompts for agent that we had to work with.

And then those would be formulated into combinations of prompts that the active inference agent could select.

So it's just kind of a...

a simple way to show that the active inference agent could pick these prompts, pick the best one, research from the environment, and then do this whole process to try to learn which is the best prompt in that very small state space over time.

It's not going to change the effectiveness of the research agent too much because the state space of the prompts is so small, but it was already good to begin with and it was good to end with.


SPEAKER_01:
Yeah, thanks.

A few comments on that.

We're seeing at this moment just such an exponential increase in the capacity.

So as you point out, even six months or a year can be very different.

And it's an exciting time for understanding research and cognitive science agents overall.

Like I think about the graph structured knowledge bases like Buehler's graph preflexor type models where

you know, limitations of in-context learning that you pointed to can be addressed with some operations on knowledge graphs.

And it's like, we're kind of exploring motifs and initial pattern designs and proofs of concepts for how these kinds of synthetic intelligence systems and augmented systems with human and non-human entities can be collaborating in information spaces

epistemically and like everything from the user interface and and the the accessibility and the human computer side on through what are we really yielding are we synthesizing new molecules are these revealing errors in previous derivations and papers are these you know shorter algorithms like so it's just like wow happy 2025 huh


SPEAKER_00:
um how arun asked how did this compare to purely llm driven agents for example llm plus while loop plus tool calling yeah so using llms um we can definitely use like lms directly to improve the agent so kind of just say like so we have this research agent we just have the llm going and say um

like if every time like every like let's say like every day do research on like all these topics around prompting um synthesize that research

put it in your context, and then use that context to, like, look at all these five prompts, make them better.

Now, if we just said that, the LLM is going to do way better than the active inference model right now, because obviously LLM can explore an infinite state space of language, and we only have, like, five prompts we're looking at, and we can't really, like...

Right now, there's no actual thing where doing the search is actually changing the prompts or changing the prompt selection mechanism or anything like that.

So yeah, LLM by itself would perform way better than the model currently.

But the issue is that at the end of the day, it's all in context learning with LLMs, and there's no way to maintain a real understanding of the environment over time.

actually encoded within belief updates and these matrices.

And that's what the active inference is bringing.

And this is more kind of like a proof of concept to show that we could do that at some point.

Because just thinking about it theoretically, an easier way to improve this is just to say, kind of like how I said the LLM can just take in context, blah, blah, blah.

Now we could just do something simpler where we could say,

Now the LLM, go do this research every day, take in that, put it in your context.

Now turn that into states that we can, or state factors that we can put with an active inference agent.

Now the active inference agent has a whole new set of state factors and states within those factors.

And now I can use that directly to learn about new prompting techniques.

And it has new, like, it's dynamic, state space is dynamically going to change because that element is adding new prompts all the time.

And this way, like, it's a much better way of having the active information station actually learn these prompts.

And it's probably, I mean, we don't know yet, but most likely it's going to perform better than the LLM just doing it in context by itself.

But it's like a pretty simple way because of just like having the LLM do a lot of the work.

Because without that, the active inference agent, like the same kind of process I described, just purely with an active inference would take a really long time to figure out.


SPEAKER_01:
Yeah, that reminds me of how many ways we're seeing pop up that computer science and AI is sort of rediscovering or reinventing cognitive science, like knowing that versus knowing how, knowing where to look,

to get more information.

And then it's like, okay, well, let's just say we are going to have our grad student, I mean, research agent, and they're going to be doing some daily task.

We say, well, I want the report to be balancing accuracy and complexity.

Well, that's variational free energy.

Or in terms of prospective experimental design,

what should be the criterion well the reinforcement strategy is with some sort of large or curated or labeled database train an auxiliary reward function and then just go ahead and try to hill climb on that reward function well what if we're into the unknown we're on the frontier we don't necessarily have a training data set um or maybe we we wouldn't even want one even if we could so then what criteria should we use that's directly based on the model

that yields pragmatic and epistemic value in the expected free energy this explicit explore exploit trade-off and and the ability to modulate between returning expected results with the high expected utility to learning

then it's like just like you gave that kind of daily duty cycle with like every day go and research something and then that could be encoded kind of during sleep into beliefs like what is the the zero to one and a variance on what is the likelihood that this is going to happen or what's the efficacy of this treatment over that treatment

and then that gives an actual information gain term so that it doesn't just continue to do the same internet searches again and again rather those searches are tuned for epistemic value so it's like and then even to the chain of thought and tree of thought

well this is where we get into questions like rumination where you could have at a hyperparametric level you could think too little and leave good thoughts kind of unthought on the table so to speak or you could ruminate and you could think too long and be past the point of diminishing return well where is the pareto optimal point for how long you should be thinking that's a metacognition question that's a cognitive security question and so it's like

it's really interesting to see even though they've been coming from the horizon with these mega parametric models they're actually converging to some of the formalisms and the trade-offs that cognitive science has been working with for a long time related to everything from like epistemic foraging and memory and skill to metacognition so i mean so cool how it's all coming together


SPEAKER_00:
Right.

I think like Google even recently was focusing one of their models on surprise.

So they were using surprise as the reward function to kind of improve their models.

And it's kind of like that's I mean, that's active inference right there.

So it's kind of it is kind of cool that we're seeing these concepts and active inference kind of extend out to just like LLMs and diffusion models and stuff like that.


SPEAKER_01:
Yeah, and although minimizing surprise is maximizing model evidence, there isn't a tractable heuristic to bound success or evidence, whereas there is one to bound surprise, again, even though they're kind of dual, so there's an interesting relationship there.

Okay, next Arun question.

Why does the A matrix need a specific action dependence?

I believe PyMDP should create a B control state for every action anyway, so you should be able to set those out of the box as it were.


SPEAKER_00:
Well, the A matrix doesn't have any action dependence.

It's just the...

the actions are able to provide observations that the A matrix can use to update itself.

But the A matrix itself doesn't have any action dependence.

It is all through the B matrix.

So the one thing is that the prompt and search states are controllable, but they don't have any legitimate transition dynamics.

So just because

if we commit some sort of action, it's not actually causing the prompt combination at one state to transition to the prompt combination at another state.

It's more that we are picking those prompt combinations independently, or independently in the sense that it's basically just going to be deriving from expected free energy.

So whichever is the lowest expected free energy is the one we're picking.

But the action isn't directly causing the transition from...

prompt combination one to prompt combination two the only thing where that's actually happening is the info state so like i think in the code or in the code there's um like b matrix learning as well but it really only happens for the um info state the other the b matrices for the prompt states and the search states are completely the same over time kind of showing that like

they really don't have any direct this action causes this state to this state kind of you know dynamics there cool um thanks for clarifying and this is sort of a classic design


SPEAKER_01:
degree of freedom or openness for those who have explored these cognitive models which is what exactly should the agent know about the consequences of its action because if it doesn't know the consequences of action it's just going to be flailing wildly

Whereas if it's given too much information about the consequences of action, it's kind of like putting the cat in the hat because it's going to know exactly what it's going to do.

So that's where having the B matrix learning and having these learning methods is really cool and really helpful because then you can see, okay, with what learning rate and what kind of variability in action and in the generative process in the niche,

what dynamics yield over what time scales the convergence to veridical learning of the consequences of action

So maybe it needs to spin 10,000 prompts out before it understands the consequences of certain kinds of prompting.

Maybe it only needs to throw out a few, depending on what it is.

So, okay.

And then one more question from Arun, and then if anyone in the live chat has questions, they can write it.

He wrote, similar question to our Bellamy, another Discord colleague.

How did you find using LandGraph?

LandGraph.

It seems like quite a polarizing framework, but still probably easier to use than PyMDP, sweating emoji.


SPEAKER_00:
Yeah, definitely easier to use than PyMDP.

I had to do a lot of going into PyMDP and changing a lot of those source code to make all of this work, which was useful for me.

But yeah, Landgraf, actually, I...

I run a company where we build AI agents for other clients and companies like that, and we typically use LandGraph for everything.

So it wasn't too hard because I have a lot of experience in that.

But the PyMDP was definitely harder, that's for sure.


SPEAKER_01:
What functionality does the LandGraph provide?

And how does it interface or pass to PyMDP?


SPEAKER_00:
Yeah, so the LandGraph is basically just a framework to create nodes and edges.

And the main other thing is that it can save state between agent runs.

So you can define nodes.

And for each node for this LandGraph agent, for example, each node was a LLM that executed a certain action.

So it would be like either it was answering the question or it was doing research or it was planning or something like that.

And each node would do certain things.

LandGraph allows you to kind of simply define controlled edges between those nodes.

So you can say this node directly leads to this node.

But if this happens, then it should lead to this node.

It's kind of conditional edges.

And it also allows you to save state.

So as the agent is running, you can kind of save state

just save the results at each stage.

So if this node ran, it's saved in the list.

If this node ran, it's saved in the list.

And that allows you to call back to use this information from this past node to inform your answer for this specific node.

And it's just a simple framework to allow you to just build agents effectively.

I don't really Yeah, I think I think it is hard if you don't have like a good framework to go off of.

But we've kind of like built a framework over time.

And actually, the agent that's used in the the the code I put out is, is using that framework.

So if you might find that helpful, if you want to build some line graph agents.


SPEAKER_01:
yeah where do you see it all sort of going with different agentic AI and where where would it look more like a fusion agents or or collaborative swarms or mesh like what do you think we might see


SPEAKER_00:
Yeah, I think I'm a big proponent of the idea that we're going to have like billions of AI agents just kind of all talking to each other, like basically just like a whole AI population, like we have a human population.

I think that's probably very likely to happen because at the end of the day, like there's probably going to, I'm skeptical that one model is going to be able to vastly overpower humans to the extent that like,

a bunch of models will be able to.

So as you can see in the typical LLM literature, if you combine, for example, if you're in your reasoning cycles, combine Claude, Chachapiti, Llama.

And if you combine those together in your reasoning, it typically performs better than if you just use only Chachapiti in loops or only Claude in loops.

So having different models trained in slightly different ways is probably going to help

increased performance by a significant amount.

So I think we're going to probably have a lot like billions of agents just communicating with each other, maybe at the speed of light, because it's all just information and they don't have to communicate in language like we do as humans.

But yeah, I kind of see that going there.

And then at least in the near future, I think we're kind of what we were saying.

We're probably going to see a big rise in using these kind of formalized frameworks to improve agents.

So like active inference or there's other Bayesian reinforcement learning schemes.

There's typical reinforcement learning schemes.

Those stuff are already being used, but I think there's probably going to be a big rise in that as the...

as the kind of benefits from just purely using like LLM reasoning kind of taper off.

I think we're gonna see a big rise in that as well.


SPEAKER_01:
That's very interesting.

Like going back to the sort of grass greener, we could see a situation where smaller interpretable active inference type models are using high dimensional interfaces like natural language sharing information.

and the opposite setting where large sort of opaque models are communicating through well-structured narrow channels that are active inference like state spaces and just sending each other that json kind of like as a semantically encrypted communication you know right it just says three one two and it's just like oh no


SPEAKER_00:
That's definitely a really insightful point, yeah.

It might just be that all these LLMs are communicating through, yeah, these narrow... It's kind of like how we communicate too.

It's not like I can't just directly pass my thoughts to you, you know?

Like, ideally, if I could, like, you would get a lot more information about what I'm thinking, like, what I'm feeling, stuff like that.

We have to communicate through words, which is kind of a narrow representation of what our thoughts actually are.

So maybe LLMs have, like, a similar, you know...


SPEAKER_01:
lot to say about that but that again comes to the cognitive science topics of of communication semantics theory of minds you know how cool right exactly um yeah what are your next moves with your education and everything and then if there's anything else you want to add you can go for it


SPEAKER_00:
I'll just continue to do this research, try to expand.

Right now, actually, what I'm working on is the thing I said about actually encoding knowledge within the agents instead of just using some unknown kind of info state modality.

I'm working on that right now, kind of using a hierarchical model.

So I think that's up in your future.

Yeah, I just want to continue working on this whole idea of combining active inference and LLMs to do as much interesting things as possible and improve LLMs and active inference at the same time.

One other thing I thought was really interesting was I was reading the paper on renormalizing generative models from Carl Friston and all of them.

But I think that seems really interesting because obviously one of the big problems with active inference is just scale.

it's kind of hard to just keep making more and more and more complex models over and over again.

Like LLMs and like typical reinforcement learning have it easy because they just put a policy on it and they just like put a bunch of data in there and then they're good to go, you know.

But we actually have to like

painstakingly build all these generative models.

And it kind of slows our progress down a lot.

So using these renormalizing generative models to kind of just take away that whole scale problem, it can just kind of run these group transformations on any space of any scale.

Would be pretty useful.

I'm trying to explore, see how I can use that as well.

I think one interesting thing with that is

doing the RGM transformation in more abstract state spaces.

So in the paper, they use stuff like pixels and stuff like that, like physical spatial spaces, right?

But maybe doing it on something like language might be a little harder because how exactly do you... There's no...

exactly pixel equivalent of language.

Because pixels are simple.

You could just say, this is a discrete quantity.

The only way you can differentiate these discrete quantities is by RGB values, and you're good to go.

But with language, it's kind of like you have

it's not like each letter really means anything.

And putting letters together has different meaning, and putting words together has different meaning.

So it's kind of a hard, it's a much harder problem to solve to use the renormalizing generative models on these language spaces versus just spatial spaces.

So I think that's also an interesting problem.

But yeah, I'm just trying to think about these things, see what contributions I can make.


UNKNOWN:
Yeah.


SPEAKER_01:
Cool.

Yeah, great.

Comments from earlier Par and Friston et al work on reading as multi-scale active inference.

There's the eye saccade.

It's reducing uncertainty on the letter.

Then letter to letter to reduce uncertainty on the word, and then they go up to the third level with a narrative, you know, cat ate bird, or was it the bird ate the cat?

So those kinds of things.

You get priors over letters, transition matrices, all these kinds of things.

And then

But that was, as you put it, painstakingly crafted.

And where could we abstract and have generalized templates

so that perhaps an adapter module is crafted to connect a given domain or system of interest to some known interoperable scheme and then something like an rgm can take over from there um okay i'm gonna ask one more question from the chat and then that will be great okay but

um are you using meta learning aspects in the system to enable self-guided research and are direction opinions guided simply by active or what was that last part or direction opinions guided simply by active okay um yeah there's really no meta learning


SPEAKER_00:
the learning rate is stable throughout the entire thing um yeah the direction opinions are are like in which like which search action should be taking or should it should a search actually be taking it should a prompt actually be taking that's all purely guided by active inference yeah

So that was kind of the main point was that the active inference has this formalized structure that can allow for like optimality in terms of like exploration exploitation.

So the active inference agent is purely responsible for picking the actions and determining where to go next.


SPEAKER_01:
Epic.

Well, thank you very much for joining.

I hope you

engage and find collaborators and replicators who are interested in this hot topic of active inference and LLMs and come back when you're ready for 95.2.

All right.

Cool.


SPEAKER_00:
Okay.


SPEAKER_01:
Thank you.

Thank you.

Peace.

Bye.